(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';var _core=require('@angular/core');var _platformBrowserDynamic=require('@angular/platform-browser-dynamic');var _common=require('@angular/common');var _http=require('@angular/http');var _app=require('./component/app');(0,_core.enableProdMode)();(0,_platformBrowserDynamic.bootstrap)(_app.app,[_http.HTTP_PROVIDERS,(0,_core.provide)(_http.XHRBackend,{useClass:_http.BaseRequestOptions}),(0,_core.provide)(_common.LocationStrategy,{useClass:_common.HashLocationStrategy})]);

},{"./component/app":2,"@angular/common":8,"@angular/core":140,"@angular/http":216,"@angular/platform-browser-dynamic":237}],2:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.app=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value" in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dec,_class;var _common=require('@angular/common');var _core=require('@angular/core');var _http=require('@angular/http');var _list=require('./list');var _share=require('./share');var _queryString=require('query-string');function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var app=exports.app=(_dec=(0,_core.Component)({selector:'body',providers:[_http.HTTP_PROVIDERS],directives:[_common.CORE_DIRECTIVES,_common.FORM_DIRECTIVES,_list.list],templateUrl:window.env.SHARE+'home.html',pipes:[_common.COMMON_PIPES]}),_dec(_class=function(){function app(http){_classCallCheck(this,app);this.query={};this.suscriber={mail:'',error:null,search:'',send:false};var query=(0,_queryString.parse)(window.location.search);for(var i in query){if(/band|city|type|place/i.test(i)){this.suscriber.search=query[i];}}this.http=http;this.http._defaultOptions.url=window.env.SUSCRIBE;}_createClass(app,[{key:'suscribe',value:function suscribe(){var _this=this;if(this.suscriber.mail){this.suscriber.error=null;this.http.post(window.env.SUSCRIBE,JSON.stringify(this.suscriber)).subscribe(function(res){var rt=res.json();if(rt.error){_this.suscriber.error=rt.error;}else {_this.suscriber.mail='';_this.suscriber.send=true;}});}}}]);return app;}())||_class);Reflect.defineMetadata('design:paramtypes',[_http.Http],app);

},{"./list":3,"./share":5,"@angular/common":8,"@angular/core":140,"@angular/http":216,"query-string":289}],3:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.list=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value" in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dec,_dec2,_class,_desc,_value,_class2,_descriptor;var _common=require('@angular/common');var _core=require('@angular/core');var _service=require('./service');var _share=require('./share');var _search=require('../pipe/search');var _time=require('../pipe/time');function _initDefineProp(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0});}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _applyDecoratedDescriptor(target,property,decorators,descriptor,context){var desc={};Object['ke'+'ys'](descriptor).forEach(function(key){desc[key]=descriptor[key];});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value' in desc||desc.initializer){desc.writable=true;}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc;},desc);if(context&&desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined;}if(desc.initializer===void 0){Object['define'+'Property'](target,property,desc);desc=null;}return desc;}function _initializerWarningHelper(descriptor,context){throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');} // 20265 35373
var list=exports.list=(_dec=(0,_core.Component)({selector:'list',providers:[_service.lives],directives:[_share.share,_common.CORE_DIRECTIVES],templateUrl:window.env.SHARE+'./list.html',pipes:[_search.search,_time.time,_common.COMMON_PIPES]}),_dec2=(0,_core.Input)(),_dec(_class=(_class2=function(){function list(l){_classCallCheck(this,list);_initDefineProp(this,'query',_descriptor,this);this.live=l;}_createClass(list,[{key:'ngOnInit',value:function ngOnInit(){this.live.getAll();}}]);return list;}(),(_descriptor=_applyDecoratedDescriptor(_class2.prototype,'query',[_dec2],{enumerable:true,initializer:function initializer(){return this.query;}})),_class2))||_class);Reflect.defineMetadata('design:paramtypes',[_service.lives],list);

},{"../pipe/search":6,"../pipe/time":7,"./service":4,"./share":5,"@angular/common":8,"@angular/core":140}],4:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.lives=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value" in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dec,_class;var _core=require('@angular/core');var _ical=require('ical/ical.js');var _http=require('@angular/http');function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var lives=exports.lives=(_dec=(0,_core.Injectable)(),_dec(_class=function(){function lives(http){_classCallCheck(this,lives);this.events=[];this.http=http;this.http._defaultOptions.url=window.env.CAL;}_createClass(lives,[{key:'getAll',value:function getAll(){var _this=this;return this.http.get().subscribe(function(res){return _this.events=res.json().event;});}},{key:'handleError',value:function handleError(error){console.error('An error occurred',error);return Promise.reject(error.message||error);}}]);return lives;}())||_class);Reflect.defineMetadata('design:paramtypes',[_http.Http],lives);

},{"@angular/core":140,"@angular/http":216,"ical/ical.js":287}],5:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.share=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value" in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dec,_dec2,_dec3,_dec4,_class,_desc,_value,_class2,_descriptor,_descriptor2,_descriptor3,_class3,_temp;var _common=require('@angular/common');var _core=require('@angular/core');var _http=require('@angular/http');function _initDefineProp(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0});}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _applyDecoratedDescriptor(target,property,decorators,descriptor,context){var desc={};Object['ke'+'ys'](descriptor).forEach(function(key){desc[key]=descriptor[key];});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value' in desc||desc.initializer){desc.writable=true;}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc;},desc);if(context&&desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined;}if(desc.initializer===void 0){Object['define'+'Property'](target,property,desc);desc=null;}return desc;}function _initializerWarningHelper(descriptor,context){throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');} /**
 *  "Unexpected directive value 'undefined' on the View of component 'app'"
 * <share is='twitter' text='Share this text' via='@alejonext' || optional -> width=300 height=600 name='hello' />
 */var share=exports.share=(_dec=(0,_core.Component)({selector:'share',viewProviders:[_http.HTTP_PROVIDERS],templateUrl:window.env.SHARE+'share.html',directives:[_common.CORE_DIRECTIVES],pipes:[_common.COMMON_PIPES]}),_dec2=(0,_core.Input)(),_dec3=(0,_core.Input)(),_dec4=(0,_core.Input)(),_dec(_class=(_class2=(_temp=_class3=function(){function share(){_classCallCheck(this,share);_initDefineProp(this,'is',_descriptor,this);_initDefineProp(this,'via',_descriptor2,this);_initDefineProp(this,'text',_descriptor3,this);this.system={};this.url=window.env.SHARE;this.more='';this.count=0;}_createClass(share,[{key:'ngOnInit',value:function ngOnInit(height,width,name){this.name=name||'Share';this.system=share[this.is];this.setting=this.windows(width,height);}},{key:'post',value:function post(){var href=this.system.share(this.url,encodeURI(this.text),this.via);var neww=window.open(href,this.name,this.setting);if(window.focus)neww.focus();}},{key:'windows',value:function windows(){var width=arguments.length<=0||arguments[0]===undefined?600:arguments[0];var height=arguments.length<=1||arguments[1]===undefined?300:arguments[1];var setting='location=1,status=1,scrollbars=1';setting+=',height='+height;setting+=',width='+width;setting+=',top='+(screen.height/2-height/2);setting+=',left='+(screen.width/2-width/2);return setting;}}]);return share;}(),_class3.facebook={icon:'facebook',share:function share(absUrl){return 'http://www.facebook.com/sharer.php?u='+absUrl;},count:function count(absUrl){return 'https://graph.facebook.com/?callback=JSON_CALLBACK&id='+absUrl;},get:function get(data){return data.shares;}},_class3.twitter={icon:'twitter',share:function share(absUrl,text,via){return 'http://twitter.com/share?text='+text+'&url='+absUrl+'&via='+via;},count:function count(absUrl){return 'https://cdn.api.twitter.com/1/urls/count.json?callback=JSON_CALLBACK&url='+absUrl;},get:function get(data){return data.count;}},_class3.google={icon:'google-plus',share:function share(absUrl){return 'https://plus.google.com/share?url='+absUrl;}},_class3.tumblr={icon:'tumblr',share:function share(absUrl){return 'https://www.tumblr.com/widgets/share/tool?shareSource=legacy&canonicalUrl=&url='+absUrl;}},_class3.reddit={icon:'reddit-alien',share:function share(absUrl){return 'https://www.reddit.com/submit?url='+absUrl;}},_class3.linkedin={icon:'linkedin',share:function share(absUrl){return 'https://www.linkedin.com/shareArticle?mini=true&url='+absUrl;},count:function count(absUrl){return 'https://www.linkedin.com/countserv/count/share?callback=JSON_CALLBACK&format=jsonp&url='+absUrl;},get:function get(data){return data.count;}},_class3.pinterest={icon:'pinterest-p',share:function share(absUrl,text,via){return 'http://pinterest.com/pin/create/button/?url='+absUrl+'&description='+text+'&media='+via;},count:function count(absUrl){return 'https://api.pinterest.com/v1/urls/count.json?callback=JSON_CALLBACK&url='+absUrl;},get:function get(data){return data.count;}},_class3.xing={icon:'xing',share:function share(absUrl){return 'https://www.xing-share.com/app/user?op=share;sc_p=xing-share;url='+absUrl;}},_class3.email={icon:'envelope-o',share:function share(absUrl,text){return 'mailto:?subject='+text+'&body='+absUrl;}},_class3.CHANGE=['k','M','B'],_class3.MULTI=1000,_class3.DEC=100,_temp),(_descriptor=_applyDecoratedDescriptor(_class2.prototype,'is',[_dec2],{enumerable:true,initializer:function initializer(){return this.is;}}),_descriptor2=_applyDecoratedDescriptor(_class2.prototype,'via',[_dec3],{enumerable:true,initializer:function initializer(){return this.via;}}),_descriptor3=_applyDecoratedDescriptor(_class2.prototype,'text',[_dec4],{enumerable:true,initializer:function initializer(){return this.text;}})),_class2))||_class);

},{"@angular/common":8,"@angular/core":140,"@angular/http":216}],6:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.search=undefined;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value" in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dec,_dec2,_class;var _core=require('@angular/core');function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}} /**
 *
 *  <input [(model)]="query" type="text" />
 *  <ul>
 * 		<li *ngFor="let hero of heroes | search:query" >{{hero.name}}</li>
 *  </ul>
 */var search=exports.search=(_dec=(0,_core.Pipe)({name:'search',pure:false}),_dec2=(0,_core.Injectable)(),_dec(_class=_dec2(_class=function(){function search(){_classCallCheck(this,search);}_createClass(search,[{key:'transform',value:function transform(items,args){var isSearch=function isSearch(data){var isAll=false;if((typeof data==='undefined'?'undefined':_typeof(data))==='object'){for(var z in data){if(isAll=isSearch(data[z])){break;}}}else {if(typeof args==='number'){isAll=data===args;}else {isAll=data.toString().match(new RegExp(args,'i'));}}return isAll;};return items.filter(isSearch).sort(search.time);}}],[{key:'time',value:function time(a,b){return Math.sign(moment(a.start).diff(moment(b.start)));}}]);return search;}())||_class)||_class);

},{"@angular/core":140}],7:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.time=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value" in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dec,_dec2,_class;var _core=require('@angular/core');function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}} /**
 *
 *  <input [(model)]="query" type="text" />
 *  <ul>
 * 		<li *ngFor="let hero of heroes | search:query" >{{hero.name}}</li>
 *  </ul>
 */var time=exports.time=(_dec=(0,_core.Pipe)({name:'time',pure:false}),_dec2=(0,_core.Injectable)(),_dec(_class=_dec2(_class=function(){function time(){_classCallCheck(this,time);}_createClass(time,[{key:'transform',value:function transform(date,args){return moment(date).format(args);}}]);return time;}())||_class)||_class);

},{"@angular/core":140}],8:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./src/pipes'));
__export(require('./src/directives'));
__export(require('./src/forms'));
__export(require('./src/common_directives'));
__export(require('./src/location'));

},{"./src/common_directives":9,"./src/directives":10,"./src/forms":28,"./src/location":52,"./src/pipes":58}],9:[function(require,module,exports){
"use strict";
var forms_1 = require('./forms');
var directives_1 = require('./directives');
/**
 * A collection of Angular core directives that are likely to be used in each and every Angular
 * application. This includes core directives (e.g., NgIf and NgFor), and forms directives (e.g.,
 * NgModel).
 *
 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
 * property of the `@Component` decorator.
 *
 * ### Example
 *
 * Instead of writing:
 *
 * ```typescript
 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm} from
 * '@angular/common';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm,
 * OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 * one could import all the common directives at once:
 *
 * ```typescript
 * import {COMMON_DIRECTIVES} from '@angular/common';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [COMMON_DIRECTIVES, OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 */
exports.COMMON_DIRECTIVES = [directives_1.CORE_DIRECTIVES, forms_1.FORM_DIRECTIVES];

},{"./directives":10,"./forms":28}],10:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
* @module
* @description
* Common directives shipped with Angular.
*/
var ng_class_1 = require('./directives/ng_class');
exports.NgClass = ng_class_1.NgClass;
var ng_for_1 = require('./directives/ng_for');
exports.NgFor = ng_for_1.NgFor;
var ng_if_1 = require('./directives/ng_if');
exports.NgIf = ng_if_1.NgIf;
var ng_template_outlet_1 = require('./directives/ng_template_outlet');
exports.NgTemplateOutlet = ng_template_outlet_1.NgTemplateOutlet;
var ng_style_1 = require('./directives/ng_style');
exports.NgStyle = ng_style_1.NgStyle;
var ng_switch_1 = require('./directives/ng_switch');
exports.NgSwitch = ng_switch_1.NgSwitch;
exports.NgSwitchWhen = ng_switch_1.NgSwitchWhen;
exports.NgSwitchDefault = ng_switch_1.NgSwitchDefault;
var ng_plural_1 = require('./directives/ng_plural');
exports.NgPlural = ng_plural_1.NgPlural;
exports.NgPluralCase = ng_plural_1.NgPluralCase;
exports.NgLocalization = ng_plural_1.NgLocalization;
__export(require('./directives/observable_list_diff'));
var core_directives_1 = require('./directives/core_directives');
exports.CORE_DIRECTIVES = core_directives_1.CORE_DIRECTIVES;

},{"./directives/core_directives":11,"./directives/ng_class":12,"./directives/ng_for":13,"./directives/ng_if":14,"./directives/ng_plural":15,"./directives/ng_style":16,"./directives/ng_switch":17,"./directives/ng_template_outlet":18,"./directives/observable_list_diff":19}],11:[function(require,module,exports){
"use strict";
var ng_class_1 = require('./ng_class');
var ng_for_1 = require('./ng_for');
var ng_if_1 = require('./ng_if');
var ng_template_outlet_1 = require('./ng_template_outlet');
var ng_style_1 = require('./ng_style');
var ng_switch_1 = require('./ng_switch');
var ng_plural_1 = require('./ng_plural');
/**
 * A collection of Angular core directives that are likely to be used in each and every Angular
 * application.
 *
 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
 * property of the `@Component` annotation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/yakGwpCdUkg0qfzX5m8g?p=preview))
 *
 * Instead of writing:
 *
 * ```typescript
 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from '@angular/common';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 * one could import all the core directives at once:
 *
 * ```typescript
 * import {CORE_DIRECTIVES} from '@angular/common';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'myComponent.html',
 *   directives: [CORE_DIRECTIVES, OtherDirective]
 * })
 * export class MyComponent {
 *   ...
 * }
 * ```
 */
exports.CORE_DIRECTIVES = [
    ng_class_1.NgClass,
    ng_for_1.NgFor,
    ng_if_1.NgIf,
    ng_template_outlet_1.NgTemplateOutlet,
    ng_style_1.NgStyle,
    ng_switch_1.NgSwitch,
    ng_switch_1.NgSwitchWhen,
    ng_switch_1.NgSwitchDefault,
    ng_plural_1.NgPlural,
    ng_plural_1.NgPluralCase
];

},{"./ng_class":12,"./ng_for":13,"./ng_if":14,"./ng_plural":15,"./ng_style":16,"./ng_switch":17,"./ng_template_outlet":18}],12:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var NgClass = (function () {
    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._initialClasses = [];
    }
    Object.defineProperty(NgClass.prototype, "initialClasses", {
        set: function (v) {
            this._applyInitialClasses(true);
            this._initialClasses = lang_1.isPresent(v) && lang_1.isString(v) ? v.split(' ') : [];
            this._applyInitialClasses(false);
            this._applyClasses(this._rawClass, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgClass.prototype, "rawClass", {
        set: function (v) {
            this._cleanupClasses(this._rawClass);
            if (lang_1.isString(v)) {
                v = v.split(' ');
            }
            this._rawClass = v;
            this._iterableDiffer = null;
            this._keyValueDiffer = null;
            if (lang_1.isPresent(v)) {
                if (collection_1.isListLikeIterable(v)) {
                    this._iterableDiffer = this._iterableDiffers.find(v).create(null);
                }
                else {
                    this._keyValueDiffer = this._keyValueDiffers.find(v).create(null);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    NgClass.prototype.ngDoCheck = function () {
        if (lang_1.isPresent(this._iterableDiffer)) {
            var changes = this._iterableDiffer.diff(this._rawClass);
            if (lang_1.isPresent(changes)) {
                this._applyIterableChanges(changes);
            }
        }
        if (lang_1.isPresent(this._keyValueDiffer)) {
            var changes = this._keyValueDiffer.diff(this._rawClass);
            if (lang_1.isPresent(changes)) {
                this._applyKeyValueChanges(changes);
            }
        }
    };
    NgClass.prototype.ngOnDestroy = function () { this._cleanupClasses(this._rawClass); };
    NgClass.prototype._cleanupClasses = function (rawClassVal) {
        this._applyClasses(rawClassVal, true);
        this._applyInitialClasses(false);
    };
    NgClass.prototype._applyKeyValueChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) {
            if (record.previousValue) {
                _this._toggleClass(record.key, false);
            }
        });
    };
    NgClass.prototype._applyIterableChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._toggleClass(record.item, true); });
        changes.forEachRemovedItem(function (record) { _this._toggleClass(record.item, false); });
    };
    NgClass.prototype._applyInitialClasses = function (isCleanup) {
        var _this = this;
        this._initialClasses.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
    };
    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
        var _this = this;
        if (lang_1.isPresent(rawClassVal)) {
            if (lang_1.isArray(rawClassVal)) {
                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
            }
            else if (rawClassVal instanceof Set) {
                rawClassVal.forEach(function (className) { return _this._toggleClass(className, !isCleanup); });
            }
            else {
                collection_1.StringMapWrapper.forEach(rawClassVal, function (expVal, className) {
                    if (lang_1.isPresent(expVal))
                        _this._toggleClass(className, !isCleanup);
                });
            }
        }
    };
    NgClass.prototype._toggleClass = function (className, enabled) {
        className = className.trim();
        if (className.length > 0) {
            if (className.indexOf(' ') > -1) {
                var classes = className.split(/\s+/g);
                for (var i = 0, len = classes.length; i < len; i++) {
                    this._renderer.setElementClass(this._ngEl.nativeElement, classes[i], enabled);
                }
            }
            else {
                this._renderer.setElementClass(this._ngEl.nativeElement, className, enabled);
            }
        }
    };
    NgClass.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngClass]', inputs: ['rawClass: ngClass', 'initialClasses: class'] },] },
    ];
    NgClass.ctorParameters = [
        { type: core_1.IterableDiffers, },
        { type: core_1.KeyValueDiffers, },
        { type: core_1.ElementRef, },
        { type: core_1.Renderer, },
    ];
    return NgClass;
}());
exports.NgClass = NgClass;

},{"../../src/facade/collection":22,"../../src/facade/lang":26,"@angular/core":140}],13:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var NgForRow = (function () {
    function NgForRow($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
    }
    Object.defineProperty(NgForRow.prototype, "first", {
        get: function () { return this.index === 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "last", {
        get: function () { return this.index === this.count - 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "even", {
        get: function () { return this.index % 2 === 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForRow.prototype, "odd", {
        get: function () { return !this.even; },
        enumerable: true,
        configurable: true
    });
    return NgForRow;
}());
exports.NgForRow = NgForRow;
var NgFor = (function () {
    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
        this._viewContainer = _viewContainer;
        this._templateRef = _templateRef;
        this._iterableDiffers = _iterableDiffers;
        this._cdr = _cdr;
    }
    Object.defineProperty(NgFor.prototype, "ngForOf", {
        set: function (value) {
            this._ngForOf = value;
            if (lang_1.isBlank(this._differ) && lang_1.isPresent(value)) {
                try {
                    this._differ = this._iterableDiffers.find(value).create(this._cdr, this._ngForTrackBy);
                }
                catch (e) {
                    throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + value + "' of type '" + lang_1.getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFor.prototype, "ngForTemplate", {
        set: function (value) {
            if (lang_1.isPresent(value)) {
                this._templateRef = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFor.prototype, "ngForTrackBy", {
        set: function (value) { this._ngForTrackBy = value; },
        enumerable: true,
        configurable: true
    });
    NgFor.prototype.ngDoCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._ngForOf);
            if (lang_1.isPresent(changes))
                this._applyChanges(changes);
        }
    };
    NgFor.prototype._applyChanges = function (changes) {
        var _this = this;
        // TODO(rado): check if change detection can produce a change record that is
        // easier to consume than current.
        var recordViewTuples = [];
        changes.forEachRemovedItem(function (removedRecord) {
            return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
        });
        changes.forEachMovedItem(function (movedRecord) {
            return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
        });
        var insertTuples = this._bulkRemove(recordViewTuples);
        changes.forEachAddedItem(function (addedRecord) {
            return insertTuples.push(new RecordViewTuple(addedRecord, null));
        });
        this._bulkInsert(insertTuples);
        for (var i = 0; i < insertTuples.length; i++) {
            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
        }
        for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
            var viewRef = this._viewContainer.get(i);
            viewRef.context.index = i;
            viewRef.context.count = ilen;
        }
        changes.forEachIdentityChange(function (record) {
            var viewRef = _this._viewContainer.get(record.currentIndex);
            viewRef.context.$implicit = record.item;
        });
    };
    NgFor.prototype._perViewChange = function (view, record) {
        view.context.$implicit = record.item;
    };
    NgFor.prototype._bulkRemove = function (tuples) {
        tuples.sort(function (a, b) {
            return a.record.previousIndex - b.record.previousIndex;
        });
        var movedTuples = [];
        for (var i = tuples.length - 1; i >= 0; i--) {
            var tuple = tuples[i];
            // separate moved views from removed views.
            if (lang_1.isPresent(tuple.record.currentIndex)) {
                tuple.view =
                    this._viewContainer.detach(tuple.record.previousIndex);
                movedTuples.push(tuple);
            }
            else {
                this._viewContainer.remove(tuple.record.previousIndex);
            }
        }
        return movedTuples;
    };
    NgFor.prototype._bulkInsert = function (tuples) {
        tuples.sort(function (a, b) { return a.record.currentIndex - b.record.currentIndex; });
        for (var i = 0; i < tuples.length; i++) {
            var tuple = tuples[i];
            if (lang_1.isPresent(tuple.view)) {
                this._viewContainer.insert(tuple.view, tuple.record.currentIndex);
            }
            else {
                tuple.view = this._viewContainer.createEmbeddedView(this._templateRef, new NgForRow(null, null, null), tuple.record.currentIndex);
            }
        }
        return tuples;
    };
    NgFor.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngFor][ngForOf]', inputs: ['ngForTrackBy', 'ngForOf', 'ngForTemplate'] },] },
    ];
    NgFor.ctorParameters = [
        { type: core_1.ViewContainerRef, },
        { type: core_1.TemplateRef, },
        { type: core_1.IterableDiffers, },
        { type: core_1.ChangeDetectorRef, },
    ];
    return NgFor;
}());
exports.NgFor = NgFor;
var RecordViewTuple = (function () {
    function RecordViewTuple(record, view) {
        this.record = record;
        this.view = view;
    }
    return RecordViewTuple;
}());

},{"../../src/facade/exceptions":24,"../../src/facade/lang":26,"@angular/core":140}],14:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var NgIf = (function () {
    function NgIf(_viewContainer, _templateRef) {
        this._viewContainer = _viewContainer;
        this._templateRef = _templateRef;
        this._prevCondition = null;
    }
    Object.defineProperty(NgIf.prototype, "ngIf", {
        set: function (newCondition /* boolean */) {
            if (newCondition && (lang_1.isBlank(this._prevCondition) || !this._prevCondition)) {
                this._prevCondition = true;
                this._viewContainer.createEmbeddedView(this._templateRef);
            }
            else if (!newCondition && (lang_1.isBlank(this._prevCondition) || this._prevCondition)) {
                this._prevCondition = false;
                this._viewContainer.clear();
            }
        },
        enumerable: true,
        configurable: true
    });
    NgIf.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngIf]', inputs: ['ngIf'] },] },
    ];
    NgIf.ctorParameters = [
        { type: core_1.ViewContainerRef, },
        { type: core_1.TemplateRef, },
    ];
    return NgIf;
}());
exports.NgIf = NgIf;

},{"../../src/facade/lang":26,"@angular/core":140}],15:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var ng_switch_1 = require('./ng_switch');
var _CATEGORY_DEFAULT = 'other';
var NgLocalization = (function () {
    function NgLocalization() {
    }
    return NgLocalization;
}());
exports.NgLocalization = NgLocalization;
var NgPluralCase = (function () {
    function NgPluralCase(value, template, viewContainer) {
        this.value = value;
        this._view = new ng_switch_1.SwitchView(viewContainer, template);
    }
    NgPluralCase.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngPluralCase]' },] },
    ];
    NgPluralCase.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Attribute, args: ['ngPluralCase',] },] },
        { type: core_1.TemplateRef, },
        { type: core_1.ViewContainerRef, },
    ];
    return NgPluralCase;
}());
exports.NgPluralCase = NgPluralCase;
var NgPlural = (function () {
    function NgPlural(_localization) {
        this._localization = _localization;
        this._caseViews = new collection_1.Map();
        this.cases = null;
    }
    Object.defineProperty(NgPlural.prototype, "ngPlural", {
        set: function (value) {
            this._switchValue = value;
            this._updateView();
        },
        enumerable: true,
        configurable: true
    });
    NgPlural.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.cases.forEach(function (pluralCase) {
            _this._caseViews.set(_this._formatValue(pluralCase), pluralCase._view);
        });
        this._updateView();
    };
    /** @internal */
    NgPlural.prototype._updateView = function () {
        this._clearViews();
        var view = this._caseViews.get(this._switchValue);
        if (!lang_1.isPresent(view))
            view = this._getCategoryView(this._switchValue);
        this._activateView(view);
    };
    /** @internal */
    NgPlural.prototype._clearViews = function () {
        if (lang_1.isPresent(this._activeView))
            this._activeView.destroy();
    };
    /** @internal */
    NgPlural.prototype._activateView = function (view) {
        if (!lang_1.isPresent(view))
            return;
        this._activeView = view;
        this._activeView.create();
    };
    /** @internal */
    NgPlural.prototype._getCategoryView = function (value) {
        var category = this._localization.getPluralCategory(value);
        var categoryView = this._caseViews.get(category);
        return lang_1.isPresent(categoryView) ? categoryView : this._caseViews.get(_CATEGORY_DEFAULT);
    };
    /** @internal */
    NgPlural.prototype._isValueView = function (pluralCase) { return pluralCase.value[0] === "="; };
    /** @internal */
    NgPlural.prototype._formatValue = function (pluralCase) {
        return this._isValueView(pluralCase) ? this._stripValue(pluralCase.value) : pluralCase.value;
    };
    /** @internal */
    NgPlural.prototype._stripValue = function (value) { return lang_1.NumberWrapper.parseInt(value.substring(1), 10); };
    NgPlural.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngPlural]' },] },
    ];
    NgPlural.ctorParameters = [
        { type: NgLocalization, },
    ];
    NgPlural.propDecorators = {
        'cases': [{ type: core_1.ContentChildren, args: [NgPluralCase,] },],
        'ngPlural': [{ type: core_1.Input },],
    };
    return NgPlural;
}());
exports.NgPlural = NgPlural;

},{"../../src/facade/collection":22,"../../src/facade/lang":26,"./ng_switch":17,"@angular/core":140}],16:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var NgStyle = (function () {
    function NgStyle(_differs, _ngEl, _renderer) {
        this._differs = _differs;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
    }
    Object.defineProperty(NgStyle.prototype, "rawStyle", {
        set: function (v) {
            this._rawStyle = v;
            if (lang_1.isBlank(this._differ) && lang_1.isPresent(v)) {
                this._differ = this._differs.find(this._rawStyle).create(null);
            }
        },
        enumerable: true,
        configurable: true
    });
    NgStyle.prototype.ngDoCheck = function () {
        if (lang_1.isPresent(this._differ)) {
            var changes = this._differ.diff(this._rawStyle);
            if (lang_1.isPresent(changes)) {
                this._applyChanges(changes);
            }
        }
    };
    NgStyle.prototype._applyChanges = function (changes) {
        var _this = this;
        changes.forEachAddedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
        changes.forEachRemovedItem(function (record) { _this._setStyle(record.key, null); });
    };
    NgStyle.prototype._setStyle = function (name, val) {
        this._renderer.setElementStyle(this._ngEl.nativeElement, name, val);
    };
    NgStyle.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngStyle]', inputs: ['rawStyle: ngStyle'] },] },
    ];
    NgStyle.ctorParameters = [
        { type: core_1.KeyValueDiffers, },
        { type: core_1.ElementRef, },
        { type: core_1.Renderer, },
    ];
    return NgStyle;
}());
exports.NgStyle = NgStyle;

},{"../../src/facade/lang":26,"@angular/core":140}],17:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var _WHEN_DEFAULT = new Object();
var SwitchView = (function () {
    function SwitchView(_viewContainerRef, _templateRef) {
        this._viewContainerRef = _viewContainerRef;
        this._templateRef = _templateRef;
    }
    SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
    SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
    return SwitchView;
}());
exports.SwitchView = SwitchView;
var NgSwitch = (function () {
    function NgSwitch() {
        this._useDefault = false;
        this._valueViews = new collection_1.Map();
        this._activeViews = [];
    }
    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
        set: function (value) {
            // Empty the currently active ViewContainers
            this._emptyAllActiveViews();
            // Add the ViewContainers matching the value (with a fallback to default)
            this._useDefault = false;
            var views = this._valueViews.get(value);
            if (lang_1.isBlank(views)) {
                this._useDefault = true;
                views = lang_1.normalizeBlank(this._valueViews.get(_WHEN_DEFAULT));
            }
            this._activateViews(views);
            this._switchValue = value;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    NgSwitch.prototype._onWhenValueChanged = function (oldWhen, newWhen, view) {
        this._deregisterView(oldWhen, view);
        this._registerView(newWhen, view);
        if (oldWhen === this._switchValue) {
            view.destroy();
            collection_1.ListWrapper.remove(this._activeViews, view);
        }
        else if (newWhen === this._switchValue) {
            if (this._useDefault) {
                this._useDefault = false;
                this._emptyAllActiveViews();
            }
            view.create();
            this._activeViews.push(view);
        }
        // Switch to default when there is no more active ViewContainers
        if (this._activeViews.length === 0 && !this._useDefault) {
            this._useDefault = true;
            this._activateViews(this._valueViews.get(_WHEN_DEFAULT));
        }
    };
    /** @internal */
    NgSwitch.prototype._emptyAllActiveViews = function () {
        var activeContainers = this._activeViews;
        for (var i = 0; i < activeContainers.length; i++) {
            activeContainers[i].destroy();
        }
        this._activeViews = [];
    };
    /** @internal */
    NgSwitch.prototype._activateViews = function (views) {
        // TODO(vicb): assert(this._activeViews.length === 0);
        if (lang_1.isPresent(views)) {
            for (var i = 0; i < views.length; i++) {
                views[i].create();
            }
            this._activeViews = views;
        }
    };
    /** @internal */
    NgSwitch.prototype._registerView = function (value, view) {
        var views = this._valueViews.get(value);
        if (lang_1.isBlank(views)) {
            views = [];
            this._valueViews.set(value, views);
        }
        views.push(view);
    };
    /** @internal */
    NgSwitch.prototype._deregisterView = function (value, view) {
        // `_WHEN_DEFAULT` is used a marker for non-registered whens
        if (value === _WHEN_DEFAULT)
            return;
        var views = this._valueViews.get(value);
        if (views.length == 1) {
            this._valueViews.delete(value);
        }
        else {
            collection_1.ListWrapper.remove(views, view);
        }
    };
    NgSwitch.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngSwitch]', inputs: ['ngSwitch'] },] },
    ];
    return NgSwitch;
}());
exports.NgSwitch = NgSwitch;
var NgSwitchWhen = (function () {
    function NgSwitchWhen(viewContainer, templateRef, ngSwitch) {
        // `_WHEN_DEFAULT` is used as a marker for a not yet initialized value
        /** @internal */
        this._value = _WHEN_DEFAULT;
        this._switch = ngSwitch;
        this._view = new SwitchView(viewContainer, templateRef);
    }
    Object.defineProperty(NgSwitchWhen.prototype, "ngSwitchWhen", {
        set: function (value) {
            this._switch._onWhenValueChanged(this._value, value, this._view);
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    NgSwitchWhen.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngSwitchWhen]', inputs: ['ngSwitchWhen'] },] },
    ];
    NgSwitchWhen.ctorParameters = [
        { type: core_1.ViewContainerRef, },
        { type: core_1.TemplateRef, },
        { type: NgSwitch, decorators: [{ type: core_1.Host },] },
    ];
    return NgSwitchWhen;
}());
exports.NgSwitchWhen = NgSwitchWhen;
var NgSwitchDefault = (function () {
    function NgSwitchDefault(viewContainer, templateRef, sswitch) {
        sswitch._registerView(_WHEN_DEFAULT, new SwitchView(viewContainer, templateRef));
    }
    NgSwitchDefault.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
    ];
    NgSwitchDefault.ctorParameters = [
        { type: core_1.ViewContainerRef, },
        { type: core_1.TemplateRef, },
        { type: NgSwitch, decorators: [{ type: core_1.Host },] },
    ];
    return NgSwitchDefault;
}());
exports.NgSwitchDefault = NgSwitchDefault;

},{"../../src/facade/collection":22,"../../src/facade/lang":26,"@angular/core":140}],18:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var NgTemplateOutlet = (function () {
    function NgTemplateOutlet(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
    }
    Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
        set: function (templateRef) {
            if (lang_1.isPresent(this._insertedViewRef)) {
                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._insertedViewRef));
            }
            if (lang_1.isPresent(templateRef)) {
                this._insertedViewRef = this._viewContainerRef.createEmbeddedView(templateRef);
            }
        },
        enumerable: true,
        configurable: true
    });
    NgTemplateOutlet.decorators = [
        { type: core_1.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
    ];
    NgTemplateOutlet.ctorParameters = [
        { type: core_1.ViewContainerRef, },
    ];
    NgTemplateOutlet.propDecorators = {
        'ngTemplateOutlet': [{ type: core_1.Input },],
    };
    return NgTemplateOutlet;
}());
exports.NgTemplateOutlet = NgTemplateOutlet;

},{"../../src/facade/lang":26,"@angular/core":140}],19:[function(require,module,exports){
"use strict";

},{}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('./lang');
var promise_1 = require('./promise');
exports.PromiseWrapper = promise_1.PromiseWrapper;
exports.PromiseCompleter = promise_1.PromiseCompleter;
var Subject_1 = require('rxjs/Subject');
var PromiseObservable_1 = require('rxjs/observable/PromiseObservable');
var toPromise_1 = require('rxjs/operator/toPromise');
var Observable_1 = require('rxjs/Observable');
exports.Observable = Observable_1.Observable;
var Subject_2 = require('rxjs/Subject');
exports.Subject = Subject_2.Subject;
var TimerWrapper = (function () {
    function TimerWrapper() {
    }
    TimerWrapper.setTimeout = function (fn, millis) {
        return lang_1.global.setTimeout(fn, millis);
    };
    TimerWrapper.clearTimeout = function (id) { lang_1.global.clearTimeout(id); };
    TimerWrapper.setInterval = function (fn, millis) {
        return lang_1.global.setInterval(fn, millis);
    };
    TimerWrapper.clearInterval = function (id) { lang_1.global.clearInterval(id); };
    return TimerWrapper;
}());
exports.TimerWrapper = TimerWrapper;
var ObservableWrapper = (function () {
    function ObservableWrapper() {
    }
    // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
    ObservableWrapper.subscribe = function (emitter, onNext, onError, onComplete) {
        if (onComplete === void 0) { onComplete = function () { }; }
        onError = (typeof onError === "function") && onError || lang_1.noop;
        onComplete = (typeof onComplete === "function") && onComplete || lang_1.noop;
        return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
    };
    ObservableWrapper.isObservable = function (obs) { return !!obs.subscribe; };
    /**
     * Returns whether `obs` has any subscribers listening to events.
     */
    ObservableWrapper.hasSubscribers = function (obs) { return obs.observers.length > 0; };
    ObservableWrapper.dispose = function (subscription) { subscription.unsubscribe(); };
    /**
     * @deprecated - use callEmit() instead
     */
    ObservableWrapper.callNext = function (emitter, value) { emitter.next(value); };
    ObservableWrapper.callEmit = function (emitter, value) { emitter.emit(value); };
    ObservableWrapper.callError = function (emitter, error) { emitter.error(error); };
    ObservableWrapper.callComplete = function (emitter) { emitter.complete(); };
    ObservableWrapper.fromPromise = function (promise) {
        return PromiseObservable_1.PromiseObservable.create(promise);
    };
    ObservableWrapper.toPromise = function (obj) { return toPromise_1.toPromise.call(obj); };
    return ObservableWrapper;
}());
exports.ObservableWrapper = ObservableWrapper;
/**
 * Use by directives and components to emit custom Events.
 *
 * ### Examples
 *
 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
 * title gets clicked:
 *
 * ```
 * @Component({
 *   selector: 'zippy',
 *   template: `
 *   <div class="zippy">
 *     <div (click)="toggle()">Toggle</div>
 *     <div [hidden]="!visible">
 *       <ng-content></ng-content>
 *     </div>
 *  </div>`})
 * export class Zippy {
 *   visible: boolean = true;
 *   @Output() open: EventEmitter<any> = new EventEmitter();
 *   @Output() close: EventEmitter<any> = new EventEmitter();
 *
 *   toggle() {
 *     this.visible = !this.visible;
 *     if (this.visible) {
 *       this.open.emit(null);
 *     } else {
 *       this.close.emit(null);
 *     }
 *   }
 * }
 * ```
 *
 * Use Rx.Observable but provides an adapter to make it work as specified here:
 * https://github.com/jhusain/observable-spec
 *
 * Once a reference implementation of the spec is available, switch to it.
 */
var EventEmitter = (function (_super) {
    __extends(EventEmitter, _super);
    /**
     * Creates an instance of [EventEmitter], which depending on [isAsync],
     * delivers events synchronously or asynchronously.
     */
    function EventEmitter(isAsync) {
        if (isAsync === void 0) { isAsync = true; }
        _super.call(this);
        this._isAsync = isAsync;
    }
    EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
    /**
     * @deprecated - use .emit(value) instead
     */
    EventEmitter.prototype.next = function (value) { _super.prototype.next.call(this, value); };
    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
        var schedulerFn;
        var errorFn = function (err) { return null; };
        var completeFn = function () { return null; };
        if (generatorOrNext && typeof generatorOrNext === 'object') {
            schedulerFn = this._isAsync ? function (value) { setTimeout(function () { return generatorOrNext.next(value); }); } :
                function (value) { generatorOrNext.next(value); };
            if (generatorOrNext.error) {
                errorFn = this._isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
                    function (err) { generatorOrNext.error(err); };
            }
            if (generatorOrNext.complete) {
                completeFn = this._isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
                    function () { generatorOrNext.complete(); };
            }
        }
        else {
            schedulerFn = this._isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
                function (value) { generatorOrNext(value); };
            if (error) {
                errorFn =
                    this._isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
            }
            if (complete) {
                completeFn =
                    this._isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
            }
        }
        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
    };
    return EventEmitter;
}(Subject_1.Subject));
exports.EventEmitter = EventEmitter;

},{"./lang":26,"./promise":27,"rxjs/Observable":290,"rxjs/Subject":292,"rxjs/observable/PromiseObservable":296,"rxjs/operator/toPromise":297}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
* A base class for the WrappedException that can be used to identify
* a WrappedException from ExceptionHandler without adding circular
* dependency.
*/
var BaseWrappedException = (function (_super) {
    __extends(BaseWrappedException, _super);
    function BaseWrappedException(message) {
        _super.call(this, message);
    }
    Object.defineProperty(BaseWrappedException.prototype, "wrapperMessage", {
        get: function () { return ''; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "wrapperStack", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalException", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "originalStack", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "context", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseWrappedException.prototype, "message", {
        get: function () { return ''; },
        enumerable: true,
        configurable: true
    });
    return BaseWrappedException;
}(Error));
exports.BaseWrappedException = BaseWrappedException;

},{}],22:[function(require,module,exports){
"use strict";
var lang_1 = require('./lang');
exports.Map = lang_1.global.Map;
exports.Set = lang_1.global.Set;
// Safari and Internet Explorer do not support the iterable parameter to the
// Map constructor.  We work around that by manually adding the items.
var createMapFromPairs = (function () {
    try {
        if (new exports.Map([[1, 2]]).size === 1) {
            return function createMapFromPairs(pairs) { return new exports.Map(pairs); };
        }
    }
    catch (e) {
    }
    return function createMapAndPopulateFromPairs(pairs) {
        var map = new exports.Map();
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            map.set(pair[0], pair[1]);
        }
        return map;
    };
})();
var createMapFromMap = (function () {
    try {
        if (new exports.Map(new exports.Map())) {
            return function createMapFromMap(m) { return new exports.Map(m); };
        }
    }
    catch (e) {
    }
    return function createMapAndPopulateFromMap(m) {
        var map = new exports.Map();
        m.forEach(function (v, k) { map.set(k, v); });
        return map;
    };
})();
var _clearValues = (function () {
    if ((new exports.Map()).keys().next) {
        return function _clearValues(m) {
            var keyIterator = m.keys();
            var k;
            while (!((k = keyIterator.next()).done)) {
                m.set(k.value, null);
            }
        };
    }
    else {
        return function _clearValuesWithForeEach(m) {
            m.forEach(function (v, k) { m.set(k, null); });
        };
    }
})();
// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
var _arrayFromMap = (function () {
    try {
        if ((new exports.Map()).values().next) {
            return function createArrayFromMap(m, getValues) {
                return getValues ? Array.from(m.values()) : Array.from(m.keys());
            };
        }
    }
    catch (e) {
    }
    return function createArrayFromMapWithForeach(m, getValues) {
        var res = ListWrapper.createFixedSize(m.size), i = 0;
        m.forEach(function (v, k) {
            res[i] = getValues ? v : k;
            i++;
        });
        return res;
    };
})();
var MapWrapper = (function () {
    function MapWrapper() {
    }
    MapWrapper.clone = function (m) { return createMapFromMap(m); };
    MapWrapper.createFromStringMap = function (stringMap) {
        var result = new exports.Map();
        for (var prop in stringMap) {
            result.set(prop, stringMap[prop]);
        }
        return result;
    };
    MapWrapper.toStringMap = function (m) {
        var r = {};
        m.forEach(function (v, k) { return r[k] = v; });
        return r;
    };
    MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
    MapWrapper.clearValues = function (m) { _clearValues(m); };
    MapWrapper.iterable = function (m) { return m; };
    MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
    MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
    return MapWrapper;
}());
exports.MapWrapper = MapWrapper;
/**
 * Wraps Javascript Objects
 */
var StringMapWrapper = (function () {
    function StringMapWrapper() {
    }
    StringMapWrapper.create = function () {
        // Note: We are not using Object.create(null) here due to
        // performance!
        // http://jsperf.com/ng2-object-create-null
        return {};
    };
    StringMapWrapper.contains = function (map, key) {
        return map.hasOwnProperty(key);
    };
    StringMapWrapper.get = function (map, key) {
        return map.hasOwnProperty(key) ? map[key] : undefined;
    };
    StringMapWrapper.set = function (map, key, value) { map[key] = value; };
    StringMapWrapper.keys = function (map) { return Object.keys(map); };
    StringMapWrapper.values = function (map) {
        return Object.keys(map).reduce(function (r, a) {
            r.push(map[a]);
            return r;
        }, []);
    };
    StringMapWrapper.isEmpty = function (map) {
        for (var prop in map) {
            return false;
        }
        return true;
    };
    StringMapWrapper.delete = function (map, key) { delete map[key]; };
    StringMapWrapper.forEach = function (map, callback) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
            }
        }
    };
    StringMapWrapper.merge = function (m1, m2) {
        var m = {};
        for (var attr in m1) {
            if (m1.hasOwnProperty(attr)) {
                m[attr] = m1[attr];
            }
        }
        for (var attr in m2) {
            if (m2.hasOwnProperty(attr)) {
                m[attr] = m2[attr];
            }
        }
        return m;
    };
    StringMapWrapper.equals = function (m1, m2) {
        var k1 = Object.keys(m1);
        var k2 = Object.keys(m2);
        if (k1.length != k2.length) {
            return false;
        }
        var key;
        for (var i = 0; i < k1.length; i++) {
            key = k1[i];
            if (m1[key] !== m2[key]) {
                return false;
            }
        }
        return true;
    };
    return StringMapWrapper;
}());
exports.StringMapWrapper = StringMapWrapper;
var ListWrapper = (function () {
    function ListWrapper() {
    }
    // JS has no way to express a statically fixed size list, but dart does so we
    // keep both methods.
    ListWrapper.createFixedSize = function (size) { return new Array(size); };
    ListWrapper.createGrowableSize = function (size) { return new Array(size); };
    ListWrapper.clone = function (array) { return array.slice(0); };
    ListWrapper.forEachWithIndex = function (array, fn) {
        for (var i = 0; i < array.length; i++) {
            fn(array[i], i);
        }
    };
    ListWrapper.first = function (array) {
        if (!array)
            return null;
        return array[0];
    };
    ListWrapper.last = function (array) {
        if (!array || array.length == 0)
            return null;
        return array[array.length - 1];
    };
    ListWrapper.indexOf = function (array, value, startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        return array.indexOf(value, startIndex);
    };
    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
    ListWrapper.reversed = function (array) {
        var a = ListWrapper.clone(array);
        return a.reverse();
    };
    ListWrapper.concat = function (a, b) { return a.concat(b); };
    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
    ListWrapper.removeAt = function (list, index) {
        var res = list[index];
        list.splice(index, 1);
        return res;
    };
    ListWrapper.removeAll = function (list, items) {
        for (var i = 0; i < items.length; ++i) {
            var index = list.indexOf(items[i]);
            list.splice(index, 1);
        }
    };
    ListWrapper.remove = function (list, el) {
        var index = list.indexOf(el);
        if (index > -1) {
            list.splice(index, 1);
            return true;
        }
        return false;
    };
    ListWrapper.clear = function (list) { list.length = 0; };
    ListWrapper.isEmpty = function (list) { return list.length == 0; };
    ListWrapper.fill = function (list, value, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = null; }
        list.fill(value, start, end === null ? list.length : end);
    };
    ListWrapper.equals = function (a, b) {
        if (a.length != b.length)
            return false;
        for (var i = 0; i < a.length; ++i) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    };
    ListWrapper.slice = function (l, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return l.slice(from, to === null ? undefined : to);
    };
    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
    ListWrapper.sort = function (l, compareFn) {
        if (lang_1.isPresent(compareFn)) {
            l.sort(compareFn);
        }
        else {
            l.sort();
        }
    };
    ListWrapper.toString = function (l) { return l.toString(); };
    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
    ListWrapper.maximum = function (list, predicate) {
        if (list.length == 0) {
            return null;
        }
        var solution = null;
        var maxValue = -Infinity;
        for (var index = 0; index < list.length; index++) {
            var candidate = list[index];
            if (lang_1.isBlank(candidate)) {
                continue;
            }
            var candidateValue = predicate(candidate);
            if (candidateValue > maxValue) {
                solution = candidate;
                maxValue = candidateValue;
            }
        }
        return solution;
    };
    ListWrapper.flatten = function (list) {
        var target = [];
        _flattenArray(list, target);
        return target;
    };
    ListWrapper.addAll = function (list, source) {
        for (var i = 0; i < source.length; i++) {
            list.push(source[i]);
        }
    };
    return ListWrapper;
}());
exports.ListWrapper = ListWrapper;
function _flattenArray(source, target) {
    if (lang_1.isPresent(source)) {
        for (var i = 0; i < source.length; i++) {
            var item = source[i];
            if (lang_1.isArray(item)) {
                _flattenArray(item, target);
            }
            else {
                target.push(item);
            }
        }
    }
    return target;
}
function isListLikeIterable(obj) {
    if (!lang_1.isJsObject(obj))
        return false;
    return lang_1.isArray(obj) ||
        (!(obj instanceof exports.Map) &&
            lang_1.getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
}
exports.isListLikeIterable = isListLikeIterable;
function areIterablesEqual(a, b, comparator) {
    var iterator1 = a[lang_1.getSymbolIterator()]();
    var iterator2 = b[lang_1.getSymbolIterator()]();
    while (true) {
        var item1 = iterator1.next();
        var item2 = iterator2.next();
        if (item1.done && item2.done)
            return true;
        if (item1.done || item2.done)
            return false;
        if (!comparator(item1.value, item2.value))
            return false;
    }
}
exports.areIterablesEqual = areIterablesEqual;
function iterateListLike(obj, fn) {
    if (lang_1.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
            fn(obj[i]);
        }
    }
    else {
        var iterator = obj[lang_1.getSymbolIterator()]();
        var item;
        while (!((item = iterator.next()).done)) {
            fn(item.value);
        }
    }
}
exports.iterateListLike = iterateListLike;
// Safari and Internet Explorer do not support the iterable parameter to the
// Set constructor.  We work around that by manually adding the items.
var createSetFromList = (function () {
    var test = new exports.Set([1, 2, 3]);
    if (test.size === 3) {
        return function createSetFromList(lst) { return new exports.Set(lst); };
    }
    else {
        return function createSetAndPopulateFromList(lst) {
            var res = new exports.Set(lst);
            if (res.size !== lst.length) {
                for (var i = 0; i < lst.length; i++) {
                    res.add(lst[i]);
                }
            }
            return res;
        };
    }
})();
var SetWrapper = (function () {
    function SetWrapper() {
    }
    SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };
    SetWrapper.has = function (s, key) { return s.has(key); };
    SetWrapper.delete = function (m, k) { m.delete(k); };
    return SetWrapper;
}());
exports.SetWrapper = SetWrapper;

},{"./lang":26}],23:[function(require,module,exports){
"use strict";
var lang_1 = require('./lang');
var base_wrapped_exception_1 = require('./base_wrapped_exception');
var collection_1 = require('./collection');
var _ArrayLogger = (function () {
    function _ArrayLogger() {
        this.res = [];
    }
    _ArrayLogger.prototype.log = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logError = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logGroup = function (s) { this.res.push(s); };
    _ArrayLogger.prototype.logGroupEnd = function () { };
    ;
    return _ArrayLogger;
}());
/**
 * Provides a hook for centralized exception handling.
 *
 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
 * intercept error handling,
 * write a custom exception handler that replaces this default as appropriate for your app.
 *
 * ### Example
 *
 * ```javascript
 *
 * class MyExceptionHandler implements ExceptionHandler {
 *   call(error, stackTrace = null, reason = null) {
 *     // do something with the exception
 *   }
 * }
 *
 * bootstrap(MyApp, [provide(ExceptionHandler, {useClass: MyExceptionHandler})])
 *
 * ```
 */
var ExceptionHandler = (function () {
    function ExceptionHandler(_logger, _rethrowException) {
        if (_rethrowException === void 0) { _rethrowException = true; }
        this._logger = _logger;
        this._rethrowException = _rethrowException;
    }
    ExceptionHandler.exceptionToString = function (exception, stackTrace, reason) {
        if (stackTrace === void 0) { stackTrace = null; }
        if (reason === void 0) { reason = null; }
        var l = new _ArrayLogger();
        var e = new ExceptionHandler(l, false);
        e.call(exception, stackTrace, reason);
        return l.res.join("\n");
    };
    ExceptionHandler.prototype.call = function (exception, stackTrace, reason) {
        if (stackTrace === void 0) { stackTrace = null; }
        if (reason === void 0) { reason = null; }
        var originalException = this._findOriginalException(exception);
        var originalStack = this._findOriginalStack(exception);
        var context = this._findContext(exception);
        this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
        if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
            this._logger.logError("STACKTRACE:");
            this._logger.logError(this._longStackTrace(stackTrace));
        }
        if (lang_1.isPresent(reason)) {
            this._logger.logError("REASON: " + reason);
        }
        if (lang_1.isPresent(originalException)) {
            this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
        }
        if (lang_1.isPresent(originalStack)) {
            this._logger.logError("ORIGINAL STACKTRACE:");
            this._logger.logError(this._longStackTrace(originalStack));
        }
        if (lang_1.isPresent(context)) {
            this._logger.logError("ERROR CONTEXT:");
            this._logger.logError(context);
        }
        this._logger.logGroupEnd();
        // We rethrow exceptions, so operations like 'bootstrap' will result in an error
        // when an exception happens. If we do not rethrow, bootstrap will always succeed.
        if (this._rethrowException)
            throw exception;
    };
    /** @internal */
    ExceptionHandler.prototype._extractMessage = function (exception) {
        return exception instanceof base_wrapped_exception_1.BaseWrappedException ? exception.wrapperMessage :
            exception.toString();
    };
    /** @internal */
    ExceptionHandler.prototype._longStackTrace = function (stackTrace) {
        return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join("\n\n-----async gap-----\n") :
            stackTrace.toString();
    };
    /** @internal */
    ExceptionHandler.prototype._findContext = function (exception) {
        try {
            if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
                return null;
            return lang_1.isPresent(exception.context) ? exception.context :
                this._findContext(exception.originalException);
        }
        catch (e) {
            // exception.context can throw an exception. if it happens, we ignore the context.
            return null;
        }
    };
    /** @internal */
    ExceptionHandler.prototype._findOriginalException = function (exception) {
        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
            return null;
        var e = exception.originalException;
        while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
            e = e.originalException;
        }
        return e;
    };
    /** @internal */
    ExceptionHandler.prototype._findOriginalStack = function (exception) {
        if (!(exception instanceof base_wrapped_exception_1.BaseWrappedException))
            return null;
        var e = exception;
        var stack = exception.originalStack;
        while (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
            e = e.originalException;
            if (e instanceof base_wrapped_exception_1.BaseWrappedException && lang_1.isPresent(e.originalException)) {
                stack = e.originalStack;
            }
        }
        return stack;
    };
    return ExceptionHandler;
}());
exports.ExceptionHandler = ExceptionHandler;

},{"./base_wrapped_exception":21,"./collection":22,"./lang":26}],24:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var base_wrapped_exception_1 = require('./base_wrapped_exception');
var exception_handler_1 = require('./exception_handler');
var exception_handler_2 = require('./exception_handler');
exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
var BaseException = (function (_super) {
    __extends(BaseException, _super);
    function BaseException(message) {
        if (message === void 0) { message = "--"; }
        _super.call(this, message);
        this.message = message;
        this.stack = (new Error(message)).stack;
    }
    BaseException.prototype.toString = function () { return this.message; };
    return BaseException;
}(Error));
exports.BaseException = BaseException;
/**
 * Wraps an exception and provides additional context or information.
 */
var WrappedException = (function (_super) {
    __extends(WrappedException, _super);
    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
        _super.call(this, _wrapperMessage);
        this._wrapperMessage = _wrapperMessage;
        this._originalException = _originalException;
        this._originalStack = _originalStack;
        this._context = _context;
        this._wrapperStack = (new Error(_wrapperMessage)).stack;
    }
    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
        get: function () { return this._wrapperMessage; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
        get: function () { return this._wrapperStack; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalException", {
        get: function () { return this._originalException; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "originalStack", {
        get: function () { return this._originalStack; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "context", {
        get: function () { return this._context; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WrappedException.prototype, "message", {
        get: function () { return exception_handler_1.ExceptionHandler.exceptionToString(this); },
        enumerable: true,
        configurable: true
    });
    WrappedException.prototype.toString = function () { return this.message; };
    return WrappedException;
}(base_wrapped_exception_1.BaseWrappedException));
exports.WrappedException = WrappedException;
function makeTypeError(message) {
    return new TypeError(message);
}
exports.makeTypeError = makeTypeError;
function unimplemented() {
    throw new BaseException('unimplemented');
}
exports.unimplemented = unimplemented;

},{"./base_wrapped_exception":21,"./exception_handler":23}],25:[function(require,module,exports){
"use strict";
(function (NumberFormatStyle) {
    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
})(exports.NumberFormatStyle || (exports.NumberFormatStyle = {}));
var NumberFormatStyle = exports.NumberFormatStyle;
var NumberFormatter = (function () {
    function NumberFormatter() {
    }
    NumberFormatter.format = function (num, locale, style, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.minimumIntegerDigits, minimumIntegerDigits = _c === void 0 ? 1 : _c, _d = _b.minimumFractionDigits, minimumFractionDigits = _d === void 0 ? 0 : _d, _e = _b.maximumFractionDigits, maximumFractionDigits = _e === void 0 ? 3 : _e, currency = _b.currency, _f = _b.currencyAsSymbol, currencyAsSymbol = _f === void 0 ? false : _f;
        var intlOptions = {
            minimumIntegerDigits: minimumIntegerDigits,
            minimumFractionDigits: minimumFractionDigits,
            maximumFractionDigits: maximumFractionDigits
        };
        intlOptions.style = NumberFormatStyle[style].toLowerCase();
        if (style == NumberFormatStyle.Currency) {
            intlOptions.currency = currency;
            intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
        }
        return new Intl.NumberFormat(locale, intlOptions).format(num);
    };
    return NumberFormatter;
}());
exports.NumberFormatter = NumberFormatter;
function digitCondition(len) {
    return len == 2 ? '2-digit' : 'numeric';
}
function nameCondition(len) {
    return len < 4 ? 'short' : 'long';
}
function extractComponents(pattern) {
    var ret = {};
    var i = 0, j;
    while (i < pattern.length) {
        j = i;
        while (j < pattern.length && pattern[j] == pattern[i])
            j++;
        var len = j - i;
        switch (pattern[i]) {
            case 'G':
                ret.era = nameCondition(len);
                break;
            case 'y':
                ret.year = digitCondition(len);
                break;
            case 'M':
                if (len >= 3)
                    ret.month = nameCondition(len);
                else
                    ret.month = digitCondition(len);
                break;
            case 'd':
                ret.day = digitCondition(len);
                break;
            case 'E':
                ret.weekday = nameCondition(len);
                break;
            case 'j':
                ret.hour = digitCondition(len);
                break;
            case 'h':
                ret.hour = digitCondition(len);
                ret.hour12 = true;
                break;
            case 'H':
                ret.hour = digitCondition(len);
                ret.hour12 = false;
                break;
            case 'm':
                ret.minute = digitCondition(len);
                break;
            case 's':
                ret.second = digitCondition(len);
                break;
            case 'z':
                ret.timeZoneName = 'long';
                break;
            case 'Z':
                ret.timeZoneName = 'short';
                break;
        }
        i = j;
    }
    return ret;
}
var dateFormatterCache = new Map();
var DateFormatter = (function () {
    function DateFormatter() {
    }
    DateFormatter.format = function (date, locale, pattern) {
        var key = locale + pattern;
        if (dateFormatterCache.has(key)) {
            return dateFormatterCache.get(key).format(date);
        }
        var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));
        dateFormatterCache.set(key, formatter);
        return formatter.format(date);
    };
    return DateFormatter;
}());
exports.DateFormatter = DateFormatter;

},{}],26:[function(require,module,exports){
(function (global){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
exports.scheduleMicroTask = scheduleMicroTask;
exports.IS_DART = false;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    if (type['name']) {
        return type['name'];
    }
    return typeof type;
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var _devMode = true;
var _modeLocked = false;
function lockMode() {
    _modeLocked = true;
}
exports.lockMode = lockMode;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 */
function enableProdMode() {
    if (_modeLocked) {
        // Cannot use BaseException as that ends up importing from facade/lang.
        throw 'Cannot enable prod mode after platform setup.';
    }
    _devMode = false;
}
exports.enableProdMode = enableProdMode;
function assertionsEnabled() {
    return _devMode;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    // TODO: to be fixed properly via #2830, noop for now
};
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isBoolean(obj) {
    return typeof obj === "boolean";
}
exports.isBoolean = isBoolean;
function isNumber(obj) {
    return typeof obj === "number";
}
exports.isNumber = isNumber;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
var STRING_MAP_PROTO = Object.getPrototypeOf({});
function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
}
exports.isStrictStringMap = isStrictStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function noop() { }
exports.noop = noop;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    if (token.overriddenName) {
        return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
function resolveEnumToken(enumValue, val) {
    return enumValue[val];
}
exports.resolveEnumToken = resolveEnumToken;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.stripLeft = function (s, charVal) {
        if (s && s.length) {
            var pos = 0;
            for (var i = 0; i < s.length; i++) {
                if (s[i] != charVal)
                    break;
                pos++;
            }
            s = s.substring(pos);
        }
        return s;
    };
    StringWrapper.stripRight = function (s, charVal) {
        if (s && s.length) {
            var pos = s.length;
            for (var i = s.length - 1; i >= 0; i--) {
                if (s[i] != charVal)
                    break;
                pos--;
            }
            s = s.substring(0, pos);
        }
        return s;
    };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
}());
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
}());
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
}(Error));
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
}());
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    RegExpWrapper.replaceAll = function (regExp, input, replace) {
        var c = regExp.exec(input);
        var res = '';
        regExp.lastIndex = 0;
        var prev = 0;
        while (c) {
            res += input.substring(prev, c.index);
            res += replace(c);
            prev = c.index + c[0].length;
            regExp.lastIndex = prev;
            c = regExp.exec(input);
        }
        res += input.substring(prev);
        return res;
    };
    return RegExpWrapper;
}());
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
}());
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
}());
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
function warn(obj) {
    console.warn(obj);
}
exports.warn = warn;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
}());
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
}());
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;
function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
        fnArgNames.push(argName);
        fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
}
exports.evalExpression = evalExpression;
function isPrimitive(obj) {
    return !isJsObject(obj);
}
exports.isPrimitive = isPrimitive;
function hasConstructor(value, type) {
    return value.constructor === type;
}
exports.hasConstructor = hasConstructor;
function bitWiseOr(values) {
    return values.reduce(function (a, b) { return a | b; });
}
exports.bitWiseOr = bitWiseOr;
function bitWiseAnd(values) {
    return values.reduce(function (a, b) { return a & b; });
}
exports.bitWiseAnd = bitWiseAnd;
function escape(s) {
    return _global.encodeURI(s);
}
exports.escape = escape;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
"use strict";
var PromiseCompleter = (function () {
    function PromiseCompleter() {
        var _this = this;
        this.promise = new Promise(function (res, rej) {
            _this.resolve = res;
            _this.reject = rej;
        });
    }
    return PromiseCompleter;
}());
exports.PromiseCompleter = PromiseCompleter;
var PromiseWrapper = (function () {
    function PromiseWrapper() {
    }
    PromiseWrapper.resolve = function (obj) { return Promise.resolve(obj); };
    PromiseWrapper.reject = function (obj, _) { return Promise.reject(obj); };
    // Note: We can't rename this method into `catch`, as this is not a valid
    // method name in Dart.
    PromiseWrapper.catchError = function (promise, onError) {
        return promise.catch(onError);
    };
    PromiseWrapper.all = function (promises) {
        if (promises.length == 0)
            return Promise.resolve([]);
        return Promise.all(promises);
    };
    PromiseWrapper.then = function (promise, success, rejection) {
        return promise.then(success, rejection);
    };
    PromiseWrapper.wrap = function (computation) {
        return new Promise(function (res, rej) {
            try {
                res(computation());
            }
            catch (e) {
                rej(e);
            }
        });
    };
    PromiseWrapper.scheduleMicrotask = function (computation) {
        PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) { });
    };
    PromiseWrapper.isPromise = function (obj) { return obj instanceof Promise; };
    PromiseWrapper.completer = function () { return new PromiseCompleter(); };
    return PromiseWrapper;
}());
exports.PromiseWrapper = PromiseWrapper;

},{}],28:[function(require,module,exports){
"use strict";
/**
* @module
* @description
* This module is used for handling user input, by defining and building a {@link ControlGroup} that
* consists of
* {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used
* to read information
* from the form DOM elements.
*
* Forms providers are not included in default providers; you must import these providers
* explicitly.
*/
var model_1 = require('./forms/model');
exports.AbstractControl = model_1.AbstractControl;
exports.Control = model_1.Control;
exports.ControlGroup = model_1.ControlGroup;
exports.ControlArray = model_1.ControlArray;
var abstract_control_directive_1 = require('./forms/directives/abstract_control_directive');
exports.AbstractControlDirective = abstract_control_directive_1.AbstractControlDirective;
var control_container_1 = require('./forms/directives/control_container');
exports.ControlContainer = control_container_1.ControlContainer;
var ng_control_name_1 = require('./forms/directives/ng_control_name');
exports.NgControlName = ng_control_name_1.NgControlName;
var ng_form_control_1 = require('./forms/directives/ng_form_control');
exports.NgFormControl = ng_form_control_1.NgFormControl;
var ng_model_1 = require('./forms/directives/ng_model');
exports.NgModel = ng_model_1.NgModel;
var ng_control_1 = require('./forms/directives/ng_control');
exports.NgControl = ng_control_1.NgControl;
var ng_control_group_1 = require('./forms/directives/ng_control_group');
exports.NgControlGroup = ng_control_group_1.NgControlGroup;
var ng_form_model_1 = require('./forms/directives/ng_form_model');
exports.NgFormModel = ng_form_model_1.NgFormModel;
var ng_form_1 = require('./forms/directives/ng_form');
exports.NgForm = ng_form_1.NgForm;
var control_value_accessor_1 = require('./forms/directives/control_value_accessor');
exports.NG_VALUE_ACCESSOR = control_value_accessor_1.NG_VALUE_ACCESSOR;
var default_value_accessor_1 = require('./forms/directives/default_value_accessor');
exports.DefaultValueAccessor = default_value_accessor_1.DefaultValueAccessor;
var ng_control_status_1 = require('./forms/directives/ng_control_status');
exports.NgControlStatus = ng_control_status_1.NgControlStatus;
var checkbox_value_accessor_1 = require('./forms/directives/checkbox_value_accessor');
exports.CheckboxControlValueAccessor = checkbox_value_accessor_1.CheckboxControlValueAccessor;
var select_control_value_accessor_1 = require('./forms/directives/select_control_value_accessor');
exports.NgSelectOption = select_control_value_accessor_1.NgSelectOption;
exports.SelectControlValueAccessor = select_control_value_accessor_1.SelectControlValueAccessor;
var directives_1 = require('./forms/directives');
exports.FORM_DIRECTIVES = directives_1.FORM_DIRECTIVES;
exports.RadioButtonState = directives_1.RadioButtonState;
var validators_1 = require('./forms/validators');
exports.NG_VALIDATORS = validators_1.NG_VALIDATORS;
exports.NG_ASYNC_VALIDATORS = validators_1.NG_ASYNC_VALIDATORS;
exports.Validators = validators_1.Validators;
var validators_2 = require('./forms/directives/validators');
exports.RequiredValidator = validators_2.RequiredValidator;
exports.MinLengthValidator = validators_2.MinLengthValidator;
exports.MaxLengthValidator = validators_2.MaxLengthValidator;
exports.PatternValidator = validators_2.PatternValidator;
var form_builder_1 = require('./forms/form_builder');
exports.FormBuilder = form_builder_1.FormBuilder;
var form_builder_2 = require('./forms/form_builder');
var radio_control_value_accessor_1 = require('./forms/directives/radio_control_value_accessor');
/**
 * Shorthand set of providers used for building Angular forms.
 *
 * ### Example
 *
 * ```typescript
 * bootstrap(MyApp, [FORM_PROVIDERS]);
 * ```
 */
exports.FORM_PROVIDERS = [form_builder_2.FormBuilder, radio_control_value_accessor_1.RadioControlRegistry];
/**
 * See {@link FORM_PROVIDERS} instead.
 *
 * @deprecated
 */
exports.FORM_BINDINGS = exports.FORM_PROVIDERS;

},{"./forms/directives":29,"./forms/directives/abstract_control_directive":30,"./forms/directives/checkbox_value_accessor":31,"./forms/directives/control_container":32,"./forms/directives/control_value_accessor":33,"./forms/directives/default_value_accessor":34,"./forms/directives/ng_control":35,"./forms/directives/ng_control_group":36,"./forms/directives/ng_control_name":37,"./forms/directives/ng_control_status":38,"./forms/directives/ng_form":39,"./forms/directives/ng_form_control":40,"./forms/directives/ng_form_model":41,"./forms/directives/ng_model":42,"./forms/directives/radio_control_value_accessor":45,"./forms/directives/select_control_value_accessor":46,"./forms/directives/validators":48,"./forms/form_builder":49,"./forms/model":50,"./forms/validators":51}],29:[function(require,module,exports){
"use strict";
var ng_control_name_1 = require('./directives/ng_control_name');
var ng_form_control_1 = require('./directives/ng_form_control');
var ng_model_1 = require('./directives/ng_model');
var ng_control_group_1 = require('./directives/ng_control_group');
var ng_form_model_1 = require('./directives/ng_form_model');
var ng_form_1 = require('./directives/ng_form');
var default_value_accessor_1 = require('./directives/default_value_accessor');
var checkbox_value_accessor_1 = require('./directives/checkbox_value_accessor');
var number_value_accessor_1 = require('./directives/number_value_accessor');
var radio_control_value_accessor_1 = require('./directives/radio_control_value_accessor');
var ng_control_status_1 = require('./directives/ng_control_status');
var select_control_value_accessor_1 = require('./directives/select_control_value_accessor');
var validators_1 = require('./directives/validators');
var ng_control_name_2 = require('./directives/ng_control_name');
exports.NgControlName = ng_control_name_2.NgControlName;
var ng_form_control_2 = require('./directives/ng_form_control');
exports.NgFormControl = ng_form_control_2.NgFormControl;
var ng_model_2 = require('./directives/ng_model');
exports.NgModel = ng_model_2.NgModel;
var ng_control_group_2 = require('./directives/ng_control_group');
exports.NgControlGroup = ng_control_group_2.NgControlGroup;
var ng_form_model_2 = require('./directives/ng_form_model');
exports.NgFormModel = ng_form_model_2.NgFormModel;
var ng_form_2 = require('./directives/ng_form');
exports.NgForm = ng_form_2.NgForm;
var default_value_accessor_2 = require('./directives/default_value_accessor');
exports.DefaultValueAccessor = default_value_accessor_2.DefaultValueAccessor;
var checkbox_value_accessor_2 = require('./directives/checkbox_value_accessor');
exports.CheckboxControlValueAccessor = checkbox_value_accessor_2.CheckboxControlValueAccessor;
var radio_control_value_accessor_2 = require('./directives/radio_control_value_accessor');
exports.RadioControlValueAccessor = radio_control_value_accessor_2.RadioControlValueAccessor;
exports.RadioButtonState = radio_control_value_accessor_2.RadioButtonState;
var number_value_accessor_2 = require('./directives/number_value_accessor');
exports.NumberValueAccessor = number_value_accessor_2.NumberValueAccessor;
var ng_control_status_2 = require('./directives/ng_control_status');
exports.NgControlStatus = ng_control_status_2.NgControlStatus;
var select_control_value_accessor_2 = require('./directives/select_control_value_accessor');
exports.SelectControlValueAccessor = select_control_value_accessor_2.SelectControlValueAccessor;
exports.NgSelectOption = select_control_value_accessor_2.NgSelectOption;
var validators_2 = require('./directives/validators');
exports.RequiredValidator = validators_2.RequiredValidator;
exports.MinLengthValidator = validators_2.MinLengthValidator;
exports.MaxLengthValidator = validators_2.MaxLengthValidator;
exports.PatternValidator = validators_2.PatternValidator;
var ng_control_1 = require('./directives/ng_control');
exports.NgControl = ng_control_1.NgControl;
/**
 *
 * A list of all the form directives used as part of a `@Component` annotation.
 *
 *  This is a shorthand for importing them each individually.
 *
 * ### Example
 *
 * ```typescript
 * @Component({
 *   selector: 'my-app',
 *   directives: [FORM_DIRECTIVES]
 * })
 * class MyApp {}
 * ```
 */
exports.FORM_DIRECTIVES = [
    ng_control_name_1.NgControlName,
    ng_control_group_1.NgControlGroup,
    ng_form_control_1.NgFormControl,
    ng_model_1.NgModel,
    ng_form_model_1.NgFormModel,
    ng_form_1.NgForm,
    select_control_value_accessor_1.NgSelectOption,
    default_value_accessor_1.DefaultValueAccessor,
    number_value_accessor_1.NumberValueAccessor,
    checkbox_value_accessor_1.CheckboxControlValueAccessor,
    select_control_value_accessor_1.SelectControlValueAccessor,
    radio_control_value_accessor_1.RadioControlValueAccessor,
    ng_control_status_1.NgControlStatus,
    validators_1.RequiredValidator,
    validators_1.MinLengthValidator,
    validators_1.MaxLengthValidator,
    validators_1.PatternValidator
];

},{"./directives/checkbox_value_accessor":31,"./directives/default_value_accessor":34,"./directives/ng_control":35,"./directives/ng_control_group":36,"./directives/ng_control_name":37,"./directives/ng_control_status":38,"./directives/ng_form":39,"./directives/ng_form_control":40,"./directives/ng_form_model":41,"./directives/ng_model":42,"./directives/number_value_accessor":44,"./directives/radio_control_value_accessor":45,"./directives/select_control_value_accessor":46,"./directives/validators":48}],30:[function(require,module,exports){
"use strict";
var lang_1 = require('../../../src/facade/lang');
var exceptions_1 = require('../../../src/facade/exceptions');
/**
 * Base class for control directives.
 *
 * Only used internally in the forms module.
 */
var AbstractControlDirective = (function () {
    function AbstractControlDirective() {
    }
    Object.defineProperty(AbstractControlDirective.prototype, "control", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "value", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.value : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "valid", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.valid : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "errors", {
        get: function () {
            return lang_1.isPresent(this.control) ? this.control.errors : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.pristine : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.dirty : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "touched", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.touched : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
        get: function () { return lang_1.isPresent(this.control) ? this.control.untouched : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControlDirective.prototype, "path", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return AbstractControlDirective;
}());
exports.AbstractControlDirective = AbstractControlDirective;

},{"../../../src/facade/exceptions":24,"../../../src/facade/lang":26}],31:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var control_value_accessor_1 = require('./control_value_accessor');
exports.CHECKBOX_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return CheckboxControlValueAccessor; }),
    multi: true
};
var CheckboxControlValueAccessor = (function () {
    function CheckboxControlValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    CheckboxControlValueAccessor.prototype.writeValue = function (value) {
        this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
    };
    CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    CheckboxControlValueAccessor.decorators = [
        { type: core_1.Directive, args: [{
                    selector: 'input[type=checkbox][ngControl],input[type=checkbox][ngFormControl],input[type=checkbox][ngModel]',
                    host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
                    providers: [exports.CHECKBOX_VALUE_ACCESSOR]
                },] },
    ];
    CheckboxControlValueAccessor.ctorParameters = [
        { type: core_1.Renderer, },
        { type: core_1.ElementRef, },
    ];
    return CheckboxControlValueAccessor;
}());
exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;

},{"./control_value_accessor":33,"@angular/core":140}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var abstract_control_directive_1 = require('./abstract_control_directive');
/**
 * A directive that contains multiple {@link NgControl}s.
 *
 * Only used by the forms module.
 */
var ControlContainer = (function (_super) {
    __extends(ControlContainer, _super);
    function ControlContainer() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(ControlContainer.prototype, "formDirective", {
        /**
         * Get the form to which this container belongs.
         */
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlContainer.prototype, "path", {
        /**
         * Get the path to this container.
         */
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return ControlContainer;
}(abstract_control_directive_1.AbstractControlDirective));
exports.ControlContainer = ControlContainer;

},{"./abstract_control_directive":30}],33:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
/**
 * Used to provide a {@link ControlValueAccessor} for form controls.
 *
 * See {@link DefaultValueAccessor} for how to implement one.
 */
exports.NG_VALUE_ACCESSOR = 
/*@ts2dart_const*/ new core_1.OpaqueToken("NgValueAccessor");

},{"@angular/core":140}],34:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var control_value_accessor_1 = require('./control_value_accessor');
exports.DEFAULT_VALUE_ACCESSOR = 
/* @ts2dart_Provider */ {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return DefaultValueAccessor; }),
    multi: true
};
var DefaultValueAccessor = (function () {
    function DefaultValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    DefaultValueAccessor.prototype.writeValue = function (value) {
        var normalizedValue = lang_1.isBlank(value) ? '' : value;
        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    };
    DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
    DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    DefaultValueAccessor.decorators = [
        { type: core_1.Directive, args: [{
                    selector: 'input:not([type=checkbox])[ngControl],textarea[ngControl],input:not([type=checkbox])[ngFormControl],textarea[ngFormControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
                    // TODO: vsavkin replace the above selector with the one below it once
                    // https://github.com/angular/angular/issues/3011 is implemented
                    // selector: '[ngControl],[ngModel],[ngFormControl]',
                    host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                    bindings: [exports.DEFAULT_VALUE_ACCESSOR]
                },] },
    ];
    DefaultValueAccessor.ctorParameters = [
        { type: core_1.Renderer, },
        { type: core_1.ElementRef, },
    ];
    return DefaultValueAccessor;
}());
exports.DefaultValueAccessor = DefaultValueAccessor;

},{"../../../src/facade/lang":26,"./control_value_accessor":33,"@angular/core":140}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('../../../src/facade/exceptions');
var abstract_control_directive_1 = require('./abstract_control_directive');
/**
 * A base class that all control directive extend.
 * It binds a {@link Control} object to a DOM element.
 *
 * Used internally by Angular forms.
 */
var NgControl = (function (_super) {
    __extends(NgControl, _super);
    function NgControl() {
        _super.apply(this, arguments);
        this.name = null;
        this.valueAccessor = null;
    }
    Object.defineProperty(NgControl.prototype, "validator", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControl.prototype, "asyncValidator", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return NgControl;
}(abstract_control_directive_1.AbstractControlDirective));
exports.NgControl = NgControl;

},{"../../../src/facade/exceptions":24,"./abstract_control_directive":30}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var control_container_1 = require('./control_container');
var shared_1 = require('./shared');
var validators_1 = require('../validators');
exports.controlGroupProvider = 
/*@ts2dart_const*/ /* @ts2dart_Provider */ {
    provide: control_container_1.ControlContainer,
    useExisting: core_1.forwardRef(function () { return NgControlGroup; })
};
var NgControlGroup = (function (_super) {
    __extends(NgControlGroup, _super);
    function NgControlGroup(parent, _validators, _asyncValidators) {
        _super.call(this);
        this._validators = _validators;
        this._asyncValidators = _asyncValidators;
        this._parent = parent;
    }
    NgControlGroup.prototype.ngOnInit = function () { this.formDirective.addControlGroup(this); };
    NgControlGroup.prototype.ngOnDestroy = function () { this.formDirective.removeControlGroup(this); };
    Object.defineProperty(NgControlGroup.prototype, "control", {
        /**
         * Get the {@link ControlGroup} backing this binding.
         */
        get: function () { return this.formDirective.getControlGroup(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "path", {
        /**
         * Get the path to this control group.
         */
        get: function () { return shared_1.controlPath(this.name, this._parent); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "formDirective", {
        /**
         * Get the {@link Form} to which this group belongs.
         */
        get: function () { return this._parent.formDirective; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "validator", {
        get: function () { return shared_1.composeValidators(this._validators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlGroup.prototype, "asyncValidator", {
        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },
        enumerable: true,
        configurable: true
    });
    NgControlGroup.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[ngControlGroup]',
                    providers: [exports.controlGroupProvider],
                    inputs: ['name: ngControlGroup'],
                    exportAs: 'ngForm'
                },] },
    ];
    NgControlGroup.ctorParameters = [
        { type: control_container_1.ControlContainer, decorators: [{ type: core_1.Host }, { type: core_1.SkipSelf },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
    ];
    return NgControlGroup;
}(control_container_1.ControlContainer));
exports.NgControlGroup = NgControlGroup;

},{"../validators":51,"./control_container":32,"./shared":47,"@angular/core":140}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var async_1 = require('../../../src/facade/async');
var control_container_1 = require('./control_container');
var ng_control_1 = require('./ng_control');
var control_value_accessor_1 = require('./control_value_accessor');
var shared_1 = require('./shared');
var validators_1 = require('../validators');
exports.controlNameBinding = 
/*@ts2dart_const*/ /* @ts2dart_Provider */ {
    provide: ng_control_1.NgControl,
    useExisting: core_1.forwardRef(function () { return NgControlName; })
};
var NgControlName = (function (_super) {
    __extends(NgControlName, _super);
    function NgControlName(_parent, _validators, _asyncValidators, valueAccessors) {
        _super.call(this);
        this._parent = _parent;
        this._validators = _validators;
        this._asyncValidators = _asyncValidators;
        /** @internal */
        this.update = new async_1.EventEmitter();
        this._added = false;
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgControlName.prototype.ngOnChanges = function (changes) {
        if (!this._added) {
            this.formDirective.addControl(this);
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this.viewModel = this.model;
            this.formDirective.updateModel(this, this.model);
        }
    };
    NgControlName.prototype.ngOnDestroy = function () { this.formDirective.removeControl(this); };
    NgControlName.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callEmit(this.update, newValue);
    };
    Object.defineProperty(NgControlName.prototype, "path", {
        get: function () { return shared_1.controlPath(this.name, this._parent); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "formDirective", {
        get: function () { return this._parent.formDirective; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "validator", {
        get: function () { return shared_1.composeValidators(this._validators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "asyncValidator", {
        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlName.prototype, "control", {
        get: function () { return this.formDirective.getControl(this); },
        enumerable: true,
        configurable: true
    });
    NgControlName.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[ngControl]',
                    bindings: [exports.controlNameBinding],
                    inputs: ['name: ngControl', 'model: ngModel'],
                    outputs: ['update: ngModelChange'],
                    exportAs: 'ngForm'
                },] },
    ];
    NgControlName.ctorParameters = [
        { type: control_container_1.ControlContainer, decorators: [{ type: core_1.Host }, { type: core_1.SkipSelf },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [control_value_accessor_1.NG_VALUE_ACCESSOR,] },] },
    ];
    return NgControlName;
}(ng_control_1.NgControl));
exports.NgControlName = NgControlName;

},{"../../../src/facade/async":20,"../validators":51,"./control_container":32,"./control_value_accessor":33,"./ng_control":35,"./shared":47,"@angular/core":140}],38:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var ng_control_1 = require('./ng_control');
var lang_1 = require('../../../src/facade/lang');
var NgControlStatus = (function () {
    function NgControlStatus(cd) {
        this._cd = cd;
    }
    Object.defineProperty(NgControlStatus.prototype, "ngClassUntouched", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassTouched", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassPristine", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassDirty", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassValid", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgControlStatus.prototype, "ngClassInvalid", {
        get: function () {
            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
        },
        enumerable: true,
        configurable: true
    });
    NgControlStatus.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[ngControl],[ngModel],[ngFormControl]',
                    host: {
                        '[class.ng-untouched]': 'ngClassUntouched',
                        '[class.ng-touched]': 'ngClassTouched',
                        '[class.ng-pristine]': 'ngClassPristine',
                        '[class.ng-dirty]': 'ngClassDirty',
                        '[class.ng-valid]': 'ngClassValid',
                        '[class.ng-invalid]': 'ngClassInvalid'
                    }
                },] },
    ];
    NgControlStatus.ctorParameters = [
        { type: ng_control_1.NgControl, decorators: [{ type: core_1.Self },] },
    ];
    return NgControlStatus;
}());
exports.NgControlStatus = NgControlStatus;

},{"../../../src/facade/lang":26,"./ng_control":35,"@angular/core":140}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var async_1 = require('../../../src/facade/async');
var collection_1 = require('../../../src/facade/collection');
var lang_1 = require('../../../src/facade/lang');
var control_container_1 = require('./control_container');
var model_1 = require('../model');
var shared_1 = require('./shared');
var validators_1 = require('../validators');
exports.formDirectiveProvider = 
/*@ts2dart_const*/ { provide: control_container_1.ControlContainer, useExisting: core_1.forwardRef(function () { return NgForm; }) };
var NgForm = (function (_super) {
    __extends(NgForm, _super);
    function NgForm(validators, asyncValidators) {
        _super.call(this);
        this.ngSubmit = new async_1.EventEmitter();
        this.form = new model_1.ControlGroup({}, null, shared_1.composeValidators(validators), shared_1.composeAsyncValidators(asyncValidators));
    }
    Object.defineProperty(NgForm.prototype, "formDirective", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForm.prototype, "controls", {
        get: function () { return this.form.controls; },
        enumerable: true,
        configurable: true
    });
    NgForm.prototype.addControl = function (dir) {
        var _this = this;
        async_1.PromiseWrapper.scheduleMicrotask(function () {
            var container = _this._findContainer(dir.path);
            var ctrl = new model_1.Control();
            shared_1.setUpControl(ctrl, dir);
            container.addControl(dir.name, ctrl);
            ctrl.updateValueAndValidity({ emitEvent: false });
        });
    };
    NgForm.prototype.getControl = function (dir) { return this.form.find(dir.path); };
    NgForm.prototype.removeControl = function (dir) {
        var _this = this;
        async_1.PromiseWrapper.scheduleMicrotask(function () {
            var container = _this._findContainer(dir.path);
            if (lang_1.isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValueAndValidity({ emitEvent: false });
            }
        });
    };
    NgForm.prototype.addControlGroup = function (dir) {
        var _this = this;
        async_1.PromiseWrapper.scheduleMicrotask(function () {
            var container = _this._findContainer(dir.path);
            var group = new model_1.ControlGroup({});
            shared_1.setUpControlGroup(group, dir);
            container.addControl(dir.name, group);
            group.updateValueAndValidity({ emitEvent: false });
        });
    };
    NgForm.prototype.removeControlGroup = function (dir) {
        var _this = this;
        async_1.PromiseWrapper.scheduleMicrotask(function () {
            var container = _this._findContainer(dir.path);
            if (lang_1.isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValueAndValidity({ emitEvent: false });
            }
        });
    };
    NgForm.prototype.getControlGroup = function (dir) {
        return this.form.find(dir.path);
    };
    NgForm.prototype.updateModel = function (dir, value) {
        var _this = this;
        async_1.PromiseWrapper.scheduleMicrotask(function () {
            var ctrl = _this.form.find(dir.path);
            ctrl.updateValue(value);
        });
    };
    NgForm.prototype.onSubmit = function () {
        async_1.ObservableWrapper.callEmit(this.ngSubmit, null);
        return false;
    };
    /** @internal */
    NgForm.prototype._findContainer = function (path) {
        path.pop();
        return collection_1.ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
    };
    NgForm.decorators = [
        { type: core_1.Directive, args: [{
                    selector: 'form:not([ngNoForm]):not([ngFormModel]),ngForm,[ngForm]',
                    bindings: [exports.formDirectiveProvider],
                    host: {
                        '(submit)': 'onSubmit()',
                    },
                    outputs: ['ngSubmit'],
                    exportAs: 'ngForm'
                },] },
    ];
    NgForm.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
    ];
    return NgForm;
}(control_container_1.ControlContainer));
exports.NgForm = NgForm;

},{"../../../src/facade/async":20,"../../../src/facade/collection":22,"../../../src/facade/lang":26,"../model":50,"../validators":51,"./control_container":32,"./shared":47,"@angular/core":140}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var collection_1 = require('../../../src/facade/collection');
var async_1 = require('../../../src/facade/async');
var ng_control_1 = require('./ng_control');
var validators_1 = require('../validators');
var control_value_accessor_1 = require('./control_value_accessor');
var shared_1 = require('./shared');
exports.formControlBinding = 
/*@ts2dart_const*/ /* @ts2dart_Provider */ {
    provide: ng_control_1.NgControl,
    useExisting: core_1.forwardRef(function () { return NgFormControl; })
};
var NgFormControl = (function (_super) {
    __extends(NgFormControl, _super);
    function NgFormControl(_validators, _asyncValidators, valueAccessors) {
        _super.call(this);
        this._validators = _validators;
        this._asyncValidators = _asyncValidators;
        this.update = new async_1.EventEmitter();
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgFormControl.prototype.ngOnChanges = function (changes) {
        if (this._isControlChanged(changes)) {
            shared_1.setUpControl(this.form, this);
            this.form.updateValueAndValidity({ emitEvent: false });
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this.form.updateValue(this.model);
            this.viewModel = this.model;
        }
    };
    Object.defineProperty(NgFormControl.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "validator", {
        get: function () { return shared_1.composeValidators(this._validators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "asyncValidator", {
        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormControl.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    NgFormControl.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callEmit(this.update, newValue);
    };
    NgFormControl.prototype._isControlChanged = function (changes) {
        return collection_1.StringMapWrapper.contains(changes, "form");
    };
    NgFormControl.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[ngFormControl]',
                    bindings: [exports.formControlBinding],
                    inputs: ['form: ngFormControl', 'model: ngModel'],
                    outputs: ['update: ngModelChange'],
                    exportAs: 'ngForm'
                },] },
    ];
    NgFormControl.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [control_value_accessor_1.NG_VALUE_ACCESSOR,] },] },
    ];
    return NgFormControl;
}(ng_control_1.NgControl));
exports.NgFormControl = NgFormControl;

},{"../../../src/facade/async":20,"../../../src/facade/collection":22,"../validators":51,"./control_value_accessor":33,"./ng_control":35,"./shared":47,"@angular/core":140}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var collection_1 = require('../../../src/facade/collection');
var exceptions_1 = require('../../../src/facade/exceptions');
var async_1 = require('../../../src/facade/async');
var control_container_1 = require('./control_container');
var shared_1 = require('./shared');
var validators_1 = require('../validators');
exports.formDirectiveProvider = 
/*@ts2dart_const*/ /* @ts2dart_Provider */ {
    provide: control_container_1.ControlContainer,
    useExisting: core_1.forwardRef(function () { return NgFormModel; })
};
var NgFormModel = (function (_super) {
    __extends(NgFormModel, _super);
    function NgFormModel(_validators, _asyncValidators) {
        _super.call(this);
        this._validators = _validators;
        this._asyncValidators = _asyncValidators;
        this.form = null;
        this.directives = [];
        this.ngSubmit = new async_1.EventEmitter();
    }
    NgFormModel.prototype.ngOnChanges = function (changes) {
        this._checkFormPresent();
        if (collection_1.StringMapWrapper.contains(changes, "form")) {
            var sync = shared_1.composeValidators(this._validators);
            this.form.validator = validators_1.Validators.compose([this.form.validator, sync]);
            var async = shared_1.composeAsyncValidators(this._asyncValidators);
            this.form.asyncValidator = validators_1.Validators.composeAsync([this.form.asyncValidator, async]);
            this.form.updateValueAndValidity({ onlySelf: true, emitEvent: false });
        }
        this._updateDomValue();
    };
    Object.defineProperty(NgFormModel.prototype, "formDirective", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "control", {
        get: function () { return this.form; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgFormModel.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    NgFormModel.prototype.addControl = function (dir) {
        var ctrl = this.form.find(dir.path);
        shared_1.setUpControl(ctrl, dir);
        ctrl.updateValueAndValidity({ emitEvent: false });
        this.directives.push(dir);
    };
    NgFormModel.prototype.getControl = function (dir) { return this.form.find(dir.path); };
    NgFormModel.prototype.removeControl = function (dir) { collection_1.ListWrapper.remove(this.directives, dir); };
    NgFormModel.prototype.addControlGroup = function (dir) {
        var ctrl = this.form.find(dir.path);
        shared_1.setUpControlGroup(ctrl, dir);
        ctrl.updateValueAndValidity({ emitEvent: false });
    };
    NgFormModel.prototype.removeControlGroup = function (dir) { };
    NgFormModel.prototype.getControlGroup = function (dir) {
        return this.form.find(dir.path);
    };
    NgFormModel.prototype.updateModel = function (dir, value) {
        var ctrl = this.form.find(dir.path);
        ctrl.updateValue(value);
    };
    NgFormModel.prototype.onSubmit = function () {
        async_1.ObservableWrapper.callEmit(this.ngSubmit, null);
        return false;
    };
    /** @internal */
    NgFormModel.prototype._updateDomValue = function () {
        var _this = this;
        this.directives.forEach(function (dir) {
            var ctrl = _this.form.find(dir.path);
            dir.valueAccessor.writeValue(ctrl.value);
        });
    };
    NgFormModel.prototype._checkFormPresent = function () {
        if (lang_1.isBlank(this.form)) {
            throw new exceptions_1.BaseException("ngFormModel expects a form. Please pass one in. Example: <form [ngFormModel]=\"myCoolForm\">");
        }
    };
    NgFormModel.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[ngFormModel]',
                    bindings: [exports.formDirectiveProvider],
                    inputs: ['form: ngFormModel'],
                    host: { '(submit)': 'onSubmit()' },
                    outputs: ['ngSubmit'],
                    exportAs: 'ngForm'
                },] },
    ];
    NgFormModel.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
    ];
    return NgFormModel;
}(control_container_1.ControlContainer));
exports.NgFormModel = NgFormModel;

},{"../../../src/facade/async":20,"../../../src/facade/collection":22,"../../../src/facade/exceptions":24,"../../../src/facade/lang":26,"../validators":51,"./control_container":32,"./shared":47,"@angular/core":140}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var async_1 = require('../../../src/facade/async');
var control_value_accessor_1 = require('./control_value_accessor');
var ng_control_1 = require('./ng_control');
var model_1 = require('../model');
var validators_1 = require('../validators');
var shared_1 = require('./shared');
exports.formControlBinding = 
/*@ts2dart_const*/ /* @ts2dart_Provider */ {
    provide: ng_control_1.NgControl,
    useExisting: core_1.forwardRef(function () { return NgModel; })
};
var NgModel = (function (_super) {
    __extends(NgModel, _super);
    function NgModel(_validators, _asyncValidators, valueAccessors) {
        _super.call(this);
        this._validators = _validators;
        this._asyncValidators = _asyncValidators;
        /** @internal */
        this._control = new model_1.Control();
        /** @internal */
        this._added = false;
        this.update = new async_1.EventEmitter();
        this.valueAccessor = shared_1.selectValueAccessor(this, valueAccessors);
    }
    NgModel.prototype.ngOnChanges = function (changes) {
        if (!this._added) {
            shared_1.setUpControl(this._control, this);
            this._control.updateValueAndValidity({ emitEvent: false });
            this._added = true;
        }
        if (shared_1.isPropertyUpdated(changes, this.viewModel)) {
            this._control.updateValue(this.model);
            this.viewModel = this.model;
        }
    };
    Object.defineProperty(NgModel.prototype, "control", {
        get: function () { return this._control; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "path", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "validator", {
        get: function () { return shared_1.composeValidators(this._validators); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgModel.prototype, "asyncValidator", {
        get: function () { return shared_1.composeAsyncValidators(this._asyncValidators); },
        enumerable: true,
        configurable: true
    });
    NgModel.prototype.viewToModelUpdate = function (newValue) {
        this.viewModel = newValue;
        async_1.ObservableWrapper.callEmit(this.update, newValue);
    };
    NgModel.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[ngModel]:not([ngControl]):not([ngFormControl])',
                    bindings: [exports.formControlBinding],
                    inputs: ['model: ngModel'],
                    outputs: ['update: ngModelChange'],
                    exportAs: 'ngForm'
                },] },
    ];
    NgModel.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [validators_1.NG_ASYNC_VALIDATORS,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Self }, { type: core_1.Inject, args: [control_value_accessor_1.NG_VALUE_ACCESSOR,] },] },
    ];
    return NgModel;
}(ng_control_1.NgControl));
exports.NgModel = NgModel;

},{"../../../src/facade/async":20,"../model":50,"../validators":51,"./control_value_accessor":33,"./ng_control":35,"./shared":47,"@angular/core":140}],43:[function(require,module,exports){
"use strict";
function normalizeValidator(validator) {
    if (validator.validate !== undefined) {
        return function (c) { return validator.validate(c); };
    }
    else {
        return validator;
    }
}
exports.normalizeValidator = normalizeValidator;
function normalizeAsyncValidator(validator) {
    if (validator.validate !== undefined) {
        return function (c) { return Promise.resolve(validator.validate(c)); };
    }
    else {
        return validator;
    }
}
exports.normalizeAsyncValidator = normalizeAsyncValidator;

},{}],44:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var control_value_accessor_1 = require('./control_value_accessor');
exports.NUMBER_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return NumberValueAccessor; }),
    multi: true
};
var NumberValueAccessor = (function () {
    function NumberValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    NumberValueAccessor.prototype.writeValue = function (value) {
        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);
    };
    NumberValueAccessor.prototype.registerOnChange = function (fn) {
        this.onChange = function (value) { fn(value == '' ? null : lang_1.NumberWrapper.parseFloat(value)); };
    };
    NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    NumberValueAccessor.decorators = [
        { type: core_1.Directive, args: [{
                    selector: 'input[type=number][ngControl],input[type=number][ngFormControl],input[type=number][ngModel]',
                    host: {
                        '(change)': 'onChange($event.target.value)',
                        '(input)': 'onChange($event.target.value)',
                        '(blur)': 'onTouched()'
                    },
                    bindings: [exports.NUMBER_VALUE_ACCESSOR]
                },] },
    ];
    NumberValueAccessor.ctorParameters = [
        { type: core_1.Renderer, },
        { type: core_1.ElementRef, },
    ];
    return NumberValueAccessor;
}());
exports.NumberValueAccessor = NumberValueAccessor;

},{"../../../src/facade/lang":26,"./control_value_accessor":33,"@angular/core":140}],45:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var collection_1 = require('../../../src/facade/collection');
var control_value_accessor_1 = require('./control_value_accessor');
var ng_control_1 = require('./ng_control');
exports.RADIO_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return RadioControlValueAccessor; }),
    multi: true
};
var RadioControlRegistry = (function () {
    function RadioControlRegistry() {
        this._accessors = [];
    }
    RadioControlRegistry.prototype.add = function (control, accessor) {
        this._accessors.push([control, accessor]);
    };
    RadioControlRegistry.prototype.remove = function (accessor) {
        var indexToRemove = -1;
        for (var i = 0; i < this._accessors.length; ++i) {
            if (this._accessors[i][1] === accessor) {
                indexToRemove = i;
            }
        }
        collection_1.ListWrapper.removeAt(this._accessors, indexToRemove);
    };
    RadioControlRegistry.prototype.select = function (accessor) {
        this._accessors.forEach(function (c) {
            if (c[0].control.root === accessor._control.control.root && c[1] !== accessor) {
                c[1].fireUncheck();
            }
        });
    };
    RadioControlRegistry.decorators = [
        { type: core_1.Injectable },
    ];
    return RadioControlRegistry;
}());
exports.RadioControlRegistry = RadioControlRegistry;
/**
 * The value provided by the forms API for radio buttons.
 */
var RadioButtonState = (function () {
    function RadioButtonState(checked, value) {
        this.checked = checked;
        this.value = value;
    }
    return RadioButtonState;
}());
exports.RadioButtonState = RadioButtonState;
var RadioControlValueAccessor = (function () {
    function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._registry = _registry;
        this._injector = _injector;
        this.onChange = function () { };
        this.onTouched = function () { };
    }
    RadioControlValueAccessor.prototype.ngOnInit = function () {
        this._control = this._injector.get(ng_control_1.NgControl);
        this._registry.add(this._control, this);
    };
    RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };
    RadioControlValueAccessor.prototype.writeValue = function (value) {
        this._state = value;
        if (lang_1.isPresent(value) && value.checked) {
            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', true);
        }
    };
    RadioControlValueAccessor.prototype.registerOnChange = function (fn) {
        var _this = this;
        this._fn = fn;
        this.onChange = function () {
            fn(new RadioButtonState(true, _this._state.value));
            _this._registry.select(_this);
        };
    };
    RadioControlValueAccessor.prototype.fireUncheck = function () { this._fn(new RadioButtonState(false, this._state.value)); };
    RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    RadioControlValueAccessor.decorators = [
        { type: core_1.Directive, args: [{
                    selector: 'input[type=radio][ngControl],input[type=radio][ngFormControl],input[type=radio][ngModel]',
                    host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
                    providers: [exports.RADIO_VALUE_ACCESSOR]
                },] },
    ];
    RadioControlValueAccessor.ctorParameters = [
        { type: core_1.Renderer, },
        { type: core_1.ElementRef, },
        { type: RadioControlRegistry, },
        { type: core_1.Injector, },
    ];
    RadioControlValueAccessor.propDecorators = {
        'name': [{ type: core_1.Input },],
    };
    return RadioControlValueAccessor;
}());
exports.RadioControlValueAccessor = RadioControlValueAccessor;

},{"../../../src/facade/collection":22,"../../../src/facade/lang":26,"./control_value_accessor":33,"./ng_control":35,"@angular/core":140}],46:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var collection_1 = require('../../../src/facade/collection');
var control_value_accessor_1 = require('./control_value_accessor');
exports.SELECT_VALUE_ACCESSOR = {
    provide: control_value_accessor_1.NG_VALUE_ACCESSOR,
    useExisting: core_1.forwardRef(function () { return SelectControlValueAccessor; }),
    multi: true
};
function _buildValueString(id, value) {
    if (lang_1.isBlank(id))
        return "" + value;
    if (!lang_1.isPrimitive(value))
        value = "Object";
    return lang_1.StringWrapper.slice(id + ": " + value, 0, 50);
}
function _extractId(valueString) {
    return valueString.split(":")[0];
}
var SelectControlValueAccessor = (function () {
    function SelectControlValueAccessor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        /** @internal */
        this._optionMap = new Map();
        /** @internal */
        this._idCounter = 0;
        this.onChange = function (_) { };
        this.onTouched = function () { };
    }
    SelectControlValueAccessor.prototype.writeValue = function (value) {
        this.value = value;
        var valueString = _buildValueString(this._getOptionId(value), value);
        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
    };
    SelectControlValueAccessor.prototype.registerOnChange = function (fn) {
        var _this = this;
        this.onChange = function (valueString) { fn(_this._getOptionValue(valueString)); };
    };
    SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
    /** @internal */
    SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };
    /** @internal */
    SelectControlValueAccessor.prototype._getOptionId = function (value) {
        for (var _i = 0, _a = collection_1.MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {
            var id = _a[_i];
            if (lang_1.looseIdentical(this._optionMap.get(id), value))
                return id;
        }
        return null;
    };
    /** @internal */
    SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {
        var value = this._optionMap.get(_extractId(valueString));
        return lang_1.isPresent(value) ? value : valueString;
    };
    SelectControlValueAccessor.decorators = [
        { type: core_1.Directive, args: [{
                    selector: 'select[ngControl],select[ngFormControl],select[ngModel]',
                    host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                    providers: [exports.SELECT_VALUE_ACCESSOR]
                },] },
    ];
    SelectControlValueAccessor.ctorParameters = [
        { type: core_1.Renderer, },
        { type: core_1.ElementRef, },
    ];
    return SelectControlValueAccessor;
}());
exports.SelectControlValueAccessor = SelectControlValueAccessor;
var NgSelectOption = (function () {
    function NgSelectOption(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (lang_1.isPresent(this._select))
            this.id = this._select._registerOption();
    }
    Object.defineProperty(NgSelectOption.prototype, "ngValue", {
        set: function (value) {
            if (this._select == null)
                return;
            this._select._optionMap.set(this.id, value);
            this._setElementValue(_buildValueString(this.id, value));
            this._select.writeValue(this._select.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgSelectOption.prototype, "value", {
        set: function (value) {
            this._setElementValue(value);
            if (lang_1.isPresent(this._select))
                this._select.writeValue(this._select.value);
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    NgSelectOption.prototype._setElementValue = function (value) {
        this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
    };
    NgSelectOption.prototype.ngOnDestroy = function () {
        if (lang_1.isPresent(this._select)) {
            this._select._optionMap.delete(this.id);
            this._select.writeValue(this._select.value);
        }
    };
    NgSelectOption.decorators = [
        { type: core_1.Directive, args: [{ selector: 'option' },] },
    ];
    NgSelectOption.ctorParameters = [
        { type: core_1.ElementRef, },
        { type: core_1.Renderer, },
        { type: SelectControlValueAccessor, decorators: [{ type: core_1.Optional }, { type: core_1.Host },] },
    ];
    NgSelectOption.propDecorators = {
        'ngValue': [{ type: core_1.Input, args: ['ngValue',] },],
        'value': [{ type: core_1.Input, args: ['value',] },],
    };
    return NgSelectOption;
}());
exports.NgSelectOption = NgSelectOption;

},{"../../../src/facade/collection":22,"../../../src/facade/lang":26,"./control_value_accessor":33,"@angular/core":140}],47:[function(require,module,exports){
"use strict";
var collection_1 = require('../../../src/facade/collection');
var lang_1 = require('../../../src/facade/lang');
var exceptions_1 = require('../../../src/facade/exceptions');
var validators_1 = require('../validators');
var default_value_accessor_1 = require('./default_value_accessor');
var number_value_accessor_1 = require('./number_value_accessor');
var checkbox_value_accessor_1 = require('./checkbox_value_accessor');
var select_control_value_accessor_1 = require('./select_control_value_accessor');
var radio_control_value_accessor_1 = require('./radio_control_value_accessor');
var normalize_validator_1 = require('./normalize_validator');
function controlPath(name, parent) {
    var p = collection_1.ListWrapper.clone(parent.path);
    p.push(name);
    return p;
}
exports.controlPath = controlPath;
function setUpControl(control, dir) {
    if (lang_1.isBlank(control))
        _throwError(dir, "Cannot find control");
    if (lang_1.isBlank(dir.valueAccessor))
        _throwError(dir, "No value accessor for");
    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
    dir.valueAccessor.writeValue(control.value);
    // view -> model
    dir.valueAccessor.registerOnChange(function (newValue) {
        dir.viewToModelUpdate(newValue);
        control.updateValue(newValue, { emitModelToViewChange: false });
        control.markAsDirty();
    });
    // model -> view
    control.registerOnChange(function (newValue) { return dir.valueAccessor.writeValue(newValue); });
    // touched
    dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
}
exports.setUpControl = setUpControl;
function setUpControlGroup(control, dir) {
    if (lang_1.isBlank(control))
        _throwError(dir, "Cannot find control");
    control.validator = validators_1.Validators.compose([control.validator, dir.validator]);
    control.asyncValidator = validators_1.Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
}
exports.setUpControlGroup = setUpControlGroup;
function _throwError(dir, message) {
    var path = dir.path.join(" -> ");
    throw new exceptions_1.BaseException(message + " '" + path + "'");
}
function composeValidators(validators) {
    return lang_1.isPresent(validators) ? validators_1.Validators.compose(validators.map(normalize_validator_1.normalizeValidator)) : null;
}
exports.composeValidators = composeValidators;
function composeAsyncValidators(validators) {
    return lang_1.isPresent(validators) ? validators_1.Validators.composeAsync(validators.map(normalize_validator_1.normalizeAsyncValidator)) :
        null;
}
exports.composeAsyncValidators = composeAsyncValidators;
function isPropertyUpdated(changes, viewModel) {
    if (!collection_1.StringMapWrapper.contains(changes, "model"))
        return false;
    var change = changes["model"];
    if (change.isFirstChange())
        return true;
    return !lang_1.looseIdentical(viewModel, change.currentValue);
}
exports.isPropertyUpdated = isPropertyUpdated;
// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
function selectValueAccessor(dir, valueAccessors) {
    if (lang_1.isBlank(valueAccessors))
        return null;
    var defaultAccessor;
    var builtinAccessor;
    var customAccessor;
    valueAccessors.forEach(function (v) {
        if (lang_1.hasConstructor(v, default_value_accessor_1.DefaultValueAccessor)) {
            defaultAccessor = v;
        }
        else if (lang_1.hasConstructor(v, checkbox_value_accessor_1.CheckboxControlValueAccessor) ||
            lang_1.hasConstructor(v, number_value_accessor_1.NumberValueAccessor) ||
            lang_1.hasConstructor(v, select_control_value_accessor_1.SelectControlValueAccessor) ||
            lang_1.hasConstructor(v, radio_control_value_accessor_1.RadioControlValueAccessor)) {
            if (lang_1.isPresent(builtinAccessor))
                _throwError(dir, "More than one built-in value accessor matches");
            builtinAccessor = v;
        }
        else {
            if (lang_1.isPresent(customAccessor))
                _throwError(dir, "More than one custom value accessor matches");
            customAccessor = v;
        }
    });
    if (lang_1.isPresent(customAccessor))
        return customAccessor;
    if (lang_1.isPresent(builtinAccessor))
        return builtinAccessor;
    if (lang_1.isPresent(defaultAccessor))
        return defaultAccessor;
    _throwError(dir, "No valid value accessor for");
    return null;
}
exports.selectValueAccessor = selectValueAccessor;

},{"../../../src/facade/collection":22,"../../../src/facade/exceptions":24,"../../../src/facade/lang":26,"../validators":51,"./checkbox_value_accessor":31,"./default_value_accessor":34,"./normalize_validator":43,"./number_value_accessor":44,"./radio_control_value_accessor":45,"./select_control_value_accessor":46}],48:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../facade/lang');
var validators_1 = require('../validators');
var REQUIRED = validators_1.Validators.required;
exports.REQUIRED_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useValue: REQUIRED,
    multi: true
};
var RequiredValidator = (function () {
    function RequiredValidator() {
    }
    RequiredValidator.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[required][ngControl],[required][ngFormControl],[required][ngModel]',
                    providers: [exports.REQUIRED_VALIDATOR]
                },] },
    ];
    return RequiredValidator;
}());
exports.RequiredValidator = RequiredValidator;
/**
 * Provivder which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
 *
 * ## Example:
 *
 * {@example common/forms/ts/validators/validators.ts region='min'}
 */
exports.MIN_LENGTH_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useExisting: core_1.forwardRef(function () { return MinLengthValidator; }),
    multi: true
};
var MinLengthValidator = (function () {
    function MinLengthValidator(minLength) {
        this._validator = validators_1.Validators.minLength(lang_1.NumberWrapper.parseInt(minLength, 10));
    }
    MinLengthValidator.prototype.validate = function (c) { return this._validator(c); };
    MinLengthValidator.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[minlength][ngControl],[minlength][ngFormControl],[minlength][ngModel]',
                    providers: [exports.MIN_LENGTH_VALIDATOR]
                },] },
    ];
    MinLengthValidator.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Attribute, args: ["minlength",] },] },
    ];
    return MinLengthValidator;
}());
exports.MinLengthValidator = MinLengthValidator;
/**
 * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
 *
 * ## Example:
 *
 * {@example common/forms/ts/validators/validators.ts region='max'}
 */
exports.MAX_LENGTH_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useExisting: core_1.forwardRef(function () { return MaxLengthValidator; }),
    multi: true
};
var MaxLengthValidator = (function () {
    function MaxLengthValidator(maxLength) {
        this._validator = validators_1.Validators.maxLength(lang_1.NumberWrapper.parseInt(maxLength, 10));
    }
    MaxLengthValidator.prototype.validate = function (c) { return this._validator(c); };
    MaxLengthValidator.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[maxlength][ngControl],[maxlength][ngFormControl],[maxlength][ngModel]',
                    providers: [exports.MAX_LENGTH_VALIDATOR]
                },] },
    ];
    MaxLengthValidator.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Attribute, args: ["maxlength",] },] },
    ];
    return MaxLengthValidator;
}());
exports.MaxLengthValidator = MaxLengthValidator;
/**
 * A Directive that adds the `pattern` validator to any controls marked with the
 * `pattern` attribute, via the {@link NG_VALIDATORS} binding. Uses attribute value
 * as the regex to validate Control value against.  Follows pattern attribute
 * semantics; i.e. regex must match entire Control value.
 *
 * ### Example
 *
 * ```
 * <input [ngControl]="fullName" pattern="[a-zA-Z ]*">
 * ```
 */
exports.PATTERN_VALIDATOR = {
    provide: validators_1.NG_VALIDATORS,
    useExisting: core_1.forwardRef(function () { return PatternValidator; }),
    multi: true
};
var PatternValidator = (function () {
    function PatternValidator(pattern) {
        this._validator = validators_1.Validators.pattern(pattern);
    }
    PatternValidator.prototype.validate = function (c) { return this._validator(c); };
    PatternValidator.decorators = [
        { type: core_1.Directive, args: [{
                    selector: '[pattern][ngControl],[pattern][ngFormControl],[pattern][ngModel]',
                    providers: [exports.PATTERN_VALIDATOR]
                },] },
    ];
    PatternValidator.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Attribute, args: ["pattern",] },] },
    ];
    return PatternValidator;
}());
exports.PatternValidator = PatternValidator;

},{"../../facade/lang":26,"../validators":51,"@angular/core":140}],49:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var modelModule = require('./model');
var FormBuilder = (function () {
    function FormBuilder() {
    }
    /**
     * Construct a new {@link ControlGroup} with the given map of configuration.
     * Valid keys for the `extra` parameter map are `optionals` and `validator`.
     *
     * See the {@link ControlGroup} constructor for more details.
     */
    FormBuilder.prototype.group = function (controlsConfig, extra) {
        if (extra === void 0) { extra = null; }
        var controls = this._reduceControls(controlsConfig);
        var optionals = (lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "optionals") : null);
        var validator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "validator") : null;
        var asyncValidator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "asyncValidator") : null;
        return new modelModule.ControlGroup(controls, optionals, validator, asyncValidator);
    };
    /**
     * Construct a new {@link Control} with the given `value`,`validator`, and `asyncValidator`.
     */
    FormBuilder.prototype.control = function (value, validator, asyncValidator) {
        if (validator === void 0) { validator = null; }
        if (asyncValidator === void 0) { asyncValidator = null; }
        return new modelModule.Control(value, validator, asyncValidator);
    };
    /**
     * Construct an array of {@link Control}s from the given `controlsConfig` array of
     * configuration, with the given optional `validator` and `asyncValidator`.
     */
    FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
        var _this = this;
        if (validator === void 0) { validator = null; }
        if (asyncValidator === void 0) { asyncValidator = null; }
        var controls = controlsConfig.map(function (c) { return _this._createControl(c); });
        return new modelModule.ControlArray(controls, validator, asyncValidator);
    };
    /** @internal */
    FormBuilder.prototype._reduceControls = function (controlsConfig) {
        var _this = this;
        var controls = {};
        collection_1.StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {
            controls[controlName] = _this._createControl(controlConfig);
        });
        return controls;
    };
    /** @internal */
    FormBuilder.prototype._createControl = function (controlConfig) {
        if (controlConfig instanceof modelModule.Control ||
            controlConfig instanceof modelModule.ControlGroup ||
            controlConfig instanceof modelModule.ControlArray) {
            return controlConfig;
        }
        else if (lang_1.isArray(controlConfig)) {
            var value = controlConfig[0];
            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
            var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
            return this.control(value, validator, asyncValidator);
        }
        else {
            return this.control(controlConfig);
        }
    };
    FormBuilder.decorators = [
        { type: core_1.Injectable },
    ];
    return FormBuilder;
}());
exports.FormBuilder = FormBuilder;

},{"../../src/facade/collection":22,"../../src/facade/lang":26,"./model":50,"@angular/core":140}],50:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var async_1 = require('../../src/facade/async');
var promise_1 = require('../../src/facade/promise');
var collection_1 = require('../../src/facade/collection');
/**
 * Indicates that a Control is valid, i.e. that no errors exist in the input value.
 */
exports.VALID = "VALID";
/**
 * Indicates that a Control is invalid, i.e. that an error exists in the input value.
 */
exports.INVALID = "INVALID";
/**
 * Indicates that a Control is pending, i.e. that async validation is occurring and
 * errors are not yet available for the input value.
 */
exports.PENDING = "PENDING";
function isControl(control) {
    return control instanceof AbstractControl;
}
exports.isControl = isControl;
function _find(control, path) {
    if (lang_1.isBlank(path))
        return null;
    if (!(path instanceof Array)) {
        path = path.split("/");
    }
    if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))
        return null;
    return path
        .reduce(function (v, name) {
        if (v instanceof ControlGroup) {
            return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;
        }
        else if (v instanceof ControlArray) {
            var index = name;
            return lang_1.isPresent(v.at(index)) ? v.at(index) : null;
        }
        else {
            return null;
        }
    }, control);
}
function toObservable(r) {
    return promise_1.PromiseWrapper.isPromise(r) ? async_1.ObservableWrapper.fromPromise(r) : r;
}
/**
 *
 */
var AbstractControl = (function () {
    function AbstractControl(validator, asyncValidator) {
        this.validator = validator;
        this.asyncValidator = asyncValidator;
        this._pristine = true;
        this._touched = false;
    }
    Object.defineProperty(AbstractControl.prototype, "value", {
        get: function () { return this._value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "status", {
        get: function () { return this._status; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valid", {
        get: function () { return this._status === exports.VALID; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "errors", {
        /**
         * Returns the errors of this control.
         */
        get: function () { return this._errors; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pristine", {
        get: function () { return this._pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "dirty", {
        get: function () { return !this.pristine; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "touched", {
        get: function () { return this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "untouched", {
        get: function () { return !this._touched; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
        get: function () { return this._valueChanges; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "statusChanges", {
        get: function () { return this._statusChanges; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractControl.prototype, "pending", {
        get: function () { return this._status == exports.PENDING; },
        enumerable: true,
        configurable: true
    });
    AbstractControl.prototype.markAsTouched = function () { this._touched = true; };
    AbstractControl.prototype.markAsDirty = function (_a) {
        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
        onlySelf = lang_1.normalizeBool(onlySelf);
        this._pristine = false;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.markAsDirty({ onlySelf: onlySelf });
        }
    };
    AbstractControl.prototype.markAsPending = function (_a) {
        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
        onlySelf = lang_1.normalizeBool(onlySelf);
        this._status = exports.PENDING;
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.markAsPending({ onlySelf: onlySelf });
        }
    };
    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
    AbstractControl.prototype.updateValueAndValidity = function (_a) {
        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
        onlySelf = lang_1.normalizeBool(onlySelf);
        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
        this._updateValue();
        this._errors = this._runValidator();
        this._status = this._calculateStatus();
        if (this._status == exports.VALID || this._status == exports.PENDING) {
            this._runAsyncValidator(emitEvent);
        }
        if (emitEvent) {
            async_1.ObservableWrapper.callEmit(this._valueChanges, this._value);
            async_1.ObservableWrapper.callEmit(this._statusChanges, this._status);
        }
        if (lang_1.isPresent(this._parent) && !onlySelf) {
            this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
        }
    };
    AbstractControl.prototype._runValidator = function () {
        return lang_1.isPresent(this.validator) ? this.validator(this) : null;
    };
    AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
        var _this = this;
        if (lang_1.isPresent(this.asyncValidator)) {
            this._status = exports.PENDING;
            this._cancelExistingSubscription();
            var obs = toObservable(this.asyncValidator(this));
            this._asyncValidationSubscription = async_1.ObservableWrapper.subscribe(obs, function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); });
        }
    };
    AbstractControl.prototype._cancelExistingSubscription = function () {
        if (lang_1.isPresent(this._asyncValidationSubscription)) {
            async_1.ObservableWrapper.dispose(this._asyncValidationSubscription);
        }
    };
    /**
     * Sets errors on a control.
     *
     * This is used when validations are run not automatically, but manually by the user.
     *
     * Calling `setErrors` will also update the validity of the parent control.
     *
     * ## Usage
     *
     * ```
     * var login = new Control("someLogin");
     * login.setErrors({
     *   "notUnique": true
     * });
     *
     * expect(login.valid).toEqual(false);
     * expect(login.errors).toEqual({"notUnique": true});
     *
     * login.updateValue("someOtherLogin");
     *
     * expect(login.valid).toEqual(true);
     * ```
     */
    AbstractControl.prototype.setErrors = function (errors, _a) {
        var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
        this._errors = errors;
        this._status = this._calculateStatus();
        if (emitEvent) {
            async_1.ObservableWrapper.callEmit(this._statusChanges, this._status);
        }
        if (lang_1.isPresent(this._parent)) {
            this._parent._updateControlsErrors();
        }
    };
    AbstractControl.prototype.find = function (path) { return _find(this, path); };
    AbstractControl.prototype.getError = function (errorCode, path) {
        if (path === void 0) { path = null; }
        var control = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;
        if (lang_1.isPresent(control) && lang_1.isPresent(control._errors)) {
            return collection_1.StringMapWrapper.get(control._errors, errorCode);
        }
        else {
            return null;
        }
    };
    AbstractControl.prototype.hasError = function (errorCode, path) {
        if (path === void 0) { path = null; }
        return lang_1.isPresent(this.getError(errorCode, path));
    };
    Object.defineProperty(AbstractControl.prototype, "root", {
        get: function () {
            var x = this;
            while (lang_1.isPresent(x._parent)) {
                x = x._parent;
            }
            return x;
        },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    AbstractControl.prototype._updateControlsErrors = function () {
        this._status = this._calculateStatus();
        if (lang_1.isPresent(this._parent)) {
            this._parent._updateControlsErrors();
        }
    };
    /** @internal */
    AbstractControl.prototype._initObservables = function () {
        this._valueChanges = new async_1.EventEmitter();
        this._statusChanges = new async_1.EventEmitter();
    };
    AbstractControl.prototype._calculateStatus = function () {
        if (lang_1.isPresent(this._errors))
            return exports.INVALID;
        if (this._anyControlsHaveStatus(exports.PENDING))
            return exports.PENDING;
        if (this._anyControlsHaveStatus(exports.INVALID))
            return exports.INVALID;
        return exports.VALID;
    };
    return AbstractControl;
}());
exports.AbstractControl = AbstractControl;
/**
 * Defines a part of a form that cannot be divided into other controls. `Control`s have values and
 * validation state, which is determined by an optional validation function.
 *
 * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
 * with {@link ControlGroup} and {@link ControlArray}.
 *
 * ## Usage
 *
 * By default, a `Control` is created for every `<input>` or other form component.
 * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be
 * bound to a DOM element instead. This `Control` can be configured with a custom
 * validation function.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var Control = (function (_super) {
    __extends(Control, _super);
    function Control(value, validator, asyncValidator) {
        if (value === void 0) { value = null; }
        if (validator === void 0) { validator = null; }
        if (asyncValidator === void 0) { asyncValidator = null; }
        _super.call(this, validator, asyncValidator);
        this._value = value;
        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
        this._initObservables();
    }
    /**
     * Set the value of the control to `value`.
     *
     * If `onlySelf` is `true`, this change will only affect the validation of this `Control`
     * and not its parent component. If `emitEvent` is `true`, this change will cause a
     * `valueChanges` event on the `Control` to be emitted. Both of these options default to
     * `false`.
     *
     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
     * specified.
     */
    Control.prototype.updateValue = function (value, _a) {
        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange;
        emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
        this._value = value;
        if (lang_1.isPresent(this._onChange) && emitModelToViewChange)
            this._onChange(this._value);
        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
    };
    /**
     * @internal
     */
    Control.prototype._updateValue = function () { };
    /**
     * @internal
     */
    Control.prototype._anyControlsHaveStatus = function (status) { return false; };
    /**
     * Register a listener for change events.
     */
    Control.prototype.registerOnChange = function (fn) { this._onChange = fn; };
    return Control;
}(AbstractControl));
exports.Control = Control;
/**
 * Defines a part of a form, of fixed length, that can contain other controls.
 *
 * A `ControlGroup` aggregates the values of each {@link Control} in the group.
 * The status of a `ControlGroup` depends on the status of its children.
 * If one of the controls in a group is invalid, the entire group is invalid.
 * Similarly, if a control changes its value, the entire group changes as well.
 *
 * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other
 * controls, but is of variable length.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var ControlGroup = (function (_super) {
    __extends(ControlGroup, _super);
    function ControlGroup(controls, optionals, validator, asyncValidator) {
        if (optionals === void 0) { optionals = null; }
        if (validator === void 0) { validator = null; }
        if (asyncValidator === void 0) { asyncValidator = null; }
        _super.call(this, validator, asyncValidator);
        this.controls = controls;
        this._optionals = lang_1.isPresent(optionals) ? optionals : {};
        this._initObservables();
        this._setParentForControls();
        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
    }
    /**
     * Add a control to this group.
     */
    ControlGroup.prototype.addControl = function (name, control) {
        this.controls[name] = control;
        control.setParent(this);
    };
    /**
     * Remove a control from this group.
     */
    ControlGroup.prototype.removeControl = function (name) { collection_1.StringMapWrapper.delete(this.controls, name); };
    /**
     * Mark the named control as non-optional.
     */
    ControlGroup.prototype.include = function (controlName) {
        collection_1.StringMapWrapper.set(this._optionals, controlName, true);
        this.updateValueAndValidity();
    };
    /**
     * Mark the named control as optional.
     */
    ControlGroup.prototype.exclude = function (controlName) {
        collection_1.StringMapWrapper.set(this._optionals, controlName, false);
        this.updateValueAndValidity();
    };
    /**
     * Check whether there is a control with the given name in the group.
     */
    ControlGroup.prototype.contains = function (controlName) {
        var c = collection_1.StringMapWrapper.contains(this.controls, controlName);
        return c && this._included(controlName);
    };
    /** @internal */
    ControlGroup.prototype._setParentForControls = function () {
        var _this = this;
        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) { control.setParent(_this); });
    };
    /** @internal */
    ControlGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
    /** @internal */
    ControlGroup.prototype._anyControlsHaveStatus = function (status) {
        var _this = this;
        var res = false;
        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {
            res = res || (_this.contains(name) && control.status == status);
        });
        return res;
    };
    /** @internal */
    ControlGroup.prototype._reduceValue = function () {
        return this._reduceChildren({}, function (acc, control, name) {
            acc[name] = control.value;
            return acc;
        });
    };
    /** @internal */
    ControlGroup.prototype._reduceChildren = function (initValue, fn) {
        var _this = this;
        var res = initValue;
        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {
            if (_this._included(name)) {
                res = fn(res, control, name);
            }
        });
        return res;
    };
    /** @internal */
    ControlGroup.prototype._included = function (controlName) {
        var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);
        return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);
    };
    return ControlGroup;
}(AbstractControl));
exports.ControlGroup = ControlGroup;
/**
 * Defines a part of a form, of variable length, that can contain other controls.
 *
 * A `ControlArray` aggregates the values of each {@link Control} in the group.
 * The status of a `ControlArray` depends on the status of its children.
 * If one of the controls in a group is invalid, the entire array is invalid.
 * Similarly, if a control changes its value, the entire array changes as well.
 *
 * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
 * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
 * other controls, but is of fixed length.
 *
 * ## Adding or removing controls
 *
 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
 * in `ControlArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `ControlArray` directly, as that will result in strange and unexpected behavior such
 * as broken change detection.
 *
 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
 */
var ControlArray = (function (_super) {
    __extends(ControlArray, _super);
    function ControlArray(controls, validator, asyncValidator) {
        if (validator === void 0) { validator = null; }
        if (asyncValidator === void 0) { asyncValidator = null; }
        _super.call(this, validator, asyncValidator);
        this.controls = controls;
        this._initObservables();
        this._setParentForControls();
        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
    }
    /**
     * Get the {@link AbstractControl} at the given `index` in the array.
     */
    ControlArray.prototype.at = function (index) { return this.controls[index]; };
    /**
     * Insert a new {@link AbstractControl} at the end of the array.
     */
    ControlArray.prototype.push = function (control) {
        this.controls.push(control);
        control.setParent(this);
        this.updateValueAndValidity();
    };
    /**
     * Insert a new {@link AbstractControl} at the given `index` in the array.
     */
    ControlArray.prototype.insert = function (index, control) {
        collection_1.ListWrapper.insert(this.controls, index, control);
        control.setParent(this);
        this.updateValueAndValidity();
    };
    /**
     * Remove the control at the given `index` in the array.
     */
    ControlArray.prototype.removeAt = function (index) {
        collection_1.ListWrapper.removeAt(this.controls, index);
        this.updateValueAndValidity();
    };
    Object.defineProperty(ControlArray.prototype, "length", {
        /**
         * Length of the control array.
         */
        get: function () { return this.controls.length; },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    ControlArray.prototype._updateValue = function () { this._value = this.controls.map(function (control) { return control.value; }); };
    /** @internal */
    ControlArray.prototype._anyControlsHaveStatus = function (status) {
        return this.controls.some(function (c) { return c.status == status; });
    };
    /** @internal */
    ControlArray.prototype._setParentForControls = function () {
        var _this = this;
        this.controls.forEach(function (control) { control.setParent(_this); });
    };
    return ControlArray;
}(AbstractControl));
exports.ControlArray = ControlArray;

},{"../../src/facade/async":20,"../../src/facade/collection":22,"../../src/facade/lang":26,"../../src/facade/promise":27}],51:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var promise_1 = require('../../src/facade/promise');
var async_1 = require('../../src/facade/async');
var collection_1 = require('../../src/facade/collection');
/**
 * Providers for validators to be used for {@link Control}s in a form.
 *
 * Provide this using `multi: true` to add validators.
 *
 * ### Example
 *
 * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
 */
exports.NG_VALIDATORS = new core_1.OpaqueToken("NgValidators");
/**
 * Providers for asynchronous validators to be used for {@link Control}s
 * in a form.
 *
 * Provide this using `multi: true` to add validators.
 *
 * See {@link NG_VALIDATORS} for more details.
 */
exports.NG_ASYNC_VALIDATORS = 
/*@ts2dart_const*/ new core_1.OpaqueToken("NgAsyncValidators");
/**
 * Provides a set of validators used by form controls.
 *
 * A validator is a function that processes a {@link Control} or collection of
 * controls and returns a map of errors. A null map means that validation has passed.
 *
 * ### Example
 *
 * ```typescript
 * var loginControl = new Control("", Validators.required)
 * ```
 */
var Validators = (function () {
    function Validators() {
    }
    /**
     * Validator that requires controls to have a non-empty value.
     */
    Validators.required = function (control) {
        return lang_1.isBlank(control.value) || (lang_1.isString(control.value) && control.value == "") ?
            { "required": true } :
            null;
    };
    /**
     * Validator that requires controls to have a value of a minimum length.
     */
    Validators.minLength = function (minLength) {
        return function (control) {
            if (lang_1.isPresent(Validators.required(control)))
                return null;
            var v = control.value;
            return v.length < minLength ?
                { "minlength": { "requiredLength": minLength, "actualLength": v.length } } :
                null;
        };
    };
    /**
     * Validator that requires controls to have a value of a maximum length.
     */
    Validators.maxLength = function (maxLength) {
        return function (control) {
            if (lang_1.isPresent(Validators.required(control)))
                return null;
            var v = control.value;
            return v.length > maxLength ?
                { "maxlength": { "requiredLength": maxLength, "actualLength": v.length } } :
                null;
        };
    };
    /**
     * Validator that requires a control to match a regex to its value.
     */
    Validators.pattern = function (pattern) {
        return function (control) {
            if (lang_1.isPresent(Validators.required(control)))
                return null;
            var regex = new RegExp("^" + pattern + "$");
            var v = control.value;
            return regex.test(v) ? null :
                { "pattern": { "requiredPattern": "^" + pattern + "$", "actualValue": v } };
        };
    };
    /**
     * No-op validator.
     */
    Validators.nullValidator = function (c) { return null; };
    /**
     * Compose multiple validators into a single function that returns the union
     * of the individual error maps.
     */
    Validators.compose = function (validators) {
        if (lang_1.isBlank(validators))
            return null;
        var presentValidators = validators.filter(lang_1.isPresent);
        if (presentValidators.length == 0)
            return null;
        return function (control) {
            return _mergeErrors(_executeValidators(control, presentValidators));
        };
    };
    Validators.composeAsync = function (validators) {
        if (lang_1.isBlank(validators))
            return null;
        var presentValidators = validators.filter(lang_1.isPresent);
        if (presentValidators.length == 0)
            return null;
        return function (control) {
            var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
            return promise_1.PromiseWrapper.all(promises).then(_mergeErrors);
        };
    };
    return Validators;
}());
exports.Validators = Validators;
function _convertToPromise(obj) {
    return promise_1.PromiseWrapper.isPromise(obj) ? obj : async_1.ObservableWrapper.toPromise(obj);
}
function _executeValidators(control, validators) {
    return validators.map(function (v) { return v(control); });
}
function _executeAsyncValidators(control, validators) {
    return validators.map(function (v) { return v(control); });
}
function _mergeErrors(arrayOfErrors) {
    var res = arrayOfErrors.reduce(function (res, errors) {
        return lang_1.isPresent(errors) ? collection_1.StringMapWrapper.merge(res, errors) : res;
    }, {});
    return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
}

},{"../../src/facade/async":20,"../../src/facade/collection":22,"../../src/facade/lang":26,"../../src/facade/promise":27,"@angular/core":140}],52:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./location/platform_location'));
__export(require('./location/location_strategy'));
__export(require('./location/hash_location_strategy'));
__export(require('./location/path_location_strategy'));
__export(require('./location/location'));

},{"./location/hash_location_strategy":53,"./location/location":54,"./location/location_strategy":55,"./location/path_location_strategy":56,"./location/platform_location":57}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var location_strategy_1 = require('./location_strategy');
var location_1 = require('./location');
var platform_location_1 = require('./platform_location');
var HashLocationStrategy = (function (_super) {
    __extends(HashLocationStrategy, _super);
    function HashLocationStrategy(_platformLocation, _baseHref) {
        _super.call(this);
        this._platformLocation = _platformLocation;
        this._baseHref = '';
        if (lang_1.isPresent(_baseHref)) {
            this._baseHref = _baseHref;
        }
    }
    HashLocationStrategy.prototype.onPopState = function (fn) {
        this._platformLocation.onPopState(fn);
        this._platformLocation.onHashChange(fn);
    };
    HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
    HashLocationStrategy.prototype.path = function () {
        // the hash value is always prefixed with a `#`
        // and if it is empty then it will stay empty
        var path = this._platformLocation.hash;
        if (!lang_1.isPresent(path))
            path = '#';
        // Dart will complain if a call to substring is
        // executed with a position value that extends the
        // length of string.
        return (path.length > 0 ? path.substring(1) : path);
    };
    HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
        var url = location_1.Location.joinWithSlash(this._baseHref, internal);
        return url.length > 0 ? ('#' + url) : url;
    };
    HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
        var url = this.prepareExternalUrl(path + location_1.Location.normalizeQueryParams(queryParams));
        if (url.length == 0) {
            url = this._platformLocation.pathname;
        }
        this._platformLocation.pushState(state, title, url);
    };
    HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
        var url = this.prepareExternalUrl(path + location_1.Location.normalizeQueryParams(queryParams));
        if (url.length == 0) {
            url = this._platformLocation.pathname;
        }
        this._platformLocation.replaceState(state, title, url);
    };
    HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
    HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
    HashLocationStrategy.decorators = [
        { type: core_1.Injectable },
    ];
    HashLocationStrategy.ctorParameters = [
        { type: platform_location_1.PlatformLocation, },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: [location_strategy_1.APP_BASE_HREF,] },] },
    ];
    return HashLocationStrategy;
}(location_strategy_1.LocationStrategy));
exports.HashLocationStrategy = HashLocationStrategy;

},{"../../src/facade/lang":26,"./location":54,"./location_strategy":55,"./platform_location":57,"@angular/core":140}],54:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var async_1 = require('../../src/facade/async');
var location_strategy_1 = require('./location_strategy');
var Location = (function () {
    function Location(platformStrategy) {
        var _this = this;
        this.platformStrategy = platformStrategy;
        /** @internal */
        this._subject = new async_1.EventEmitter();
        var browserBaseHref = this.platformStrategy.getBaseHref();
        this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
        this.platformStrategy.onPopState(function (ev) {
            async_1.ObservableWrapper.callEmit(_this._subject, { 'url': _this.path(), 'pop': true, 'type': ev.type });
        });
    }
    /**
     * Returns the normalized URL path.
     */
    Location.prototype.path = function () { return this.normalize(this.platformStrategy.path()); };
    /**
     * Given a string representing a URL, returns the normalized URL path without leading or
     * trailing slashes
     */
    Location.prototype.normalize = function (url) {
        return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    };
    /**
     * Given a string representing a URL, returns the platform-specific external URL path.
     * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
     * before normalizing. This method will also add a hash if `HashLocationStrategy` is
     * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
     */
    Location.prototype.prepareExternalUrl = function (url) {
        if (url.length > 0 && !url.startsWith('/')) {
            url = '/' + url;
        }
        return this.platformStrategy.prepareExternalUrl(url);
    };
    // TODO: rename this method to pushState
    /**
     * Changes the browsers URL to the normalized version of the given URL, and pushes a
     * new item onto the platform's history.
     */
    Location.prototype.go = function (path, query) {
        if (query === void 0) { query = ''; }
        this.platformStrategy.pushState(null, '', path, query);
    };
    /**
     * Changes the browsers URL to the normalized version of the given URL, and replaces
     * the top item on the platform's history stack.
     */
    Location.prototype.replaceState = function (path, query) {
        if (query === void 0) { query = ''; }
        this.platformStrategy.replaceState(null, '', path, query);
    };
    /**
     * Navigates forward in the platform's history.
     */
    Location.prototype.forward = function () { this.platformStrategy.forward(); };
    /**
     * Navigates back in the platform's history.
     */
    Location.prototype.back = function () { this.platformStrategy.back(); };
    /**
     * Subscribe to the platform's `popState` events.
     */
    Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
        if (onThrow === void 0) { onThrow = null; }
        if (onReturn === void 0) { onReturn = null; }
        return async_1.ObservableWrapper.subscribe(this._subject, onNext, onThrow, onReturn);
    };
    /**
     * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
     * is.
     */
    Location.normalizeQueryParams = function (params) {
        return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
    };
    /**
     * Given 2 parts of a url, join them with a slash if needed.
     */
    Location.joinWithSlash = function (start, end) {
        if (start.length == 0) {
            return end;
        }
        if (end.length == 0) {
            return start;
        }
        var slashes = 0;
        if (start.endsWith('/')) {
            slashes++;
        }
        if (end.startsWith('/')) {
            slashes++;
        }
        if (slashes == 2) {
            return start + end.substring(1);
        }
        if (slashes == 1) {
            return start + end;
        }
        return start + '/' + end;
    };
    /**
     * If url has a trailing slash, remove it, otherwise return url as is.
     */
    Location.stripTrailingSlash = function (url) {
        if (/\/$/g.test(url)) {
            url = url.substring(0, url.length - 1);
        }
        return url;
    };
    Location.decorators = [
        { type: core_1.Injectable },
    ];
    Location.ctorParameters = [
        { type: location_strategy_1.LocationStrategy, },
    ];
    return Location;
}());
exports.Location = Location;
function _stripBaseHref(baseHref, url) {
    if (baseHref.length > 0 && url.startsWith(baseHref)) {
        return url.substring(baseHref.length);
    }
    return url;
}
function _stripIndexHtml(url) {
    if (/\/index.html$/g.test(url)) {
        // '/index.html'.length == 11
        return url.substring(0, url.length - 11);
    }
    return url;
}

},{"../../src/facade/async":20,"./location_strategy":55,"@angular/core":140}],55:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
/**
 * `LocationStrategy` is responsible for representing and reading route state
 * from the browser's URL. Angular provides two strategies:
 * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).
 *
 * This is used under the hood of the {@link Location} service.
 *
 * Applications should use the {@link Router} or {@link Location} services to
 * interact with application route state.
 *
 * For instance, {@link HashLocationStrategy} produces URLs like
 * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
 * `http://example.com/foo` as an equivalent URL.
 *
 * See these two classes for more.
 */
var LocationStrategy = (function () {
    function LocationStrategy() {
    }
    return LocationStrategy;
}());
exports.LocationStrategy = LocationStrategy;
/**
 * The `APP_BASE_HREF` token represents the base href to be used with the
 * {@link PathLocationStrategy}.
 *
 * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
 * representing the URL prefix that should be preserved when generating and recognizing
 * URLs.
 *
 * ### Example
 *
 * ```
 * import {Component} from '@angular/core';
 * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from '@angular/router';
 * import {APP_BASE_HREF} from '@angular/common';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [
 *   ROUTER_PROVIDERS,
 *   provide(APP_BASE_HREF, {useValue: '/my/app'})
 * ]);
 * ```
 */
exports.APP_BASE_HREF = new core_1.OpaqueToken('appBaseHref');

},{"@angular/core":140}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var platform_location_1 = require('./platform_location');
var location_strategy_1 = require('./location_strategy');
var location_1 = require('./location');
var PathLocationStrategy = (function (_super) {
    __extends(PathLocationStrategy, _super);
    function PathLocationStrategy(_platformLocation, href) {
        _super.call(this);
        this._platformLocation = _platformLocation;
        if (lang_1.isBlank(href)) {
            href = this._platformLocation.getBaseHrefFromDOM();
        }
        if (lang_1.isBlank(href)) {
            throw new exceptions_1.BaseException("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
        }
        this._baseHref = href;
    }
    PathLocationStrategy.prototype.onPopState = function (fn) {
        this._platformLocation.onPopState(fn);
        this._platformLocation.onHashChange(fn);
    };
    PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
    PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
        return location_1.Location.joinWithSlash(this._baseHref, internal);
    };
    PathLocationStrategy.prototype.path = function () {
        return this._platformLocation.pathname +
            location_1.Location.normalizeQueryParams(this._platformLocation.search);
    };
    PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
        var externalUrl = this.prepareExternalUrl(url + location_1.Location.normalizeQueryParams(queryParams));
        this._platformLocation.pushState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
        var externalUrl = this.prepareExternalUrl(url + location_1.Location.normalizeQueryParams(queryParams));
        this._platformLocation.replaceState(state, title, externalUrl);
    };
    PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
    PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
    PathLocationStrategy.decorators = [
        { type: core_1.Injectable },
    ];
    PathLocationStrategy.ctorParameters = [
        { type: platform_location_1.PlatformLocation, },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: [location_strategy_1.APP_BASE_HREF,] },] },
    ];
    return PathLocationStrategy;
}(location_strategy_1.LocationStrategy));
exports.PathLocationStrategy = PathLocationStrategy;

},{"../../src/facade/exceptions":24,"../../src/facade/lang":26,"./location":54,"./location_strategy":55,"./platform_location":57,"@angular/core":140}],57:[function(require,module,exports){
"use strict";
/**
* This class should not be used directly by an application developer. Instead, use
* {@link Location}.
*
* `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
* agnostic.
* This means that we can have different implementation of `PlatformLocation` for the different
* platforms
* that angular supports. For example, the default `PlatformLocation` is {@link
* BrowserPlatformLocation},
* however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.
*
* The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}
* when
* they need to interact with the DOM apis like pushState, popState, etc...
*
* {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly
* by
* the {@link Router} in order to navigate between routes. Since all interactions between {@link
* Router} /
* {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
* class
* they are all platform independent.
*/
var PlatformLocation = (function () {
    function PlatformLocation() {
    }
    Object.defineProperty(PlatformLocation.prototype, "pathname", {
        /* abstract */ get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlatformLocation.prototype, "search", {
        /* abstract */ get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlatformLocation.prototype, "hash", {
        /* abstract */ get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return PlatformLocation;
}());
exports.PlatformLocation = PlatformLocation;

},{}],58:[function(require,module,exports){
"use strict";
/**
* @module
* @description
* This module provides a set of common Pipes.
*/
var async_pipe_1 = require('./pipes/async_pipe');
exports.AsyncPipe = async_pipe_1.AsyncPipe;
var date_pipe_1 = require('./pipes/date_pipe');
exports.DatePipe = date_pipe_1.DatePipe;
var json_pipe_1 = require('./pipes/json_pipe');
exports.JsonPipe = json_pipe_1.JsonPipe;
var slice_pipe_1 = require('./pipes/slice_pipe');
exports.SlicePipe = slice_pipe_1.SlicePipe;
var lowercase_pipe_1 = require('./pipes/lowercase_pipe');
exports.LowerCasePipe = lowercase_pipe_1.LowerCasePipe;
var number_pipe_1 = require('./pipes/number_pipe');
exports.NumberPipe = number_pipe_1.NumberPipe;
exports.DecimalPipe = number_pipe_1.DecimalPipe;
exports.PercentPipe = number_pipe_1.PercentPipe;
exports.CurrencyPipe = number_pipe_1.CurrencyPipe;
var uppercase_pipe_1 = require('./pipes/uppercase_pipe');
exports.UpperCasePipe = uppercase_pipe_1.UpperCasePipe;
var replace_pipe_1 = require('./pipes/replace_pipe');
exports.ReplacePipe = replace_pipe_1.ReplacePipe;
var i18n_plural_pipe_1 = require('./pipes/i18n_plural_pipe');
exports.I18nPluralPipe = i18n_plural_pipe_1.I18nPluralPipe;
var i18n_select_pipe_1 = require('./pipes/i18n_select_pipe');
exports.I18nSelectPipe = i18n_select_pipe_1.I18nSelectPipe;
var common_pipes_1 = require('./pipes/common_pipes');
exports.COMMON_PIPES = common_pipes_1.COMMON_PIPES;

},{"./pipes/async_pipe":59,"./pipes/common_pipes":60,"./pipes/date_pipe":61,"./pipes/i18n_plural_pipe":62,"./pipes/i18n_select_pipe":63,"./pipes/json_pipe":65,"./pipes/lowercase_pipe":66,"./pipes/number_pipe":67,"./pipes/replace_pipe":68,"./pipes/slice_pipe":69,"./pipes/uppercase_pipe":70}],59:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var async_1 = require('../../src/facade/async');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var ObservableStrategy = (function () {
    function ObservableStrategy() {
    }
    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async_1.ObservableWrapper.subscribe(async, updateLatestValue, function (e) { throw e; });
    };
    ObservableStrategy.prototype.dispose = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
    ObservableStrategy.prototype.onDestroy = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
    return ObservableStrategy;
}());
var PromiseStrategy = (function () {
    function PromiseStrategy() {
    }
    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
        return async.then(updateLatestValue);
    };
    PromiseStrategy.prototype.dispose = function (subscription) { };
    PromiseStrategy.prototype.onDestroy = function (subscription) { };
    return PromiseStrategy;
}());
var _promiseStrategy = new PromiseStrategy();
var _observableStrategy = new ObservableStrategy();
var __unused;
var AsyncPipe = (function () {
    function AsyncPipe(_ref) {
        /** @internal */
        this._latestValue = null;
        /** @internal */
        this._latestReturnedValue = null;
        /** @internal */
        this._subscription = null;
        /** @internal */
        this._obj = null;
        this._strategy = null;
        this._ref = _ref;
    }
    AsyncPipe.prototype.ngOnDestroy = function () {
        if (lang_1.isPresent(this._subscription)) {
            this._dispose();
        }
    };
    AsyncPipe.prototype.transform = function (obj) {
        if (lang_1.isBlank(this._obj)) {
            if (lang_1.isPresent(obj)) {
                this._subscribe(obj);
            }
            this._latestReturnedValue = this._latestValue;
            return this._latestValue;
        }
        if (obj !== this._obj) {
            this._dispose();
            return this.transform(obj);
        }
        if (this._latestValue === this._latestReturnedValue) {
            return this._latestReturnedValue;
        }
        else {
            this._latestReturnedValue = this._latestValue;
            return core_1.WrappedValue.wrap(this._latestValue);
        }
    };
    /** @internal */
    AsyncPipe.prototype._subscribe = function (obj) {
        var _this = this;
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
    };
    /** @internal */
    AsyncPipe.prototype._selectStrategy = function (obj) {
        if (lang_1.isPromise(obj)) {
            return _promiseStrategy;
        }
        else if (async_1.ObservableWrapper.isObservable(obj)) {
            return _observableStrategy;
        }
        else {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(AsyncPipe, obj);
        }
    };
    /** @internal */
    AsyncPipe.prototype._dispose = function () {
        this._strategy.dispose(this._subscription);
        this._latestValue = null;
        this._latestReturnedValue = null;
        this._subscription = null;
        this._obj = null;
    };
    /** @internal */
    AsyncPipe.prototype._updateLatestValue = function (async, value) {
        if (async === this._obj) {
            this._latestValue = value;
            this._ref.markForCheck();
        }
    };
    AsyncPipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'async', pure: false },] },
        { type: core_1.Injectable },
    ];
    AsyncPipe.ctorParameters = [
        { type: core_1.ChangeDetectorRef, },
    ];
    return AsyncPipe;
}());
exports.AsyncPipe = AsyncPipe;

},{"../../src/facade/async":20,"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],60:[function(require,module,exports){
"use strict";
/**
* @module
* @description
* This module provides a set of common Pipes.
*/
var async_pipe_1 = require('./async_pipe');
var uppercase_pipe_1 = require('./uppercase_pipe');
var lowercase_pipe_1 = require('./lowercase_pipe');
var json_pipe_1 = require('./json_pipe');
var slice_pipe_1 = require('./slice_pipe');
var date_pipe_1 = require('./date_pipe');
var number_pipe_1 = require('./number_pipe');
var replace_pipe_1 = require('./replace_pipe');
var i18n_plural_pipe_1 = require('./i18n_plural_pipe');
var i18n_select_pipe_1 = require('./i18n_select_pipe');
/**
 * A collection of Angular core pipes that are likely to be used in each and every
 * application.
 *
 * This collection can be used to quickly enumerate all the built-in pipes in the `pipes`
 * property of the `@Component` decorator.
 */
exports.COMMON_PIPES = [
    async_pipe_1.AsyncPipe,
    uppercase_pipe_1.UpperCasePipe,
    lowercase_pipe_1.LowerCasePipe,
    json_pipe_1.JsonPipe,
    slice_pipe_1.SlicePipe,
    number_pipe_1.DecimalPipe,
    number_pipe_1.PercentPipe,
    number_pipe_1.CurrencyPipe,
    date_pipe_1.DatePipe,
    replace_pipe_1.ReplacePipe,
    i18n_plural_pipe_1.I18nPluralPipe,
    i18n_select_pipe_1.I18nSelectPipe
];

},{"./async_pipe":59,"./date_pipe":61,"./i18n_plural_pipe":62,"./i18n_select_pipe":63,"./json_pipe":65,"./lowercase_pipe":66,"./number_pipe":67,"./replace_pipe":68,"./slice_pipe":69,"./uppercase_pipe":70}],61:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var intl_1 = require('../../src/facade/intl');
var collection_1 = require('../../src/facade/collection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
// TODO: move to a global configurable location along with other i18n components.
var defaultLocale = 'en-US';
var DatePipe = (function () {
    function DatePipe() {
    }
    DatePipe.prototype.transform = function (value, pattern) {
        if (pattern === void 0) { pattern = 'mediumDate'; }
        if (lang_1.isBlank(value))
            return null;
        if (!this.supports(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(DatePipe, value);
        }
        if (lang_1.isNumber(value)) {
            value = lang_1.DateWrapper.fromMillis(value);
        }
        if (collection_1.StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
            pattern = collection_1.StringMapWrapper.get(DatePipe._ALIASES, pattern);
        }
        return intl_1.DateFormatter.format(value, defaultLocale, pattern);
    };
    DatePipe.prototype.supports = function (obj) { return lang_1.isDate(obj) || lang_1.isNumber(obj); };
    /** @internal */
    DatePipe._ALIASES = {
        'medium': 'yMMMdjms',
        'short': 'yMdjm',
        'fullDate': 'yMMMMEEEEd',
        'longDate': 'yMMMMd',
        'mediumDate': 'yMMMd',
        'shortDate': 'yMd',
        'mediumTime': 'jms',
        'shortTime': 'jm'
    };
    DatePipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'date', pure: true },] },
        { type: core_1.Injectable },
    ];
    return DatePipe;
}());
exports.DatePipe = DatePipe;

},{"../../src/facade/collection":22,"../../src/facade/intl":25,"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],62:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var interpolationExp = lang_1.RegExpWrapper.create('#');
var I18nPluralPipe = (function () {
    function I18nPluralPipe() {
    }
    I18nPluralPipe.prototype.transform = function (value, pluralMap) {
        var key;
        var valueStr;
        if (!lang_1.isStringMap(pluralMap)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(I18nPluralPipe, pluralMap);
        }
        key = value === 0 || value === 1 ? "=" + value : 'other';
        valueStr = lang_1.isPresent(value) ? value.toString() : '';
        return lang_1.StringWrapper.replaceAll(pluralMap[key], interpolationExp, valueStr);
    };
    I18nPluralPipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
        { type: core_1.Injectable },
    ];
    return I18nPluralPipe;
}());
exports.I18nPluralPipe = I18nPluralPipe;

},{"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],63:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var I18nSelectPipe = (function () {
    function I18nSelectPipe() {
    }
    I18nSelectPipe.prototype.transform = function (value, mapping) {
        if (!lang_1.isStringMap(mapping)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(I18nSelectPipe, mapping);
        }
        return collection_1.StringMapWrapper.contains(mapping, value) ? mapping[value] : mapping['other'];
    };
    I18nSelectPipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
        { type: core_1.Injectable },
    ];
    return I18nSelectPipe;
}());
exports.I18nSelectPipe = I18nSelectPipe;

},{"../../src/facade/collection":22,"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var InvalidPipeArgumentException = (function (_super) {
    __extends(InvalidPipeArgumentException, _super);
    function InvalidPipeArgumentException(type, value) {
        _super.call(this, "Invalid argument '" + value + "' for pipe '" + lang_1.stringify(type) + "'");
    }
    return InvalidPipeArgumentException;
}(exceptions_1.BaseException));
exports.InvalidPipeArgumentException = InvalidPipeArgumentException;

},{"../../src/facade/exceptions":24,"../../src/facade/lang":26}],65:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var JsonPipe = (function () {
    function JsonPipe() {
    }
    JsonPipe.prototype.transform = function (value) { return lang_1.Json.stringify(value); };
    JsonPipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'json', pure: false },] },
        { type: core_1.Injectable },
    ];
    return JsonPipe;
}());
exports.JsonPipe = JsonPipe;

},{"../../src/facade/lang":26,"@angular/core":140}],66:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var LowerCasePipe = (function () {
    function LowerCasePipe() {
    }
    LowerCasePipe.prototype.transform = function (value) {
        if (lang_1.isBlank(value))
            return value;
        if (!lang_1.isString(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LowerCasePipe, value);
        }
        return value.toLowerCase();
    };
    LowerCasePipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'lowercase' },] },
        { type: core_1.Injectable },
    ];
    return LowerCasePipe;
}());
exports.LowerCasePipe = LowerCasePipe;

},{"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],67:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var intl_1 = require('../../src/facade/intl');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var defaultLocale = 'en-US';
var _re = lang_1.RegExpWrapper.create('^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$');
var NumberPipe = (function () {
    function NumberPipe() {
    }
    /** @internal */
    NumberPipe._format = function (value, style, digits, currency, currencyAsSymbol) {
        if (currency === void 0) { currency = null; }
        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
        if (lang_1.isBlank(value))
            return null;
        if (!lang_1.isNumber(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(NumberPipe, value);
        }
        var minInt = 1, minFraction = 0, maxFraction = 3;
        if (lang_1.isPresent(digits)) {
            var parts = lang_1.RegExpWrapper.firstMatch(_re, digits);
            if (lang_1.isBlank(parts)) {
                throw new exceptions_1.BaseException(digits + " is not a valid digit info for number pipes");
            }
            if (lang_1.isPresent(parts[1])) {
                minInt = lang_1.NumberWrapper.parseIntAutoRadix(parts[1]);
            }
            if (lang_1.isPresent(parts[3])) {
                minFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[3]);
            }
            if (lang_1.isPresent(parts[5])) {
                maxFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[5]);
            }
        }
        return intl_1.NumberFormatter.format(value, defaultLocale, style, {
            minimumIntegerDigits: minInt,
            minimumFractionDigits: minFraction,
            maximumFractionDigits: maxFraction,
            currency: currency,
            currencyAsSymbol: currencyAsSymbol
        });
    };
    NumberPipe.decorators = [
        { type: core_1.Injectable },
    ];
    return NumberPipe;
}());
exports.NumberPipe = NumberPipe;
var DecimalPipe = (function (_super) {
    __extends(DecimalPipe, _super);
    function DecimalPipe() {
        _super.apply(this, arguments);
    }
    DecimalPipe.prototype.transform = function (value, digits) {
        if (digits === void 0) { digits = null; }
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Decimal, digits);
    };
    DecimalPipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'number' },] },
        { type: core_1.Injectable },
    ];
    return DecimalPipe;
}(NumberPipe));
exports.DecimalPipe = DecimalPipe;
var PercentPipe = (function (_super) {
    __extends(PercentPipe, _super);
    function PercentPipe() {
        _super.apply(this, arguments);
    }
    PercentPipe.prototype.transform = function (value, digits) {
        if (digits === void 0) { digits = null; }
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Percent, digits);
    };
    PercentPipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'percent' },] },
        { type: core_1.Injectable },
    ];
    return PercentPipe;
}(NumberPipe));
exports.PercentPipe = PercentPipe;
var CurrencyPipe = (function (_super) {
    __extends(CurrencyPipe, _super);
    function CurrencyPipe() {
        _super.apply(this, arguments);
    }
    CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
        if (currencyCode === void 0) { currencyCode = 'USD'; }
        if (symbolDisplay === void 0) { symbolDisplay = false; }
        if (digits === void 0) { digits = null; }
        return NumberPipe._format(value, intl_1.NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
    };
    CurrencyPipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'currency' },] },
        { type: core_1.Injectable },
    ];
    return CurrencyPipe;
}(NumberPipe));
exports.CurrencyPipe = CurrencyPipe;

},{"../../src/facade/exceptions":24,"../../src/facade/intl":25,"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],68:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var ReplacePipe = (function () {
    function ReplacePipe() {
    }
    ReplacePipe.prototype.transform = function (value, pattern, replacement) {
        if (lang_1.isBlank(value)) {
            return value;
        }
        if (!this._supportedInput(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, value);
        }
        var input = value.toString();
        if (!this._supportedPattern(pattern)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, pattern);
        }
        if (!this._supportedReplacement(replacement)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(ReplacePipe, replacement);
        }
        // template fails with literal RegExp e.g /pattern/igm
        // var rgx = pattern instanceof RegExp ? pattern : RegExpWrapper.create(pattern);
        if (lang_1.isFunction(replacement)) {
            var rgxPattern = lang_1.isString(pattern) ? lang_1.RegExpWrapper.create(pattern) : pattern;
            return lang_1.StringWrapper.replaceAllMapped(input, rgxPattern, replacement);
        }
        if (pattern instanceof RegExp) {
            // use the replaceAll variant
            return lang_1.StringWrapper.replaceAll(input, pattern, replacement);
        }
        return lang_1.StringWrapper.replace(input, pattern, replacement);
    };
    ReplacePipe.prototype._supportedInput = function (input) { return lang_1.isString(input) || lang_1.isNumber(input); };
    ReplacePipe.prototype._supportedPattern = function (pattern) {
        return lang_1.isString(pattern) || pattern instanceof RegExp;
    };
    ReplacePipe.prototype._supportedReplacement = function (replacement) {
        return lang_1.isString(replacement) || lang_1.isFunction(replacement);
    };
    ReplacePipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'replace' },] },
        { type: core_1.Injectable },
    ];
    return ReplacePipe;
}());
exports.ReplacePipe = ReplacePipe;

},{"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],69:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var SlicePipe = (function () {
    function SlicePipe() {
    }
    SlicePipe.prototype.transform = function (value, start, end) {
        if (end === void 0) { end = null; }
        if (!this.supports(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(SlicePipe, value);
        }
        if (lang_1.isBlank(value))
            return value;
        if (lang_1.isString(value)) {
            return lang_1.StringWrapper.slice(value, start, end);
        }
        return collection_1.ListWrapper.slice(value, start, end);
    };
    SlicePipe.prototype.supports = function (obj) { return lang_1.isString(obj) || lang_1.isArray(obj); };
    SlicePipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'slice', pure: false },] },
        { type: core_1.Injectable },
    ];
    return SlicePipe;
}());
exports.SlicePipe = SlicePipe;

},{"../../src/facade/collection":22,"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],70:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var invalid_pipe_argument_exception_1 = require('./invalid_pipe_argument_exception');
var UpperCasePipe = (function () {
    function UpperCasePipe() {
    }
    UpperCasePipe.prototype.transform = function (value) {
        if (lang_1.isBlank(value))
            return value;
        if (!lang_1.isString(value)) {
            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(UpperCasePipe, value);
        }
        return value.toUpperCase();
    };
    UpperCasePipe.decorators = [
        { type: core_1.Pipe, args: [{ name: 'uppercase' },] },
        { type: core_1.Injectable },
    ];
    return UpperCasePipe;
}());
exports.UpperCasePipe = UpperCasePipe;

},{"../../src/facade/lang":26,"./invalid_pipe_argument_exception":64,"@angular/core":140}],71:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
* @module
* @description
* Starting point to import all compiler APIs.
*/
var element_schema_registry_1 = require('./src/schema/element_schema_registry');
exports.ElementSchemaRegistry = element_schema_registry_1.ElementSchemaRegistry;
var compiler_1 = require('./src/compiler');
exports.COMPILER_PROVIDERS = compiler_1.COMPILER_PROVIDERS;
exports.TEMPLATE_TRANSFORMS = compiler_1.TEMPLATE_TRANSFORMS;
exports.CompilerConfig = compiler_1.CompilerConfig;
exports.RenderTypes = compiler_1.RenderTypes;
exports.UrlResolver = compiler_1.UrlResolver;
exports.DEFAULT_PACKAGE_URL_PROVIDER = compiler_1.DEFAULT_PACKAGE_URL_PROVIDER;
exports.createOfflineCompileUrlResolver = compiler_1.createOfflineCompileUrlResolver;
exports.XHR = compiler_1.XHR;
exports.ViewResolver = compiler_1.ViewResolver;
exports.DirectiveResolver = compiler_1.DirectiveResolver;
exports.PipeResolver = compiler_1.PipeResolver;
exports.SourceModule = compiler_1.SourceModule;
exports.NormalizedComponentWithViewDirectives = compiler_1.NormalizedComponentWithViewDirectives;
exports.OfflineCompiler = compiler_1.OfflineCompiler;
exports.CompileMetadataWithIdentifier = compiler_1.CompileMetadataWithIdentifier;
exports.CompileMetadataWithType = compiler_1.CompileMetadataWithType;
exports.CompileIdentifierMetadata = compiler_1.CompileIdentifierMetadata;
exports.CompileDiDependencyMetadata = compiler_1.CompileDiDependencyMetadata;
exports.CompileProviderMetadata = compiler_1.CompileProviderMetadata;
exports.CompileFactoryMetadata = compiler_1.CompileFactoryMetadata;
exports.CompileTokenMetadata = compiler_1.CompileTokenMetadata;
exports.CompileTypeMetadata = compiler_1.CompileTypeMetadata;
exports.CompileQueryMetadata = compiler_1.CompileQueryMetadata;
exports.CompileTemplateMetadata = compiler_1.CompileTemplateMetadata;
exports.CompileDirectiveMetadata = compiler_1.CompileDirectiveMetadata;
exports.CompilePipeMetadata = compiler_1.CompilePipeMetadata;
__export(require('./src/template_ast'));
__export(require('./private_export'));

},{"./private_export":74,"./src/compiler":77,"./src/schema/element_schema_registry":113,"./src/template_ast":118}],72:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
exports.isDefaultChangeDetectionStrategy = core_1.__core_private__.isDefaultChangeDetectionStrategy;
exports.ChangeDetectorState = core_1.__core_private__.ChangeDetectorState;
exports.CHANGE_DETECTION_STRATEGY_VALUES = core_1.__core_private__.CHANGE_DETECTION_STRATEGY_VALUES;
exports.constructDependencies = core_1.__core_private__.constructDependencies;
exports.LifecycleHooks = core_1.__core_private__.LifecycleHooks;
exports.LIFECYCLE_HOOKS_VALUES = core_1.__core_private__.LIFECYCLE_HOOKS_VALUES;
exports.ReflectorReader = core_1.__core_private__.ReflectorReader;
exports.ReflectorComponentResolver = core_1.__core_private__.ReflectorComponentResolver;
exports.AppElement = core_1.__core_private__.AppElement;
exports.AppView = core_1.__core_private__.AppView;
exports.DebugAppView = core_1.__core_private__.DebugAppView;
exports.ViewType = core_1.__core_private__.ViewType;
exports.MAX_INTERPOLATION_VALUES = core_1.__core_private__.MAX_INTERPOLATION_VALUES;
exports.checkBinding = core_1.__core_private__.checkBinding;
exports.flattenNestedViewRenderNodes = core_1.__core_private__.flattenNestedViewRenderNodes;
exports.interpolate = core_1.__core_private__.interpolate;
exports.ViewUtils = core_1.__core_private__.ViewUtils;
exports.VIEW_ENCAPSULATION_VALUES = core_1.__core_private__.VIEW_ENCAPSULATION_VALUES;
exports.DebugContext = core_1.__core_private__.DebugContext;
exports.StaticNodeDebugInfo = core_1.__core_private__.StaticNodeDebugInfo;
exports.devModeEqual = core_1.__core_private__.devModeEqual;
exports.uninitialized = core_1.__core_private__.uninitialized;
exports.ValueUnwrapper = core_1.__core_private__.ValueUnwrapper;
exports.TemplateRef_ = core_1.__core_private__.TemplateRef_;
exports.RenderDebugInfo = core_1.__core_private__.RenderDebugInfo;
exports.SecurityContext = core_1.__core_private__.SecurityContext;
exports.SanitizationService = core_1.__core_private__.SanitizationService;
exports.createProvider = core_1.__core_private__.createProvider;
exports.isProviderLiteral = core_1.__core_private__.isProviderLiteral;
exports.EMPTY_ARRAY = core_1.__core_private__.EMPTY_ARRAY;
exports.EMPTY_MAP = core_1.__core_private__.EMPTY_MAP;
exports.pureProxy1 = core_1.__core_private__.pureProxy1;
exports.pureProxy2 = core_1.__core_private__.pureProxy2;
exports.pureProxy3 = core_1.__core_private__.pureProxy3;
exports.pureProxy4 = core_1.__core_private__.pureProxy4;
exports.pureProxy5 = core_1.__core_private__.pureProxy5;
exports.pureProxy6 = core_1.__core_private__.pureProxy6;
exports.pureProxy7 = core_1.__core_private__.pureProxy7;
exports.pureProxy8 = core_1.__core_private__.pureProxy8;
exports.pureProxy9 = core_1.__core_private__.pureProxy9;
exports.pureProxy10 = core_1.__core_private__.pureProxy10;
exports.castByValue = core_1.__core_private__.castByValue;
exports.Console = core_1.__core_private__.Console;

},{"@angular/core":140}],73:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./compiler'));

},{"./compiler":71}],74:[function(require,module,exports){
"use strict";
var selector = require('./src/selector');
var pathUtil = require('./src/output/path_util');
var __compiler_private__;
(function (__compiler_private__) {
    __compiler_private__.SelectorMatcher = selector.SelectorMatcher;
    __compiler_private__.CssSelector = selector.CssSelector;
    __compiler_private__.AssetUrl = pathUtil.AssetUrl;
    __compiler_private__.ImportGenerator = pathUtil.ImportGenerator;
})(__compiler_private__ = exports.__compiler_private__ || (exports.__compiler_private__ = {}));

},{"./src/output/path_util":106,"./src/selector":114}],75:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
function assertArrayOfStrings(identifier, value) {
    if (!lang_1.assertionsEnabled() || lang_1.isBlank(value)) {
        return;
    }
    if (!lang_1.isArray(value)) {
        throw new exceptions_1.BaseException("Expected '" + identifier + "' to be an array of strings.");
    }
    for (var i = 0; i < value.length; i += 1) {
        if (!lang_1.isString(value[i])) {
            throw new exceptions_1.BaseException("Expected '" + identifier + "' to be an array of strings.");
        }
    }
}
exports.assertArrayOfStrings = assertArrayOfStrings;

},{"../src/facade/exceptions":89,"../src/facade/lang":90}],76:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var collection_1 = require('../src/facade/collection');
var selector_1 = require('./selector');
var util_1 = require('./util');
var url_resolver_1 = require('./url_resolver');
// group 1: "property" from "[property]"
// group 2: "event" from "(event)"
var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
var CompileMetadataWithIdentifier = (function () {
    function CompileMetadataWithIdentifier() {
    }
    Object.defineProperty(CompileMetadataWithIdentifier.prototype, "identifier", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return CompileMetadataWithIdentifier;
}());
exports.CompileMetadataWithIdentifier = CompileMetadataWithIdentifier;
var CompileMetadataWithType = (function (_super) {
    __extends(CompileMetadataWithType, _super);
    function CompileMetadataWithType() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(CompileMetadataWithType.prototype, "type", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompileMetadataWithType.prototype, "identifier", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return CompileMetadataWithType;
}(CompileMetadataWithIdentifier));
exports.CompileMetadataWithType = CompileMetadataWithType;
function metadataFromJson(data) {
    return _COMPILE_METADATA_FROM_JSON[data['class']](data);
}
exports.metadataFromJson = metadataFromJson;
var CompileIdentifierMetadata = (function () {
    function CompileIdentifierMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, runtime = _b.runtime, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, value = _b.value;
        this.runtime = runtime;
        this.name = name;
        this.prefix = prefix;
        this.moduleUrl = moduleUrl;
        this.value = value;
    }
    CompileIdentifierMetadata.fromJson = function (data) {
        var value = lang_1.isArray(data['value']) ? _arrayFromJson(data['value'], metadataFromJson) :
            _objFromJson(data['value'], metadataFromJson);
        return new CompileIdentifierMetadata({ name: data['name'], prefix: data['prefix'], moduleUrl: data['moduleUrl'], value: value });
    };
    CompileIdentifierMetadata.prototype.toJson = function () {
        var value = lang_1.isArray(this.value) ? _arrayToJson(this.value) : _objToJson(this.value);
        return {
            // Note: Runtime type can't be serialized...
            'class': 'Identifier',
            'name': this.name,
            'moduleUrl': this.moduleUrl,
            'prefix': this.prefix,
            'value': value
        };
    };
    Object.defineProperty(CompileIdentifierMetadata.prototype, "identifier", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    return CompileIdentifierMetadata;
}());
exports.CompileIdentifierMetadata = CompileIdentifierMetadata;
var CompileDiDependencyMetadata = (function () {
    function CompileDiDependencyMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, isAttribute = _b.isAttribute, isSelf = _b.isSelf, isHost = _b.isHost, isSkipSelf = _b.isSkipSelf, isOptional = _b.isOptional, isValue = _b.isValue, query = _b.query, viewQuery = _b.viewQuery, token = _b.token, value = _b.value;
        this.isAttribute = lang_1.normalizeBool(isAttribute);
        this.isSelf = lang_1.normalizeBool(isSelf);
        this.isHost = lang_1.normalizeBool(isHost);
        this.isSkipSelf = lang_1.normalizeBool(isSkipSelf);
        this.isOptional = lang_1.normalizeBool(isOptional);
        this.isValue = lang_1.normalizeBool(isValue);
        this.query = query;
        this.viewQuery = viewQuery;
        this.token = token;
        this.value = value;
    }
    CompileDiDependencyMetadata.fromJson = function (data) {
        return new CompileDiDependencyMetadata({
            token: _objFromJson(data['token'], CompileTokenMetadata.fromJson),
            query: _objFromJson(data['query'], CompileQueryMetadata.fromJson),
            viewQuery: _objFromJson(data['viewQuery'], CompileQueryMetadata.fromJson),
            value: data['value'],
            isAttribute: data['isAttribute'],
            isSelf: data['isSelf'],
            isHost: data['isHost'],
            isSkipSelf: data['isSkipSelf'],
            isOptional: data['isOptional'],
            isValue: data['isValue']
        });
    };
    CompileDiDependencyMetadata.prototype.toJson = function () {
        return {
            'token': _objToJson(this.token),
            'query': _objToJson(this.query),
            'viewQuery': _objToJson(this.viewQuery),
            'value': this.value,
            'isAttribute': this.isAttribute,
            'isSelf': this.isSelf,
            'isHost': this.isHost,
            'isSkipSelf': this.isSkipSelf,
            'isOptional': this.isOptional,
            'isValue': this.isValue
        };
    };
    return CompileDiDependencyMetadata;
}());
exports.CompileDiDependencyMetadata = CompileDiDependencyMetadata;
var CompileProviderMetadata = (function () {
    function CompileProviderMetadata(_a) {
        var token = _a.token, useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
        this.token = token;
        this.useClass = useClass;
        this.useValue = useValue;
        this.useExisting = useExisting;
        this.useFactory = useFactory;
        this.deps = lang_1.normalizeBlank(deps);
        this.multi = lang_1.normalizeBool(multi);
    }
    CompileProviderMetadata.fromJson = function (data) {
        return new CompileProviderMetadata({
            token: _objFromJson(data['token'], CompileTokenMetadata.fromJson),
            useClass: _objFromJson(data['useClass'], CompileTypeMetadata.fromJson),
            useExisting: _objFromJson(data['useExisting'], CompileTokenMetadata.fromJson),
            useValue: _objFromJson(data['useValue'], CompileIdentifierMetadata.fromJson),
            useFactory: _objFromJson(data['useFactory'], CompileFactoryMetadata.fromJson),
            multi: data['multi'],
            deps: _arrayFromJson(data['deps'], CompileDiDependencyMetadata.fromJson)
        });
    };
    CompileProviderMetadata.prototype.toJson = function () {
        return {
            // Note: Runtime type can't be serialized...
            'class': 'Provider',
            'token': _objToJson(this.token),
            'useClass': _objToJson(this.useClass),
            'useExisting': _objToJson(this.useExisting),
            'useValue': _objToJson(this.useValue),
            'useFactory': _objToJson(this.useFactory),
            'multi': this.multi,
            'deps': _arrayToJson(this.deps)
        };
    };
    return CompileProviderMetadata;
}());
exports.CompileProviderMetadata = CompileProviderMetadata;
var CompileFactoryMetadata = (function () {
    function CompileFactoryMetadata(_a) {
        var runtime = _a.runtime, name = _a.name, moduleUrl = _a.moduleUrl, prefix = _a.prefix, diDeps = _a.diDeps, value = _a.value;
        this.runtime = runtime;
        this.name = name;
        this.prefix = prefix;
        this.moduleUrl = moduleUrl;
        this.diDeps = _normalizeArray(diDeps);
        this.value = value;
    }
    Object.defineProperty(CompileFactoryMetadata.prototype, "identifier", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    CompileFactoryMetadata.fromJson = function (data) {
        return new CompileFactoryMetadata({
            name: data['name'],
            prefix: data['prefix'],
            moduleUrl: data['moduleUrl'],
            value: data['value'],
            diDeps: _arrayFromJson(data['diDeps'], CompileDiDependencyMetadata.fromJson)
        });
    };
    CompileFactoryMetadata.prototype.toJson = function () {
        return {
            'class': 'Factory',
            'name': this.name,
            'prefix': this.prefix,
            'moduleUrl': this.moduleUrl,
            'value': this.value,
            'diDeps': _arrayToJson(this.diDeps)
        };
    };
    return CompileFactoryMetadata;
}());
exports.CompileFactoryMetadata = CompileFactoryMetadata;
var CompileTokenMetadata = (function () {
    function CompileTokenMetadata(_a) {
        var value = _a.value, identifier = _a.identifier, identifierIsInstance = _a.identifierIsInstance;
        this.value = value;
        this.identifier = identifier;
        this.identifierIsInstance = lang_1.normalizeBool(identifierIsInstance);
    }
    CompileTokenMetadata.fromJson = function (data) {
        return new CompileTokenMetadata({
            value: data['value'],
            identifier: _objFromJson(data['identifier'], CompileIdentifierMetadata.fromJson),
            identifierIsInstance: data['identifierIsInstance']
        });
    };
    CompileTokenMetadata.prototype.toJson = function () {
        return {
            'value': this.value,
            'identifier': _objToJson(this.identifier),
            'identifierIsInstance': this.identifierIsInstance
        };
    };
    Object.defineProperty(CompileTokenMetadata.prototype, "runtimeCacheKey", {
        get: function () {
            if (lang_1.isPresent(this.identifier)) {
                return this.identifier.runtime;
            }
            else {
                return this.value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompileTokenMetadata.prototype, "assetCacheKey", {
        get: function () {
            if (lang_1.isPresent(this.identifier)) {
                return lang_1.isPresent(this.identifier.moduleUrl) &&
                    lang_1.isPresent(url_resolver_1.getUrlScheme(this.identifier.moduleUrl)) ?
                    this.identifier.name + "|" + this.identifier.moduleUrl + "|" + this.identifierIsInstance :
                    null;
            }
            else {
                return this.value;
            }
        },
        enumerable: true,
        configurable: true
    });
    CompileTokenMetadata.prototype.equalsTo = function (token2) {
        var rk = this.runtimeCacheKey;
        var ak = this.assetCacheKey;
        return (lang_1.isPresent(rk) && rk == token2.runtimeCacheKey) ||
            (lang_1.isPresent(ak) && ak == token2.assetCacheKey);
    };
    Object.defineProperty(CompileTokenMetadata.prototype, "name", {
        get: function () {
            return lang_1.isPresent(this.value) ? util_1.sanitizeIdentifier(this.value) : this.identifier.name;
        },
        enumerable: true,
        configurable: true
    });
    return CompileTokenMetadata;
}());
exports.CompileTokenMetadata = CompileTokenMetadata;
var CompileTokenMap = (function () {
    function CompileTokenMap() {
        this._valueMap = new Map();
        this._values = [];
    }
    CompileTokenMap.prototype.add = function (token, value) {
        var existing = this.get(token);
        if (lang_1.isPresent(existing)) {
            throw new exceptions_1.BaseException("Can only add to a TokenMap! Token: " + token.name);
        }
        this._values.push(value);
        var rk = token.runtimeCacheKey;
        if (lang_1.isPresent(rk)) {
            this._valueMap.set(rk, value);
        }
        var ak = token.assetCacheKey;
        if (lang_1.isPresent(ak)) {
            this._valueMap.set(ak, value);
        }
    };
    CompileTokenMap.prototype.get = function (token) {
        var rk = token.runtimeCacheKey;
        var ak = token.assetCacheKey;
        var result;
        if (lang_1.isPresent(rk)) {
            result = this._valueMap.get(rk);
        }
        if (lang_1.isBlank(result) && lang_1.isPresent(ak)) {
            result = this._valueMap.get(ak);
        }
        return result;
    };
    CompileTokenMap.prototype.values = function () { return this._values; };
    Object.defineProperty(CompileTokenMap.prototype, "size", {
        get: function () { return this._values.length; },
        enumerable: true,
        configurable: true
    });
    return CompileTokenMap;
}());
exports.CompileTokenMap = CompileTokenMap;
/**
 * Metadata regarding compilation of a type.
 */
var CompileTypeMetadata = (function () {
    function CompileTypeMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, runtime = _b.runtime, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, isHost = _b.isHost, value = _b.value, diDeps = _b.diDeps;
        this.runtime = runtime;
        this.name = name;
        this.moduleUrl = moduleUrl;
        this.prefix = prefix;
        this.isHost = lang_1.normalizeBool(isHost);
        this.value = value;
        this.diDeps = _normalizeArray(diDeps);
    }
    CompileTypeMetadata.fromJson = function (data) {
        return new CompileTypeMetadata({
            name: data['name'],
            moduleUrl: data['moduleUrl'],
            prefix: data['prefix'],
            isHost: data['isHost'],
            value: data['value'],
            diDeps: _arrayFromJson(data['diDeps'], CompileDiDependencyMetadata.fromJson)
        });
    };
    Object.defineProperty(CompileTypeMetadata.prototype, "identifier", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompileTypeMetadata.prototype, "type", {
        get: function () { return this; },
        enumerable: true,
        configurable: true
    });
    CompileTypeMetadata.prototype.toJson = function () {
        return {
            // Note: Runtime type can't be serialized...
            'class': 'Type',
            'name': this.name,
            'moduleUrl': this.moduleUrl,
            'prefix': this.prefix,
            'isHost': this.isHost,
            'value': this.value,
            'diDeps': _arrayToJson(this.diDeps)
        };
    };
    return CompileTypeMetadata;
}());
exports.CompileTypeMetadata = CompileTypeMetadata;
var CompileQueryMetadata = (function () {
    function CompileQueryMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selectors = _b.selectors, descendants = _b.descendants, first = _b.first, propertyName = _b.propertyName, read = _b.read;
        this.selectors = selectors;
        this.descendants = lang_1.normalizeBool(descendants);
        this.first = lang_1.normalizeBool(first);
        this.propertyName = propertyName;
        this.read = read;
    }
    CompileQueryMetadata.fromJson = function (data) {
        return new CompileQueryMetadata({
            selectors: _arrayFromJson(data['selectors'], CompileTokenMetadata.fromJson),
            descendants: data['descendants'],
            first: data['first'],
            propertyName: data['propertyName'],
            read: _objFromJson(data['read'], CompileTokenMetadata.fromJson)
        });
    };
    CompileQueryMetadata.prototype.toJson = function () {
        return {
            'selectors': _arrayToJson(this.selectors),
            'descendants': this.descendants,
            'first': this.first,
            'propertyName': this.propertyName,
            'read': _objToJson(this.read)
        };
    };
    return CompileQueryMetadata;
}());
exports.CompileQueryMetadata = CompileQueryMetadata;
/**
 * Metadata regarding compilation of a template.
 */
var CompileTemplateMetadata = (function () {
    function CompileTemplateMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, ngContentSelectors = _b.ngContentSelectors;
        this.encapsulation = lang_1.isPresent(encapsulation) ? encapsulation : core_1.ViewEncapsulation.Emulated;
        this.template = template;
        this.templateUrl = templateUrl;
        this.styles = lang_1.isPresent(styles) ? styles : [];
        this.styleUrls = lang_1.isPresent(styleUrls) ? styleUrls : [];
        this.ngContentSelectors = lang_1.isPresent(ngContentSelectors) ? ngContentSelectors : [];
    }
    CompileTemplateMetadata.fromJson = function (data) {
        return new CompileTemplateMetadata({
            encapsulation: lang_1.isPresent(data['encapsulation']) ?
                core_private_1.VIEW_ENCAPSULATION_VALUES[data['encapsulation']] :
                data['encapsulation'],
            template: data['template'],
            templateUrl: data['templateUrl'],
            styles: data['styles'],
            styleUrls: data['styleUrls'],
            ngContentSelectors: data['ngContentSelectors']
        });
    };
    CompileTemplateMetadata.prototype.toJson = function () {
        return {
            'encapsulation': lang_1.isPresent(this.encapsulation) ? lang_1.serializeEnum(this.encapsulation) : this.encapsulation,
            'template': this.template,
            'templateUrl': this.templateUrl,
            'styles': this.styles,
            'styleUrls': this.styleUrls,
            'ngContentSelectors': this.ngContentSelectors
        };
    };
    return CompileTemplateMetadata;
}());
exports.CompileTemplateMetadata = CompileTemplateMetadata;
/**
 * Metadata regarding compilation of a directive.
 */
var CompileDirectiveMetadata = (function () {
    function CompileDirectiveMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, lifecycleHooks = _b.lifecycleHooks, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, template = _b.template;
        this.type = type;
        this.isComponent = isComponent;
        this.selector = selector;
        this.exportAs = exportAs;
        this.changeDetection = changeDetection;
        this.inputs = inputs;
        this.outputs = outputs;
        this.hostListeners = hostListeners;
        this.hostProperties = hostProperties;
        this.hostAttributes = hostAttributes;
        this.lifecycleHooks = _normalizeArray(lifecycleHooks);
        this.providers = _normalizeArray(providers);
        this.viewProviders = _normalizeArray(viewProviders);
        this.queries = _normalizeArray(queries);
        this.viewQueries = _normalizeArray(viewQueries);
        this.template = template;
    }
    CompileDirectiveMetadata.create = function (_a) {
        var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, lifecycleHooks = _b.lifecycleHooks, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, template = _b.template;
        var hostListeners = {};
        var hostProperties = {};
        var hostAttributes = {};
        if (lang_1.isPresent(host)) {
            collection_1.StringMapWrapper.forEach(host, function (value, key) {
                var matches = lang_1.RegExpWrapper.firstMatch(HOST_REG_EXP, key);
                if (lang_1.isBlank(matches)) {
                    hostAttributes[key] = value;
                }
                else if (lang_1.isPresent(matches[1])) {
                    hostProperties[matches[1]] = value;
                }
                else if (lang_1.isPresent(matches[2])) {
                    hostListeners[matches[2]] = value;
                }
            });
        }
        var inputsMap = {};
        if (lang_1.isPresent(inputs)) {
            inputs.forEach(function (bindConfig) {
                // canonical syntax: `dirProp: elProp`
                // if there is no `:`, use dirProp = elProp
                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                inputsMap[parts[0]] = parts[1];
            });
        }
        var outputsMap = {};
        if (lang_1.isPresent(outputs)) {
            outputs.forEach(function (bindConfig) {
                // canonical syntax: `dirProp: elProp`
                // if there is no `:`, use dirProp = elProp
                var parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);
                outputsMap[parts[0]] = parts[1];
            });
        }
        return new CompileDirectiveMetadata({
            type: type,
            isComponent: lang_1.normalizeBool(isComponent),
            selector: selector,
            exportAs: exportAs,
            changeDetection: changeDetection,
            inputs: inputsMap,
            outputs: outputsMap,
            hostListeners: hostListeners,
            hostProperties: hostProperties,
            hostAttributes: hostAttributes,
            lifecycleHooks: lang_1.isPresent(lifecycleHooks) ? lifecycleHooks : [],
            providers: providers,
            viewProviders: viewProviders,
            queries: queries,
            viewQueries: viewQueries,
            template: template
        });
    };
    Object.defineProperty(CompileDirectiveMetadata.prototype, "identifier", {
        get: function () { return this.type; },
        enumerable: true,
        configurable: true
    });
    CompileDirectiveMetadata.fromJson = function (data) {
        return new CompileDirectiveMetadata({
            isComponent: data['isComponent'],
            selector: data['selector'],
            exportAs: data['exportAs'],
            type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
            changeDetection: lang_1.isPresent(data['changeDetection']) ?
                core_private_1.CHANGE_DETECTION_STRATEGY_VALUES[data['changeDetection']] :
                data['changeDetection'],
            inputs: data['inputs'],
            outputs: data['outputs'],
            hostListeners: data['hostListeners'],
            hostProperties: data['hostProperties'],
            hostAttributes: data['hostAttributes'],
            lifecycleHooks: data['lifecycleHooks'].map(function (hookValue) { return core_private_1.LIFECYCLE_HOOKS_VALUES[hookValue]; }),
            template: lang_1.isPresent(data['template']) ? CompileTemplateMetadata.fromJson(data['template']) :
                data['template'],
            providers: _arrayFromJson(data['providers'], metadataFromJson),
            viewProviders: _arrayFromJson(data['viewProviders'], metadataFromJson),
            queries: _arrayFromJson(data['queries'], CompileQueryMetadata.fromJson),
            viewQueries: _arrayFromJson(data['viewQueries'], CompileQueryMetadata.fromJson)
        });
    };
    CompileDirectiveMetadata.prototype.toJson = function () {
        return {
            'class': 'Directive',
            'isComponent': this.isComponent,
            'selector': this.selector,
            'exportAs': this.exportAs,
            'type': lang_1.isPresent(this.type) ? this.type.toJson() : this.type,
            'changeDetection': lang_1.isPresent(this.changeDetection) ? lang_1.serializeEnum(this.changeDetection) :
                this.changeDetection,
            'inputs': this.inputs,
            'outputs': this.outputs,
            'hostListeners': this.hostListeners,
            'hostProperties': this.hostProperties,
            'hostAttributes': this.hostAttributes,
            'lifecycleHooks': this.lifecycleHooks.map(function (hook) { return lang_1.serializeEnum(hook); }),
            'template': lang_1.isPresent(this.template) ? this.template.toJson() : this.template,
            'providers': _arrayToJson(this.providers),
            'viewProviders': _arrayToJson(this.viewProviders),
            'queries': _arrayToJson(this.queries),
            'viewQueries': _arrayToJson(this.viewQueries)
        };
    };
    return CompileDirectiveMetadata;
}());
exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
/**
 * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
 */
function createHostComponentMeta(componentType, componentSelector) {
    var template = selector_1.CssSelector.parse(componentSelector)[0].getMatchingElementTemplate();
    return CompileDirectiveMetadata.create({
        type: new CompileTypeMetadata({
            runtime: Object,
            name: componentType.name + "_Host",
            moduleUrl: componentType.moduleUrl,
            isHost: true
        }),
        template: new CompileTemplateMetadata({ template: template, templateUrl: '', styles: [], styleUrls: [], ngContentSelectors: [] }),
        changeDetection: core_1.ChangeDetectionStrategy.Default,
        inputs: [],
        outputs: [],
        host: {},
        lifecycleHooks: [],
        isComponent: true,
        selector: '*',
        providers: [],
        viewProviders: [],
        queries: [],
        viewQueries: []
    });
}
exports.createHostComponentMeta = createHostComponentMeta;
var CompilePipeMetadata = (function () {
    function CompilePipeMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure, lifecycleHooks = _b.lifecycleHooks;
        this.type = type;
        this.name = name;
        this.pure = lang_1.normalizeBool(pure);
        this.lifecycleHooks = _normalizeArray(lifecycleHooks);
    }
    Object.defineProperty(CompilePipeMetadata.prototype, "identifier", {
        get: function () { return this.type; },
        enumerable: true,
        configurable: true
    });
    CompilePipeMetadata.fromJson = function (data) {
        return new CompilePipeMetadata({
            type: lang_1.isPresent(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
            name: data['name'],
            pure: data['pure']
        });
    };
    CompilePipeMetadata.prototype.toJson = function () {
        return {
            'class': 'Pipe',
            'type': lang_1.isPresent(this.type) ? this.type.toJson() : null,
            'name': this.name,
            'pure': this.pure
        };
    };
    return CompilePipeMetadata;
}());
exports.CompilePipeMetadata = CompilePipeMetadata;
var _COMPILE_METADATA_FROM_JSON = {
    'Directive': CompileDirectiveMetadata.fromJson,
    'Pipe': CompilePipeMetadata.fromJson,
    'Type': CompileTypeMetadata.fromJson,
    'Provider': CompileProviderMetadata.fromJson,
    'Identifier': CompileIdentifierMetadata.fromJson,
    'Factory': CompileFactoryMetadata.fromJson
};
function _arrayFromJson(obj, fn) {
    return lang_1.isBlank(obj) ? null : obj.map(function (o) { return _objFromJson(o, fn); });
}
function _arrayToJson(obj) {
    return lang_1.isBlank(obj) ? null : obj.map(_objToJson);
}
function _objFromJson(obj, fn) {
    if (lang_1.isArray(obj))
        return _arrayFromJson(obj, fn);
    if (lang_1.isString(obj) || lang_1.isBlank(obj) || lang_1.isBoolean(obj) || lang_1.isNumber(obj))
        return obj;
    return fn(obj);
}
function _objToJson(obj) {
    if (lang_1.isArray(obj))
        return _arrayToJson(obj);
    if (lang_1.isString(obj) || lang_1.isBlank(obj) || lang_1.isBoolean(obj) || lang_1.isNumber(obj))
        return obj;
    return obj.toJson();
}
function _normalizeArray(obj) {
    return lang_1.isPresent(obj) ? obj : [];
}

},{"../core_private":72,"../src/facade/collection":87,"../src/facade/exceptions":89,"../src/facade/lang":90,"./selector":114,"./url_resolver":121,"./util":122,"@angular/core":140}],77:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var core_1 = require('@angular/core');
var lang_1 = require('../src/facade/lang');
__export(require('./template_ast'));
var template_parser_1 = require('./template_parser');
exports.TEMPLATE_TRANSFORMS = template_parser_1.TEMPLATE_TRANSFORMS;
var config_1 = require('./config');
exports.CompilerConfig = config_1.CompilerConfig;
exports.RenderTypes = config_1.RenderTypes;
__export(require('./compile_metadata'));
__export(require('./offline_compiler'));
var runtime_compiler_1 = require('./runtime_compiler');
exports.RuntimeCompiler = runtime_compiler_1.RuntimeCompiler;
__export(require('./url_resolver'));
__export(require('./xhr'));
var view_resolver_1 = require('./view_resolver');
exports.ViewResolver = view_resolver_1.ViewResolver;
var directive_resolver_1 = require('./directive_resolver');
exports.DirectiveResolver = directive_resolver_1.DirectiveResolver;
var pipe_resolver_1 = require('./pipe_resolver');
exports.PipeResolver = pipe_resolver_1.PipeResolver;
var template_parser_2 = require('./template_parser');
var html_parser_1 = require('./html_parser');
var directive_normalizer_1 = require('./directive_normalizer');
var metadata_resolver_1 = require('./metadata_resolver');
var style_compiler_1 = require('./style_compiler');
var view_compiler_1 = require('./view_compiler/view_compiler');
var config_2 = require('./config');
var runtime_compiler_2 = require('./runtime_compiler');
var element_schema_registry_1 = require('./schema/element_schema_registry');
var dom_element_schema_registry_1 = require('./schema/dom_element_schema_registry');
var url_resolver_2 = require('./url_resolver');
var parser_1 = require('./expression_parser/parser');
var lexer_1 = require('./expression_parser/lexer');
var view_resolver_2 = require('./view_resolver');
var directive_resolver_2 = require('./directive_resolver');
var pipe_resolver_2 = require('./pipe_resolver');
function _createCompilerConfig() {
    return new config_2.CompilerConfig(lang_1.assertionsEnabled(), false, true);
}
/**
 * A set of providers that provide `RuntimeCompiler` and its dependencies to use for
 * template compilation.
 */
exports.COMPILER_PROVIDERS = 
/*@ts2dart_const*/ [
    lexer_1.Lexer,
    parser_1.Parser,
    html_parser_1.HtmlParser,
    template_parser_2.TemplateParser,
    directive_normalizer_1.DirectiveNormalizer,
    metadata_resolver_1.CompileMetadataResolver,
    url_resolver_2.DEFAULT_PACKAGE_URL_PROVIDER,
    style_compiler_1.StyleCompiler,
    view_compiler_1.ViewCompiler,
    /*@ts2dart_Provider*/ { provide: config_2.CompilerConfig, useFactory: _createCompilerConfig, deps: [] },
    runtime_compiler_2.RuntimeCompiler,
    /*@ts2dart_Provider*/ { provide: core_1.ComponentResolver, useExisting: runtime_compiler_2.RuntimeCompiler },
    dom_element_schema_registry_1.DomElementSchemaRegistry,
    /*@ts2dart_Provider*/ { provide: element_schema_registry_1.ElementSchemaRegistry, useExisting: dom_element_schema_registry_1.DomElementSchemaRegistry },
    url_resolver_2.UrlResolver,
    view_resolver_2.ViewResolver,
    directive_resolver_2.DirectiveResolver,
    pipe_resolver_2.PipeResolver
];

},{"../src/facade/lang":90,"./compile_metadata":76,"./config":78,"./directive_normalizer":80,"./directive_resolver":81,"./expression_parser/lexer":83,"./expression_parser/parser":84,"./html_parser":94,"./metadata_resolver":97,"./offline_compiler":98,"./pipe_resolver":109,"./runtime_compiler":111,"./schema/dom_element_schema_registry":112,"./schema/element_schema_registry":113,"./style_compiler":116,"./template_ast":118,"./template_parser":119,"./url_resolver":121,"./view_compiler/view_compiler":137,"./view_resolver":138,"./xhr":139,"@angular/core":140}],78:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var identifiers_1 = require('./identifiers');
var CompilerConfig = (function () {
    function CompilerConfig(genDebugInfo, logBindingUpdate, useJit, renderTypes) {
        if (renderTypes === void 0) { renderTypes = null; }
        this.genDebugInfo = genDebugInfo;
        this.logBindingUpdate = logBindingUpdate;
        this.useJit = useJit;
        if (lang_1.isBlank(renderTypes)) {
            renderTypes = new DefaultRenderTypes();
        }
        this.renderTypes = renderTypes;
    }
    return CompilerConfig;
}());
exports.CompilerConfig = CompilerConfig;
/**
 * Types used for the renderer.
 * Can be replaced to specialize the generated output to a specific renderer
 * to help tree shaking.
 */
var RenderTypes = (function () {
    function RenderTypes() {
    }
    Object.defineProperty(RenderTypes.prototype, "renderer", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderText", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderElement", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderComment", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderNode", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderTypes.prototype, "renderEvent", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return RenderTypes;
}());
exports.RenderTypes = RenderTypes;
var DefaultRenderTypes = (function () {
    function DefaultRenderTypes() {
        this.renderer = identifiers_1.Identifiers.Renderer;
        this.renderText = null;
        this.renderElement = null;
        this.renderComment = null;
        this.renderNode = null;
        this.renderEvent = null;
    }
    return DefaultRenderTypes;
}());
exports.DefaultRenderTypes = DefaultRenderTypes;

},{"../src/facade/exceptions":89,"../src/facade/lang":90,"./identifiers":96}],79:[function(require,module,exports){
"use strict";
var core_private_1 = require('../core_private');
var lang_1 = require('../src/facade/lang');
function hasLifecycleHook(lcInterface, token) {
    if (!(token instanceof lang_1.Type))
        return false;
    var proto = token.prototype;
    switch (lcInterface) {
        case core_private_1.LifecycleHooks.AfterContentInit:
            return !!proto.ngAfterContentInit;
        case core_private_1.LifecycleHooks.AfterContentChecked:
            return !!proto.ngAfterContentChecked;
        case core_private_1.LifecycleHooks.AfterViewInit:
            return !!proto.ngAfterViewInit;
        case core_private_1.LifecycleHooks.AfterViewChecked:
            return !!proto.ngAfterViewChecked;
        case core_private_1.LifecycleHooks.OnChanges:
            return !!proto.ngOnChanges;
        case core_private_1.LifecycleHooks.DoCheck:
            return !!proto.ngDoCheck;
        case core_private_1.LifecycleHooks.OnDestroy:
            return !!proto.ngOnDestroy;
        case core_private_1.LifecycleHooks.OnInit:
            return !!proto.ngOnInit;
        default:
            return false;
    }
}
exports.hasLifecycleHook = hasLifecycleHook;

},{"../core_private":72,"../src/facade/lang":90}],80:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var async_1 = require('../src/facade/async');
var compile_metadata_1 = require('./compile_metadata');
var xhr_1 = require('./xhr');
var url_resolver_1 = require('./url_resolver');
var style_url_resolver_1 = require('./style_url_resolver');
var html_ast_1 = require('./html_ast');
var html_parser_1 = require('./html_parser');
var template_preparser_1 = require('./template_preparser');
var DirectiveNormalizer = (function () {
    function DirectiveNormalizer(_xhr, _urlResolver, _htmlParser) {
        this._xhr = _xhr;
        this._urlResolver = _urlResolver;
        this._htmlParser = _htmlParser;
    }
    DirectiveNormalizer.prototype.normalizeDirective = function (directive) {
        if (!directive.isComponent) {
            // For non components there is nothing to be normalized yet.
            return async_1.PromiseWrapper.resolve(directive);
        }
        return this.normalizeTemplate(directive.type, directive.template)
            .then(function (normalizedTemplate) { return new compile_metadata_1.CompileDirectiveMetadata({
            type: directive.type,
            isComponent: directive.isComponent,
            selector: directive.selector,
            exportAs: directive.exportAs,
            changeDetection: directive.changeDetection,
            inputs: directive.inputs,
            outputs: directive.outputs,
            hostListeners: directive.hostListeners,
            hostProperties: directive.hostProperties,
            hostAttributes: directive.hostAttributes,
            lifecycleHooks: directive.lifecycleHooks,
            providers: directive.providers,
            viewProviders: directive.viewProviders,
            queries: directive.queries,
            viewQueries: directive.viewQueries,
            template: normalizedTemplate
        }); });
    };
    DirectiveNormalizer.prototype.normalizeTemplate = function (directiveType, template) {
        var _this = this;
        if (lang_1.isPresent(template.template)) {
            return async_1.PromiseWrapper.resolve(this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl));
        }
        else if (lang_1.isPresent(template.templateUrl)) {
            var sourceAbsUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
            return this._xhr.get(sourceAbsUrl)
                .then(function (templateContent) { return _this.normalizeLoadedTemplate(directiveType, template, templateContent, sourceAbsUrl); });
        }
        else {
            throw new exceptions_1.BaseException("No template specified for component " + directiveType.name);
        }
    };
    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (directiveType, templateMeta, template, templateAbsUrl) {
        var _this = this;
        var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name);
        if (rootNodesAndErrors.errors.length > 0) {
            var errorString = rootNodesAndErrors.errors.join('\n');
            throw new exceptions_1.BaseException("Template parse errors:\n" + errorString);
        }
        var visitor = new TemplatePreparseVisitor();
        html_ast_1.htmlVisitAll(visitor, rootNodesAndErrors.rootNodes);
        var allStyles = templateMeta.styles.concat(visitor.styles);
        var allStyleAbsUrls = visitor.styleUrls.filter(style_url_resolver_1.isStyleUrlResolvable)
            .map(function (url) { return _this._urlResolver.resolve(templateAbsUrl, url); })
            .concat(templateMeta.styleUrls.filter(style_url_resolver_1.isStyleUrlResolvable)
            .map(function (url) { return _this._urlResolver.resolve(directiveType.moduleUrl, url); }));
        var allResolvedStyles = allStyles.map(function (style) {
            var styleWithImports = style_url_resolver_1.extractStyleUrls(_this._urlResolver, templateAbsUrl, style);
            styleWithImports.styleUrls.forEach(function (styleUrl) { return allStyleAbsUrls.push(styleUrl); });
            return styleWithImports.style;
        });
        var encapsulation = templateMeta.encapsulation;
        if (encapsulation === core_1.ViewEncapsulation.Emulated && allResolvedStyles.length === 0 &&
            allStyleAbsUrls.length === 0) {
            encapsulation = core_1.ViewEncapsulation.None;
        }
        return new compile_metadata_1.CompileTemplateMetadata({
            encapsulation: encapsulation,
            template: template,
            templateUrl: templateAbsUrl,
            styles: allResolvedStyles,
            styleUrls: allStyleAbsUrls,
            ngContentSelectors: visitor.ngContentSelectors
        });
    };
    DirectiveNormalizer.decorators = [
        { type: core_1.Injectable },
    ];
    DirectiveNormalizer.ctorParameters = [
        { type: xhr_1.XHR, },
        { type: url_resolver_1.UrlResolver, },
        { type: html_parser_1.HtmlParser, },
    ];
    return DirectiveNormalizer;
}());
exports.DirectiveNormalizer = DirectiveNormalizer;
var TemplatePreparseVisitor = (function () {
    function TemplatePreparseVisitor() {
        this.ngContentSelectors = [];
        this.styles = [];
        this.styleUrls = [];
        this.ngNonBindableStackCount = 0;
    }
    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {
        var preparsedElement = template_preparser_1.preparseElement(ast);
        switch (preparsedElement.type) {
            case template_preparser_1.PreparsedElementType.NG_CONTENT:
                if (this.ngNonBindableStackCount === 0) {
                    this.ngContentSelectors.push(preparsedElement.selectAttr);
                }
                break;
            case template_preparser_1.PreparsedElementType.STYLE:
                var textContent = '';
                ast.children.forEach(function (child) {
                    if (child instanceof html_ast_1.HtmlTextAst) {
                        textContent += child.value;
                    }
                });
                this.styles.push(textContent);
                break;
            case template_preparser_1.PreparsedElementType.STYLESHEET:
                this.styleUrls.push(preparsedElement.hrefAttr);
                break;
            default:
                // DDC reports this as error. See:
                // https://github.com/dart-lang/dev_compiler/issues/428
                break;
        }
        if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount++;
        }
        html_ast_1.htmlVisitAll(this, ast.children);
        if (preparsedElement.nonBindable) {
            this.ngNonBindableStackCount--;
        }
        return null;
    };
    TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };
    TemplatePreparseVisitor.prototype.visitAttr = function (ast, context) { return null; };
    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };
    TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { return null; };
    TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) { return null; };
    return TemplatePreparseVisitor;
}());

},{"../src/facade/async":85,"../src/facade/exceptions":89,"../src/facade/lang":90,"./compile_metadata":76,"./html_ast":92,"./html_parser":94,"./style_url_resolver":117,"./template_preparser":120,"./url_resolver":121,"./xhr":139,"@angular/core":140}],81:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var collection_1 = require('../src/facade/collection');
function _isDirectiveMetadata(type) {
    return type instanceof core_1.DirectiveMetadata;
}
var DirectiveResolver = (function () {
    function DirectiveResolver(_reflector) {
        if (lang_1.isPresent(_reflector)) {
            this._reflector = _reflector;
        }
        else {
            this._reflector = core_1.reflector;
        }
    }
    /**
     * Return {@link DirectiveMetadata} for a given `Type`.
     */
    DirectiveResolver.prototype.resolve = function (type) {
        var typeMetadata = this._reflector.annotations(core_1.resolveForwardRef(type));
        if (lang_1.isPresent(typeMetadata)) {
            var metadata = typeMetadata.find(_isDirectiveMetadata);
            if (lang_1.isPresent(metadata)) {
                var propertyMetadata = this._reflector.propMetadata(type);
                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
            }
        }
        throw new exceptions_1.BaseException("No Directive annotation found on " + lang_1.stringify(type));
    };
    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {
        var inputs = [];
        var outputs = [];
        var host = {};
        var queries = {};
        collection_1.StringMapWrapper.forEach(propertyMetadata, function (metadata, propName) {
            metadata.forEach(function (a) {
                if (a instanceof core_1.InputMetadata) {
                    if (lang_1.isPresent(a.bindingPropertyName)) {
                        inputs.push(propName + ": " + a.bindingPropertyName);
                    }
                    else {
                        inputs.push(propName);
                    }
                }
                if (a instanceof core_1.OutputMetadata) {
                    if (lang_1.isPresent(a.bindingPropertyName)) {
                        outputs.push(propName + ": " + a.bindingPropertyName);
                    }
                    else {
                        outputs.push(propName);
                    }
                }
                if (a instanceof core_1.HostBindingMetadata) {
                    if (lang_1.isPresent(a.hostPropertyName)) {
                        host[("[" + a.hostPropertyName + "]")] = propName;
                    }
                    else {
                        host[("[" + propName + "]")] = propName;
                    }
                }
                if (a instanceof core_1.HostListenerMetadata) {
                    var args = lang_1.isPresent(a.args) ? a.args.join(', ') : '';
                    host[("(" + a.eventName + ")")] = propName + "(" + args + ")";
                }
                if (a instanceof core_1.ContentChildrenMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof core_1.ViewChildrenMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof core_1.ContentChildMetadata) {
                    queries[propName] = a;
                }
                if (a instanceof core_1.ViewChildMetadata) {
                    queries[propName] = a;
                }
            });
        });
        return this._merge(dm, inputs, outputs, host, queries, directiveType);
    };
    DirectiveResolver.prototype._merge = function (dm, inputs, outputs, host, queries, directiveType) {
        var mergedInputs = lang_1.isPresent(dm.inputs) ? collection_1.ListWrapper.concat(dm.inputs, inputs) : inputs;
        var mergedOutputs;
        if (lang_1.isPresent(dm.outputs)) {
            dm.outputs.forEach(function (propName) {
                if (collection_1.ListWrapper.contains(outputs, propName)) {
                    throw new exceptions_1.BaseException("Output event '" + propName + "' defined multiple times in '" + lang_1.stringify(directiveType) + "'");
                }
            });
            mergedOutputs = collection_1.ListWrapper.concat(dm.outputs, outputs);
        }
        else {
            mergedOutputs = outputs;
        }
        var mergedHost = lang_1.isPresent(dm.host) ? collection_1.StringMapWrapper.merge(dm.host, host) : host;
        var mergedQueries = lang_1.isPresent(dm.queries) ? collection_1.StringMapWrapper.merge(dm.queries, queries) : queries;
        if (dm instanceof core_1.ComponentMetadata) {
            return new core_1.ComponentMetadata({
                selector: dm.selector,
                inputs: mergedInputs,
                outputs: mergedOutputs,
                host: mergedHost,
                exportAs: dm.exportAs,
                moduleId: dm.moduleId,
                queries: mergedQueries,
                changeDetection: dm.changeDetection,
                providers: dm.providers,
                viewProviders: dm.viewProviders
            });
        }
        else {
            return new core_1.DirectiveMetadata({
                selector: dm.selector,
                inputs: mergedInputs,
                outputs: mergedOutputs,
                host: mergedHost,
                exportAs: dm.exportAs,
                queries: mergedQueries,
                providers: dm.providers
            });
        }
    };
    DirectiveResolver.decorators = [
        { type: core_1.Injectable },
    ];
    DirectiveResolver.ctorParameters = [
        { type: core_private_1.ReflectorReader, },
    ];
    return DirectiveResolver;
}());
exports.DirectiveResolver = DirectiveResolver;
exports.CODEGEN_DIRECTIVE_RESOLVER = new DirectiveResolver(core_1.reflector);

},{"../core_private":72,"../src/facade/collection":87,"../src/facade/exceptions":89,"../src/facade/lang":90,"@angular/core":140}],82:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('../../src/facade/collection');
var AST = (function () {
    function AST() {
    }
    AST.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return null;
    };
    AST.prototype.toString = function () { return "AST"; };
    return AST;
}());
exports.AST = AST;
/**
 * Represents a quoted expression of the form:
 *
 * quote = prefix `:` uninterpretedExpression
 * prefix = identifier
 * uninterpretedExpression = arbitrary string
 *
 * A quoted expression is meant to be pre-processed by an AST transformer that
 * converts it into another AST that no longer contains quoted expressions.
 * It is meant to allow third-party developers to extend Angular template
 * expression language. The `uninterpretedExpression` part of the quote is
 * therefore not interpreted by the Angular's own expression parser.
 */
var Quote = (function (_super) {
    __extends(Quote, _super);
    function Quote(prefix, uninterpretedExpression, location) {
        _super.call(this);
        this.prefix = prefix;
        this.uninterpretedExpression = uninterpretedExpression;
        this.location = location;
    }
    Quote.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitQuote(this, context);
    };
    Quote.prototype.toString = function () { return "Quote"; };
    return Quote;
}(AST));
exports.Quote = Quote;
var EmptyExpr = (function (_super) {
    __extends(EmptyExpr, _super);
    function EmptyExpr() {
        _super.apply(this, arguments);
    }
    EmptyExpr.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        // do nothing
    };
    return EmptyExpr;
}(AST));
exports.EmptyExpr = EmptyExpr;
var ImplicitReceiver = (function (_super) {
    __extends(ImplicitReceiver, _super);
    function ImplicitReceiver() {
        _super.apply(this, arguments);
    }
    ImplicitReceiver.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitImplicitReceiver(this, context);
    };
    return ImplicitReceiver;
}(AST));
exports.ImplicitReceiver = ImplicitReceiver;
/**
 * Multiple expressions separated by a semicolon.
 */
var Chain = (function (_super) {
    __extends(Chain, _super);
    function Chain(expressions) {
        _super.call(this);
        this.expressions = expressions;
    }
    Chain.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitChain(this, context);
    };
    return Chain;
}(AST));
exports.Chain = Chain;
var Conditional = (function (_super) {
    __extends(Conditional, _super);
    function Conditional(condition, trueExp, falseExp) {
        _super.call(this);
        this.condition = condition;
        this.trueExp = trueExp;
        this.falseExp = falseExp;
    }
    Conditional.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitConditional(this, context);
    };
    return Conditional;
}(AST));
exports.Conditional = Conditional;
var PropertyRead = (function (_super) {
    __extends(PropertyRead, _super);
    function PropertyRead(receiver, name) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
    }
    PropertyRead.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitPropertyRead(this, context);
    };
    return PropertyRead;
}(AST));
exports.PropertyRead = PropertyRead;
var PropertyWrite = (function (_super) {
    __extends(PropertyWrite, _super);
    function PropertyWrite(receiver, name, value) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.value = value;
    }
    PropertyWrite.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitPropertyWrite(this, context);
    };
    return PropertyWrite;
}(AST));
exports.PropertyWrite = PropertyWrite;
var SafePropertyRead = (function (_super) {
    __extends(SafePropertyRead, _super);
    function SafePropertyRead(receiver, name) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
    }
    SafePropertyRead.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitSafePropertyRead(this, context);
    };
    return SafePropertyRead;
}(AST));
exports.SafePropertyRead = SafePropertyRead;
var KeyedRead = (function (_super) {
    __extends(KeyedRead, _super);
    function KeyedRead(obj, key) {
        _super.call(this);
        this.obj = obj;
        this.key = key;
    }
    KeyedRead.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitKeyedRead(this, context);
    };
    return KeyedRead;
}(AST));
exports.KeyedRead = KeyedRead;
var KeyedWrite = (function (_super) {
    __extends(KeyedWrite, _super);
    function KeyedWrite(obj, key, value) {
        _super.call(this);
        this.obj = obj;
        this.key = key;
        this.value = value;
    }
    KeyedWrite.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitKeyedWrite(this, context);
    };
    return KeyedWrite;
}(AST));
exports.KeyedWrite = KeyedWrite;
var BindingPipe = (function (_super) {
    __extends(BindingPipe, _super);
    function BindingPipe(exp, name, args) {
        _super.call(this);
        this.exp = exp;
        this.name = name;
        this.args = args;
    }
    BindingPipe.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitPipe(this, context);
    };
    return BindingPipe;
}(AST));
exports.BindingPipe = BindingPipe;
var LiteralPrimitive = (function (_super) {
    __extends(LiteralPrimitive, _super);
    function LiteralPrimitive(value) {
        _super.call(this);
        this.value = value;
    }
    LiteralPrimitive.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitLiteralPrimitive(this, context);
    };
    return LiteralPrimitive;
}(AST));
exports.LiteralPrimitive = LiteralPrimitive;
var LiteralArray = (function (_super) {
    __extends(LiteralArray, _super);
    function LiteralArray(expressions) {
        _super.call(this);
        this.expressions = expressions;
    }
    LiteralArray.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitLiteralArray(this, context);
    };
    return LiteralArray;
}(AST));
exports.LiteralArray = LiteralArray;
var LiteralMap = (function (_super) {
    __extends(LiteralMap, _super);
    function LiteralMap(keys, values) {
        _super.call(this);
        this.keys = keys;
        this.values = values;
    }
    LiteralMap.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitLiteralMap(this, context);
    };
    return LiteralMap;
}(AST));
exports.LiteralMap = LiteralMap;
var Interpolation = (function (_super) {
    __extends(Interpolation, _super);
    function Interpolation(strings, expressions) {
        _super.call(this);
        this.strings = strings;
        this.expressions = expressions;
    }
    Interpolation.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitInterpolation(this, context);
    };
    return Interpolation;
}(AST));
exports.Interpolation = Interpolation;
var Binary = (function (_super) {
    __extends(Binary, _super);
    function Binary(operation, left, right) {
        _super.call(this);
        this.operation = operation;
        this.left = left;
        this.right = right;
    }
    Binary.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitBinary(this, context);
    };
    return Binary;
}(AST));
exports.Binary = Binary;
var PrefixNot = (function (_super) {
    __extends(PrefixNot, _super);
    function PrefixNot(expression) {
        _super.call(this);
        this.expression = expression;
    }
    PrefixNot.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitPrefixNot(this, context);
    };
    return PrefixNot;
}(AST));
exports.PrefixNot = PrefixNot;
var MethodCall = (function (_super) {
    __extends(MethodCall, _super);
    function MethodCall(receiver, name, args) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.args = args;
    }
    MethodCall.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitMethodCall(this, context);
    };
    return MethodCall;
}(AST));
exports.MethodCall = MethodCall;
var SafeMethodCall = (function (_super) {
    __extends(SafeMethodCall, _super);
    function SafeMethodCall(receiver, name, args) {
        _super.call(this);
        this.receiver = receiver;
        this.name = name;
        this.args = args;
    }
    SafeMethodCall.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitSafeMethodCall(this, context);
    };
    return SafeMethodCall;
}(AST));
exports.SafeMethodCall = SafeMethodCall;
var FunctionCall = (function (_super) {
    __extends(FunctionCall, _super);
    function FunctionCall(target, args) {
        _super.call(this);
        this.target = target;
        this.args = args;
    }
    FunctionCall.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return visitor.visitFunctionCall(this, context);
    };
    return FunctionCall;
}(AST));
exports.FunctionCall = FunctionCall;
var ASTWithSource = (function (_super) {
    __extends(ASTWithSource, _super);
    function ASTWithSource(ast, source, location) {
        _super.call(this);
        this.ast = ast;
        this.source = source;
        this.location = location;
    }
    ASTWithSource.prototype.visit = function (visitor, context) {
        if (context === void 0) { context = null; }
        return this.ast.visit(visitor, context);
    };
    ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
    return ASTWithSource;
}(AST));
exports.ASTWithSource = ASTWithSource;
var TemplateBinding = (function () {
    function TemplateBinding(key, keyIsVar, name, expression) {
        this.key = key;
        this.keyIsVar = keyIsVar;
        this.name = name;
        this.expression = expression;
    }
    return TemplateBinding;
}());
exports.TemplateBinding = TemplateBinding;
var RecursiveAstVisitor = (function () {
    function RecursiveAstVisitor() {
    }
    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {
        ast.left.visit(this);
        ast.right.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };
    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {
        ast.condition.visit(this);
        ast.trueExp.visit(this);
        ast.falseExp.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {
        ast.exp.visit(this);
        this.visitAll(ast.args, context);
        return null;
    };
    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {
        ast.target.visit(this);
        this.visitAll(ast.args, context);
        return null;
    };
    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };
    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {
        return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {
        ast.obj.visit(this);
        ast.key.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {
        ast.obj.visit(this);
        ast.key.visit(this);
        ast.value.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {
        return this.visitAll(ast.expressions, context);
    };
    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };
    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };
    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {
        ast.receiver.visit(this);
        return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {
        ast.expression.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {
        ast.receiver.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {
        ast.receiver.visit(this);
        ast.value.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {
        ast.receiver.visit(this);
        return null;
    };
    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {
        ast.receiver.visit(this);
        return this.visitAll(ast.args, context);
    };
    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {
        var _this = this;
        asts.forEach(function (ast) { return ast.visit(_this, context); });
        return null;
    };
    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };
    return RecursiveAstVisitor;
}());
exports.RecursiveAstVisitor = RecursiveAstVisitor;
var AstTransformer = (function () {
    function AstTransformer() {
    }
    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) { return ast; };
    AstTransformer.prototype.visitInterpolation = function (ast, context) {
        return new Interpolation(ast.strings, this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {
        return new LiteralPrimitive(ast.value);
    };
    AstTransformer.prototype.visitPropertyRead = function (ast, context) {
        return new PropertyRead(ast.receiver.visit(this), ast.name);
    };
    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {
        return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.value);
    };
    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {
        return new SafePropertyRead(ast.receiver.visit(this), ast.name);
    };
    AstTransformer.prototype.visitMethodCall = function (ast, context) {
        return new MethodCall(ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {
        return new SafeMethodCall(ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitFunctionCall = function (ast, context) {
        return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitLiteralArray = function (ast, context) {
        return new LiteralArray(this.visitAll(ast.expressions));
    };
    AstTransformer.prototype.visitLiteralMap = function (ast, context) {
        return new LiteralMap(ast.keys, this.visitAll(ast.values));
    };
    AstTransformer.prototype.visitBinary = function (ast, context) {
        return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
    };
    AstTransformer.prototype.visitPrefixNot = function (ast, context) {
        return new PrefixNot(ast.expression.visit(this));
    };
    AstTransformer.prototype.visitConditional = function (ast, context) {
        return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    };
    AstTransformer.prototype.visitPipe = function (ast, context) {
        return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
    };
    AstTransformer.prototype.visitKeyedRead = function (ast, context) {
        return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));
    };
    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {
        return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
    };
    AstTransformer.prototype.visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    AstTransformer.prototype.visitChain = function (ast, context) { return new Chain(this.visitAll(ast.expressions)); };
    AstTransformer.prototype.visitQuote = function (ast, context) {
        return new Quote(ast.prefix, ast.uninterpretedExpression, ast.location);
    };
    return AstTransformer;
}());
exports.AstTransformer = AstTransformer;

},{"../../src/facade/collection":87}],83:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
(function (TokenType) {
    TokenType[TokenType["Character"] = 0] = "Character";
    TokenType[TokenType["Identifier"] = 1] = "Identifier";
    TokenType[TokenType["Keyword"] = 2] = "Keyword";
    TokenType[TokenType["String"] = 3] = "String";
    TokenType[TokenType["Operator"] = 4] = "Operator";
    TokenType[TokenType["Number"] = 5] = "Number";
})(exports.TokenType || (exports.TokenType = {}));
var TokenType = exports.TokenType;
var Lexer = (function () {
    function Lexer() {
    }
    Lexer.prototype.tokenize = function (text) {
        var scanner = new _Scanner(text);
        var tokens = [];
        var token = scanner.scanToken();
        while (token != null) {
            tokens.push(token);
            token = scanner.scanToken();
        }
        return tokens;
    };
    Lexer.decorators = [
        { type: core_1.Injectable },
    ];
    return Lexer;
}());
exports.Lexer = Lexer;
var Token = (function () {
    function Token(index, type, numValue, strValue) {
        this.index = index;
        this.type = type;
        this.numValue = numValue;
        this.strValue = strValue;
    }
    Token.prototype.isCharacter = function (code) {
        return (this.type == TokenType.Character && this.numValue == code);
    };
    Token.prototype.isNumber = function () { return (this.type == TokenType.Number); };
    Token.prototype.isString = function () { return (this.type == TokenType.String); };
    Token.prototype.isOperator = function (operater) {
        return (this.type == TokenType.Operator && this.strValue == operater);
    };
    Token.prototype.isIdentifier = function () { return (this.type == TokenType.Identifier); };
    Token.prototype.isKeyword = function () { return (this.type == TokenType.Keyword); };
    Token.prototype.isKeywordDeprecatedVar = function () {
        return (this.type == TokenType.Keyword && this.strValue == "var");
    };
    Token.prototype.isKeywordLet = function () { return (this.type == TokenType.Keyword && this.strValue == "let"); };
    Token.prototype.isKeywordNull = function () { return (this.type == TokenType.Keyword && this.strValue == "null"); };
    Token.prototype.isKeywordUndefined = function () {
        return (this.type == TokenType.Keyword && this.strValue == "undefined");
    };
    Token.prototype.isKeywordTrue = function () { return (this.type == TokenType.Keyword && this.strValue == "true"); };
    Token.prototype.isKeywordFalse = function () { return (this.type == TokenType.Keyword && this.strValue == "false"); };
    Token.prototype.toNumber = function () {
        // -1 instead of NULL ok?
        return (this.type == TokenType.Number) ? this.numValue : -1;
    };
    Token.prototype.toString = function () {
        switch (this.type) {
            case TokenType.Character:
            case TokenType.Identifier:
            case TokenType.Keyword:
            case TokenType.Operator:
            case TokenType.String:
                return this.strValue;
            case TokenType.Number:
                return this.numValue.toString();
            default:
                return null;
        }
    };
    return Token;
}());
exports.Token = Token;
function newCharacterToken(index, code) {
    return new Token(index, TokenType.Character, code, lang_1.StringWrapper.fromCharCode(code));
}
function newIdentifierToken(index, text) {
    return new Token(index, TokenType.Identifier, 0, text);
}
function newKeywordToken(index, text) {
    return new Token(index, TokenType.Keyword, 0, text);
}
function newOperatorToken(index, text) {
    return new Token(index, TokenType.Operator, 0, text);
}
function newStringToken(index, text) {
    return new Token(index, TokenType.String, 0, text);
}
function newNumberToken(index, n) {
    return new Token(index, TokenType.Number, n, "");
}
exports.EOF = new Token(-1, TokenType.Character, 0, "");
exports.$EOF = 0;
exports.$TAB = 9;
exports.$LF = 10;
exports.$VTAB = 11;
exports.$FF = 12;
exports.$CR = 13;
exports.$SPACE = 32;
exports.$BANG = 33;
exports.$DQ = 34;
exports.$HASH = 35;
exports.$$ = 36;
exports.$PERCENT = 37;
exports.$AMPERSAND = 38;
exports.$SQ = 39;
exports.$LPAREN = 40;
exports.$RPAREN = 41;
exports.$STAR = 42;
exports.$PLUS = 43;
exports.$COMMA = 44;
exports.$MINUS = 45;
exports.$PERIOD = 46;
exports.$SLASH = 47;
exports.$COLON = 58;
exports.$SEMICOLON = 59;
exports.$LT = 60;
exports.$EQ = 61;
exports.$GT = 62;
exports.$QUESTION = 63;
var $0 = 48;
var $9 = 57;
var $A = 65, $E = 69, $Z = 90;
exports.$LBRACKET = 91;
exports.$BACKSLASH = 92;
exports.$RBRACKET = 93;
var $CARET = 94;
var $_ = 95;
exports.$BT = 96;
var $a = 97, $e = 101, $f = 102;
var $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;
exports.$LBRACE = 123;
exports.$BAR = 124;
exports.$RBRACE = 125;
var $NBSP = 160;
var ScannerError = (function (_super) {
    __extends(ScannerError, _super);
    function ScannerError(message) {
        _super.call(this);
        this.message = message;
    }
    ScannerError.prototype.toString = function () { return this.message; };
    return ScannerError;
}(exceptions_1.BaseException));
exports.ScannerError = ScannerError;
var _Scanner = (function () {
    function _Scanner(input) {
        this.input = input;
        this.peek = 0;
        this.index = -1;
        this.length = input.length;
        this.advance();
    }
    _Scanner.prototype.advance = function () {
        this.peek =
            ++this.index >= this.length ? exports.$EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index);
    };
    _Scanner.prototype.scanToken = function () {
        var input = this.input, length = this.length, peek = this.peek, index = this.index;
        // Skip whitespace.
        while (peek <= exports.$SPACE) {
            if (++index >= length) {
                peek = exports.$EOF;
                break;
            }
            else {
                peek = lang_1.StringWrapper.charCodeAt(input, index);
            }
        }
        this.peek = peek;
        this.index = index;
        if (index >= length) {
            return null;
        }
        // Handle identifiers and numbers.
        if (isIdentifierStart(peek))
            return this.scanIdentifier();
        if (isDigit(peek))
            return this.scanNumber(index);
        var start = index;
        switch (peek) {
            case exports.$PERIOD:
                this.advance();
                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, exports.$PERIOD);
            case exports.$LPAREN:
            case exports.$RPAREN:
            case exports.$LBRACE:
            case exports.$RBRACE:
            case exports.$LBRACKET:
            case exports.$RBRACKET:
            case exports.$COMMA:
            case exports.$COLON:
            case exports.$SEMICOLON:
                return this.scanCharacter(start, peek);
            case exports.$SQ:
            case exports.$DQ:
                return this.scanString();
            case exports.$HASH:
            case exports.$PLUS:
            case exports.$MINUS:
            case exports.$STAR:
            case exports.$SLASH:
            case exports.$PERCENT:
            case $CARET:
                return this.scanOperator(start, lang_1.StringWrapper.fromCharCode(peek));
            case exports.$QUESTION:
                return this.scanComplexOperator(start, '?', exports.$PERIOD, '.');
            case exports.$LT:
            case exports.$GT:
                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=');
            case exports.$BANG:
            case exports.$EQ:
                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=', exports.$EQ, '=');
            case exports.$AMPERSAND:
                return this.scanComplexOperator(start, '&', exports.$AMPERSAND, '&');
            case exports.$BAR:
                return this.scanComplexOperator(start, '|', exports.$BAR, '|');
            case $NBSP:
                while (isWhitespace(this.peek))
                    this.advance();
                return this.scanToken();
        }
        this.error("Unexpected character [" + lang_1.StringWrapper.fromCharCode(peek) + "]", 0);
        return null;
    };
    _Scanner.prototype.scanCharacter = function (start, code) {
        this.advance();
        return newCharacterToken(start, code);
    };
    _Scanner.prototype.scanOperator = function (start, str) {
        this.advance();
        return newOperatorToken(start, str);
    };
    /**
     * Tokenize a 2/3 char long operator
     *
     * @param start start index in the expression
     * @param one first symbol (always part of the operator)
     * @param twoCode code point for the second symbol
     * @param two second symbol (part of the operator when the second code point matches)
     * @param threeCode code point for the third symbol
     * @param three third symbol (part of the operator when provided and matches source expression)
     * @returns {Token}
     */
    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
        this.advance();
        var str = one;
        if (this.peek == twoCode) {
            this.advance();
            str += two;
        }
        if (lang_1.isPresent(threeCode) && this.peek == threeCode) {
            this.advance();
            str += three;
        }
        return newOperatorToken(start, str);
    };
    _Scanner.prototype.scanIdentifier = function () {
        var start = this.index;
        this.advance();
        while (isIdentifierPart(this.peek))
            this.advance();
        var str = this.input.substring(start, this.index);
        if (collection_1.SetWrapper.has(KEYWORDS, str)) {
            return newKeywordToken(start, str);
        }
        else {
            return newIdentifierToken(start, str);
        }
    };
    _Scanner.prototype.scanNumber = function (start) {
        var simple = (this.index === start);
        this.advance(); // Skip initial digit.
        while (true) {
            if (isDigit(this.peek)) {
            }
            else if (this.peek == exports.$PERIOD) {
                simple = false;
            }
            else if (isExponentStart(this.peek)) {
                this.advance();
                if (isExponentSign(this.peek))
                    this.advance();
                if (!isDigit(this.peek))
                    this.error('Invalid exponent', -1);
                simple = false;
            }
            else {
                break;
            }
            this.advance();
        }
        var str = this.input.substring(start, this.index);
        // TODO
        var value = simple ? lang_1.NumberWrapper.parseIntAutoRadix(str) : lang_1.NumberWrapper.parseFloat(str);
        return newNumberToken(start, value);
    };
    _Scanner.prototype.scanString = function () {
        var start = this.index;
        var quote = this.peek;
        this.advance(); // Skip initial quote.
        var buffer;
        var marker = this.index;
        var input = this.input;
        while (this.peek != quote) {
            if (this.peek == exports.$BACKSLASH) {
                if (buffer == null)
                    buffer = new lang_1.StringJoiner();
                buffer.add(input.substring(marker, this.index));
                this.advance();
                var unescapedCode;
                if (this.peek == $u) {
                    // 4 character hex code for unicode character.
                    var hex = input.substring(this.index + 1, this.index + 5);
                    try {
                        unescapedCode = lang_1.NumberWrapper.parseInt(hex, 16);
                    }
                    catch (e) {
                        this.error("Invalid unicode escape [\\u" + hex + "]", 0);
                    }
                    for (var i = 0; i < 5; i++) {
                        this.advance();
                    }
                }
                else {
                    unescapedCode = unescape(this.peek);
                    this.advance();
                }
                buffer.add(lang_1.StringWrapper.fromCharCode(unescapedCode));
                marker = this.index;
            }
            else if (this.peek == exports.$EOF) {
                this.error('Unterminated quote', 0);
            }
            else {
                this.advance();
            }
        }
        var last = input.substring(marker, this.index);
        this.advance(); // Skip terminating quote.
        // Compute the unescaped string value.
        var unescaped = last;
        if (buffer != null) {
            buffer.add(last);
            unescaped = buffer.toString();
        }
        return newStringToken(start, unescaped);
    };
    _Scanner.prototype.error = function (message, offset) {
        var position = this.index + offset;
        throw new ScannerError("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
    };
    return _Scanner;
}());
function isWhitespace(code) {
    return (code >= exports.$TAB && code <= exports.$SPACE) || (code == $NBSP);
}
function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == exports.$$);
}
function isIdentifier(input) {
    if (input.length == 0)
        return false;
    var scanner = new _Scanner(input);
    if (!isIdentifierStart(scanner.peek))
        return false;
    scanner.advance();
    while (scanner.peek !== exports.$EOF) {
        if (!isIdentifierPart(scanner.peek))
            return false;
        scanner.advance();
    }
    return true;
}
exports.isIdentifier = isIdentifier;
function isIdentifierPart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) ||
        (code == $_) || (code == exports.$$);
}
function isDigit(code) {
    return $0 <= code && code <= $9;
}
function isExponentStart(code) {
    return code == $e || code == $E;
}
function isExponentSign(code) {
    return code == exports.$MINUS || code == exports.$PLUS;
}
function isQuote(code) {
    return code === exports.$SQ || code === exports.$DQ || code === exports.$BT;
}
exports.isQuote = isQuote;
function unescape(code) {
    switch (code) {
        case $n:
            return exports.$LF;
        case $f:
            return exports.$FF;
        case $r:
            return exports.$CR;
        case $t:
            return exports.$TAB;
        case $v:
            return exports.$VTAB;
        default:
            return code;
    }
}
var OPERATORS = collection_1.SetWrapper.createFromList([
    '+',
    '-',
    '*',
    '/',
    '%',
    '^',
    '=',
    '==',
    '!=',
    '===',
    '!==',
    '<',
    '>',
    '<=',
    '>=',
    '&&',
    '||',
    '&',
    '|',
    '!',
    '?',
    '#',
    '?.'
]);
var KEYWORDS = collection_1.SetWrapper.createFromList(['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else']);

},{"../../src/facade/collection":87,"../../src/facade/exceptions":89,"../../src/facade/lang":90,"@angular/core":140}],84:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var collection_1 = require('../../src/facade/collection');
var lexer_1 = require('./lexer');
var ast_1 = require('./ast');
var _implicitReceiver = new ast_1.ImplicitReceiver();
// TODO(tbosch): Cannot make this const/final right now because of the transpiler...
var INTERPOLATION_REGEXP = /\{\{([\s\S]*?)\}\}/g;
var ParseException = (function (_super) {
    __extends(ParseException, _super);
    function ParseException(message, input, errLocation, ctxLocation) {
        _super.call(this, "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation);
    }
    return ParseException;
}(exceptions_1.BaseException));
var SplitInterpolation = (function () {
    function SplitInterpolation(strings, expressions) {
        this.strings = strings;
        this.expressions = expressions;
    }
    return SplitInterpolation;
}());
exports.SplitInterpolation = SplitInterpolation;
var TemplateBindingParseResult = (function () {
    function TemplateBindingParseResult(templateBindings, warnings) {
        this.templateBindings = templateBindings;
        this.warnings = warnings;
    }
    return TemplateBindingParseResult;
}());
exports.TemplateBindingParseResult = TemplateBindingParseResult;
var Parser = (function () {
    function Parser(/** @internal */ _lexer) {
        this._lexer = _lexer;
    }
    Parser.prototype.parseAction = function (input, location) {
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(this._stripComments(input));
        var ast = new _ParseAST(input, location, tokens, true).parseChain();
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseBinding = function (input, location) {
        var ast = this._parseBindingAst(input, location);
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype.parseSimpleBinding = function (input, location) {
        var ast = this._parseBindingAst(input, location);
        if (!SimpleExpressionChecker.check(ast)) {
            throw new ParseException('Host binding expression can only contain field access and constants', input, location);
        }
        return new ast_1.ASTWithSource(ast, input, location);
    };
    Parser.prototype._parseBindingAst = function (input, location) {
        // Quotes expressions use 3rd-party expression language. We don't want to use
        // our lexer or parser for that, so we check for that ahead of time.
        var quote = this._parseQuote(input, location);
        if (lang_1.isPresent(quote)) {
            return quote;
        }
        this._checkNoInterpolation(input, location);
        var tokens = this._lexer.tokenize(this._stripComments(input));
        return new _ParseAST(input, location, tokens, false).parseChain();
    };
    Parser.prototype._parseQuote = function (input, location) {
        if (lang_1.isBlank(input))
            return null;
        var prefixSeparatorIndex = input.indexOf(':');
        if (prefixSeparatorIndex == -1)
            return null;
        var prefix = input.substring(0, prefixSeparatorIndex).trim();
        if (!lexer_1.isIdentifier(prefix))
            return null;
        var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
        return new ast_1.Quote(prefix, uninterpretedExpression, location);
    };
    Parser.prototype.parseTemplateBindings = function (input, location) {
        var tokens = this._lexer.tokenize(input);
        return new _ParseAST(input, location, tokens, false).parseTemplateBindings();
    };
    Parser.prototype.parseInterpolation = function (input, location) {
        var split = this.splitInterpolation(input, location);
        if (split == null)
            return null;
        var expressions = [];
        for (var i = 0; i < split.expressions.length; ++i) {
            var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
            var ast = new _ParseAST(input, location, tokens, false).parseChain();
            expressions.push(ast);
        }
        return new ast_1.ASTWithSource(new ast_1.Interpolation(split.strings, expressions), input, location);
    };
    Parser.prototype.splitInterpolation = function (input, location) {
        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
        if (parts.length <= 1) {
            return null;
        }
        var strings = [];
        var expressions = [];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i % 2 === 0) {
                // fixed string
                strings.push(part);
            }
            else if (part.trim().length > 0) {
                expressions.push(part);
            }
            else {
                throw new ParseException('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i) + " in", location);
            }
        }
        return new SplitInterpolation(strings, expressions);
    };
    Parser.prototype.wrapLiteralPrimitive = function (input, location) {
        return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(input), input, location);
    };
    Parser.prototype._stripComments = function (input) {
        var i = this._commentStart(input);
        return lang_1.isPresent(i) ? input.substring(0, i).trim() : input;
    };
    Parser.prototype._commentStart = function (input) {
        var outerQuote = null;
        for (var i = 0; i < input.length - 1; i++) {
            var char = lang_1.StringWrapper.charCodeAt(input, i);
            var nextChar = lang_1.StringWrapper.charCodeAt(input, i + 1);
            if (char === lexer_1.$SLASH && nextChar == lexer_1.$SLASH && lang_1.isBlank(outerQuote))
                return i;
            if (outerQuote === char) {
                outerQuote = null;
            }
            else if (lang_1.isBlank(outerQuote) && lexer_1.isQuote(char)) {
                outerQuote = char;
            }
        }
        return null;
    };
    Parser.prototype._checkNoInterpolation = function (input, location) {
        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
        if (parts.length > 1) {
            throw new ParseException('Got interpolation ({{}}) where expression was expected', input, "at column " + this._findInterpolationErrorColumn(parts, 1) + " in", location);
        }
    };
    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx) {
        var errLocation = '';
        for (var j = 0; j < partInErrIdx; j++) {
            errLocation += j % 2 === 0 ? parts[j] : "{{" + parts[j] + "}}";
        }
        return errLocation.length;
    };
    Parser.decorators = [
        { type: core_1.Injectable },
    ];
    Parser.ctorParameters = [
        { type: lexer_1.Lexer, },
    ];
    return Parser;
}());
exports.Parser = Parser;
var _ParseAST = (function () {
    function _ParseAST(input, location, tokens, parseAction) {
        this.input = input;
        this.location = location;
        this.tokens = tokens;
        this.parseAction = parseAction;
        this.index = 0;
    }
    _ParseAST.prototype.peek = function (offset) {
        var i = this.index + offset;
        return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;
    };
    Object.defineProperty(_ParseAST.prototype, "next", {
        get: function () { return this.peek(0); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
        get: function () {
            return (this.index < this.tokens.length) ? this.next.index : this.input.length;
        },
        enumerable: true,
        configurable: true
    });
    _ParseAST.prototype.advance = function () { this.index++; };
    _ParseAST.prototype.optionalCharacter = function (code) {
        if (this.next.isCharacter(code)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };
    _ParseAST.prototype.peekDeprecatedKeywordVar = function () { return this.next.isKeywordDeprecatedVar(); };
    _ParseAST.prototype.peekDeprecatedOperatorHash = function () { return this.next.isOperator('#'); };
    _ParseAST.prototype.expectCharacter = function (code) {
        if (this.optionalCharacter(code))
            return;
        this.error("Missing expected " + lang_1.StringWrapper.fromCharCode(code));
    };
    _ParseAST.prototype.optionalOperator = function (op) {
        if (this.next.isOperator(op)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.expectOperator = function (operator) {
        if (this.optionalOperator(operator))
            return;
        this.error("Missing expected operator " + operator);
    };
    _ParseAST.prototype.expectIdentifierOrKeyword = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword()) {
            this.error("Unexpected token " + n + ", expected identifier or keyword");
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
            this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.parseChain = function () {
        var exprs = [];
        while (this.index < this.tokens.length) {
            var expr = this.parsePipe();
            exprs.push(expr);
            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                if (!this.parseAction) {
                    this.error("Binding expression cannot contain chained expression");
                }
                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                } // read all semicolons
            }
            else if (this.index < this.tokens.length) {
                this.error("Unexpected token '" + this.next + "'");
            }
        }
        if (exprs.length == 0)
            return new ast_1.EmptyExpr();
        if (exprs.length == 1)
            return exprs[0];
        return new ast_1.Chain(exprs);
    };
    _ParseAST.prototype.parsePipe = function () {
        var result = this.parseExpression();
        if (this.optionalOperator("|")) {
            if (this.parseAction) {
                this.error("Cannot have a pipe in an action expression");
            }
            do {
                var name = this.expectIdentifierOrKeyword();
                var args = [];
                while (this.optionalCharacter(lexer_1.$COLON)) {
                    args.push(this.parseExpression());
                }
                result = new ast_1.BindingPipe(result, name, args);
            } while (this.optionalOperator("|"));
        }
        return result;
    };
    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
    _ParseAST.prototype.parseConditional = function () {
        var start = this.inputIndex;
        var result = this.parseLogicalOr();
        if (this.optionalOperator('?')) {
            var yes = this.parsePipe();
            if (!this.optionalCharacter(lexer_1.$COLON)) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error("Conditional expression " + expression + " requires all 3 expressions");
            }
            var no = this.parsePipe();
            return new ast_1.Conditional(result, yes, no);
        }
        else {
            return result;
        }
    };
    _ParseAST.prototype.parseLogicalOr = function () {
        // '||'
        var result = this.parseLogicalAnd();
        while (this.optionalOperator('||')) {
            result = new ast_1.Binary('||', result, this.parseLogicalAnd());
        }
        return result;
    };
    _ParseAST.prototype.parseLogicalAnd = function () {
        // '&&'
        var result = this.parseEquality();
        while (this.optionalOperator('&&')) {
            result = new ast_1.Binary('&&', result, this.parseEquality());
        }
        return result;
    };
    _ParseAST.prototype.parseEquality = function () {
        // '==','!=','===','!=='
        var result = this.parseRelational();
        while (true) {
            if (this.optionalOperator('==')) {
                result = new ast_1.Binary('==', result, this.parseRelational());
            }
            else if (this.optionalOperator('===')) {
                result = new ast_1.Binary('===', result, this.parseRelational());
            }
            else if (this.optionalOperator('!=')) {
                result = new ast_1.Binary('!=', result, this.parseRelational());
            }
            else if (this.optionalOperator('!==')) {
                result = new ast_1.Binary('!==', result, this.parseRelational());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseRelational = function () {
        // '<', '>', '<=', '>='
        var result = this.parseAdditive();
        while (true) {
            if (this.optionalOperator('<')) {
                result = new ast_1.Binary('<', result, this.parseAdditive());
            }
            else if (this.optionalOperator('>')) {
                result = new ast_1.Binary('>', result, this.parseAdditive());
            }
            else if (this.optionalOperator('<=')) {
                result = new ast_1.Binary('<=', result, this.parseAdditive());
            }
            else if (this.optionalOperator('>=')) {
                result = new ast_1.Binary('>=', result, this.parseAdditive());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseAdditive = function () {
        // '+', '-'
        var result = this.parseMultiplicative();
        while (true) {
            if (this.optionalOperator('+')) {
                result = new ast_1.Binary('+', result, this.parseMultiplicative());
            }
            else if (this.optionalOperator('-')) {
                result = new ast_1.Binary('-', result, this.parseMultiplicative());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parseMultiplicative = function () {
        // '*', '%', '/'
        var result = this.parsePrefix();
        while (true) {
            if (this.optionalOperator('*')) {
                result = new ast_1.Binary('*', result, this.parsePrefix());
            }
            else if (this.optionalOperator('%')) {
                result = new ast_1.Binary('%', result, this.parsePrefix());
            }
            else if (this.optionalOperator('/')) {
                result = new ast_1.Binary('/', result, this.parsePrefix());
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parsePrefix = function () {
        if (this.optionalOperator('+')) {
            return this.parsePrefix();
        }
        else if (this.optionalOperator('-')) {
            return new ast_1.Binary('-', new ast_1.LiteralPrimitive(0), this.parsePrefix());
        }
        else if (this.optionalOperator('!')) {
            return new ast_1.PrefixNot(this.parsePrefix());
        }
        else {
            return this.parseCallChain();
        }
    };
    _ParseAST.prototype.parseCallChain = function () {
        var result = this.parsePrimary();
        while (true) {
            if (this.optionalCharacter(lexer_1.$PERIOD)) {
                result = this.parseAccessMemberOrMethodCall(result, false);
            }
            else if (this.optionalOperator('?.')) {
                result = this.parseAccessMemberOrMethodCall(result, true);
            }
            else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
                var key = this.parsePipe();
                this.expectCharacter(lexer_1.$RBRACKET);
                if (this.optionalOperator("=")) {
                    var value = this.parseConditional();
                    result = new ast_1.KeyedWrite(result, key, value);
                }
                else {
                    result = new ast_1.KeyedRead(result, key);
                }
            }
            else if (this.optionalCharacter(lexer_1.$LPAREN)) {
                var args = this.parseCallArguments();
                this.expectCharacter(lexer_1.$RPAREN);
                result = new ast_1.FunctionCall(result, args);
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parsePrimary = function () {
        if (this.optionalCharacter(lexer_1.$LPAREN)) {
            var result = this.parsePipe();
            this.expectCharacter(lexer_1.$RPAREN);
            return result;
        }
        else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
            this.advance();
            return new ast_1.LiteralPrimitive(null);
        }
        else if (this.next.isKeywordTrue()) {
            this.advance();
            return new ast_1.LiteralPrimitive(true);
        }
        else if (this.next.isKeywordFalse()) {
            this.advance();
            return new ast_1.LiteralPrimitive(false);
        }
        else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
            var elements = this.parseExpressionList(lexer_1.$RBRACKET);
            this.expectCharacter(lexer_1.$RBRACKET);
            return new ast_1.LiteralArray(elements);
        }
        else if (this.next.isCharacter(lexer_1.$LBRACE)) {
            return this.parseLiteralMap();
        }
        else if (this.next.isIdentifier()) {
            return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
        }
        else if (this.next.isNumber()) {
            var value = this.next.toNumber();
            this.advance();
            return new ast_1.LiteralPrimitive(value);
        }
        else if (this.next.isString()) {
            var literalValue = this.next.toString();
            this.advance();
            return new ast_1.LiteralPrimitive(literalValue);
        }
        else if (this.index >= this.tokens.length) {
            this.error("Unexpected end of expression: " + this.input);
        }
        else {
            this.error("Unexpected token " + this.next);
        }
        // error() throws, so we don't reach here.
        throw new exceptions_1.BaseException("Fell through all cases in parsePrimary");
    };
    _ParseAST.prototype.parseExpressionList = function (terminator) {
        var result = [];
        if (!this.next.isCharacter(terminator)) {
            do {
                result.push(this.parsePipe());
            } while (this.optionalCharacter(lexer_1.$COMMA));
        }
        return result;
    };
    _ParseAST.prototype.parseLiteralMap = function () {
        var keys = [];
        var values = [];
        this.expectCharacter(lexer_1.$LBRACE);
        if (!this.optionalCharacter(lexer_1.$RBRACE)) {
            do {
                var key = this.expectIdentifierOrKeywordOrString();
                keys.push(key);
                this.expectCharacter(lexer_1.$COLON);
                values.push(this.parsePipe());
            } while (this.optionalCharacter(lexer_1.$COMMA));
            this.expectCharacter(lexer_1.$RBRACE);
        }
        return new ast_1.LiteralMap(keys, values);
    };
    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
        if (isSafe === void 0) { isSafe = false; }
        var id = this.expectIdentifierOrKeyword();
        if (this.optionalCharacter(lexer_1.$LPAREN)) {
            var args = this.parseCallArguments();
            this.expectCharacter(lexer_1.$RPAREN);
            return isSafe ? new ast_1.SafeMethodCall(receiver, id, args) : new ast_1.MethodCall(receiver, id, args);
        }
        else {
            if (isSafe) {
                if (this.optionalOperator("=")) {
                    this.error("The '?.' operator cannot be used in the assignment");
                }
                else {
                    return new ast_1.SafePropertyRead(receiver, id);
                }
            }
            else {
                if (this.optionalOperator("=")) {
                    if (!this.parseAction) {
                        this.error("Bindings cannot contain assignments");
                    }
                    var value = this.parseConditional();
                    return new ast_1.PropertyWrite(receiver, id, value);
                }
                else {
                    return new ast_1.PropertyRead(receiver, id);
                }
            }
        }
        return null;
    };
    _ParseAST.prototype.parseCallArguments = function () {
        if (this.next.isCharacter(lexer_1.$RPAREN))
            return [];
        var positionals = [];
        do {
            positionals.push(this.parsePipe());
        } while (this.optionalCharacter(lexer_1.$COMMA));
        return positionals;
    };
    _ParseAST.prototype.parseBlockContent = function () {
        if (!this.parseAction) {
            this.error("Binding expression cannot contain chained expression");
        }
        var exprs = [];
        while (this.index < this.tokens.length && !this.next.isCharacter(lexer_1.$RBRACE)) {
            var expr = this.parseExpression();
            exprs.push(expr);
            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
                } // read all semicolons
            }
        }
        if (exprs.length == 0)
            return new ast_1.EmptyExpr();
        if (exprs.length == 1)
            return exprs[0];
        return new ast_1.Chain(exprs);
    };
    /**
     * An identifier, a keyword, a string with an optional `-` inbetween.
     */
    _ParseAST.prototype.expectTemplateBindingKey = function () {
        var result = '';
        var operatorFound = false;
        do {
            result += this.expectIdentifierOrKeywordOrString();
            operatorFound = this.optionalOperator('-');
            if (operatorFound) {
                result += '-';
            }
        } while (operatorFound);
        return result.toString();
    };
    _ParseAST.prototype.parseTemplateBindings = function () {
        var bindings = [];
        var prefix = null;
        var warnings = [];
        while (this.index < this.tokens.length) {
            var keyIsVar = this.peekKeywordLet();
            if (!keyIsVar && this.peekDeprecatedKeywordVar()) {
                keyIsVar = true;
                warnings.push("\"var\" inside of expressions is deprecated. Use \"let\" instead!");
            }
            if (!keyIsVar && this.peekDeprecatedOperatorHash()) {
                keyIsVar = true;
                warnings.push("\"#\" inside of expressions is deprecated. Use \"let\" instead!");
            }
            if (keyIsVar) {
                this.advance();
            }
            var key = this.expectTemplateBindingKey();
            if (!keyIsVar) {
                if (prefix == null) {
                    prefix = key;
                }
                else {
                    key = prefix + key[0].toUpperCase() + key.substring(1);
                }
            }
            this.optionalCharacter(lexer_1.$COLON);
            var name = null;
            var expression = null;
            if (keyIsVar) {
                if (this.optionalOperator("=")) {
                    name = this.expectTemplateBindingKey();
                }
                else {
                    name = '\$implicit';
                }
            }
            else if (this.next !== lexer_1.EOF && !this.peekKeywordLet() && !this.peekDeprecatedKeywordVar() &&
                !this.peekDeprecatedOperatorHash()) {
                var start = this.inputIndex;
                var ast = this.parsePipe();
                var source = this.input.substring(start, this.inputIndex);
                expression = new ast_1.ASTWithSource(ast, source, this.location);
            }
            bindings.push(new ast_1.TemplateBinding(key, keyIsVar, name, expression));
            if (!this.optionalCharacter(lexer_1.$SEMICOLON)) {
                this.optionalCharacter(lexer_1.$COMMA);
            }
        }
        return new TemplateBindingParseResult(bindings, warnings);
    };
    _ParseAST.prototype.error = function (message, index) {
        if (index === void 0) { index = null; }
        if (lang_1.isBlank(index))
            index = this.index;
        var location = (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
            "at the end of the expression";
        throw new ParseException(message, this.input, location, this.location);
    };
    return _ParseAST;
}());
exports._ParseAST = _ParseAST;
var SimpleExpressionChecker = (function () {
    function SimpleExpressionChecker() {
        this.simple = true;
    }
    SimpleExpressionChecker.check = function (ast) {
        var s = new SimpleExpressionChecker();
        ast.visit(s);
        return s.simple;
    };
    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };
    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };
    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };
    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };
    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };
    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitAll = function (asts) {
        var res = collection_1.ListWrapper.createFixedSize(asts.length);
        for (var i = 0; i < asts.length; ++i) {
            res[i] = asts[i].visit(this);
        }
        return res;
    };
    SimpleExpressionChecker.prototype.visitChain = function (ast, context) { this.simple = false; };
    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { this.simple = false; };
    return SimpleExpressionChecker;
}());

},{"../../src/facade/collection":87,"../../src/facade/exceptions":89,"../../src/facade/lang":90,"./ast":82,"./lexer":83,"@angular/core":140}],85:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./lang":90,"./promise":91,"dup":20,"rxjs/Observable":290,"rxjs/Subject":292,"rxjs/observable/PromiseObservable":296,"rxjs/operator/toPromise":297}],86:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],87:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./lang":90,"dup":22}],88:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./base_wrapped_exception":86,"./collection":87,"./lang":90,"dup":23}],89:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./base_wrapped_exception":86,"./exception_handler":88,"dup":24}],90:[function(require,module,exports){
(function (global){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
exports.scheduleMicroTask = scheduleMicroTask;
exports.IS_DART = false;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    if (type['name']) {
        return type['name'];
    }
    return typeof type;
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var _devMode = true;
var _modeLocked = false;
function lockMode() {
    _modeLocked = true;
}
exports.lockMode = lockMode;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 */
function enableProdMode() {
    if (_modeLocked) {
        // Cannot use BaseException as that ends up importing from facade/lang.
        throw 'Cannot enable prod mode after platform setup.';
    }
    _devMode = false;
}
exports.enableProdMode = enableProdMode;
function assertionsEnabled() {
    return _devMode;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    // TODO: to be fixed properly via #2830, noop for now
};
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isBoolean(obj) {
    return typeof obj === "boolean";
}
exports.isBoolean = isBoolean;
function isNumber(obj) {
    return typeof obj === "number";
}
exports.isNumber = isNumber;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
var STRING_MAP_PROTO = Object.getPrototypeOf({});
function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
}
exports.isStrictStringMap = isStrictStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function noop() { }
exports.noop = noop;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    if (token.overriddenName) {
        return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
function resolveEnumToken(enumValue, val) {
    return enumValue[val];
}
exports.resolveEnumToken = resolveEnumToken;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.stripLeft = function (s, charVal) {
        if (s && s.length) {
            var pos = 0;
            for (var i = 0; i < s.length; i++) {
                if (s[i] != charVal)
                    break;
                pos++;
            }
            s = s.substring(pos);
        }
        return s;
    };
    StringWrapper.stripRight = function (s, charVal) {
        if (s && s.length) {
            var pos = s.length;
            for (var i = s.length - 1; i >= 0; i--) {
                if (s[i] != charVal)
                    break;
                pos--;
            }
            s = s.substring(0, pos);
        }
        return s;
    };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
}());
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
}());
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
}(Error));
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
}());
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    RegExpWrapper.replaceAll = function (regExp, input, replace) {
        var c = regExp.exec(input);
        var res = '';
        regExp.lastIndex = 0;
        var prev = 0;
        while (c) {
            res += input.substring(prev, c.index);
            res += replace(c);
            prev = c.index + c[0].length;
            regExp.lastIndex = prev;
            c = regExp.exec(input);
        }
        res += input.substring(prev);
        return res;
    };
    return RegExpWrapper;
}());
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
}());
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
}());
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
function warn(obj) {
    console.warn(obj);
}
exports.warn = warn;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
}());
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
}());
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;
function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
        fnArgNames.push(argName);
        fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
}
exports.evalExpression = evalExpression;
function isPrimitive(obj) {
    return !isJsObject(obj);
}
exports.isPrimitive = isPrimitive;
function hasConstructor(value, type) {
    return value.constructor === type;
}
exports.hasConstructor = hasConstructor;
function bitWiseOr(values) {
    return values.reduce(function (a, b) { return a | b; });
}
exports.bitWiseOr = bitWiseOr;
function bitWiseAnd(values) {
    return values.reduce(function (a, b) { return a & b; });
}
exports.bitWiseAnd = bitWiseAnd;
function escape(s) {
    return _global.encodeURI(s);
}
exports.escape = escape;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],91:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],92:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var HtmlTextAst = (function () {
    function HtmlTextAst(value, sourceSpan) {
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    HtmlTextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
    return HtmlTextAst;
}());
exports.HtmlTextAst = HtmlTextAst;
var HtmlExpansionAst = (function () {
    function HtmlExpansionAst(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
        this.switchValue = switchValue;
        this.type = type;
        this.cases = cases;
        this.sourceSpan = sourceSpan;
        this.switchValueSourceSpan = switchValueSourceSpan;
    }
    HtmlExpansionAst.prototype.visit = function (visitor, context) {
        return visitor.visitExpansion(this, context);
    };
    return HtmlExpansionAst;
}());
exports.HtmlExpansionAst = HtmlExpansionAst;
var HtmlExpansionCaseAst = (function () {
    function HtmlExpansionCaseAst(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
        this.value = value;
        this.expression = expression;
        this.sourceSpan = sourceSpan;
        this.valueSourceSpan = valueSourceSpan;
        this.expSourceSpan = expSourceSpan;
    }
    HtmlExpansionCaseAst.prototype.visit = function (visitor, context) {
        return visitor.visitExpansionCase(this, context);
    };
    return HtmlExpansionCaseAst;
}());
exports.HtmlExpansionCaseAst = HtmlExpansionCaseAst;
var HtmlAttrAst = (function () {
    function HtmlAttrAst(name, value, sourceSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    HtmlAttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
    return HtmlAttrAst;
}());
exports.HtmlAttrAst = HtmlAttrAst;
var HtmlElementAst = (function () {
    function HtmlElementAst(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
        this.name = name;
        this.attrs = attrs;
        this.children = children;
        this.sourceSpan = sourceSpan;
        this.startSourceSpan = startSourceSpan;
        this.endSourceSpan = endSourceSpan;
    }
    HtmlElementAst.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };
    return HtmlElementAst;
}());
exports.HtmlElementAst = HtmlElementAst;
var HtmlCommentAst = (function () {
    function HtmlCommentAst(value, sourceSpan) {
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    HtmlCommentAst.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };
    return HtmlCommentAst;
}());
exports.HtmlCommentAst = HtmlCommentAst;
function htmlVisitAll(visitor, asts, context) {
    if (context === void 0) { context = null; }
    var result = [];
    asts.forEach(function (ast) {
        var astResult = ast.visit(visitor, context);
        if (lang_1.isPresent(astResult)) {
            result.push(astResult);
        }
    });
    return result;
}
exports.htmlVisitAll = htmlVisitAll;

},{"../src/facade/lang":90}],93:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../src/facade/lang');
var collection_1 = require('../src/facade/collection');
var parse_util_1 = require('./parse_util');
var html_tags_1 = require('./html_tags');
(function (HtmlTokenType) {
    HtmlTokenType[HtmlTokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
    HtmlTokenType[HtmlTokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
    HtmlTokenType[HtmlTokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
    HtmlTokenType[HtmlTokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
    HtmlTokenType[HtmlTokenType["TEXT"] = 4] = "TEXT";
    HtmlTokenType[HtmlTokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
    HtmlTokenType[HtmlTokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
    HtmlTokenType[HtmlTokenType["COMMENT_START"] = 7] = "COMMENT_START";
    HtmlTokenType[HtmlTokenType["COMMENT_END"] = 8] = "COMMENT_END";
    HtmlTokenType[HtmlTokenType["CDATA_START"] = 9] = "CDATA_START";
    HtmlTokenType[HtmlTokenType["CDATA_END"] = 10] = "CDATA_END";
    HtmlTokenType[HtmlTokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
    HtmlTokenType[HtmlTokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
    HtmlTokenType[HtmlTokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
    HtmlTokenType[HtmlTokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
    HtmlTokenType[HtmlTokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
    HtmlTokenType[HtmlTokenType["EOF"] = 19] = "EOF";
})(exports.HtmlTokenType || (exports.HtmlTokenType = {}));
var HtmlTokenType = exports.HtmlTokenType;
var HtmlToken = (function () {
    function HtmlToken(type, parts, sourceSpan) {
        this.type = type;
        this.parts = parts;
        this.sourceSpan = sourceSpan;
    }
    return HtmlToken;
}());
exports.HtmlToken = HtmlToken;
var HtmlTokenError = (function (_super) {
    __extends(HtmlTokenError, _super);
    function HtmlTokenError(errorMsg, tokenType, span) {
        _super.call(this, span, errorMsg);
        this.tokenType = tokenType;
    }
    return HtmlTokenError;
}(parse_util_1.ParseError));
exports.HtmlTokenError = HtmlTokenError;
var HtmlTokenizeResult = (function () {
    function HtmlTokenizeResult(tokens, errors) {
        this.tokens = tokens;
        this.errors = errors;
    }
    return HtmlTokenizeResult;
}());
exports.HtmlTokenizeResult = HtmlTokenizeResult;
function tokenizeHtml(sourceContent, sourceUrl, tokenizeExpansionForms) {
    if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }
    return new _HtmlTokenizer(new parse_util_1.ParseSourceFile(sourceContent, sourceUrl), tokenizeExpansionForms)
        .tokenize();
}
exports.tokenizeHtml = tokenizeHtml;
var $EOF = 0;
var $TAB = 9;
var $LF = 10;
var $FF = 12;
var $CR = 13;
var $SPACE = 32;
var $BANG = 33;
var $DQ = 34;
var $HASH = 35;
var $$ = 36;
var $AMPERSAND = 38;
var $SQ = 39;
var $MINUS = 45;
var $SLASH = 47;
var $0 = 48;
var $SEMICOLON = 59;
var $9 = 57;
var $COLON = 58;
var $LT = 60;
var $EQ = 61;
var $GT = 62;
var $QUESTION = 63;
var $LBRACKET = 91;
var $RBRACKET = 93;
var $LBRACE = 123;
var $RBRACE = 125;
var $COMMA = 44;
var $A = 65;
var $F = 70;
var $X = 88;
var $Z = 90;
var $a = 97;
var $f = 102;
var $z = 122;
var $x = 120;
var $NBSP = 160;
var CR_OR_CRLF_REGEXP = /\r\n?/g;
function unexpectedCharacterErrorMsg(charCode) {
    var char = charCode === $EOF ? 'EOF' : lang_1.StringWrapper.fromCharCode(charCode);
    return "Unexpected character \"" + char + "\"";
}
function unknownEntityErrorMsg(entitySrc) {
    return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
}
var ControlFlowError = (function () {
    function ControlFlowError(error) {
        this.error = error;
    }
    return ControlFlowError;
}());
// See http://www.w3.org/TR/html51/syntax.html#writing
var _HtmlTokenizer = (function () {
    function _HtmlTokenizer(file, tokenizeExpansionForms) {
        this.file = file;
        this.tokenizeExpansionForms = tokenizeExpansionForms;
        // Note: this is always lowercase!
        this.peek = -1;
        this.nextPeek = -1;
        this.index = -1;
        this.line = 0;
        this.column = -1;
        this.expansionCaseStack = [];
        this.tokens = [];
        this.errors = [];
        this.input = file.content;
        this.length = file.content.length;
        this._advance();
    }
    _HtmlTokenizer.prototype._processCarriageReturns = function (content) {
        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
        // In order to keep the original position in the source, we can not
        // pre-process it.
        // Instead CRs are processed right before instantiating the tokens.
        return lang_1.StringWrapper.replaceAll(content, CR_OR_CRLF_REGEXP, '\n');
    };
    _HtmlTokenizer.prototype.tokenize = function () {
        while (this.peek !== $EOF) {
            var start = this._getLocation();
            try {
                if (this._attemptCharCode($LT)) {
                    if (this._attemptCharCode($BANG)) {
                        if (this._attemptCharCode($LBRACKET)) {
                            this._consumeCdata(start);
                        }
                        else if (this._attemptCharCode($MINUS)) {
                            this._consumeComment(start);
                        }
                        else {
                            this._consumeDocType(start);
                        }
                    }
                    else if (this._attemptCharCode($SLASH)) {
                        this._consumeTagClose(start);
                    }
                    else {
                        this._consumeTagOpen(start);
                    }
                }
                else if (isSpecialFormStart(this.peek, this.nextPeek) && this.tokenizeExpansionForms) {
                    this._consumeExpansionFormStart();
                }
                else if (this.peek === $EQ && this.tokenizeExpansionForms) {
                    this._consumeExpansionCaseStart();
                }
                else if (this.peek === $RBRACE && this.isInExpansionCase() &&
                    this.tokenizeExpansionForms) {
                    this._consumeExpansionCaseEnd();
                }
                else if (this.peek === $RBRACE && this.isInExpansionForm() &&
                    this.tokenizeExpansionForms) {
                    this._consumeExpansionFormEnd();
                }
                else {
                    this._consumeText();
                }
            }
            catch (e) {
                if (e instanceof ControlFlowError) {
                    this.errors.push(e.error);
                }
                else {
                    throw e;
                }
            }
        }
        this._beginToken(HtmlTokenType.EOF);
        this._endToken([]);
        return new HtmlTokenizeResult(mergeTextTokens(this.tokens), this.errors);
    };
    _HtmlTokenizer.prototype._getLocation = function () {
        return new parse_util_1.ParseLocation(this.file, this.index, this.line, this.column);
    };
    _HtmlTokenizer.prototype._getSpan = function (start, end) {
        if (lang_1.isBlank(start)) {
            start = this._getLocation();
        }
        if (lang_1.isBlank(end)) {
            end = this._getLocation();
        }
        return new parse_util_1.ParseSourceSpan(start, end);
    };
    _HtmlTokenizer.prototype._beginToken = function (type, start) {
        if (start === void 0) { start = null; }
        if (lang_1.isBlank(start)) {
            start = this._getLocation();
        }
        this.currentTokenStart = start;
        this.currentTokenType = type;
    };
    _HtmlTokenizer.prototype._endToken = function (parts, end) {
        if (end === void 0) { end = null; }
        if (lang_1.isBlank(end)) {
            end = this._getLocation();
        }
        var token = new HtmlToken(this.currentTokenType, parts, new parse_util_1.ParseSourceSpan(this.currentTokenStart, end));
        this.tokens.push(token);
        this.currentTokenStart = null;
        this.currentTokenType = null;
        return token;
    };
    _HtmlTokenizer.prototype._createError = function (msg, span) {
        var error = new HtmlTokenError(msg, this.currentTokenType, span);
        this.currentTokenStart = null;
        this.currentTokenType = null;
        return new ControlFlowError(error);
    };
    _HtmlTokenizer.prototype._advance = function () {
        if (this.index >= this.length) {
            throw this._createError(unexpectedCharacterErrorMsg($EOF), this._getSpan());
        }
        if (this.peek === $LF) {
            this.line++;
            this.column = 0;
        }
        else if (this.peek !== $LF && this.peek !== $CR) {
            this.column++;
        }
        this.index++;
        this.peek = this.index >= this.length ? $EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index);
        this.nextPeek =
            this.index + 1 >= this.length ? $EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index + 1);
    };
    _HtmlTokenizer.prototype._attemptCharCode = function (charCode) {
        if (this.peek === charCode) {
            this._advance();
            return true;
        }
        return false;
    };
    _HtmlTokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {
        if (compareCharCodeCaseInsensitive(this.peek, charCode)) {
            this._advance();
            return true;
        }
        return false;
    };
    _HtmlTokenizer.prototype._requireCharCode = function (charCode) {
        var location = this._getLocation();
        if (!this._attemptCharCode(charCode)) {
            throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan(location, location));
        }
    };
    _HtmlTokenizer.prototype._attemptStr = function (chars) {
        for (var i = 0; i < chars.length; i++) {
            if (!this._attemptCharCode(lang_1.StringWrapper.charCodeAt(chars, i))) {
                return false;
            }
        }
        return true;
    };
    _HtmlTokenizer.prototype._attemptStrCaseInsensitive = function (chars) {
        for (var i = 0; i < chars.length; i++) {
            if (!this._attemptCharCodeCaseInsensitive(lang_1.StringWrapper.charCodeAt(chars, i))) {
                return false;
            }
        }
        return true;
    };
    _HtmlTokenizer.prototype._requireStr = function (chars) {
        var location = this._getLocation();
        if (!this._attemptStr(chars)) {
            throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan(location));
        }
    };
    _HtmlTokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {
        while (!predicate(this.peek)) {
            this._advance();
        }
    };
    _HtmlTokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {
        var start = this._getLocation();
        this._attemptCharCodeUntilFn(predicate);
        if (this.index - start.offset < len) {
            throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan(start, start));
        }
    };
    _HtmlTokenizer.prototype._attemptUntilChar = function (char) {
        while (this.peek !== char) {
            this._advance();
        }
    };
    _HtmlTokenizer.prototype._readChar = function (decodeEntities) {
        if (decodeEntities && this.peek === $AMPERSAND) {
            return this._decodeEntity();
        }
        else {
            var index = this.index;
            this._advance();
            return this.input[index];
        }
    };
    _HtmlTokenizer.prototype._decodeEntity = function () {
        var start = this._getLocation();
        this._advance();
        if (this._attemptCharCode($HASH)) {
            var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
            var numberStart = this._getLocation().offset;
            this._attemptCharCodeUntilFn(isDigitEntityEnd);
            if (this.peek != $SEMICOLON) {
                throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan());
            }
            this._advance();
            var strNum = this.input.substring(numberStart, this.index - 1);
            try {
                var charCode = lang_1.NumberWrapper.parseInt(strNum, isHex ? 16 : 10);
                return lang_1.StringWrapper.fromCharCode(charCode);
            }
            catch (e) {
                var entity = this.input.substring(start.offset + 1, this.index - 1);
                throw this._createError(unknownEntityErrorMsg(entity), this._getSpan(start));
            }
        }
        else {
            var startPosition = this._savePosition();
            this._attemptCharCodeUntilFn(isNamedEntityEnd);
            if (this.peek != $SEMICOLON) {
                this._restorePosition(startPosition);
                return '&';
            }
            this._advance();
            var name_1 = this.input.substring(start.offset + 1, this.index - 1);
            var char = html_tags_1.NAMED_ENTITIES[name_1];
            if (lang_1.isBlank(char)) {
                throw this._createError(unknownEntityErrorMsg(name_1), this._getSpan(start));
            }
            return char;
        }
    };
    _HtmlTokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {
        var tagCloseStart;
        var textStart = this._getLocation();
        this._beginToken(decodeEntities ? HtmlTokenType.ESCAPABLE_RAW_TEXT : HtmlTokenType.RAW_TEXT, textStart);
        var parts = [];
        while (true) {
            tagCloseStart = this._getLocation();
            if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
                break;
            }
            if (this.index > tagCloseStart.offset) {
                parts.push(this.input.substring(tagCloseStart.offset, this.index));
            }
            while (this.peek !== firstCharOfEnd) {
                parts.push(this._readChar(decodeEntities));
            }
        }
        return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
    };
    _HtmlTokenizer.prototype._consumeComment = function (start) {
        var _this = this;
        this._beginToken(HtmlTokenType.COMMENT_START, start);
        this._requireCharCode($MINUS);
        this._endToken([]);
        var textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });
        this._beginToken(HtmlTokenType.COMMENT_END, textToken.sourceSpan.end);
        this._endToken([]);
    };
    _HtmlTokenizer.prototype._consumeCdata = function (start) {
        var _this = this;
        this._beginToken(HtmlTokenType.CDATA_START, start);
        this._requireStr('CDATA[');
        this._endToken([]);
        var textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });
        this._beginToken(HtmlTokenType.CDATA_END, textToken.sourceSpan.end);
        this._endToken([]);
    };
    _HtmlTokenizer.prototype._consumeDocType = function (start) {
        this._beginToken(HtmlTokenType.DOC_TYPE, start);
        this._attemptUntilChar($GT);
        this._advance();
        this._endToken([this.input.substring(start.offset + 2, this.index - 1)]);
    };
    _HtmlTokenizer.prototype._consumePrefixAndName = function () {
        var nameOrPrefixStart = this.index;
        var prefix = null;
        while (this.peek !== $COLON && !isPrefixEnd(this.peek)) {
            this._advance();
        }
        var nameStart;
        if (this.peek === $COLON) {
            this._advance();
            prefix = this.input.substring(nameOrPrefixStart, this.index - 1);
            nameStart = this.index;
        }
        else {
            nameStart = nameOrPrefixStart;
        }
        this._requireCharCodeUntilFn(isNameEnd, this.index === nameStart ? 1 : 0);
        var name = this.input.substring(nameStart, this.index);
        return [prefix, name];
    };
    _HtmlTokenizer.prototype._consumeTagOpen = function (start) {
        var savedPos = this._savePosition();
        var lowercaseTagName;
        try {
            if (!isAsciiLetter(this.peek)) {
                throw this._createError(unexpectedCharacterErrorMsg(this.peek), this._getSpan());
            }
            var nameStart = this.index;
            this._consumeTagOpenStart(start);
            lowercaseTagName = this.input.substring(nameStart, this.index).toLowerCase();
            this._attemptCharCodeUntilFn(isNotWhitespace);
            while (this.peek !== $SLASH && this.peek !== $GT) {
                this._consumeAttributeName();
                this._attemptCharCodeUntilFn(isNotWhitespace);
                if (this._attemptCharCode($EQ)) {
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                    this._consumeAttributeValue();
                }
                this._attemptCharCodeUntilFn(isNotWhitespace);
            }
            this._consumeTagOpenEnd();
        }
        catch (e) {
            if (e instanceof ControlFlowError) {
                // When the start tag is invalid, assume we want a "<"
                this._restorePosition(savedPos);
                // Back to back text tokens are merged at the end
                this._beginToken(HtmlTokenType.TEXT, start);
                this._endToken(['<']);
                return;
            }
            throw e;
        }
        var contentTokenType = html_tags_1.getHtmlTagDefinition(lowercaseTagName).contentType;
        if (contentTokenType === html_tags_1.HtmlTagContentType.RAW_TEXT) {
            this._consumeRawTextWithTagClose(lowercaseTagName, false);
        }
        else if (contentTokenType === html_tags_1.HtmlTagContentType.ESCAPABLE_RAW_TEXT) {
            this._consumeRawTextWithTagClose(lowercaseTagName, true);
        }
    };
    _HtmlTokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {
        var _this = this;
        var textToken = this._consumeRawText(decodeEntities, $LT, function () {
            if (!_this._attemptCharCode($SLASH))
                return false;
            _this._attemptCharCodeUntilFn(isNotWhitespace);
            if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
                return false;
            _this._attemptCharCodeUntilFn(isNotWhitespace);
            if (!_this._attemptCharCode($GT))
                return false;
            return true;
        });
        this._beginToken(HtmlTokenType.TAG_CLOSE, textToken.sourceSpan.end);
        this._endToken([null, lowercaseTagName]);
    };
    _HtmlTokenizer.prototype._consumeTagOpenStart = function (start) {
        this._beginToken(HtmlTokenType.TAG_OPEN_START, start);
        var parts = this._consumePrefixAndName();
        this._endToken(parts);
    };
    _HtmlTokenizer.prototype._consumeAttributeName = function () {
        this._beginToken(HtmlTokenType.ATTR_NAME);
        var prefixAndName = this._consumePrefixAndName();
        this._endToken(prefixAndName);
    };
    _HtmlTokenizer.prototype._consumeAttributeValue = function () {
        this._beginToken(HtmlTokenType.ATTR_VALUE);
        var value;
        if (this.peek === $SQ || this.peek === $DQ) {
            var quoteChar = this.peek;
            this._advance();
            var parts = [];
            while (this.peek !== quoteChar) {
                parts.push(this._readChar(true));
            }
            value = parts.join('');
            this._advance();
        }
        else {
            var valueStart = this.index;
            this._requireCharCodeUntilFn(isNameEnd, 1);
            value = this.input.substring(valueStart, this.index);
        }
        this._endToken([this._processCarriageReturns(value)]);
    };
    _HtmlTokenizer.prototype._consumeTagOpenEnd = function () {
        var tokenType = this._attemptCharCode($SLASH) ? HtmlTokenType.TAG_OPEN_END_VOID :
            HtmlTokenType.TAG_OPEN_END;
        this._beginToken(tokenType);
        this._requireCharCode($GT);
        this._endToken([]);
    };
    _HtmlTokenizer.prototype._consumeTagClose = function (start) {
        this._beginToken(HtmlTokenType.TAG_CLOSE, start);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        var prefixAndName;
        prefixAndName = this._consumePrefixAndName();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._requireCharCode($GT);
        this._endToken(prefixAndName);
    };
    _HtmlTokenizer.prototype._consumeExpansionFormStart = function () {
        this._beginToken(HtmlTokenType.EXPANSION_FORM_START, this._getLocation());
        this._requireCharCode($LBRACE);
        this._endToken([]);
        this._beginToken(HtmlTokenType.RAW_TEXT, this._getLocation());
        var condition = this._readUntil($COMMA);
        this._endToken([condition], this._getLocation());
        this._requireCharCode($COMMA);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._beginToken(HtmlTokenType.RAW_TEXT, this._getLocation());
        var type = this._readUntil($COMMA);
        this._endToken([type], this._getLocation());
        this._requireCharCode($COMMA);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this.expansionCaseStack.push(HtmlTokenType.EXPANSION_FORM_START);
    };
    _HtmlTokenizer.prototype._consumeExpansionCaseStart = function () {
        this._requireCharCode($EQ);
        this._beginToken(HtmlTokenType.EXPANSION_CASE_VALUE, this._getLocation());
        var value = this._readUntil($LBRACE).trim();
        this._endToken([value], this._getLocation());
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._beginToken(HtmlTokenType.EXPANSION_CASE_EXP_START, this._getLocation());
        this._requireCharCode($LBRACE);
        this._endToken([], this._getLocation());
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this.expansionCaseStack.push(HtmlTokenType.EXPANSION_CASE_EXP_START);
    };
    _HtmlTokenizer.prototype._consumeExpansionCaseEnd = function () {
        this._beginToken(HtmlTokenType.EXPANSION_CASE_EXP_END, this._getLocation());
        this._requireCharCode($RBRACE);
        this._endToken([], this._getLocation());
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this.expansionCaseStack.pop();
    };
    _HtmlTokenizer.prototype._consumeExpansionFormEnd = function () {
        this._beginToken(HtmlTokenType.EXPANSION_FORM_END, this._getLocation());
        this._requireCharCode($RBRACE);
        this._endToken([]);
        this.expansionCaseStack.pop();
    };
    _HtmlTokenizer.prototype._consumeText = function () {
        var start = this._getLocation();
        this._beginToken(HtmlTokenType.TEXT, start);
        var parts = [];
        var interpolation = false;
        if (this.peek === $LBRACE && this.nextPeek === $LBRACE) {
            parts.push(this._readChar(true));
            parts.push(this._readChar(true));
            interpolation = true;
        }
        else {
            parts.push(this._readChar(true));
        }
        while (!this.isTextEnd(interpolation)) {
            if (this.peek === $LBRACE && this.nextPeek === $LBRACE) {
                parts.push(this._readChar(true));
                parts.push(this._readChar(true));
                interpolation = true;
            }
            else if (this.peek === $RBRACE && this.nextPeek === $RBRACE && interpolation) {
                parts.push(this._readChar(true));
                parts.push(this._readChar(true));
                interpolation = false;
            }
            else {
                parts.push(this._readChar(true));
            }
        }
        this._endToken([this._processCarriageReturns(parts.join(''))]);
    };
    _HtmlTokenizer.prototype.isTextEnd = function (interpolation) {
        if (this.peek === $LT || this.peek === $EOF)
            return true;
        if (this.tokenizeExpansionForms) {
            if (isSpecialFormStart(this.peek, this.nextPeek))
                return true;
            if (this.peek === $RBRACE && !interpolation &&
                (this.isInExpansionCase() || this.isInExpansionForm()))
                return true;
        }
        return false;
    };
    _HtmlTokenizer.prototype._savePosition = function () {
        return [this.peek, this.index, this.column, this.line, this.tokens.length];
    };
    _HtmlTokenizer.prototype._readUntil = function (char) {
        var start = this.index;
        this._attemptUntilChar(char);
        return this.input.substring(start, this.index);
    };
    _HtmlTokenizer.prototype._restorePosition = function (position) {
        this.peek = position[0];
        this.index = position[1];
        this.column = position[2];
        this.line = position[3];
        var nbTokens = position[4];
        if (nbTokens < this.tokens.length) {
            // remove any extra tokens
            this.tokens = collection_1.ListWrapper.slice(this.tokens, 0, nbTokens);
        }
    };
    _HtmlTokenizer.prototype.isInExpansionCase = function () {
        return this.expansionCaseStack.length > 0 &&
            this.expansionCaseStack[this.expansionCaseStack.length - 1] ===
                HtmlTokenType.EXPANSION_CASE_EXP_START;
    };
    _HtmlTokenizer.prototype.isInExpansionForm = function () {
        return this.expansionCaseStack.length > 0 &&
            this.expansionCaseStack[this.expansionCaseStack.length - 1] ===
                HtmlTokenType.EXPANSION_FORM_START;
    };
    return _HtmlTokenizer;
}());
function isNotWhitespace(code) {
    return !isWhitespace(code) || code === $EOF;
}
function isWhitespace(code) {
    return (code >= $TAB && code <= $SPACE) || (code === $NBSP);
}
function isNameEnd(code) {
    return isWhitespace(code) || code === $GT || code === $SLASH || code === $SQ || code === $DQ ||
        code === $EQ;
}
function isPrefixEnd(code) {
    return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
}
function isDigitEntityEnd(code) {
    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
}
function isNamedEntityEnd(code) {
    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
}
function isSpecialFormStart(peek, nextPeek) {
    return peek === $LBRACE && nextPeek != $LBRACE;
}
function isAsciiLetter(code) {
    return code >= $a && code <= $z || code >= $A && code <= $Z;
}
function isAsciiHexDigit(code) {
    return code >= $a && code <= $f || code >= $A && code <= $F || code >= $0 && code <= $9;
}
function compareCharCodeCaseInsensitive(code1, code2) {
    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
}
function toUpperCaseCharCode(code) {
    return code >= $a && code <= $z ? code - $a + $A : code;
}
function mergeTextTokens(srcTokens) {
    var dstTokens = [];
    var lastDstToken;
    for (var i = 0; i < srcTokens.length; i++) {
        var token = srcTokens[i];
        if (lang_1.isPresent(lastDstToken) && lastDstToken.type == HtmlTokenType.TEXT &&
            token.type == HtmlTokenType.TEXT) {
            lastDstToken.parts[0] += token.parts[0];
            lastDstToken.sourceSpan.end = token.sourceSpan.end;
        }
        else {
            lastDstToken = token;
            dstTokens.push(lastDstToken);
        }
    }
    return dstTokens;
}

},{"../src/facade/collection":87,"../src/facade/lang":90,"./html_tags":95,"./parse_util":108}],94:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../src/facade/lang');
var collection_1 = require('../src/facade/collection');
var html_ast_1 = require('./html_ast');
var html_lexer_1 = require('./html_lexer');
var parse_util_1 = require('./parse_util');
var html_tags_1 = require('./html_tags');
var HtmlTreeError = (function (_super) {
    __extends(HtmlTreeError, _super);
    function HtmlTreeError(elementName, span, msg) {
        _super.call(this, span, msg);
        this.elementName = elementName;
    }
    HtmlTreeError.create = function (elementName, span, msg) {
        return new HtmlTreeError(elementName, span, msg);
    };
    return HtmlTreeError;
}(parse_util_1.ParseError));
exports.HtmlTreeError = HtmlTreeError;
var HtmlParseTreeResult = (function () {
    function HtmlParseTreeResult(rootNodes, errors) {
        this.rootNodes = rootNodes;
        this.errors = errors;
    }
    return HtmlParseTreeResult;
}());
exports.HtmlParseTreeResult = HtmlParseTreeResult;
var HtmlParser = (function () {
    function HtmlParser() {
    }
    HtmlParser.prototype.parse = function (sourceContent, sourceUrl, parseExpansionForms) {
        if (parseExpansionForms === void 0) { parseExpansionForms = false; }
        var tokensAndErrors = html_lexer_1.tokenizeHtml(sourceContent, sourceUrl, parseExpansionForms);
        var treeAndErrors = new TreeBuilder(tokensAndErrors.tokens).build();
        return new HtmlParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors
            .concat(treeAndErrors.errors));
    };
    HtmlParser.decorators = [
        { type: core_1.Injectable },
    ];
    return HtmlParser;
}());
exports.HtmlParser = HtmlParser;
var TreeBuilder = (function () {
    function TreeBuilder(tokens) {
        this.tokens = tokens;
        this.index = -1;
        this.rootNodes = [];
        this.errors = [];
        this.elementStack = [];
        this._advance();
    }
    TreeBuilder.prototype.build = function () {
        while (this.peek.type !== html_lexer_1.HtmlTokenType.EOF) {
            if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_OPEN_START) {
                this._consumeStartTag(this._advance());
            }
            else if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_CLOSE) {
                this._consumeEndTag(this._advance());
            }
            else if (this.peek.type === html_lexer_1.HtmlTokenType.CDATA_START) {
                this._closeVoidElement();
                this._consumeCdata(this._advance());
            }
            else if (this.peek.type === html_lexer_1.HtmlTokenType.COMMENT_START) {
                this._closeVoidElement();
                this._consumeComment(this._advance());
            }
            else if (this.peek.type === html_lexer_1.HtmlTokenType.TEXT ||
                this.peek.type === html_lexer_1.HtmlTokenType.RAW_TEXT ||
                this.peek.type === html_lexer_1.HtmlTokenType.ESCAPABLE_RAW_TEXT) {
                this._closeVoidElement();
                this._consumeText(this._advance());
            }
            else if (this.peek.type === html_lexer_1.HtmlTokenType.EXPANSION_FORM_START) {
                this._consumeExpansion(this._advance());
            }
            else {
                // Skip all other tokens...
                this._advance();
            }
        }
        return new HtmlParseTreeResult(this.rootNodes, this.errors);
    };
    TreeBuilder.prototype._advance = function () {
        var prev = this.peek;
        if (this.index < this.tokens.length - 1) {
            // Note: there is always an EOF token at the end
            this.index++;
        }
        this.peek = this.tokens[this.index];
        return prev;
    };
    TreeBuilder.prototype._advanceIf = function (type) {
        if (this.peek.type === type) {
            return this._advance();
        }
        return null;
    };
    TreeBuilder.prototype._consumeCdata = function (startToken) {
        this._consumeText(this._advance());
        this._advanceIf(html_lexer_1.HtmlTokenType.CDATA_END);
    };
    TreeBuilder.prototype._consumeComment = function (token) {
        var text = this._advanceIf(html_lexer_1.HtmlTokenType.RAW_TEXT);
        this._advanceIf(html_lexer_1.HtmlTokenType.COMMENT_END);
        var value = lang_1.isPresent(text) ? text.parts[0].trim() : null;
        this._addToParent(new html_ast_1.HtmlCommentAst(value, token.sourceSpan));
    };
    TreeBuilder.prototype._consumeExpansion = function (token) {
        var switchValue = this._advance();
        var type = this._advance();
        var cases = [];
        // read =
        while (this.peek.type === html_lexer_1.HtmlTokenType.EXPANSION_CASE_VALUE) {
            var expCase = this._parseExpansionCase();
            if (lang_1.isBlank(expCase))
                return; // error
            cases.push(expCase);
        }
        // read the final }
        if (this.peek.type !== html_lexer_1.HtmlTokenType.EXPANSION_FORM_END) {
            this.errors.push(HtmlTreeError.create(null, this.peek.sourceSpan, "Invalid expansion form. Missing '}'."));
            return;
        }
        this._advance();
        var mainSourceSpan = new parse_util_1.ParseSourceSpan(token.sourceSpan.start, this.peek.sourceSpan.end);
        this._addToParent(new html_ast_1.HtmlExpansionAst(switchValue.parts[0], type.parts[0], cases, mainSourceSpan, switchValue.sourceSpan));
    };
    TreeBuilder.prototype._parseExpansionCase = function () {
        var value = this._advance();
        // read {
        if (this.peek.type !== html_lexer_1.HtmlTokenType.EXPANSION_CASE_EXP_START) {
            this.errors.push(HtmlTreeError.create(null, this.peek.sourceSpan, "Invalid expansion form. Missing '{'.,"));
            return null;
        }
        // read until }
        var start = this._advance();
        var exp = this._collectExpansionExpTokens(start);
        if (lang_1.isBlank(exp))
            return null;
        var end = this._advance();
        exp.push(new html_lexer_1.HtmlToken(html_lexer_1.HtmlTokenType.EOF, [], end.sourceSpan));
        // parse everything in between { and }
        var parsedExp = new TreeBuilder(exp).build();
        if (parsedExp.errors.length > 0) {
            this.errors = this.errors.concat(parsedExp.errors);
            return null;
        }
        var sourceSpan = new parse_util_1.ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
        var expSourceSpan = new parse_util_1.ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
        return new html_ast_1.HtmlExpansionCaseAst(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    };
    TreeBuilder.prototype._collectExpansionExpTokens = function (start) {
        var exp = [];
        var expansionFormStack = [html_lexer_1.HtmlTokenType.EXPANSION_CASE_EXP_START];
        while (true) {
            if (this.peek.type === html_lexer_1.HtmlTokenType.EXPANSION_FORM_START ||
                this.peek.type === html_lexer_1.HtmlTokenType.EXPANSION_CASE_EXP_START) {
                expansionFormStack.push(this.peek.type);
            }
            if (this.peek.type === html_lexer_1.HtmlTokenType.EXPANSION_CASE_EXP_END) {
                if (lastOnStack(expansionFormStack, html_lexer_1.HtmlTokenType.EXPANSION_CASE_EXP_START)) {
                    expansionFormStack.pop();
                    if (expansionFormStack.length == 0)
                        return exp;
                }
                else {
                    this.errors.push(HtmlTreeError.create(null, start.sourceSpan, "Invalid expansion form. Missing '}'."));
                    return null;
                }
            }
            if (this.peek.type === html_lexer_1.HtmlTokenType.EXPANSION_FORM_END) {
                if (lastOnStack(expansionFormStack, html_lexer_1.HtmlTokenType.EXPANSION_FORM_START)) {
                    expansionFormStack.pop();
                }
                else {
                    this.errors.push(HtmlTreeError.create(null, start.sourceSpan, "Invalid expansion form. Missing '}'."));
                    return null;
                }
            }
            if (this.peek.type === html_lexer_1.HtmlTokenType.EOF) {
                this.errors.push(HtmlTreeError.create(null, start.sourceSpan, "Invalid expansion form. Missing '}'."));
                return null;
            }
            exp.push(this._advance());
        }
    };
    TreeBuilder.prototype._consumeText = function (token) {
        var text = token.parts[0];
        if (text.length > 0 && text[0] == '\n') {
            var parent_1 = this._getParentElement();
            if (lang_1.isPresent(parent_1) && parent_1.children.length == 0 &&
                html_tags_1.getHtmlTagDefinition(parent_1.name).ignoreFirstLf) {
                text = text.substring(1);
            }
        }
        if (text.length > 0) {
            this._addToParent(new html_ast_1.HtmlTextAst(text, token.sourceSpan));
        }
    };
    TreeBuilder.prototype._closeVoidElement = function () {
        if (this.elementStack.length > 0) {
            var el = collection_1.ListWrapper.last(this.elementStack);
            if (html_tags_1.getHtmlTagDefinition(el.name).isVoid) {
                this.elementStack.pop();
            }
        }
    };
    TreeBuilder.prototype._consumeStartTag = function (startTagToken) {
        var prefix = startTagToken.parts[0];
        var name = startTagToken.parts[1];
        var attrs = [];
        while (this.peek.type === html_lexer_1.HtmlTokenType.ATTR_NAME) {
            attrs.push(this._consumeAttr(this._advance()));
        }
        var fullName = getElementFullName(prefix, name, this._getParentElement());
        var selfClosing = false;
        // Note: There could have been a tokenizer error
        // so that we don't get a token for the end tag...
        if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_OPEN_END_VOID) {
            this._advance();
            selfClosing = true;
            if (html_tags_1.getNsPrefix(fullName) == null && !html_tags_1.getHtmlTagDefinition(fullName).isVoid) {
                this.errors.push(HtmlTreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
            }
        }
        else if (this.peek.type === html_lexer_1.HtmlTokenType.TAG_OPEN_END) {
            this._advance();
            selfClosing = false;
        }
        var end = this.peek.sourceSpan.start;
        var span = new parse_util_1.ParseSourceSpan(startTagToken.sourceSpan.start, end);
        var el = new html_ast_1.HtmlElementAst(fullName, attrs, [], span, span, null);
        this._pushElement(el);
        if (selfClosing) {
            this._popElement(fullName);
            el.endSourceSpan = span;
        }
    };
    TreeBuilder.prototype._pushElement = function (el) {
        if (this.elementStack.length > 0) {
            var parentEl = collection_1.ListWrapper.last(this.elementStack);
            if (html_tags_1.getHtmlTagDefinition(parentEl.name).isClosedByChild(el.name)) {
                this.elementStack.pop();
            }
        }
        var tagDef = html_tags_1.getHtmlTagDefinition(el.name);
        var parentEl = this._getParentElement();
        if (tagDef.requireExtraParent(lang_1.isPresent(parentEl) ? parentEl.name : null)) {
            var newParent = new html_ast_1.HtmlElementAst(tagDef.parentToAdd, [], [el], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
            this._addToParent(newParent);
            this.elementStack.push(newParent);
            this.elementStack.push(el);
        }
        else {
            this._addToParent(el);
            this.elementStack.push(el);
        }
    };
    TreeBuilder.prototype._consumeEndTag = function (endTagToken) {
        var fullName = getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
        this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
        if (html_tags_1.getHtmlTagDefinition(fullName).isVoid) {
            this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
        }
        else if (!this._popElement(fullName)) {
            this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan, "Unexpected closing tag \"" + endTagToken.parts[1] + "\""));
        }
    };
    TreeBuilder.prototype._popElement = function (fullName) {
        for (var stackIndex = this.elementStack.length - 1; stackIndex >= 0; stackIndex--) {
            var el = this.elementStack[stackIndex];
            if (el.name == fullName) {
                collection_1.ListWrapper.splice(this.elementStack, stackIndex, this.elementStack.length - stackIndex);
                return true;
            }
            if (!html_tags_1.getHtmlTagDefinition(el.name).closedByParent) {
                return false;
            }
        }
        return false;
    };
    TreeBuilder.prototype._consumeAttr = function (attrName) {
        var fullName = html_tags_1.mergeNsAndName(attrName.parts[0], attrName.parts[1]);
        var end = attrName.sourceSpan.end;
        var value = '';
        if (this.peek.type === html_lexer_1.HtmlTokenType.ATTR_VALUE) {
            var valueToken = this._advance();
            value = valueToken.parts[0];
            end = valueToken.sourceSpan.end;
        }
        return new html_ast_1.HtmlAttrAst(fullName, value, new parse_util_1.ParseSourceSpan(attrName.sourceSpan.start, end));
    };
    TreeBuilder.prototype._getParentElement = function () {
        return this.elementStack.length > 0 ? collection_1.ListWrapper.last(this.elementStack) : null;
    };
    TreeBuilder.prototype._addToParent = function (node) {
        var parent = this._getParentElement();
        if (lang_1.isPresent(parent)) {
            parent.children.push(node);
        }
        else {
            this.rootNodes.push(node);
        }
    };
    return TreeBuilder;
}());
function getElementFullName(prefix, localName, parentElement) {
    if (lang_1.isBlank(prefix)) {
        prefix = html_tags_1.getHtmlTagDefinition(localName).implicitNamespacePrefix;
        if (lang_1.isBlank(prefix) && lang_1.isPresent(parentElement)) {
            prefix = html_tags_1.getNsPrefix(parentElement.name);
        }
    }
    return html_tags_1.mergeNsAndName(prefix, localName);
}
function lastOnStack(stack, element) {
    return stack.length > 0 && stack[stack.length - 1] === element;
}

},{"../src/facade/collection":87,"../src/facade/lang":90,"./html_ast":92,"./html_lexer":93,"./html_tags":95,"./parse_util":108,"@angular/core":140}],95:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
// see http://www.w3.org/TR/html51/syntax.html#named-character-references
// see https://html.spec.whatwg.org/multipage/entities.json
// This list is not exhaustive to keep the compiler footprint low.
// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.
exports.NAMED_ENTITIES = {
    'Aacute': '\u00C1',
    'aacute': '\u00E1',
    'Acirc': '\u00C2',
    'acirc': '\u00E2',
    'acute': '\u00B4',
    'AElig': '\u00C6',
    'aelig': '\u00E6',
    'Agrave': '\u00C0',
    'agrave': '\u00E0',
    'alefsym': '\u2135',
    'Alpha': '\u0391',
    'alpha': '\u03B1',
    'amp': '&',
    'and': '\u2227',
    'ang': '\u2220',
    'apos': '\u0027',
    'Aring': '\u00C5',
    'aring': '\u00E5',
    'asymp': '\u2248',
    'Atilde': '\u00C3',
    'atilde': '\u00E3',
    'Auml': '\u00C4',
    'auml': '\u00E4',
    'bdquo': '\u201E',
    'Beta': '\u0392',
    'beta': '\u03B2',
    'brvbar': '\u00A6',
    'bull': '\u2022',
    'cap': '\u2229',
    'Ccedil': '\u00C7',
    'ccedil': '\u00E7',
    'cedil': '\u00B8',
    'cent': '\u00A2',
    'Chi': '\u03A7',
    'chi': '\u03C7',
    'circ': '\u02C6',
    'clubs': '\u2663',
    'cong': '\u2245',
    'copy': '\u00A9',
    'crarr': '\u21B5',
    'cup': '\u222A',
    'curren': '\u00A4',
    'dagger': '\u2020',
    'Dagger': '\u2021',
    'darr': '\u2193',
    'dArr': '\u21D3',
    'deg': '\u00B0',
    'Delta': '\u0394',
    'delta': '\u03B4',
    'diams': '\u2666',
    'divide': '\u00F7',
    'Eacute': '\u00C9',
    'eacute': '\u00E9',
    'Ecirc': '\u00CA',
    'ecirc': '\u00EA',
    'Egrave': '\u00C8',
    'egrave': '\u00E8',
    'empty': '\u2205',
    'emsp': '\u2003',
    'ensp': '\u2002',
    'Epsilon': '\u0395',
    'epsilon': '\u03B5',
    'equiv': '\u2261',
    'Eta': '\u0397',
    'eta': '\u03B7',
    'ETH': '\u00D0',
    'eth': '\u00F0',
    'Euml': '\u00CB',
    'euml': '\u00EB',
    'euro': '\u20AC',
    'exist': '\u2203',
    'fnof': '\u0192',
    'forall': '\u2200',
    'frac12': '\u00BD',
    'frac14': '\u00BC',
    'frac34': '\u00BE',
    'frasl': '\u2044',
    'Gamma': '\u0393',
    'gamma': '\u03B3',
    'ge': '\u2265',
    'gt': '>',
    'harr': '\u2194',
    'hArr': '\u21D4',
    'hearts': '\u2665',
    'hellip': '\u2026',
    'Iacute': '\u00CD',
    'iacute': '\u00ED',
    'Icirc': '\u00CE',
    'icirc': '\u00EE',
    'iexcl': '\u00A1',
    'Igrave': '\u00CC',
    'igrave': '\u00EC',
    'image': '\u2111',
    'infin': '\u221E',
    'int': '\u222B',
    'Iota': '\u0399',
    'iota': '\u03B9',
    'iquest': '\u00BF',
    'isin': '\u2208',
    'Iuml': '\u00CF',
    'iuml': '\u00EF',
    'Kappa': '\u039A',
    'kappa': '\u03BA',
    'Lambda': '\u039B',
    'lambda': '\u03BB',
    'lang': '\u27E8',
    'laquo': '\u00AB',
    'larr': '\u2190',
    'lArr': '\u21D0',
    'lceil': '\u2308',
    'ldquo': '\u201C',
    'le': '\u2264',
    'lfloor': '\u230A',
    'lowast': '\u2217',
    'loz': '\u25CA',
    'lrm': '\u200E',
    'lsaquo': '\u2039',
    'lsquo': '\u2018',
    'lt': '<',
    'macr': '\u00AF',
    'mdash': '\u2014',
    'micro': '\u00B5',
    'middot': '\u00B7',
    'minus': '\u2212',
    'Mu': '\u039C',
    'mu': '\u03BC',
    'nabla': '\u2207',
    'nbsp': '\u00A0',
    'ndash': '\u2013',
    'ne': '\u2260',
    'ni': '\u220B',
    'not': '\u00AC',
    'notin': '\u2209',
    'nsub': '\u2284',
    'Ntilde': '\u00D1',
    'ntilde': '\u00F1',
    'Nu': '\u039D',
    'nu': '\u03BD',
    'Oacute': '\u00D3',
    'oacute': '\u00F3',
    'Ocirc': '\u00D4',
    'ocirc': '\u00F4',
    'OElig': '\u0152',
    'oelig': '\u0153',
    'Ograve': '\u00D2',
    'ograve': '\u00F2',
    'oline': '\u203E',
    'Omega': '\u03A9',
    'omega': '\u03C9',
    'Omicron': '\u039F',
    'omicron': '\u03BF',
    'oplus': '\u2295',
    'or': '\u2228',
    'ordf': '\u00AA',
    'ordm': '\u00BA',
    'Oslash': '\u00D8',
    'oslash': '\u00F8',
    'Otilde': '\u00D5',
    'otilde': '\u00F5',
    'otimes': '\u2297',
    'Ouml': '\u00D6',
    'ouml': '\u00F6',
    'para': '\u00B6',
    'permil': '\u2030',
    'perp': '\u22A5',
    'Phi': '\u03A6',
    'phi': '\u03C6',
    'Pi': '\u03A0',
    'pi': '\u03C0',
    'piv': '\u03D6',
    'plusmn': '\u00B1',
    'pound': '\u00A3',
    'prime': '\u2032',
    'Prime': '\u2033',
    'prod': '\u220F',
    'prop': '\u221D',
    'Psi': '\u03A8',
    'psi': '\u03C8',
    'quot': '\u0022',
    'radic': '\u221A',
    'rang': '\u27E9',
    'raquo': '\u00BB',
    'rarr': '\u2192',
    'rArr': '\u21D2',
    'rceil': '\u2309',
    'rdquo': '\u201D',
    'real': '\u211C',
    'reg': '\u00AE',
    'rfloor': '\u230B',
    'Rho': '\u03A1',
    'rho': '\u03C1',
    'rlm': '\u200F',
    'rsaquo': '\u203A',
    'rsquo': '\u2019',
    'sbquo': '\u201A',
    'Scaron': '\u0160',
    'scaron': '\u0161',
    'sdot': '\u22C5',
    'sect': '\u00A7',
    'shy': '\u00AD',
    'Sigma': '\u03A3',
    'sigma': '\u03C3',
    'sigmaf': '\u03C2',
    'sim': '\u223C',
    'spades': '\u2660',
    'sub': '\u2282',
    'sube': '\u2286',
    'sum': '\u2211',
    'sup': '\u2283',
    'sup1': '\u00B9',
    'sup2': '\u00B2',
    'sup3': '\u00B3',
    'supe': '\u2287',
    'szlig': '\u00DF',
    'Tau': '\u03A4',
    'tau': '\u03C4',
    'there4': '\u2234',
    'Theta': '\u0398',
    'theta': '\u03B8',
    'thetasym': '\u03D1',
    'thinsp': '\u2009',
    'THORN': '\u00DE',
    'thorn': '\u00FE',
    'tilde': '\u02DC',
    'times': '\u00D7',
    'trade': '\u2122',
    'Uacute': '\u00DA',
    'uacute': '\u00FA',
    'uarr': '\u2191',
    'uArr': '\u21D1',
    'Ucirc': '\u00DB',
    'ucirc': '\u00FB',
    'Ugrave': '\u00D9',
    'ugrave': '\u00F9',
    'uml': '\u00A8',
    'upsih': '\u03D2',
    'Upsilon': '\u03A5',
    'upsilon': '\u03C5',
    'Uuml': '\u00DC',
    'uuml': '\u00FC',
    'weierp': '\u2118',
    'Xi': '\u039E',
    'xi': '\u03BE',
    'Yacute': '\u00DD',
    'yacute': '\u00FD',
    'yen': '\u00A5',
    'yuml': '\u00FF',
    'Yuml': '\u0178',
    'Zeta': '\u0396',
    'zeta': '\u03B6',
    'zwj': '\u200D',
    'zwnj': '\u200C',
};
(function (HtmlTagContentType) {
    HtmlTagContentType[HtmlTagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
    HtmlTagContentType[HtmlTagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
    HtmlTagContentType[HtmlTagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
})(exports.HtmlTagContentType || (exports.HtmlTagContentType = {}));
var HtmlTagContentType = exports.HtmlTagContentType;
var HtmlTagDefinition = (function () {
    function HtmlTagDefinition(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, contentType = _b.contentType, closedByParent = _b.closedByParent, isVoid = _b.isVoid, ignoreFirstLf = _b.ignoreFirstLf;
        this.closedByChildren = {};
        this.closedByParent = false;
        if (lang_1.isPresent(closedByChildren) && closedByChildren.length > 0) {
            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });
        }
        this.isVoid = lang_1.normalizeBool(isVoid);
        this.closedByParent = lang_1.normalizeBool(closedByParent) || this.isVoid;
        if (lang_1.isPresent(requiredParents) && requiredParents.length > 0) {
            this.requiredParents = {};
            this.parentToAdd = requiredParents[0];
            requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });
        }
        this.implicitNamespacePrefix = implicitNamespacePrefix;
        this.contentType = lang_1.isPresent(contentType) ? contentType : HtmlTagContentType.PARSABLE_DATA;
        this.ignoreFirstLf = lang_1.normalizeBool(ignoreFirstLf);
    }
    HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {
        if (lang_1.isBlank(this.requiredParents)) {
            return false;
        }
        if (lang_1.isBlank(currentParent)) {
            return true;
        }
        var lcParent = currentParent.toLowerCase();
        return this.requiredParents[lcParent] != true && lcParent != 'template';
    };
    HtmlTagDefinition.prototype.isClosedByChild = function (name) {
        return this.isVoid || lang_1.normalizeBool(this.closedByChildren[name.toLowerCase()]);
    };
    return HtmlTagDefinition;
}());
exports.HtmlTagDefinition = HtmlTagDefinition;
// see http://www.w3.org/TR/html51/syntax.html#optional-tags
// This implementation does not fully conform to the HTML5 spec.
var TAG_DEFINITIONS = {
    'base': new HtmlTagDefinition({ isVoid: true }),
    'meta': new HtmlTagDefinition({ isVoid: true }),
    'area': new HtmlTagDefinition({ isVoid: true }),
    'embed': new HtmlTagDefinition({ isVoid: true }),
    'link': new HtmlTagDefinition({ isVoid: true }),
    'img': new HtmlTagDefinition({ isVoid: true }),
    'input': new HtmlTagDefinition({ isVoid: true }),
    'param': new HtmlTagDefinition({ isVoid: true }),
    'hr': new HtmlTagDefinition({ isVoid: true }),
    'br': new HtmlTagDefinition({ isVoid: true }),
    'source': new HtmlTagDefinition({ isVoid: true }),
    'track': new HtmlTagDefinition({ isVoid: true }),
    'wbr': new HtmlTagDefinition({ isVoid: true }),
    'p': new HtmlTagDefinition({
        closedByChildren: [
            'address',
            'article',
            'aside',
            'blockquote',
            'div',
            'dl',
            'fieldset',
            'footer',
            'form',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'header',
            'hgroup',
            'hr',
            'main',
            'nav',
            'ol',
            'p',
            'pre',
            'section',
            'table',
            'ul'
        ],
        closedByParent: true
    }),
    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
    'tr': new HtmlTagDefinition({
        closedByChildren: ['tr'],
        requiredParents: ['tbody', 'tfoot', 'thead'],
        closedByParent: true
    }),
    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),
    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
    'style': new HtmlTagDefinition({ contentType: HtmlTagContentType.RAW_TEXT }),
    'script': new HtmlTagDefinition({ contentType: HtmlTagContentType.RAW_TEXT }),
    'title': new HtmlTagDefinition({ contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT }),
    'textarea': new HtmlTagDefinition({ contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
};
var DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
function getHtmlTagDefinition(tagName) {
    var result = TAG_DEFINITIONS[tagName.toLowerCase()];
    return lang_1.isPresent(result) ? result : DEFAULT_TAG_DEFINITION;
}
exports.getHtmlTagDefinition = getHtmlTagDefinition;
var NS_PREFIX_RE = /^@([^:]+):(.+)/g;
function splitNsName(elementName) {
    if (elementName[0] != '@') {
        return [null, elementName];
    }
    var match = lang_1.RegExpWrapper.firstMatch(NS_PREFIX_RE, elementName);
    return [match[1], match[2]];
}
exports.splitNsName = splitNsName;
function getNsPrefix(elementName) {
    return splitNsName(elementName)[0];
}
exports.getNsPrefix = getNsPrefix;
function mergeNsAndName(prefix, localName) {
    return lang_1.isPresent(prefix) ? "@" + prefix + ":" + localName : localName;
}
exports.mergeNsAndName = mergeNsAndName;

},{"../src/facade/lang":90}],96:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var core_private_2 = require('../core_private');
var compile_metadata_1 = require('./compile_metadata');
var util_1 = require('./util');
var APP_VIEW_MODULE_URL = util_1.assetUrl('core', 'linker/view');
var VIEW_UTILS_MODULE_URL = util_1.assetUrl('core', 'linker/view_utils');
var CD_MODULE_URL = util_1.assetUrl('core', 'change_detection/change_detection');
// Reassign the imports to different variables so we can
// define static variables with the name of the import.
// (only needed for Dart).
var impViewUtils = core_private_2.ViewUtils;
var impAppView = core_private_2.AppView;
var impDebugAppView = core_private_2.DebugAppView;
var impDebugContext = core_private_2.DebugContext;
var impAppElement = core_private_2.AppElement;
var impElementRef = core_1.ElementRef;
var impViewContainerRef = core_1.ViewContainerRef;
var impChangeDetectorRef = core_1.ChangeDetectorRef;
var impRenderComponentType = core_1.RenderComponentType;
var impQueryList = core_1.QueryList;
var impTemplateRef = core_1.TemplateRef;
var impTemplateRef_ = core_private_2.TemplateRef_;
var impValueUnwrapper = core_private_2.ValueUnwrapper;
var impInjector = core_1.Injector;
var impViewEncapsulation = core_1.ViewEncapsulation;
var impViewType = core_private_2.ViewType;
var impChangeDetectionStrategy = core_1.ChangeDetectionStrategy;
var impStaticNodeDebugInfo = core_private_2.StaticNodeDebugInfo;
var impRenderer = core_1.Renderer;
var impSimpleChange = core_1.SimpleChange;
var impUninitialized = core_private_2.uninitialized;
var impChangeDetectorState = core_private_2.ChangeDetectorState;
var impFlattenNestedViewRenderNodes = core_private_2.flattenNestedViewRenderNodes;
var impDevModeEqual = core_private_2.devModeEqual;
var impInterpolate = core_private_2.interpolate;
var impCheckBinding = core_private_2.checkBinding;
var impCastByValue = core_private_2.castByValue;
var impEMPTY_ARRAY = core_private_2.EMPTY_ARRAY;
var impEMPTY_MAP = core_private_2.EMPTY_MAP;
var Identifiers = (function () {
    function Identifiers() {
    }
    Identifiers.ViewUtils = new compile_metadata_1.CompileIdentifierMetadata({ name: 'ViewUtils', moduleUrl: util_1.assetUrl('core', 'linker/view_utils'), runtime: impViewUtils });
    Identifiers.AppView = new compile_metadata_1.CompileIdentifierMetadata({ name: 'AppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: impAppView });
    Identifiers.DebugAppView = new compile_metadata_1.CompileIdentifierMetadata({ name: 'DebugAppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: impDebugAppView });
    Identifiers.AppElement = new compile_metadata_1.CompileIdentifierMetadata({ name: 'AppElement', moduleUrl: util_1.assetUrl('core', 'linker/element'), runtime: impAppElement });
    Identifiers.ElementRef = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'ElementRef',
        moduleUrl: util_1.assetUrl('core', 'linker/element_ref'),
        runtime: impElementRef
    });
    Identifiers.ViewContainerRef = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'ViewContainerRef',
        moduleUrl: util_1.assetUrl('core', 'linker/view_container_ref'),
        runtime: impViewContainerRef
    });
    Identifiers.ChangeDetectorRef = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'ChangeDetectorRef',
        moduleUrl: util_1.assetUrl('core', 'change_detection/change_detector_ref'),
        runtime: impChangeDetectorRef
    });
    Identifiers.RenderComponentType = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'RenderComponentType',
        moduleUrl: util_1.assetUrl('core', 'render/api'),
        runtime: impRenderComponentType
    });
    Identifiers.QueryList = new compile_metadata_1.CompileIdentifierMetadata({ name: 'QueryList', moduleUrl: util_1.assetUrl('core', 'linker/query_list'), runtime: impQueryList });
    Identifiers.TemplateRef = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'TemplateRef',
        moduleUrl: util_1.assetUrl('core', 'linker/template_ref'),
        runtime: impTemplateRef
    });
    Identifiers.TemplateRef_ = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'TemplateRef_',
        moduleUrl: util_1.assetUrl('core', 'linker/template_ref'),
        runtime: impTemplateRef_
    });
    Identifiers.ValueUnwrapper = new compile_metadata_1.CompileIdentifierMetadata({ name: 'ValueUnwrapper', moduleUrl: CD_MODULE_URL, runtime: impValueUnwrapper });
    Identifiers.Injector = new compile_metadata_1.CompileIdentifierMetadata({ name: 'Injector', moduleUrl: util_1.assetUrl('core', 'di/injector'), runtime: impInjector });
    Identifiers.ViewEncapsulation = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'ViewEncapsulation',
        moduleUrl: util_1.assetUrl('core', 'metadata/view'),
        runtime: impViewEncapsulation
    });
    Identifiers.ViewType = new compile_metadata_1.CompileIdentifierMetadata({ name: 'ViewType', moduleUrl: util_1.assetUrl('core', 'linker/view_type'), runtime: impViewType });
    Identifiers.ChangeDetectionStrategy = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'ChangeDetectionStrategy',
        moduleUrl: CD_MODULE_URL,
        runtime: impChangeDetectionStrategy
    });
    Identifiers.StaticNodeDebugInfo = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'StaticNodeDebugInfo',
        moduleUrl: util_1.assetUrl('core', 'linker/debug_context'),
        runtime: impStaticNodeDebugInfo
    });
    Identifiers.DebugContext = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'DebugContext',
        moduleUrl: util_1.assetUrl('core', 'linker/debug_context'),
        runtime: impDebugContext
    });
    Identifiers.Renderer = new compile_metadata_1.CompileIdentifierMetadata({ name: 'Renderer', moduleUrl: util_1.assetUrl('core', 'render/api'), runtime: impRenderer });
    Identifiers.SimpleChange = new compile_metadata_1.CompileIdentifierMetadata({ name: 'SimpleChange', moduleUrl: CD_MODULE_URL, runtime: impSimpleChange });
    Identifiers.uninitialized = new compile_metadata_1.CompileIdentifierMetadata({ name: 'uninitialized', moduleUrl: CD_MODULE_URL, runtime: impUninitialized });
    Identifiers.ChangeDetectorState = new compile_metadata_1.CompileIdentifierMetadata({ name: 'ChangeDetectorState', moduleUrl: CD_MODULE_URL, runtime: impChangeDetectorState });
    Identifiers.checkBinding = new compile_metadata_1.CompileIdentifierMetadata({ name: 'checkBinding', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impCheckBinding });
    Identifiers.flattenNestedViewRenderNodes = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'flattenNestedViewRenderNodes',
        moduleUrl: VIEW_UTILS_MODULE_URL,
        runtime: impFlattenNestedViewRenderNodes
    });
    Identifiers.devModeEqual = new compile_metadata_1.CompileIdentifierMetadata({ name: 'devModeEqual', moduleUrl: CD_MODULE_URL, runtime: impDevModeEqual });
    Identifiers.interpolate = new compile_metadata_1.CompileIdentifierMetadata({ name: 'interpolate', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impInterpolate });
    Identifiers.castByValue = new compile_metadata_1.CompileIdentifierMetadata({ name: 'castByValue', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impCastByValue });
    Identifiers.EMPTY_ARRAY = new compile_metadata_1.CompileIdentifierMetadata({ name: 'EMPTY_ARRAY', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impEMPTY_ARRAY });
    Identifiers.EMPTY_MAP = new compile_metadata_1.CompileIdentifierMetadata({ name: 'EMPTY_MAP', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impEMPTY_MAP });
    Identifiers.pureProxies = [
        null,
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy1', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy1 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy2 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy3', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy3 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy4 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy5', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy5 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy6', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy6 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy7', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy7 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy8 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy9', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy9 }),
        new compile_metadata_1.CompileIdentifierMetadata({ name: 'pureProxy10', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: core_private_2.pureProxy10 }),
    ];
    Identifiers.SecurityContext = new compile_metadata_1.CompileIdentifierMetadata({
        name: 'SecurityContext',
        moduleUrl: util_1.assetUrl('core', 'security'),
        runtime: core_private_1.SecurityContext,
    });
    return Identifiers;
}());
exports.Identifiers = Identifiers;
function identifierToken(identifier) {
    return new compile_metadata_1.CompileTokenMetadata({ identifier: identifier });
}
exports.identifierToken = identifierToken;

},{"../core_private":72,"./compile_metadata":76,"./util":122,"@angular/core":140}],97:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var lang_1 = require('../src/facade/lang');
var collection_1 = require('../src/facade/collection');
var exceptions_1 = require('../src/facade/exceptions');
var cpl = require('./compile_metadata');
var directive_resolver_1 = require('./directive_resolver');
var pipe_resolver_1 = require('./pipe_resolver');
var view_resolver_1 = require('./view_resolver');
var directive_lifecycle_reflector_1 = require('./directive_lifecycle_reflector');
var util_1 = require('./util');
var assertions_1 = require('./assertions');
var url_resolver_1 = require('./url_resolver');
var core_private_2 = require("../core_private");
var CompileMetadataResolver = (function () {
    function CompileMetadataResolver(_directiveResolver, _pipeResolver, _viewResolver, _platformDirectives, _platformPipes, _reflector) {
        this._directiveResolver = _directiveResolver;
        this._pipeResolver = _pipeResolver;
        this._viewResolver = _viewResolver;
        this._platformDirectives = _platformDirectives;
        this._platformPipes = _platformPipes;
        this._directiveCache = new Map();
        this._pipeCache = new Map();
        this._anonymousTypes = new Map();
        this._anonymousTypeIndex = 0;
        if (lang_1.isPresent(_reflector)) {
            this._reflector = _reflector;
        }
        else {
            this._reflector = core_1.reflector;
        }
    }
    CompileMetadataResolver.prototype.sanitizeTokenName = function (token) {
        var identifier = lang_1.stringify(token);
        if (identifier.indexOf('(') >= 0) {
            // case: anonymous functions!
            var found = this._anonymousTypes.get(token);
            if (lang_1.isBlank(found)) {
                this._anonymousTypes.set(token, this._anonymousTypeIndex++);
                found = this._anonymousTypes.get(token);
            }
            identifier = "anonymous_token_" + found + "_";
        }
        return util_1.sanitizeIdentifier(identifier);
    };
    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {
        var meta = this._directiveCache.get(directiveType);
        if (lang_1.isBlank(meta)) {
            var dirMeta = this._directiveResolver.resolve(directiveType);
            var templateMeta = null;
            var changeDetectionStrategy = null;
            var viewProviders = [];
            var moduleUrl = staticTypeModuleUrl(directiveType);
            if (dirMeta instanceof core_1.ComponentMetadata) {
                assertions_1.assertArrayOfStrings('styles', dirMeta.styles);
                var cmpMeta = dirMeta;
                var viewMeta = this._viewResolver.resolve(directiveType);
                assertions_1.assertArrayOfStrings('styles', viewMeta.styles);
                templateMeta = new cpl.CompileTemplateMetadata({
                    encapsulation: viewMeta.encapsulation,
                    template: viewMeta.template,
                    templateUrl: viewMeta.templateUrl,
                    styles: viewMeta.styles,
                    styleUrls: viewMeta.styleUrls
                });
                changeDetectionStrategy = cmpMeta.changeDetection;
                if (lang_1.isPresent(dirMeta.viewProviders)) {
                    viewProviders = this.getProvidersMetadata(dirMeta.viewProviders);
                }
                moduleUrl = componentModuleUrl(this._reflector, directiveType, cmpMeta);
            }
            var providers = [];
            if (lang_1.isPresent(dirMeta.providers)) {
                providers = this.getProvidersMetadata(dirMeta.providers);
            }
            var queries = [];
            var viewQueries = [];
            if (lang_1.isPresent(dirMeta.queries)) {
                queries = this.getQueriesMetadata(dirMeta.queries, false);
                viewQueries = this.getQueriesMetadata(dirMeta.queries, true);
            }
            meta = cpl.CompileDirectiveMetadata.create({
                selector: dirMeta.selector,
                exportAs: dirMeta.exportAs,
                isComponent: lang_1.isPresent(templateMeta),
                type: this.getTypeMetadata(directiveType, moduleUrl),
                template: templateMeta,
                changeDetection: changeDetectionStrategy,
                inputs: dirMeta.inputs,
                outputs: dirMeta.outputs,
                host: dirMeta.host,
                lifecycleHooks: core_private_1.LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return directive_lifecycle_reflector_1.hasLifecycleHook(hook, directiveType); }),
                providers: providers,
                viewProviders: viewProviders,
                queries: queries,
                viewQueries: viewQueries
            });
            this._directiveCache.set(directiveType, meta);
        }
        return meta;
    };
    /**
     * @param someType a symbol which may or may not be a directive type
     * @returns {cpl.CompileDirectiveMetadata} if possible, otherwise null.
     */
    CompileMetadataResolver.prototype.maybeGetDirectiveMetadata = function (someType) {
        try {
            return this.getDirectiveMetadata(someType);
        }
        catch (e) {
            if (e.message.indexOf('No Directive annotation') !== -1) {
                return null;
            }
            throw e;
        }
    };
    CompileMetadataResolver.prototype.getTypeMetadata = function (type, moduleUrl) {
        return new cpl.CompileTypeMetadata({
            name: this.sanitizeTokenName(type),
            moduleUrl: moduleUrl,
            runtime: type,
            diDeps: this.getDependenciesMetadata(type, null)
        });
    };
    CompileMetadataResolver.prototype.getFactoryMetadata = function (factory, moduleUrl) {
        return new cpl.CompileFactoryMetadata({
            name: this.sanitizeTokenName(factory),
            moduleUrl: moduleUrl,
            runtime: factory,
            diDeps: this.getDependenciesMetadata(factory, null)
        });
    };
    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {
        var meta = this._pipeCache.get(pipeType);
        if (lang_1.isBlank(meta)) {
            var pipeMeta = this._pipeResolver.resolve(pipeType);
            meta = new cpl.CompilePipeMetadata({
                type: this.getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),
                name: pipeMeta.name,
                pure: pipeMeta.pure,
                lifecycleHooks: core_private_1.LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return directive_lifecycle_reflector_1.hasLifecycleHook(hook, pipeType); }),
            });
            this._pipeCache.set(pipeType, meta);
        }
        return meta;
    };
    CompileMetadataResolver.prototype.getViewDirectivesMetadata = function (component) {
        var _this = this;
        var view = this._viewResolver.resolve(component);
        var directives = flattenDirectives(view, this._platformDirectives);
        for (var i = 0; i < directives.length; i++) {
            if (!isValidType(directives[i])) {
                throw new exceptions_1.BaseException("Unexpected directive value '" + lang_1.stringify(directives[i]) + "' on the View of component '" + lang_1.stringify(component) + "'");
            }
        }
        return directives.map(function (type) { return _this.getDirectiveMetadata(type); });
    };
    CompileMetadataResolver.prototype.getViewPipesMetadata = function (component) {
        var _this = this;
        var view = this._viewResolver.resolve(component);
        var pipes = flattenPipes(view, this._platformPipes);
        for (var i = 0; i < pipes.length; i++) {
            if (!isValidType(pipes[i])) {
                throw new exceptions_1.BaseException("Unexpected piped value '" + lang_1.stringify(pipes[i]) + "' on the View of component '" + lang_1.stringify(component) + "'");
            }
        }
        return pipes.map(function (type) { return _this.getPipeMetadata(type); });
    };
    CompileMetadataResolver.prototype.getDependenciesMetadata = function (typeOrFunc, dependencies) {
        var _this = this;
        var params = lang_1.isPresent(dependencies) ? dependencies : this._reflector.parameters(typeOrFunc);
        if (lang_1.isBlank(params)) {
            params = [];
        }
        return params.map(function (param) {
            if (lang_1.isBlank(param)) {
                return null;
            }
            var isAttribute = false;
            var isHost = false;
            var isSelf = false;
            var isSkipSelf = false;
            var isOptional = false;
            var query = null;
            var viewQuery = null;
            var token = null;
            if (lang_1.isArray(param)) {
                param
                    .forEach(function (paramEntry) {
                    if (paramEntry instanceof core_1.HostMetadata) {
                        isHost = true;
                    }
                    else if (paramEntry instanceof core_1.SelfMetadata) {
                        isSelf = true;
                    }
                    else if (paramEntry instanceof core_1.SkipSelfMetadata) {
                        isSkipSelf = true;
                    }
                    else if (paramEntry instanceof core_1.OptionalMetadata) {
                        isOptional = true;
                    }
                    else if (paramEntry instanceof core_1.AttributeMetadata) {
                        isAttribute = true;
                        token = paramEntry.attributeName;
                    }
                    else if (paramEntry instanceof core_1.QueryMetadata) {
                        if (paramEntry.isViewQuery) {
                            viewQuery = paramEntry;
                        }
                        else {
                            query = paramEntry;
                        }
                    }
                    else if (paramEntry instanceof core_1.InjectMetadata) {
                        token = paramEntry.token;
                    }
                    else if (isValidType(paramEntry) && lang_1.isBlank(token)) {
                        token = paramEntry;
                    }
                });
            }
            else {
                token = param;
            }
            if (lang_1.isBlank(token)) {
                return null;
            }
            return new cpl.CompileDiDependencyMetadata({
                isAttribute: isAttribute,
                isHost: isHost,
                isSelf: isSelf,
                isSkipSelf: isSkipSelf,
                isOptional: isOptional,
                query: lang_1.isPresent(query) ? _this.getQueryMetadata(query, null) : null,
                viewQuery: lang_1.isPresent(viewQuery) ? _this.getQueryMetadata(viewQuery, null) : null,
                token: _this.getTokenMetadata(token)
            });
        });
    };
    CompileMetadataResolver.prototype.getTokenMetadata = function (token) {
        token = core_1.resolveForwardRef(token);
        var compileToken;
        if (lang_1.isString(token)) {
            compileToken = new cpl.CompileTokenMetadata({ value: token });
        }
        else {
            compileToken = new cpl.CompileTokenMetadata({
                identifier: new cpl.CompileIdentifierMetadata({
                    runtime: token,
                    name: this.sanitizeTokenName(token),
                    moduleUrl: staticTypeModuleUrl(token)
                })
            });
        }
        return compileToken;
    };
    CompileMetadataResolver.prototype.getProvidersMetadata = function (providers) {
        var _this = this;
        return providers.map(function (provider) {
            provider = core_1.resolveForwardRef(provider);
            if (lang_1.isArray(provider)) {
                return _this.getProvidersMetadata(provider);
            }
            else if (provider instanceof core_1.Provider) {
                return _this.getProviderMetadata(provider);
            }
            else if (core_private_2.isProviderLiteral(provider)) {
                return _this.getProviderMetadata(core_private_2.createProvider(provider));
            }
            else {
                return _this.getTypeMetadata(provider, staticTypeModuleUrl(provider));
            }
        });
    };
    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {
        var compileDeps;
        if (lang_1.isPresent(provider.useClass)) {
            compileDeps = this.getDependenciesMetadata(provider.useClass, provider.dependencies);
        }
        else if (lang_1.isPresent(provider.useFactory)) {
            compileDeps = this.getDependenciesMetadata(provider.useFactory, provider.dependencies);
        }
        return new cpl.CompileProviderMetadata({
            token: this.getTokenMetadata(provider.token),
            useClass: lang_1.isPresent(provider.useClass) ?
                this.getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass)) :
                null,
            useValue: convertToCompileValue(provider.useValue),
            useFactory: lang_1.isPresent(provider.useFactory) ?
                this.getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory)) :
                null,
            useExisting: lang_1.isPresent(provider.useExisting) ? this.getTokenMetadata(provider.useExisting) :
                null,
            deps: compileDeps,
            multi: provider.multi
        });
    };
    CompileMetadataResolver.prototype.getQueriesMetadata = function (queries, isViewQuery) {
        var _this = this;
        var compileQueries = [];
        collection_1.StringMapWrapper.forEach(queries, function (query, propertyName) {
            if (query.isViewQuery === isViewQuery) {
                compileQueries.push(_this.getQueryMetadata(query, propertyName));
            }
        });
        return compileQueries;
    };
    CompileMetadataResolver.prototype.getQueryMetadata = function (q, propertyName) {
        var _this = this;
        var selectors;
        if (q.isVarBindingQuery) {
            selectors = q.varBindings.map(function (varName) { return _this.getTokenMetadata(varName); });
        }
        else {
            selectors = [this.getTokenMetadata(q.selector)];
        }
        return new cpl.CompileQueryMetadata({
            selectors: selectors,
            first: q.first,
            descendants: q.descendants,
            propertyName: propertyName,
            read: lang_1.isPresent(q.read) ? this.getTokenMetadata(q.read) : null
        });
    };
    CompileMetadataResolver.decorators = [
        { type: core_1.Injectable },
    ];
    CompileMetadataResolver.ctorParameters = [
        { type: directive_resolver_1.DirectiveResolver, },
        { type: pipe_resolver_1.PipeResolver, },
        { type: view_resolver_1.ViewResolver, },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: [core_1.PLATFORM_DIRECTIVES,] },] },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: [core_1.PLATFORM_PIPES,] },] },
        { type: core_private_1.ReflectorReader, },
    ];
    return CompileMetadataResolver;
}());
exports.CompileMetadataResolver = CompileMetadataResolver;
function flattenDirectives(view, platformDirectives) {
    var directives = [];
    if (lang_1.isPresent(platformDirectives)) {
        flattenArray(platformDirectives, directives);
    }
    if (lang_1.isPresent(view.directives)) {
        flattenArray(view.directives, directives);
    }
    return directives;
}
function flattenPipes(view, platformPipes) {
    var pipes = [];
    if (lang_1.isPresent(platformPipes)) {
        flattenArray(platformPipes, pipes);
    }
    if (lang_1.isPresent(view.pipes)) {
        flattenArray(view.pipes, pipes);
    }
    return pipes;
}
function flattenArray(tree, out) {
    for (var i = 0; i < tree.length; i++) {
        var item = core_1.resolveForwardRef(tree[i]);
        if (lang_1.isArray(item)) {
            flattenArray(item, out);
        }
        else {
            out.push(item);
        }
    }
}
function isStaticType(value) {
    return lang_1.isStringMap(value) && lang_1.isPresent(value['name']) && lang_1.isPresent(value['filePath']);
}
function isValidType(value) {
    return isStaticType(value) || (value instanceof lang_1.Type);
}
function staticTypeModuleUrl(value) {
    return isStaticType(value) ? value['filePath'] : null;
}
function componentModuleUrl(reflector, type, cmpMetadata) {
    if (isStaticType(type)) {
        return staticTypeModuleUrl(type);
    }
    if (lang_1.isPresent(cmpMetadata.moduleId)) {
        var moduleId = cmpMetadata.moduleId;
        var scheme = url_resolver_1.getUrlScheme(moduleId);
        return lang_1.isPresent(scheme) && scheme.length > 0 ? moduleId :
            "package:" + moduleId + util_1.MODULE_SUFFIX;
    }
    return reflector.importUri(type);
}
// Only fill CompileIdentifierMetadata.runtime if needed...
function convertToCompileValue(value) {
    return util_1.visitValue(value, new _CompileValueConverter(), null);
}
var _CompileValueConverter = (function (_super) {
    __extends(_CompileValueConverter, _super);
    function _CompileValueConverter() {
        _super.apply(this, arguments);
    }
    _CompileValueConverter.prototype.visitOther = function (value, context) {
        if (isStaticType(value)) {
            return new cpl.CompileIdentifierMetadata({ name: value['name'], moduleUrl: staticTypeModuleUrl(value) });
        }
        else {
            return new cpl.CompileIdentifierMetadata({ runtime: value });
        }
    };
    return _CompileValueConverter;
}(util_1.ValueTransformer));

},{"../core_private":72,"../src/facade/collection":87,"../src/facade/exceptions":89,"../src/facade/lang":90,"./assertions":75,"./compile_metadata":76,"./directive_lifecycle_reflector":79,"./directive_resolver":81,"./pipe_resolver":109,"./url_resolver":121,"./util":122,"./view_resolver":138,"@angular/core":140}],98:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var compile_metadata_1 = require('./compile_metadata');
var exceptions_1 = require('../src/facade/exceptions');
var collection_1 = require('../src/facade/collection');
var o = require('./output/output_ast');
var util_1 = require('./util');
var _COMPONENT_FACTORY_IDENTIFIER = new compile_metadata_1.CompileIdentifierMetadata({
    name: 'ComponentFactory',
    runtime: core_1.ComponentFactory,
    moduleUrl: util_1.assetUrl('core', 'linker/component_factory')
});
var SourceModule = (function () {
    function SourceModule(moduleUrl, source) {
        this.moduleUrl = moduleUrl;
        this.source = source;
    }
    return SourceModule;
}());
exports.SourceModule = SourceModule;
var StyleSheetSourceWithImports = (function () {
    function StyleSheetSourceWithImports(source, importedUrls) {
        this.source = source;
        this.importedUrls = importedUrls;
    }
    return StyleSheetSourceWithImports;
}());
exports.StyleSheetSourceWithImports = StyleSheetSourceWithImports;
var NormalizedComponentWithViewDirectives = (function () {
    function NormalizedComponentWithViewDirectives(component, directives, pipes) {
        this.component = component;
        this.directives = directives;
        this.pipes = pipes;
    }
    return NormalizedComponentWithViewDirectives;
}());
exports.NormalizedComponentWithViewDirectives = NormalizedComponentWithViewDirectives;
var OfflineCompiler = (function () {
    function OfflineCompiler(_directiveNormalizer, _templateParser, _styleCompiler, _viewCompiler, _outputEmitter, _xhr) {
        this._directiveNormalizer = _directiveNormalizer;
        this._templateParser = _templateParser;
        this._styleCompiler = _styleCompiler;
        this._viewCompiler = _viewCompiler;
        this._outputEmitter = _outputEmitter;
        this._xhr = _xhr;
    }
    OfflineCompiler.prototype.normalizeDirectiveMetadata = function (directive) {
        return this._directiveNormalizer.normalizeDirective(directive);
    };
    OfflineCompiler.prototype.compileTemplates = function (components) {
        var _this = this;
        if (components.length === 0) {
            throw new exceptions_1.BaseException('No components given');
        }
        var statements = [];
        var exportedVars = [];
        var moduleUrl = _templateModuleUrl(components[0].component);
        components.forEach(function (componentWithDirs) {
            var compMeta = componentWithDirs.component;
            _assertComponent(compMeta);
            var compViewFactoryVar = _this._compileComponent(compMeta, componentWithDirs.directives, componentWithDirs.pipes, statements);
            exportedVars.push(compViewFactoryVar);
            var hostMeta = compile_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);
            var hostViewFactoryVar = _this._compileComponent(hostMeta, [compMeta], [], statements);
            var compFactoryVar = compMeta.type.name + "NgFactory";
            statements.push(o.variable(compFactoryVar)
                .set(o.importExpr(_COMPONENT_FACTORY_IDENTIFIER, [o.importType(compMeta.type)])
                .instantiate([
                o.literal(compMeta.selector),
                o.variable(hostViewFactoryVar),
                o.importExpr(compMeta.type)
            ], o.importType(_COMPONENT_FACTORY_IDENTIFIER, [o.importType(compMeta.type)], [o.TypeModifier.Const])))
                .toDeclStmt(null, [o.StmtModifier.Final]));
            exportedVars.push(compFactoryVar);
        });
        return this._codegenSourceModule(moduleUrl, statements, exportedVars);
    };
    OfflineCompiler.prototype.loadAndCompileStylesheet = function (stylesheetUrl, shim, suffix) {
        var _this = this;
        return this._xhr.get(stylesheetUrl)
            .then(function (cssText) {
            var compileResult = _this._styleCompiler.compileStylesheet(stylesheetUrl, cssText, shim);
            var importedUrls = [];
            compileResult.dependencies.forEach(function (dep) {
                importedUrls.push(dep.moduleUrl);
                dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, suffix);
            });
            return new StyleSheetSourceWithImports(_this._codgenStyles(stylesheetUrl, shim, suffix, compileResult), importedUrls);
        });
    };
    OfflineCompiler.prototype._compileComponent = function (compMeta, directives, pipes, targetStatements) {
        var styleResult = this._styleCompiler.compileComponent(compMeta);
        var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, compMeta.type.name);
        var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, o.variable(styleResult.stylesVar), pipes);
        collection_1.ListWrapper.addAll(targetStatements, _resolveStyleStatements(compMeta.type.moduleUrl, styleResult));
        collection_1.ListWrapper.addAll(targetStatements, _resolveViewStatements(viewResult));
        return viewResult.viewFactoryVar;
    };
    OfflineCompiler.prototype._codgenStyles = function (inputUrl, shim, suffix, stylesCompileResult) {
        return this._codegenSourceModule(_stylesModuleUrl(inputUrl, shim, suffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
    };
    OfflineCompiler.prototype._codegenSourceModule = function (moduleUrl, statements, exportedVars) {
        return new SourceModule(moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));
    };
    return OfflineCompiler;
}());
exports.OfflineCompiler = OfflineCompiler;
function _resolveViewStatements(compileResult) {
    compileResult.dependencies.forEach(function (dep) { dep.factoryPlaceholder.moduleUrl = _templateModuleUrl(dep.comp); });
    return compileResult.statements;
}
function _resolveStyleStatements(containingModuleUrl, compileResult) {
    var containingSuffix = _splitSuffix(containingModuleUrl)[1];
    compileResult.dependencies.forEach(function (dep) {
        dep.valuePlaceholder.moduleUrl =
            _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, containingSuffix);
    });
    return compileResult.statements;
}
function _templateModuleUrl(comp) {
    var urlWithSuffix = _splitSuffix(comp.type.moduleUrl);
    return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
}
function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
    return shim ? stylesheetUrl + ".shim" + suffix : "" + stylesheetUrl + suffix;
}
function _assertComponent(meta) {
    if (!meta.isComponent) {
        throw new exceptions_1.BaseException("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
}
function _splitSuffix(path) {
    var lastDot = path.lastIndexOf('.');
    if (lastDot !== -1) {
        return [path.substring(0, lastDot), path.substring(lastDot)];
    }
    else {
        return [path, ''];
    }
}

},{"../src/facade/collection":87,"../src/facade/exceptions":89,"./compile_metadata":76,"./output/output_ast":103,"./util":122,"@angular/core":140}],99:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var o = require('./output_ast');
var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
exports.CATCH_ERROR_VAR = o.variable('error');
exports.CATCH_STACK_VAR = o.variable('stack');
var OutputEmitter = (function () {
    function OutputEmitter() {
    }
    return OutputEmitter;
}());
exports.OutputEmitter = OutputEmitter;
var _EmittedLine = (function () {
    function _EmittedLine(indent) {
        this.indent = indent;
        this.parts = [];
    }
    return _EmittedLine;
}());
var EmitterVisitorContext = (function () {
    function EmitterVisitorContext(_exportedVars, _indent) {
        this._exportedVars = _exportedVars;
        this._indent = _indent;
        this._classes = [];
        this._lines = [new _EmittedLine(_indent)];
    }
    EmitterVisitorContext.createRoot = function (exportedVars) {
        return new EmitterVisitorContext(exportedVars, 0);
    };
    Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
        get: function () { return this._lines[this._lines.length - 1]; },
        enumerable: true,
        configurable: true
    });
    EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };
    EmitterVisitorContext.prototype.println = function (lastPart) {
        if (lastPart === void 0) { lastPart = ''; }
        this.print(lastPart, true);
    };
    EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };
    EmitterVisitorContext.prototype.print = function (part, newLine) {
        if (newLine === void 0) { newLine = false; }
        if (part.length > 0) {
            this._currentLine.parts.push(part);
        }
        if (newLine) {
            this._lines.push(new _EmittedLine(this._indent));
        }
    };
    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {
        if (this.lineIsEmpty()) {
            this._lines.pop();
        }
    };
    EmitterVisitorContext.prototype.incIndent = function () {
        this._indent++;
        this._currentLine.indent = this._indent;
    };
    EmitterVisitorContext.prototype.decIndent = function () {
        this._indent--;
        this._currentLine.indent = this._indent;
    };
    EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };
    EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };
    Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
        get: function () {
            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
        },
        enumerable: true,
        configurable: true
    });
    EmitterVisitorContext.prototype.toSource = function () {
        var lines = this._lines;
        if (lines[lines.length - 1].parts.length === 0) {
            lines = lines.slice(0, lines.length - 1);
        }
        return lines.map(function (line) {
            if (line.parts.length > 0) {
                return _createIndent(line.indent) + line.parts.join('');
            }
            else {
                return '';
            }
        })
            .join('\n');
    };
    return EmitterVisitorContext;
}());
exports.EmitterVisitorContext = EmitterVisitorContext;
var AbstractEmitterVisitor = (function () {
    function AbstractEmitterVisitor(_escapeDollarInStrings) {
        this._escapeDollarInStrings = _escapeDollarInStrings;
    }
    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {
        stmt.expr.visitExpression(this, ctx);
        ctx.println(';');
        return null;
    };
    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {
        ctx.print("return ");
        stmt.value.visitExpression(this, ctx);
        ctx.println(';');
        return null;
    };
    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {
        ctx.print("if (");
        stmt.condition.visitExpression(this, ctx);
        ctx.print(") {");
        var hasElseCase = lang_1.isPresent(stmt.falseCase) && stmt.falseCase.length > 0;
        if (stmt.trueCase.length <= 1 && !hasElseCase) {
            ctx.print(" ");
            this.visitAllStatements(stmt.trueCase, ctx);
            ctx.removeEmptyLastLine();
            ctx.print(" ");
        }
        else {
            ctx.println();
            ctx.incIndent();
            this.visitAllStatements(stmt.trueCase, ctx);
            ctx.decIndent();
            if (hasElseCase) {
                ctx.println("} else {");
                ctx.incIndent();
                this.visitAllStatements(stmt.falseCase, ctx);
                ctx.decIndent();
            }
        }
        ctx.println("}");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {
        ctx.print("throw ");
        stmt.error.visitExpression(this, ctx);
        ctx.println(";");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {
        var lines = stmt.comment.split('\n');
        lines.forEach(function (line) { ctx.println("// " + line); });
        return null;
    };
    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {
        var lineWasEmpty = ctx.lineIsEmpty();
        if (!lineWasEmpty) {
            ctx.print('(');
        }
        ctx.print(expr.name + " = ");
        expr.value.visitExpression(this, ctx);
        if (!lineWasEmpty) {
            ctx.print(')');
        }
        return null;
    };
    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {
        var lineWasEmpty = ctx.lineIsEmpty();
        if (!lineWasEmpty) {
            ctx.print('(');
        }
        expr.receiver.visitExpression(this, ctx);
        ctx.print("[");
        expr.index.visitExpression(this, ctx);
        ctx.print("] = ");
        expr.value.visitExpression(this, ctx);
        if (!lineWasEmpty) {
            ctx.print(')');
        }
        return null;
    };
    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {
        var lineWasEmpty = ctx.lineIsEmpty();
        if (!lineWasEmpty) {
            ctx.print('(');
        }
        expr.receiver.visitExpression(this, ctx);
        ctx.print("." + expr.name + " = ");
        expr.value.visitExpression(this, ctx);
        if (!lineWasEmpty) {
            ctx.print(')');
        }
        return null;
    };
    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {
        expr.receiver.visitExpression(this, ctx);
        var name = expr.name;
        if (lang_1.isPresent(expr.builtin)) {
            name = this.getBuiltinMethodName(expr.builtin);
            if (lang_1.isBlank(name)) {
                // some builtins just mean to skip the call.
                // e.g. `bind` in Dart.
                return null;
            }
        }
        ctx.print("." + name + "(");
        this.visitAllExpressions(expr.args, ctx, ",");
        ctx.print(")");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
        expr.fn.visitExpression(this, ctx);
        ctx.print("(");
        this.visitAllExpressions(expr.args, ctx, ',');
        ctx.print(")");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
        var varName = ast.name;
        if (lang_1.isPresent(ast.builtin)) {
            switch (ast.builtin) {
                case o.BuiltinVar.Super:
                    varName = 'super';
                    break;
                case o.BuiltinVar.This:
                    varName = 'this';
                    break;
                case o.BuiltinVar.CatchError:
                    varName = exports.CATCH_ERROR_VAR.name;
                    break;
                case o.BuiltinVar.CatchStack:
                    varName = exports.CATCH_STACK_VAR.name;
                    break;
                default:
                    throw new exceptions_1.BaseException("Unknown builtin variable " + ast.builtin);
            }
        }
        ctx.print(varName);
        return null;
    };
    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {
        ctx.print("new ");
        ast.classExpr.visitExpression(this, ctx);
        ctx.print("(");
        this.visitAllExpressions(ast.args, ctx, ',');
        ctx.print(")");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {
        var value = ast.value;
        if (lang_1.isString(value)) {
            ctx.print(escapeSingleQuoteString(value, this._escapeDollarInStrings));
        }
        else if (lang_1.isBlank(value)) {
            ctx.print('null');
        }
        else {
            ctx.print("" + value);
        }
        return null;
    };
    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {
        ctx.print("(");
        ast.condition.visitExpression(this, ctx);
        ctx.print('? ');
        ast.trueCase.visitExpression(this, ctx);
        ctx.print(': ');
        ast.falseCase.visitExpression(this, ctx);
        ctx.print(")");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {
        ctx.print('!');
        ast.condition.visitExpression(this, ctx);
        return null;
    };
    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
        var opStr;
        switch (ast.operator) {
            case o.BinaryOperator.Equals:
                opStr = '==';
                break;
            case o.BinaryOperator.Identical:
                opStr = '===';
                break;
            case o.BinaryOperator.NotEquals:
                opStr = '!=';
                break;
            case o.BinaryOperator.NotIdentical:
                opStr = '!==';
                break;
            case o.BinaryOperator.And:
                opStr = '&&';
                break;
            case o.BinaryOperator.Or:
                opStr = '||';
                break;
            case o.BinaryOperator.Plus:
                opStr = '+';
                break;
            case o.BinaryOperator.Minus:
                opStr = '-';
                break;
            case o.BinaryOperator.Divide:
                opStr = '/';
                break;
            case o.BinaryOperator.Multiply:
                opStr = '*';
                break;
            case o.BinaryOperator.Modulo:
                opStr = '%';
                break;
            case o.BinaryOperator.Lower:
                opStr = '<';
                break;
            case o.BinaryOperator.LowerEquals:
                opStr = '<=';
                break;
            case o.BinaryOperator.Bigger:
                opStr = '>';
                break;
            case o.BinaryOperator.BiggerEquals:
                opStr = '>=';
                break;
            default:
                throw new exceptions_1.BaseException("Unknown operator " + ast.operator);
        }
        ctx.print("(");
        ast.lhs.visitExpression(this, ctx);
        ctx.print(" " + opStr + " ");
        ast.rhs.visitExpression(this, ctx);
        ctx.print(")");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {
        ast.receiver.visitExpression(this, ctx);
        ctx.print(".");
        ctx.print(ast.name);
        return null;
    };
    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {
        ast.receiver.visitExpression(this, ctx);
        ctx.print("[");
        ast.index.visitExpression(this, ctx);
        ctx.print("]");
        return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
        var useNewLine = ast.entries.length > 1;
        ctx.print("[", useNewLine);
        ctx.incIndent();
        this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
        ctx.decIndent();
        ctx.print("]", useNewLine);
        return null;
    };
    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {
        var _this = this;
        var useNewLine = ast.entries.length > 1;
        ctx.print("{", useNewLine);
        ctx.incIndent();
        this.visitAllObjects(function (entry) {
            ctx.print(escapeSingleQuoteString(entry[0], _this._escapeDollarInStrings) + ": ");
            entry[1].visitExpression(_this, ctx);
        }, ast.entries, ctx, ',', useNewLine);
        ctx.decIndent();
        ctx.print("}", useNewLine);
        return null;
    };
    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {
        var _this = this;
        if (newLine === void 0) { newLine = false; }
        this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);
    };
    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {
        if (newLine === void 0) { newLine = false; }
        for (var i = 0; i < expressions.length; i++) {
            if (i > 0) {
                ctx.print(separator, newLine);
            }
            handler(expressions[i]);
        }
        if (newLine) {
            ctx.println();
        }
    };
    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {
        var _this = this;
        statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });
    };
    return AbstractEmitterVisitor;
}());
exports.AbstractEmitterVisitor = AbstractEmitterVisitor;
function escapeSingleQuoteString(input, escapeDollar) {
    if (lang_1.isBlank(input)) {
        return null;
    }
    var body = lang_1.StringWrapper.replaceAllMapped(input, _SINGLE_QUOTE_ESCAPE_STRING_RE, function (match) {
        if (match[0] == '$') {
            return escapeDollar ? '\\$' : '$';
        }
        else if (match[0] == '\n') {
            return '\\n';
        }
        else if (match[0] == '\r') {
            return '\\r';
        }
        else {
            return "\\" + match[0];
        }
    });
    return "'" + body + "'";
}
exports.escapeSingleQuoteString = escapeSingleQuoteString;
function _createIndent(count) {
    var res = '';
    for (var i = 0; i < count; i++) {
        res += '  ';
    }
    return res;
}

},{"../../src/facade/exceptions":89,"../../src/facade/lang":90,"./output_ast":103}],100:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var o = require('./output_ast');
var abstract_emitter_1 = require('./abstract_emitter');
var AbstractJsEmitterVisitor = (function (_super) {
    __extends(AbstractJsEmitterVisitor, _super);
    function AbstractJsEmitterVisitor() {
        _super.call(this, false);
    }
    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
        var _this = this;
        ctx.pushClass(stmt);
        this._visitClassConstructor(stmt, ctx);
        if (lang_1.isPresent(stmt.parent)) {
            ctx.print(stmt.name + ".prototype = Object.create(");
            stmt.parent.visitExpression(this, ctx);
            ctx.println(".prototype);");
        }
        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });
        stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });
        ctx.popClass();
        return null;
    };
    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
        ctx.print("function " + stmt.name + "(");
        if (lang_1.isPresent(stmt.constructorMethod)) {
            this._visitParams(stmt.constructorMethod.params, ctx);
        }
        ctx.println(") {");
        ctx.incIndent();
        if (lang_1.isPresent(stmt.constructorMethod)) {
            if (stmt.constructorMethod.body.length > 0) {
                ctx.println("var self = this;");
                this.visitAllStatements(stmt.constructorMethod.body, ctx);
            }
        }
        ctx.decIndent();
        ctx.println("}");
    };
    AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {
        ctx.println("Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
        ctx.incIndent();
        if (getter.body.length > 0) {
            ctx.println("var self = this;");
            this.visitAllStatements(getter.body, ctx);
        }
        ctx.decIndent();
        ctx.println("}});");
    };
    AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {
        ctx.print(stmt.name + ".prototype." + method.name + " = function(");
        this._visitParams(method.params, ctx);
        ctx.println(") {");
        ctx.incIndent();
        if (method.body.length > 0) {
            ctx.println("var self = this;");
            this.visitAllStatements(method.body, ctx);
        }
        ctx.decIndent();
        ctx.println("};");
    };
    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
        if (ast.builtin === o.BuiltinVar.This) {
            ctx.print('self');
        }
        else if (ast.builtin === o.BuiltinVar.Super) {
            throw new exceptions_1.BaseException("'super' needs to be handled at a parent ast node, not at the variable level!");
        }
        else {
            _super.prototype.visitReadVarExpr.call(this, ast, ctx);
        }
        return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
        ctx.print("var " + stmt.name + " = ");
        stmt.value.visitExpression(this, ctx);
        ctx.println(";");
        return null;
    };
    AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
        ast.value.visitExpression(this, ctx);
        return null;
    };
    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
        var fnExpr = expr.fn;
        if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {
            ctx.currentClass.parent.visitExpression(this, ctx);
            ctx.print(".call(this");
            if (expr.args.length > 0) {
                ctx.print(", ");
                this.visitAllExpressions(expr.args, ctx, ',');
            }
            ctx.print(")");
        }
        else {
            _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
        }
        return null;
    };
    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
        ctx.print("function(");
        this._visitParams(ast.params, ctx);
        ctx.println(") {");
        ctx.incIndent();
        this.visitAllStatements(ast.statements, ctx);
        ctx.decIndent();
        ctx.print("}");
        return null;
    };
    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
        ctx.print("function " + stmt.name + "(");
        this._visitParams(stmt.params, ctx);
        ctx.println(") {");
        ctx.incIndent();
        this.visitAllStatements(stmt.statements, ctx);
        ctx.decIndent();
        ctx.println("}");
        return null;
    };
    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
        ctx.println("try {");
        ctx.incIndent();
        this.visitAllStatements(stmt.bodyStmts, ctx);
        ctx.decIndent();
        ctx.println("} catch (" + abstract_emitter_1.CATCH_ERROR_VAR.name + ") {");
        ctx.incIndent();
        var catchStmts = [
            abstract_emitter_1.CATCH_STACK_VAR.set(abstract_emitter_1.CATCH_ERROR_VAR.prop('stack'))
                .toDeclStmt(null, [o.StmtModifier.Final])
        ].concat(stmt.catchStmts);
        this.visitAllStatements(catchStmts, ctx);
        ctx.decIndent();
        ctx.println("}");
        return null;
    };
    AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {
        this.visitAllObjects(function (param) { return ctx.print(param.name); }, params, ctx, ',');
    };
    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
        var name;
        switch (method) {
            case o.BuiltinMethod.ConcatArray:
                name = 'concat';
                break;
            case o.BuiltinMethod.SubscribeObservable:
                name = 'subscribe';
                break;
            case o.BuiltinMethod.bind:
                name = 'bind';
                break;
            default:
                throw new exceptions_1.BaseException("Unknown builtin method: " + method);
        }
        return name;
    };
    return AbstractJsEmitterVisitor;
}(abstract_emitter_1.AbstractEmitterVisitor));
exports.AbstractJsEmitterVisitor = AbstractJsEmitterVisitor;

},{"../../src/facade/exceptions":89,"../../src/facade/lang":90,"./abstract_emitter":99,"./output_ast":103}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var o = require('./output_ast');
var abstract_emitter_1 = require('./abstract_emitter');
var _debugModuleUrl = 'asset://debug/lib';
function debugOutputAstAsDart(ast) {
    var converter = new _DartEmitterVisitor(_debugModuleUrl);
    var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot([]);
    var asts;
    if (lang_1.isArray(ast)) {
        asts = ast;
    }
    else {
        asts = [ast];
    }
    asts.forEach(function (ast) {
        if (ast instanceof o.Statement) {
            ast.visitStatement(converter, ctx);
        }
        else if (ast instanceof o.Expression) {
            ast.visitExpression(converter, ctx);
        }
        else if (ast instanceof o.Type) {
            ast.visitType(converter, ctx);
        }
        else {
            throw new exceptions_1.BaseException("Don't know how to print debug info for " + ast);
        }
    });
    return ctx.toSource();
}
exports.debugOutputAstAsDart = debugOutputAstAsDart;
var DartEmitter = (function () {
    function DartEmitter(_importGenerator) {
        this._importGenerator = _importGenerator;
    }
    DartEmitter.prototype.emitStatements = function (moduleUrl, stmts, exportedVars) {
        var _this = this;
        var srcParts = [];
        // Note: We are not creating a library here as Dart does not need it.
        // Dart analzyer might complain about it though.
        var converter = new _DartEmitterVisitor(moduleUrl);
        var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot(exportedVars);
        converter.visitAllStatements(stmts, ctx);
        converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
            srcParts.push("import '" + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + "' as " + prefix + ";");
        });
        srcParts.push(ctx.toSource());
        return srcParts.join('\n');
    };
    return DartEmitter;
}());
exports.DartEmitter = DartEmitter;
var _DartEmitterVisitor = (function (_super) {
    __extends(_DartEmitterVisitor, _super);
    function _DartEmitterVisitor(_moduleUrl) {
        _super.call(this, true);
        this._moduleUrl = _moduleUrl;
        this.importsWithPrefixes = new Map();
    }
    _DartEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
        this._visitIdentifier(ast.value, ast.typeParams, ctx);
        return null;
    };
    _DartEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
        if (stmt.hasModifier(o.StmtModifier.Final)) {
            if (isConstType(stmt.type)) {
                ctx.print("const ");
            }
            else {
                ctx.print("final ");
            }
        }
        else if (lang_1.isBlank(stmt.type)) {
            ctx.print("var ");
        }
        if (lang_1.isPresent(stmt.type)) {
            stmt.type.visitType(this, ctx);
            ctx.print(" ");
        }
        ctx.print(stmt.name + " = ");
        stmt.value.visitExpression(this, ctx);
        ctx.println(";");
        return null;
    };
    _DartEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
        ctx.print("(");
        ast.value.visitExpression(this, ctx);
        ctx.print(" as ");
        ast.type.visitType(this, ctx);
        ctx.print(")");
        return null;
    };
    _DartEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
        var _this = this;
        ctx.pushClass(stmt);
        ctx.print("class " + stmt.name);
        if (lang_1.isPresent(stmt.parent)) {
            ctx.print(" extends ");
            stmt.parent.visitExpression(this, ctx);
        }
        ctx.println(" {");
        ctx.incIndent();
        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });
        if (lang_1.isPresent(stmt.constructorMethod)) {
            this._visitClassConstructor(stmt, ctx);
        }
        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });
        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });
        ctx.decIndent();
        ctx.println("}");
        ctx.popClass();
        return null;
    };
    _DartEmitterVisitor.prototype._visitClassField = function (field, ctx) {
        if (field.hasModifier(o.StmtModifier.Final)) {
            ctx.print("final ");
        }
        else if (lang_1.isBlank(field.type)) {
            ctx.print("var ");
        }
        if (lang_1.isPresent(field.type)) {
            field.type.visitType(this, ctx);
            ctx.print(" ");
        }
        ctx.println(field.name + ";");
    };
    _DartEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {
        if (lang_1.isPresent(getter.type)) {
            getter.type.visitType(this, ctx);
            ctx.print(" ");
        }
        ctx.println("get " + getter.name + " {");
        ctx.incIndent();
        this.visitAllStatements(getter.body, ctx);
        ctx.decIndent();
        ctx.println("}");
    };
    _DartEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
        ctx.print(stmt.name + "(");
        this._visitParams(stmt.constructorMethod.params, ctx);
        ctx.print(")");
        var ctorStmts = stmt.constructorMethod.body;
        var superCtorExpr = ctorStmts.length > 0 ? getSuperConstructorCallExpr(ctorStmts[0]) : null;
        if (lang_1.isPresent(superCtorExpr)) {
            ctx.print(": ");
            superCtorExpr.visitExpression(this, ctx);
            ctorStmts = ctorStmts.slice(1);
        }
        ctx.println(" {");
        ctx.incIndent();
        this.visitAllStatements(ctorStmts, ctx);
        ctx.decIndent();
        ctx.println("}");
    };
    _DartEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {
        if (lang_1.isPresent(method.type)) {
            method.type.visitType(this, ctx);
        }
        else {
            ctx.print("void");
        }
        ctx.print(" " + method.name + "(");
        this._visitParams(method.params, ctx);
        ctx.println(") {");
        ctx.incIndent();
        this.visitAllStatements(method.body, ctx);
        ctx.decIndent();
        ctx.println("}");
    };
    _DartEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
        ctx.print("(");
        this._visitParams(ast.params, ctx);
        ctx.println(") {");
        ctx.incIndent();
        this.visitAllStatements(ast.statements, ctx);
        ctx.decIndent();
        ctx.print("}");
        return null;
    };
    _DartEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
        if (lang_1.isPresent(stmt.type)) {
            stmt.type.visitType(this, ctx);
        }
        else {
            ctx.print("void");
        }
        ctx.print(" " + stmt.name + "(");
        this._visitParams(stmt.params, ctx);
        ctx.println(") {");
        ctx.incIndent();
        this.visitAllStatements(stmt.statements, ctx);
        ctx.decIndent();
        ctx.println("}");
        return null;
    };
    _DartEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
        var name;
        switch (method) {
            case o.BuiltinMethod.ConcatArray:
                name = '.addAll';
                break;
            case o.BuiltinMethod.SubscribeObservable:
                name = 'listen';
                break;
            case o.BuiltinMethod.bind:
                name = null;
                break;
            default:
                throw new exceptions_1.BaseException("Unknown builtin method: " + method);
        }
        return name;
    };
    _DartEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
        ctx.println("try {");
        ctx.incIndent();
        this.visitAllStatements(stmt.bodyStmts, ctx);
        ctx.decIndent();
        ctx.println("} catch (" + abstract_emitter_1.CATCH_ERROR_VAR.name + ", " + abstract_emitter_1.CATCH_STACK_VAR.name + ") {");
        ctx.incIndent();
        this.visitAllStatements(stmt.catchStmts, ctx);
        ctx.decIndent();
        ctx.println("}");
        return null;
    };
    _DartEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
        switch (ast.operator) {
            case o.BinaryOperator.Identical:
                ctx.print("identical(");
                ast.lhs.visitExpression(this, ctx);
                ctx.print(", ");
                ast.rhs.visitExpression(this, ctx);
                ctx.print(")");
                break;
            case o.BinaryOperator.NotIdentical:
                ctx.print("!identical(");
                ast.lhs.visitExpression(this, ctx);
                ctx.print(", ");
                ast.rhs.visitExpression(this, ctx);
                ctx.print(")");
                break;
            default:
                _super.prototype.visitBinaryOperatorExpr.call(this, ast, ctx);
        }
        return null;
    };
    _DartEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
        if (isConstType(ast.type)) {
            ctx.print("const ");
        }
        return _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);
    };
    _DartEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {
        if (isConstType(ast.type)) {
            ctx.print("const ");
        }
        if (lang_1.isPresent(ast.valueType)) {
            ctx.print("<String, ");
            ast.valueType.visitType(this, ctx);
            ctx.print(">");
        }
        return _super.prototype.visitLiteralMapExpr.call(this, ast, ctx);
    };
    _DartEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {
        ctx.print(isConstType(ast.type) ? "const" : "new");
        ctx.print(' ');
        ast.classExpr.visitExpression(this, ctx);
        ctx.print("(");
        this.visitAllExpressions(ast.args, ctx, ",");
        ctx.print(")");
        return null;
    };
    _DartEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {
        var typeStr;
        switch (type.name) {
            case o.BuiltinTypeName.Bool:
                typeStr = 'bool';
                break;
            case o.BuiltinTypeName.Dynamic:
                typeStr = 'dynamic';
                break;
            case o.BuiltinTypeName.Function:
                typeStr = 'Function';
                break;
            case o.BuiltinTypeName.Number:
                typeStr = 'num';
                break;
            case o.BuiltinTypeName.Int:
                typeStr = 'int';
                break;
            case o.BuiltinTypeName.String:
                typeStr = 'String';
                break;
            default:
                throw new exceptions_1.BaseException("Unsupported builtin type " + type.name);
        }
        ctx.print(typeStr);
        return null;
    };
    _DartEmitterVisitor.prototype.visitExternalType = function (ast, ctx) {
        this._visitIdentifier(ast.value, ast.typeParams, ctx);
        return null;
    };
    _DartEmitterVisitor.prototype.visitArrayType = function (type, ctx) {
        ctx.print("List<");
        if (lang_1.isPresent(type.of)) {
            type.of.visitType(this, ctx);
        }
        else {
            ctx.print("dynamic");
        }
        ctx.print(">");
        return null;
    };
    _DartEmitterVisitor.prototype.visitMapType = function (type, ctx) {
        ctx.print("Map<String, ");
        if (lang_1.isPresent(type.valueType)) {
            type.valueType.visitType(this, ctx);
        }
        else {
            ctx.print("dynamic");
        }
        ctx.print(">");
        return null;
    };
    _DartEmitterVisitor.prototype._visitParams = function (params, ctx) {
        var _this = this;
        this.visitAllObjects(function (param) {
            if (lang_1.isPresent(param.type)) {
                param.type.visitType(_this, ctx);
                ctx.print(' ');
            }
            ctx.print(param.name);
        }, params, ctx, ',');
    };
    _DartEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {
        var _this = this;
        if (lang_1.isBlank(value.name)) {
            throw new exceptions_1.BaseException("Internal error: unknown identifier " + value);
        }
        if (lang_1.isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
            var prefix = this.importsWithPrefixes.get(value.moduleUrl);
            if (lang_1.isBlank(prefix)) {
                prefix = "import" + this.importsWithPrefixes.size;
                this.importsWithPrefixes.set(value.moduleUrl, prefix);
            }
            ctx.print(prefix + ".");
        }
        ctx.print(value.name);
        if (lang_1.isPresent(typeParams) && typeParams.length > 0) {
            ctx.print("<");
            this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');
            ctx.print(">");
        }
    };
    return _DartEmitterVisitor;
}(abstract_emitter_1.AbstractEmitterVisitor));
function getSuperConstructorCallExpr(stmt) {
    if (stmt instanceof o.ExpressionStatement) {
        var expr = stmt.expr;
        if (expr instanceof o.InvokeFunctionExpr) {
            var fn = expr.fn;
            if (fn instanceof o.ReadVarExpr) {
                if (fn.builtin === o.BuiltinVar.Super) {
                    return expr;
                }
            }
        }
    }
    return null;
}
function isConstType(type) {
    return lang_1.isPresent(type) && type.hasModifier(o.TypeModifier.Const);
}

},{"../../src/facade/exceptions":89,"../../src/facade/lang":90,"./abstract_emitter":99,"./output_ast":103}],102:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_private_1 = require('../../core_private');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var InterpretiveAppViewInstanceFactory = (function () {
    function InterpretiveAppViewInstanceFactory() {
    }
    InterpretiveAppViewInstanceFactory.prototype.createInstance = function (superClass, clazz, args, props, getters, methods) {
        if (superClass === core_private_1.AppView) {
            // We are always using DebugAppView as parent.
            // However, in prod mode we generate a constructor call that does
            // not have the argument for the debugNodeInfos.
            args = args.concat([null]);
            return new _InterpretiveAppView(args, props, getters, methods);
        }
        else if (superClass === core_private_1.DebugAppView) {
            return new _InterpretiveAppView(args, props, getters, methods);
        }
        throw new exceptions_1.BaseException("Can't instantiate class " + superClass + " in interpretative mode");
    };
    return InterpretiveAppViewInstanceFactory;
}());
exports.InterpretiveAppViewInstanceFactory = InterpretiveAppViewInstanceFactory;
var _InterpretiveAppView = (function (_super) {
    __extends(_InterpretiveAppView, _super);
    function _InterpretiveAppView(args, props, getters, methods) {
        _super.call(this, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        this.props = props;
        this.getters = getters;
        this.methods = methods;
    }
    _InterpretiveAppView.prototype.createInternal = function (rootSelector) {
        var m = this.methods.get('createInternal');
        if (lang_1.isPresent(m)) {
            return m(rootSelector);
        }
        else {
            return _super.prototype.createInternal.call(this, rootSelector);
        }
    };
    _InterpretiveAppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
        var m = this.methods.get('injectorGetInternal');
        if (lang_1.isPresent(m)) {
            return m(token, nodeIndex, notFoundResult);
        }
        else {
            return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
        }
    };
    _InterpretiveAppView.prototype.destroyInternal = function () {
        var m = this.methods.get('destroyInternal');
        if (lang_1.isPresent(m)) {
            return m();
        }
        else {
            return _super.prototype.destroyInternal.call(this);
        }
    };
    _InterpretiveAppView.prototype.dirtyParentQueriesInternal = function () {
        var m = this.methods.get('dirtyParentQueriesInternal');
        if (lang_1.isPresent(m)) {
            return m();
        }
        else {
            return _super.prototype.dirtyParentQueriesInternal.call(this);
        }
    };
    _InterpretiveAppView.prototype.detectChangesInternal = function (throwOnChange) {
        var m = this.methods.get('detectChangesInternal');
        if (lang_1.isPresent(m)) {
            return m(throwOnChange);
        }
        else {
            return _super.prototype.detectChangesInternal.call(this, throwOnChange);
        }
    };
    return _InterpretiveAppView;
}(core_private_1.DebugAppView));

},{"../../core_private":72,"../../src/facade/exceptions":89,"../../src/facade/lang":90}],103:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
//// Types
(function (TypeModifier) {
    TypeModifier[TypeModifier["Const"] = 0] = "Const";
})(exports.TypeModifier || (exports.TypeModifier = {}));
var TypeModifier = exports.TypeModifier;
var Type = (function () {
    function Type(modifiers) {
        if (modifiers === void 0) { modifiers = null; }
        this.modifiers = modifiers;
        if (lang_1.isBlank(modifiers)) {
            this.modifiers = [];
        }
    }
    Type.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
    return Type;
}());
exports.Type = Type;
(function (BuiltinTypeName) {
    BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
    BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
    BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
    BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
    BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
    BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
})(exports.BuiltinTypeName || (exports.BuiltinTypeName = {}));
var BuiltinTypeName = exports.BuiltinTypeName;
var BuiltinType = (function (_super) {
    __extends(BuiltinType, _super);
    function BuiltinType(name, modifiers) {
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, modifiers);
        this.name = name;
    }
    BuiltinType.prototype.visitType = function (visitor, context) {
        return visitor.visitBuiltintType(this, context);
    };
    return BuiltinType;
}(Type));
exports.BuiltinType = BuiltinType;
var ExternalType = (function (_super) {
    __extends(ExternalType, _super);
    function ExternalType(value, typeParams, modifiers) {
        if (typeParams === void 0) { typeParams = null; }
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, modifiers);
        this.value = value;
        this.typeParams = typeParams;
    }
    ExternalType.prototype.visitType = function (visitor, context) {
        return visitor.visitExternalType(this, context);
    };
    return ExternalType;
}(Type));
exports.ExternalType = ExternalType;
var ArrayType = (function (_super) {
    __extends(ArrayType, _super);
    function ArrayType(of, modifiers) {
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, modifiers);
        this.of = of;
    }
    ArrayType.prototype.visitType = function (visitor, context) {
        return visitor.visitArrayType(this, context);
    };
    return ArrayType;
}(Type));
exports.ArrayType = ArrayType;
var MapType = (function (_super) {
    __extends(MapType, _super);
    function MapType(valueType, modifiers) {
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, modifiers);
        this.valueType = valueType;
    }
    MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };
    return MapType;
}(Type));
exports.MapType = MapType;
exports.DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
exports.BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
exports.INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
exports.NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
exports.STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
exports.FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
///// Expressions
(function (BinaryOperator) {
    BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
    BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
    BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
    BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
    BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
    BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
    BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
    BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
    BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
    BinaryOperator[BinaryOperator["And"] = 9] = "And";
    BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
    BinaryOperator[BinaryOperator["Lower"] = 11] = "Lower";
    BinaryOperator[BinaryOperator["LowerEquals"] = 12] = "LowerEquals";
    BinaryOperator[BinaryOperator["Bigger"] = 13] = "Bigger";
    BinaryOperator[BinaryOperator["BiggerEquals"] = 14] = "BiggerEquals";
})(exports.BinaryOperator || (exports.BinaryOperator = {}));
var BinaryOperator = exports.BinaryOperator;
var Expression = (function () {
    function Expression(type) {
        this.type = type;
    }
    Expression.prototype.prop = function (name) { return new ReadPropExpr(this, name); };
    Expression.prototype.key = function (index, type) {
        if (type === void 0) { type = null; }
        return new ReadKeyExpr(this, index, type);
    };
    Expression.prototype.callMethod = function (name, params) {
        return new InvokeMethodExpr(this, name, params);
    };
    Expression.prototype.callFn = function (params) { return new InvokeFunctionExpr(this, params); };
    Expression.prototype.instantiate = function (params, type) {
        if (type === void 0) { type = null; }
        return new InstantiateExpr(this, params, type);
    };
    Expression.prototype.conditional = function (trueCase, falseCase) {
        if (falseCase === void 0) { falseCase = null; }
        return new ConditionalExpr(this, trueCase, falseCase);
    };
    Expression.prototype.equals = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
    };
    Expression.prototype.notEquals = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
    };
    Expression.prototype.identical = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
    };
    Expression.prototype.notIdentical = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
    };
    Expression.prototype.minus = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
    };
    Expression.prototype.plus = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
    };
    Expression.prototype.divide = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
    };
    Expression.prototype.multiply = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
    };
    Expression.prototype.modulo = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
    };
    Expression.prototype.and = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
    };
    Expression.prototype.or = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
    };
    Expression.prototype.lower = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
    };
    Expression.prototype.lowerEquals = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
    };
    Expression.prototype.bigger = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
    };
    Expression.prototype.biggerEquals = function (rhs) {
        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
    };
    Expression.prototype.isBlank = function () {
        // Note: We use equals by purpose here to compare to null and undefined in JS.
        return this.equals(exports.NULL_EXPR);
    };
    Expression.prototype.cast = function (type) { return new CastExpr(this, type); };
    Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };
    return Expression;
}());
exports.Expression = Expression;
(function (BuiltinVar) {
    BuiltinVar[BuiltinVar["This"] = 0] = "This";
    BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
    BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
    BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
})(exports.BuiltinVar || (exports.BuiltinVar = {}));
var BuiltinVar = exports.BuiltinVar;
var ReadVarExpr = (function (_super) {
    __extends(ReadVarExpr, _super);
    function ReadVarExpr(name, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        if (lang_1.isString(name)) {
            this.name = name;
            this.builtin = null;
        }
        else {
            this.name = null;
            this.builtin = name;
        }
    }
    ReadVarExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitReadVarExpr(this, context);
    };
    ReadVarExpr.prototype.set = function (value) { return new WriteVarExpr(this.name, value); };
    return ReadVarExpr;
}(Expression));
exports.ReadVarExpr = ReadVarExpr;
var WriteVarExpr = (function (_super) {
    __extends(WriteVarExpr, _super);
    function WriteVarExpr(name, value, type) {
        if (type === void 0) { type = null; }
        _super.call(this, lang_1.isPresent(type) ? type : value.type);
        this.name = name;
        this.value = value;
    }
    WriteVarExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitWriteVarExpr(this, context);
    };
    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {
        if (type === void 0) { type = null; }
        if (modifiers === void 0) { modifiers = null; }
        return new DeclareVarStmt(this.name, this.value, type, modifiers);
    };
    return WriteVarExpr;
}(Expression));
exports.WriteVarExpr = WriteVarExpr;
var WriteKeyExpr = (function (_super) {
    __extends(WriteKeyExpr, _super);
    function WriteKeyExpr(receiver, index, value, type) {
        if (type === void 0) { type = null; }
        _super.call(this, lang_1.isPresent(type) ? type : value.type);
        this.receiver = receiver;
        this.index = index;
        this.value = value;
    }
    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitWriteKeyExpr(this, context);
    };
    return WriteKeyExpr;
}(Expression));
exports.WriteKeyExpr = WriteKeyExpr;
var WritePropExpr = (function (_super) {
    __extends(WritePropExpr, _super);
    function WritePropExpr(receiver, name, value, type) {
        if (type === void 0) { type = null; }
        _super.call(this, lang_1.isPresent(type) ? type : value.type);
        this.receiver = receiver;
        this.name = name;
        this.value = value;
    }
    WritePropExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitWritePropExpr(this, context);
    };
    return WritePropExpr;
}(Expression));
exports.WritePropExpr = WritePropExpr;
(function (BuiltinMethod) {
    BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
    BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
    BuiltinMethod[BuiltinMethod["bind"] = 2] = "bind";
})(exports.BuiltinMethod || (exports.BuiltinMethod = {}));
var BuiltinMethod = exports.BuiltinMethod;
var InvokeMethodExpr = (function (_super) {
    __extends(InvokeMethodExpr, _super);
    function InvokeMethodExpr(receiver, method, args, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.receiver = receiver;
        this.args = args;
        if (lang_1.isString(method)) {
            this.name = method;
            this.builtin = null;
        }
        else {
            this.name = null;
            this.builtin = method;
        }
    }
    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitInvokeMethodExpr(this, context);
    };
    return InvokeMethodExpr;
}(Expression));
exports.InvokeMethodExpr = InvokeMethodExpr;
var InvokeFunctionExpr = (function (_super) {
    __extends(InvokeFunctionExpr, _super);
    function InvokeFunctionExpr(fn, args, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.fn = fn;
        this.args = args;
    }
    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitInvokeFunctionExpr(this, context);
    };
    return InvokeFunctionExpr;
}(Expression));
exports.InvokeFunctionExpr = InvokeFunctionExpr;
var InstantiateExpr = (function (_super) {
    __extends(InstantiateExpr, _super);
    function InstantiateExpr(classExpr, args, type) {
        _super.call(this, type);
        this.classExpr = classExpr;
        this.args = args;
    }
    InstantiateExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitInstantiateExpr(this, context);
    };
    return InstantiateExpr;
}(Expression));
exports.InstantiateExpr = InstantiateExpr;
var LiteralExpr = (function (_super) {
    __extends(LiteralExpr, _super);
    function LiteralExpr(value, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.value = value;
    }
    LiteralExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitLiteralExpr(this, context);
    };
    return LiteralExpr;
}(Expression));
exports.LiteralExpr = LiteralExpr;
var ExternalExpr = (function (_super) {
    __extends(ExternalExpr, _super);
    function ExternalExpr(value, type, typeParams) {
        if (type === void 0) { type = null; }
        if (typeParams === void 0) { typeParams = null; }
        _super.call(this, type);
        this.value = value;
        this.typeParams = typeParams;
    }
    ExternalExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitExternalExpr(this, context);
    };
    return ExternalExpr;
}(Expression));
exports.ExternalExpr = ExternalExpr;
var ConditionalExpr = (function (_super) {
    __extends(ConditionalExpr, _super);
    function ConditionalExpr(condition, trueCase, falseCase, type) {
        if (falseCase === void 0) { falseCase = null; }
        if (type === void 0) { type = null; }
        _super.call(this, lang_1.isPresent(type) ? type : trueCase.type);
        this.condition = condition;
        this.falseCase = falseCase;
        this.trueCase = trueCase;
    }
    ConditionalExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitConditionalExpr(this, context);
    };
    return ConditionalExpr;
}(Expression));
exports.ConditionalExpr = ConditionalExpr;
var NotExpr = (function (_super) {
    __extends(NotExpr, _super);
    function NotExpr(condition) {
        _super.call(this, exports.BOOL_TYPE);
        this.condition = condition;
    }
    NotExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitNotExpr(this, context);
    };
    return NotExpr;
}(Expression));
exports.NotExpr = NotExpr;
var CastExpr = (function (_super) {
    __extends(CastExpr, _super);
    function CastExpr(value, type) {
        _super.call(this, type);
        this.value = value;
    }
    CastExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitCastExpr(this, context);
    };
    return CastExpr;
}(Expression));
exports.CastExpr = CastExpr;
var FnParam = (function () {
    function FnParam(name, type) {
        if (type === void 0) { type = null; }
        this.name = name;
        this.type = type;
    }
    return FnParam;
}());
exports.FnParam = FnParam;
var FunctionExpr = (function (_super) {
    __extends(FunctionExpr, _super);
    function FunctionExpr(params, statements, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.params = params;
        this.statements = statements;
    }
    FunctionExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitFunctionExpr(this, context);
    };
    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {
        if (modifiers === void 0) { modifiers = null; }
        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
    };
    return FunctionExpr;
}(Expression));
exports.FunctionExpr = FunctionExpr;
var BinaryOperatorExpr = (function (_super) {
    __extends(BinaryOperatorExpr, _super);
    function BinaryOperatorExpr(operator, lhs, rhs, type) {
        if (type === void 0) { type = null; }
        _super.call(this, lang_1.isPresent(type) ? type : lhs.type);
        this.operator = operator;
        this.rhs = rhs;
        this.lhs = lhs;
    }
    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitBinaryOperatorExpr(this, context);
    };
    return BinaryOperatorExpr;
}(Expression));
exports.BinaryOperatorExpr = BinaryOperatorExpr;
var ReadPropExpr = (function (_super) {
    __extends(ReadPropExpr, _super);
    function ReadPropExpr(receiver, name, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.receiver = receiver;
        this.name = name;
    }
    ReadPropExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitReadPropExpr(this, context);
    };
    ReadPropExpr.prototype.set = function (value) {
        return new WritePropExpr(this.receiver, this.name, value);
    };
    return ReadPropExpr;
}(Expression));
exports.ReadPropExpr = ReadPropExpr;
var ReadKeyExpr = (function (_super) {
    __extends(ReadKeyExpr, _super);
    function ReadKeyExpr(receiver, index, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.receiver = receiver;
        this.index = index;
    }
    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitReadKeyExpr(this, context);
    };
    ReadKeyExpr.prototype.set = function (value) {
        return new WriteKeyExpr(this.receiver, this.index, value);
    };
    return ReadKeyExpr;
}(Expression));
exports.ReadKeyExpr = ReadKeyExpr;
var LiteralArrayExpr = (function (_super) {
    __extends(LiteralArrayExpr, _super);
    function LiteralArrayExpr(entries, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.entries = entries;
    }
    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitLiteralArrayExpr(this, context);
    };
    return LiteralArrayExpr;
}(Expression));
exports.LiteralArrayExpr = LiteralArrayExpr;
var LiteralMapExpr = (function (_super) {
    __extends(LiteralMapExpr, _super);
    function LiteralMapExpr(entries, type) {
        if (type === void 0) { type = null; }
        _super.call(this, type);
        this.entries = entries;
        this.valueType = null;
        if (lang_1.isPresent(type)) {
            this.valueType = type.valueType;
        }
    }
    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {
        return visitor.visitLiteralMapExpr(this, context);
    };
    return LiteralMapExpr;
}(Expression));
exports.LiteralMapExpr = LiteralMapExpr;
exports.THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
exports.SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
exports.CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
exports.CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
exports.NULL_EXPR = new LiteralExpr(null, null);
//// Statements
(function (StmtModifier) {
    StmtModifier[StmtModifier["Final"] = 0] = "Final";
    StmtModifier[StmtModifier["Private"] = 1] = "Private";
})(exports.StmtModifier || (exports.StmtModifier = {}));
var StmtModifier = exports.StmtModifier;
var Statement = (function () {
    function Statement(modifiers) {
        if (modifiers === void 0) { modifiers = null; }
        this.modifiers = modifiers;
        if (lang_1.isBlank(modifiers)) {
            this.modifiers = [];
        }
    }
    Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
    return Statement;
}());
exports.Statement = Statement;
var DeclareVarStmt = (function (_super) {
    __extends(DeclareVarStmt, _super);
    function DeclareVarStmt(name, value, type, modifiers) {
        if (type === void 0) { type = null; }
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, modifiers);
        this.name = name;
        this.value = value;
        this.type = lang_1.isPresent(type) ? type : value.type;
    }
    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {
        return visitor.visitDeclareVarStmt(this, context);
    };
    return DeclareVarStmt;
}(Statement));
exports.DeclareVarStmt = DeclareVarStmt;
var DeclareFunctionStmt = (function (_super) {
    __extends(DeclareFunctionStmt, _super);
    function DeclareFunctionStmt(name, params, statements, type, modifiers) {
        if (type === void 0) { type = null; }
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, modifiers);
        this.name = name;
        this.params = params;
        this.statements = statements;
        this.type = type;
    }
    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {
        return visitor.visitDeclareFunctionStmt(this, context);
    };
    return DeclareFunctionStmt;
}(Statement));
exports.DeclareFunctionStmt = DeclareFunctionStmt;
var ExpressionStatement = (function (_super) {
    __extends(ExpressionStatement, _super);
    function ExpressionStatement(expr) {
        _super.call(this);
        this.expr = expr;
    }
    ExpressionStatement.prototype.visitStatement = function (visitor, context) {
        return visitor.visitExpressionStmt(this, context);
    };
    return ExpressionStatement;
}(Statement));
exports.ExpressionStatement = ExpressionStatement;
var ReturnStatement = (function (_super) {
    __extends(ReturnStatement, _super);
    function ReturnStatement(value) {
        _super.call(this);
        this.value = value;
    }
    ReturnStatement.prototype.visitStatement = function (visitor, context) {
        return visitor.visitReturnStmt(this, context);
    };
    return ReturnStatement;
}(Statement));
exports.ReturnStatement = ReturnStatement;
var AbstractClassPart = (function () {
    function AbstractClassPart(type, modifiers) {
        if (type === void 0) { type = null; }
        this.type = type;
        this.modifiers = modifiers;
        if (lang_1.isBlank(modifiers)) {
            this.modifiers = [];
        }
    }
    AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
    return AbstractClassPart;
}());
exports.AbstractClassPart = AbstractClassPart;
var ClassField = (function (_super) {
    __extends(ClassField, _super);
    function ClassField(name, type, modifiers) {
        if (type === void 0) { type = null; }
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, type, modifiers);
        this.name = name;
    }
    return ClassField;
}(AbstractClassPart));
exports.ClassField = ClassField;
var ClassMethod = (function (_super) {
    __extends(ClassMethod, _super);
    function ClassMethod(name, params, body, type, modifiers) {
        if (type === void 0) { type = null; }
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, type, modifiers);
        this.name = name;
        this.params = params;
        this.body = body;
    }
    return ClassMethod;
}(AbstractClassPart));
exports.ClassMethod = ClassMethod;
var ClassGetter = (function (_super) {
    __extends(ClassGetter, _super);
    function ClassGetter(name, body, type, modifiers) {
        if (type === void 0) { type = null; }
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, type, modifiers);
        this.name = name;
        this.body = body;
    }
    return ClassGetter;
}(AbstractClassPart));
exports.ClassGetter = ClassGetter;
var ClassStmt = (function (_super) {
    __extends(ClassStmt, _super);
    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {
        if (modifiers === void 0) { modifiers = null; }
        _super.call(this, modifiers);
        this.name = name;
        this.parent = parent;
        this.fields = fields;
        this.getters = getters;
        this.constructorMethod = constructorMethod;
        this.methods = methods;
    }
    ClassStmt.prototype.visitStatement = function (visitor, context) {
        return visitor.visitDeclareClassStmt(this, context);
    };
    return ClassStmt;
}(Statement));
exports.ClassStmt = ClassStmt;
var IfStmt = (function (_super) {
    __extends(IfStmt, _super);
    function IfStmt(condition, trueCase, falseCase) {
        if (falseCase === void 0) { falseCase = []; }
        _super.call(this);
        this.condition = condition;
        this.trueCase = trueCase;
        this.falseCase = falseCase;
    }
    IfStmt.prototype.visitStatement = function (visitor, context) {
        return visitor.visitIfStmt(this, context);
    };
    return IfStmt;
}(Statement));
exports.IfStmt = IfStmt;
var CommentStmt = (function (_super) {
    __extends(CommentStmt, _super);
    function CommentStmt(comment) {
        _super.call(this);
        this.comment = comment;
    }
    CommentStmt.prototype.visitStatement = function (visitor, context) {
        return visitor.visitCommentStmt(this, context);
    };
    return CommentStmt;
}(Statement));
exports.CommentStmt = CommentStmt;
var TryCatchStmt = (function (_super) {
    __extends(TryCatchStmt, _super);
    function TryCatchStmt(bodyStmts, catchStmts) {
        _super.call(this);
        this.bodyStmts = bodyStmts;
        this.catchStmts = catchStmts;
    }
    TryCatchStmt.prototype.visitStatement = function (visitor, context) {
        return visitor.visitTryCatchStmt(this, context);
    };
    return TryCatchStmt;
}(Statement));
exports.TryCatchStmt = TryCatchStmt;
var ThrowStmt = (function (_super) {
    __extends(ThrowStmt, _super);
    function ThrowStmt(error) {
        _super.call(this);
        this.error = error;
    }
    ThrowStmt.prototype.visitStatement = function (visitor, context) {
        return visitor.visitThrowStmt(this, context);
    };
    return ThrowStmt;
}(Statement));
exports.ThrowStmt = ThrowStmt;
var ExpressionTransformer = (function () {
    function ExpressionTransformer() {
    }
    ExpressionTransformer.prototype.visitReadVarExpr = function (ast, context) { return ast; };
    ExpressionTransformer.prototype.visitWriteVarExpr = function (expr, context) {
        return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitWriteKeyExpr = function (expr, context) {
        return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitWritePropExpr = function (expr, context) {
        return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {
        var method = lang_1.isPresent(ast.builtin) ? ast.builtin : ast.name;
        return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {
        return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitInstantiateExpr = function (ast, context) {
        return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
    };
    ExpressionTransformer.prototype.visitLiteralExpr = function (ast, context) { return ast; };
    ExpressionTransformer.prototype.visitExternalExpr = function (ast, context) { return ast; };
    ExpressionTransformer.prototype.visitConditionalExpr = function (ast, context) {
        return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitNotExpr = function (ast, context) {
        return new NotExpr(ast.condition.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitCastExpr = function (ast, context) {
        return new CastExpr(ast.value.visitExpression(this, context), context);
    };
    ExpressionTransformer.prototype.visitFunctionExpr = function (ast, context) {
        // Don't descend into nested functions
        return ast;
    };
    ExpressionTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {
        return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
    };
    ExpressionTransformer.prototype.visitReadPropExpr = function (ast, context) {
        return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
    };
    ExpressionTransformer.prototype.visitReadKeyExpr = function (ast, context) {
        return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
    };
    ExpressionTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {
        return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
    };
    ExpressionTransformer.prototype.visitLiteralMapExpr = function (ast, context) {
        var _this = this;
        return new LiteralMapExpr(ast.entries.map(function (entry) { return [entry[0], entry[1].visitExpression(_this, context)]; }));
    };
    ExpressionTransformer.prototype.visitAllExpressions = function (exprs, context) {
        var _this = this;
        return exprs.map(function (expr) { return expr.visitExpression(_this, context); });
    };
    ExpressionTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {
        return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
    };
    ExpressionTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {
        // Don't descend into nested functions
        return stmt;
    };
    ExpressionTransformer.prototype.visitExpressionStmt = function (stmt, context) {
        return new ExpressionStatement(stmt.expr.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitReturnStmt = function (stmt, context) {
        return new ReturnStatement(stmt.value.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {
        // Don't descend into nested functions
        return stmt;
    };
    ExpressionTransformer.prototype.visitIfStmt = function (stmt, context) {
        return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
    };
    ExpressionTransformer.prototype.visitTryCatchStmt = function (stmt, context) {
        return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
    };
    ExpressionTransformer.prototype.visitThrowStmt = function (stmt, context) {
        return new ThrowStmt(stmt.error.visitExpression(this, context));
    };
    ExpressionTransformer.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
    ExpressionTransformer.prototype.visitAllStatements = function (stmts, context) {
        var _this = this;
        return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });
    };
    return ExpressionTransformer;
}());
exports.ExpressionTransformer = ExpressionTransformer;
var RecursiveExpressionVisitor = (function () {
    function RecursiveExpressionVisitor() {
    }
    RecursiveExpressionVisitor.prototype.visitReadVarExpr = function (ast, context) { return ast; };
    RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function (expr, context) {
        expr.value.visitExpression(this, context);
        return expr;
    };
    RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function (expr, context) {
        expr.receiver.visitExpression(this, context);
        expr.index.visitExpression(this, context);
        expr.value.visitExpression(this, context);
        return expr;
    };
    RecursiveExpressionVisitor.prototype.visitWritePropExpr = function (expr, context) {
        expr.receiver.visitExpression(this, context);
        expr.value.visitExpression(this, context);
        return expr;
    };
    RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {
        ast.receiver.visitExpression(this, context);
        this.visitAllExpressions(ast.args, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {
        ast.fn.visitExpression(this, context);
        this.visitAllExpressions(ast.args, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function (ast, context) {
        ast.classExpr.visitExpression(this, context);
        this.visitAllExpressions(ast.args, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralExpr = function (ast, context) { return ast; };
    RecursiveExpressionVisitor.prototype.visitExternalExpr = function (ast, context) { return ast; };
    RecursiveExpressionVisitor.prototype.visitConditionalExpr = function (ast, context) {
        ast.condition.visitExpression(this, context);
        ast.trueCase.visitExpression(this, context);
        ast.falseCase.visitExpression(this, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitNotExpr = function (ast, context) {
        ast.condition.visitExpression(this, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitCastExpr = function (ast, context) {
        ast.value.visitExpression(this, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitFunctionExpr = function (ast, context) { return ast; };
    RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {
        ast.lhs.visitExpression(this, context);
        ast.rhs.visitExpression(this, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitReadPropExpr = function (ast, context) {
        ast.receiver.visitExpression(this, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function (ast, context) {
        ast.receiver.visitExpression(this, context);
        ast.index.visitExpression(this, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {
        this.visitAllExpressions(ast.entries, context);
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function (ast, context) {
        var _this = this;
        ast.entries.forEach(function (entry) { return entry[1].visitExpression(_this, context); });
        return ast;
    };
    RecursiveExpressionVisitor.prototype.visitAllExpressions = function (exprs, context) {
        var _this = this;
        exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });
    };
    RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {
        stmt.value.visitExpression(this, context);
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {
        // Don't descend into nested functions
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitExpressionStmt = function (stmt, context) {
        stmt.expr.visitExpression(this, context);
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitReturnStmt = function (stmt, context) {
        stmt.value.visitExpression(this, context);
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {
        // Don't descend into nested functions
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitIfStmt = function (stmt, context) {
        stmt.condition.visitExpression(this, context);
        this.visitAllStatements(stmt.trueCase, context);
        this.visitAllStatements(stmt.falseCase, context);
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function (stmt, context) {
        this.visitAllStatements(stmt.bodyStmts, context);
        this.visitAllStatements(stmt.catchStmts, context);
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitThrowStmt = function (stmt, context) {
        stmt.error.visitExpression(this, context);
        return stmt;
    };
    RecursiveExpressionVisitor.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
    RecursiveExpressionVisitor.prototype.visitAllStatements = function (stmts, context) {
        var _this = this;
        stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });
    };
    return RecursiveExpressionVisitor;
}());
exports.RecursiveExpressionVisitor = RecursiveExpressionVisitor;
function replaceVarInExpression(varName, newValue, expression) {
    var transformer = new _ReplaceVariableTransformer(varName, newValue);
    return expression.visitExpression(transformer, null);
}
exports.replaceVarInExpression = replaceVarInExpression;
var _ReplaceVariableTransformer = (function (_super) {
    __extends(_ReplaceVariableTransformer, _super);
    function _ReplaceVariableTransformer(_varName, _newValue) {
        _super.call(this);
        this._varName = _varName;
        this._newValue = _newValue;
    }
    _ReplaceVariableTransformer.prototype.visitReadVarExpr = function (ast, context) {
        return ast.name == this._varName ? this._newValue : ast;
    };
    return _ReplaceVariableTransformer;
}(ExpressionTransformer));
function findReadVarNames(stmts) {
    var finder = new _VariableFinder();
    finder.visitAllStatements(stmts, null);
    return finder.varNames;
}
exports.findReadVarNames = findReadVarNames;
var _VariableFinder = (function (_super) {
    __extends(_VariableFinder, _super);
    function _VariableFinder() {
        _super.apply(this, arguments);
        this.varNames = new Set();
    }
    _VariableFinder.prototype.visitReadVarExpr = function (ast, context) {
        this.varNames.add(ast.name);
        return null;
    };
    return _VariableFinder;
}(RecursiveExpressionVisitor));
function variable(name, type) {
    if (type === void 0) { type = null; }
    return new ReadVarExpr(name, type);
}
exports.variable = variable;
function importExpr(id, typeParams) {
    if (typeParams === void 0) { typeParams = null; }
    return new ExternalExpr(id, null, typeParams);
}
exports.importExpr = importExpr;
function importType(id, typeParams, typeModifiers) {
    if (typeParams === void 0) { typeParams = null; }
    if (typeModifiers === void 0) { typeModifiers = null; }
    return lang_1.isPresent(id) ? new ExternalType(id, typeParams, typeModifiers) : null;
}
exports.importType = importType;
function literal(value, type) {
    if (type === void 0) { type = null; }
    return new LiteralExpr(value, type);
}
exports.literal = literal;
function literalArr(values, type) {
    if (type === void 0) { type = null; }
    return new LiteralArrayExpr(values, type);
}
exports.literalArr = literalArr;
function literalMap(values, type) {
    if (type === void 0) { type = null; }
    return new LiteralMapExpr(values, type);
}
exports.literalMap = literalMap;
function not(expr) {
    return new NotExpr(expr);
}
exports.not = not;
function fn(params, body, type) {
    if (type === void 0) { type = null; }
    return new FunctionExpr(params, body, type);
}
exports.fn = fn;

},{"../../src/facade/lang":90}],104:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var async_1 = require('../../src/facade/async');
var exceptions_1 = require('../../src/facade/exceptions');
var collection_1 = require('../../src/facade/collection');
var o = require('./output_ast');
var dart_emitter_1 = require('./dart_emitter');
var ts_emitter_1 = require('./ts_emitter');
function interpretStatements(statements, resultVar, instanceFactory) {
    var stmtsWithReturn = statements.concat([new o.ReturnStatement(o.variable(resultVar))]);
    var ctx = new _ExecutionContext(null, null, null, null, new Map(), new Map(), new Map(), new Map(), instanceFactory);
    var visitor = new StatementInterpreter();
    var result = visitor.visitAllStatements(stmtsWithReturn, ctx);
    return lang_1.isPresent(result) ? result.value : null;
}
exports.interpretStatements = interpretStatements;
var DynamicInstance = (function () {
    function DynamicInstance() {
    }
    Object.defineProperty(DynamicInstance.prototype, "props", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DynamicInstance.prototype, "getters", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DynamicInstance.prototype, "methods", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DynamicInstance.prototype, "clazz", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return DynamicInstance;
}());
exports.DynamicInstance = DynamicInstance;
function isDynamicInstance(instance) {
    if (lang_1.IS_DART) {
        return instance instanceof DynamicInstance;
    }
    else {
        return lang_1.isPresent(instance) && lang_1.isPresent(instance.props) && lang_1.isPresent(instance.getters) &&
            lang_1.isPresent(instance.methods);
    }
}
function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
    var childCtx = ctx.createChildWihtLocalVars();
    for (var i = 0; i < varNames.length; i++) {
        childCtx.vars.set(varNames[i], varValues[i]);
    }
    var result = visitor.visitAllStatements(statements, childCtx);
    return lang_1.isPresent(result) ? result.value : null;
}
var _ExecutionContext = (function () {
    function _ExecutionContext(parent, superClass, superInstance, className, vars, props, getters, methods, instanceFactory) {
        this.parent = parent;
        this.superClass = superClass;
        this.superInstance = superInstance;
        this.className = className;
        this.vars = vars;
        this.props = props;
        this.getters = getters;
        this.methods = methods;
        this.instanceFactory = instanceFactory;
    }
    _ExecutionContext.prototype.createChildWihtLocalVars = function () {
        return new _ExecutionContext(this, this.superClass, this.superInstance, this.className, new Map(), this.props, this.getters, this.methods, this.instanceFactory);
    };
    return _ExecutionContext;
}());
var ReturnValue = (function () {
    function ReturnValue(value) {
        this.value = value;
    }
    return ReturnValue;
}());
var _DynamicClass = (function () {
    function _DynamicClass(_classStmt, _ctx, _visitor) {
        this._classStmt = _classStmt;
        this._ctx = _ctx;
        this._visitor = _visitor;
    }
    _DynamicClass.prototype.instantiate = function (args) {
        var _this = this;
        var props = new Map();
        var getters = new Map();
        var methods = new Map();
        var superClass = this._classStmt.parent.visitExpression(this._visitor, this._ctx);
        var instanceCtx = new _ExecutionContext(this._ctx, superClass, null, this._classStmt.name, this._ctx.vars, props, getters, methods, this._ctx.instanceFactory);
        this._classStmt.fields.forEach(function (field) { props.set(field.name, null); });
        this._classStmt.getters.forEach(function (getter) {
            getters.set(getter.name, function () { return _executeFunctionStatements([], [], getter.body, instanceCtx, _this._visitor); });
        });
        this._classStmt.methods.forEach(function (method) {
            var paramNames = method.params.map(function (param) { return param.name; });
            methods.set(method.name, _declareFn(paramNames, method.body, instanceCtx, _this._visitor));
        });
        var ctorParamNames = this._classStmt.constructorMethod.params.map(function (param) { return param.name; });
        _executeFunctionStatements(ctorParamNames, args, this._classStmt.constructorMethod.body, instanceCtx, this._visitor);
        return instanceCtx.superInstance;
    };
    _DynamicClass.prototype.debugAst = function () { return this._visitor.debugAst(this._classStmt); };
    return _DynamicClass;
}());
var StatementInterpreter = (function () {
    function StatementInterpreter() {
    }
    StatementInterpreter.prototype.debugAst = function (ast) {
        return lang_1.IS_DART ? dart_emitter_1.debugOutputAstAsDart(ast) : ts_emitter_1.debugOutputAstAsTypeScript(ast);
    };
    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {
        ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
        return null;
    };
    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {
        var value = expr.value.visitExpression(this, ctx);
        var currCtx = ctx;
        while (currCtx != null) {
            if (currCtx.vars.has(expr.name)) {
                currCtx.vars.set(expr.name, value);
                return value;
            }
            currCtx = currCtx.parent;
        }
        throw new exceptions_1.BaseException("Not declared variable " + expr.name);
    };
    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {
        var varName = ast.name;
        if (lang_1.isPresent(ast.builtin)) {
            switch (ast.builtin) {
                case o.BuiltinVar.Super:
                case o.BuiltinVar.This:
                    return ctx.superInstance;
                case o.BuiltinVar.CatchError:
                    varName = CATCH_ERROR_VAR;
                    break;
                case o.BuiltinVar.CatchStack:
                    varName = CATCH_STACK_VAR;
                    break;
                default:
                    throw new exceptions_1.BaseException("Unknown builtin variable " + ast.builtin);
            }
        }
        var currCtx = ctx;
        while (currCtx != null) {
            if (currCtx.vars.has(varName)) {
                return currCtx.vars.get(varName);
            }
            currCtx = currCtx.parent;
        }
        throw new exceptions_1.BaseException("Not declared variable " + varName);
    };
    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {
        var receiver = expr.receiver.visitExpression(this, ctx);
        var index = expr.index.visitExpression(this, ctx);
        var value = expr.value.visitExpression(this, ctx);
        receiver[index] = value;
        return value;
    };
    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {
        var receiver = expr.receiver.visitExpression(this, ctx);
        var value = expr.value.visitExpression(this, ctx);
        if (isDynamicInstance(receiver)) {
            var di = receiver;
            if (di.props.has(expr.name)) {
                di.props.set(expr.name, value);
            }
            else {
                core_1.reflector.setter(expr.name)(receiver, value);
            }
        }
        else {
            core_1.reflector.setter(expr.name)(receiver, value);
        }
        return value;
    };
    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {
        var receiver = expr.receiver.visitExpression(this, ctx);
        var args = this.visitAllExpressions(expr.args, ctx);
        var result;
        if (lang_1.isPresent(expr.builtin)) {
            switch (expr.builtin) {
                case o.BuiltinMethod.ConcatArray:
                    result = collection_1.ListWrapper.concat(receiver, args[0]);
                    break;
                case o.BuiltinMethod.SubscribeObservable:
                    result = async_1.ObservableWrapper.subscribe(receiver, args[0]);
                    break;
                case o.BuiltinMethod.bind:
                    if (lang_1.IS_DART) {
                        result = receiver;
                    }
                    else {
                        result = receiver.bind(args[0]);
                    }
                    break;
                default:
                    throw new exceptions_1.BaseException("Unknown builtin method " + expr.builtin);
            }
        }
        else if (isDynamicInstance(receiver)) {
            var di = receiver;
            if (di.methods.has(expr.name)) {
                result = lang_1.FunctionWrapper.apply(di.methods.get(expr.name), args);
            }
            else {
                result = core_1.reflector.method(expr.name)(receiver, args);
            }
        }
        else {
            result = core_1.reflector.method(expr.name)(receiver, args);
        }
        return result;
    };
    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {
        var args = this.visitAllExpressions(stmt.args, ctx);
        var fnExpr = stmt.fn;
        if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {
            ctx.superInstance = ctx.instanceFactory.createInstance(ctx.superClass, ctx.className, args, ctx.props, ctx.getters, ctx.methods);
            ctx.parent.superInstance = ctx.superInstance;
            return null;
        }
        else {
            var fn = stmt.fn.visitExpression(this, ctx);
            return lang_1.FunctionWrapper.apply(fn, args);
        }
    };
    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {
        return new ReturnValue(stmt.value.visitExpression(this, ctx));
    };
    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {
        var clazz = new _DynamicClass(stmt, ctx, this);
        ctx.vars.set(stmt.name, clazz);
        return null;
    };
    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {
        return stmt.expr.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {
        var condition = stmt.condition.visitExpression(this, ctx);
        if (condition) {
            return this.visitAllStatements(stmt.trueCase, ctx);
        }
        else if (lang_1.isPresent(stmt.falseCase)) {
            return this.visitAllStatements(stmt.falseCase, ctx);
        }
        return null;
    };
    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {
        try {
            return this.visitAllStatements(stmt.bodyStmts, ctx);
        }
        catch (e) {
            var childCtx = ctx.createChildWihtLocalVars();
            childCtx.vars.set(CATCH_ERROR_VAR, e);
            childCtx.vars.set(CATCH_STACK_VAR, e.stack);
            return this.visitAllStatements(stmt.catchStmts, childCtx);
        }
    };
    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {
        throw stmt.error.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };
    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {
        var args = this.visitAllExpressions(ast.args, ctx);
        var clazz = ast.classExpr.visitExpression(this, ctx);
        if (clazz instanceof _DynamicClass) {
            return clazz.instantiate(args);
        }
        else {
            return lang_1.FunctionWrapper.apply(core_1.reflector.factory(clazz), args);
        }
    };
    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };
    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) { return ast.value.runtime; };
    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {
        if (ast.condition.visitExpression(this, ctx)) {
            return ast.trueCase.visitExpression(this, ctx);
        }
        else if (lang_1.isPresent(ast.falseCase)) {
            return ast.falseCase.visitExpression(this, ctx);
        }
        return null;
    };
    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {
        return !ast.condition.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {
        return ast.value.visitExpression(this, ctx);
    };
    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {
        var paramNames = ast.params.map(function (param) { return param.name; });
        return _declareFn(paramNames, ast.statements, ctx, this);
    };
    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
        var paramNames = stmt.params.map(function (param) { return param.name; });
        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
        return null;
    };
    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
        var _this = this;
        var lhs = function () { return ast.lhs.visitExpression(_this, ctx); };
        var rhs = function () { return ast.rhs.visitExpression(_this, ctx); };
        switch (ast.operator) {
            case o.BinaryOperator.Equals:
                return lhs() == rhs();
            case o.BinaryOperator.Identical:
                return lhs() === rhs();
            case o.BinaryOperator.NotEquals:
                return lhs() != rhs();
            case o.BinaryOperator.NotIdentical:
                return lhs() !== rhs();
            case o.BinaryOperator.And:
                return lhs() && rhs();
            case o.BinaryOperator.Or:
                return lhs() || rhs();
            case o.BinaryOperator.Plus:
                return lhs() + rhs();
            case o.BinaryOperator.Minus:
                return lhs() - rhs();
            case o.BinaryOperator.Divide:
                return lhs() / rhs();
            case o.BinaryOperator.Multiply:
                return lhs() * rhs();
            case o.BinaryOperator.Modulo:
                return lhs() % rhs();
            case o.BinaryOperator.Lower:
                return lhs() < rhs();
            case o.BinaryOperator.LowerEquals:
                return lhs() <= rhs();
            case o.BinaryOperator.Bigger:
                return lhs() > rhs();
            case o.BinaryOperator.BiggerEquals:
                return lhs() >= rhs();
            default:
                throw new exceptions_1.BaseException("Unknown operator " + ast.operator);
        }
    };
    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {
        var result;
        var receiver = ast.receiver.visitExpression(this, ctx);
        if (isDynamicInstance(receiver)) {
            var di = receiver;
            if (di.props.has(ast.name)) {
                result = di.props.get(ast.name);
            }
            else if (di.getters.has(ast.name)) {
                result = di.getters.get(ast.name)();
            }
            else if (di.methods.has(ast.name)) {
                result = di.methods.get(ast.name);
            }
            else {
                result = core_1.reflector.getter(ast.name)(receiver);
            }
        }
        else {
            result = core_1.reflector.getter(ast.name)(receiver);
        }
        return result;
    };
    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {
        var receiver = ast.receiver.visitExpression(this, ctx);
        var prop = ast.index.visitExpression(this, ctx);
        return receiver[prop];
    };
    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {
        return this.visitAllExpressions(ast.entries, ctx);
    };
    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {
        var _this = this;
        var result = {};
        ast.entries.forEach(function (entry) { return result[entry[0]] =
            entry[1].visitExpression(_this, ctx); });
        return result;
    };
    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {
        var _this = this;
        return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });
    };
    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {
        for (var i = 0; i < statements.length; i++) {
            var stmt = statements[i];
            var val = stmt.visitStatement(this, ctx);
            if (val instanceof ReturnValue) {
                return val;
            }
        }
        return null;
    };
    return StatementInterpreter;
}());
function _declareFn(varNames, statements, ctx, visitor) {
    switch (varNames.length) {
        case 0:
            return function () { return _executeFunctionStatements(varNames, [], statements, ctx, visitor); };
        case 1:
            return function (d0) { return _executeFunctionStatements(varNames, [d0], statements, ctx, visitor); };
        case 2:
            return function (d0, d1) { return _executeFunctionStatements(varNames, [d0, d1], statements, ctx, visitor); };
        case 3:
            return function (d0, d1, d2) {
                return _executeFunctionStatements(varNames, [d0, d1, d2], statements, ctx, visitor);
            };
        case 4:
            return function (d0, d1, d2, d3) {
                return _executeFunctionStatements(varNames, [d0, d1, d2, d3], statements, ctx, visitor);
            };
        case 5:
            return function (d0, d1, d2, d3, d4) { return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4], statements, ctx, visitor); };
        case 6:
            return function (d0, d1, d2, d3, d4, d5) { return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5], statements, ctx, visitor); };
        case 7:
            return function (d0, d1, d2, d3, d4, d5, d6) { return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6], statements, ctx, visitor); };
        case 8:
            return function (d0, d1, d2, d3, d4, d5, d6, d7) { return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7], statements, ctx, visitor); };
        case 9:
            return function (d0, d1, d2, d3, d4, d5, d6, d7, d8) { return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7, d8], statements, ctx, visitor); };
        case 10:
            return function (d0, d1, d2, d3, d4, d5, d6, d7, d8, d9) { return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7, d8, d9], statements, ctx, visitor); };
        default:
            throw new exceptions_1.BaseException('Declaring functions with more than 10 arguments is not supported right now');
    }
}
var CATCH_ERROR_VAR = 'error';
var CATCH_STACK_VAR = 'stack';

},{"../../src/facade/async":85,"../../src/facade/collection":87,"../../src/facade/exceptions":89,"../../src/facade/lang":90,"./dart_emitter":101,"./output_ast":103,"./ts_emitter":107,"@angular/core":140}],105:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var abstract_emitter_1 = require('./abstract_emitter');
var abstract_js_emitter_1 = require('./abstract_js_emitter');
var util_1 = require('../util');
function jitStatements(sourceUrl, statements, resultVar) {
    var converter = new JitEmitterVisitor();
    var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot([resultVar]);
    converter.visitAllStatements(statements, ctx);
    return lang_1.evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
}
exports.jitStatements = jitStatements;
var JitEmitterVisitor = (function (_super) {
    __extends(JitEmitterVisitor, _super);
    function JitEmitterVisitor() {
        _super.apply(this, arguments);
        this._evalArgNames = [];
        this._evalArgValues = [];
    }
    JitEmitterVisitor.prototype.getArgs = function () {
        var result = {};
        for (var i = 0; i < this._evalArgNames.length; i++) {
            result[this._evalArgNames[i]] = this._evalArgValues[i];
        }
        return result;
    };
    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
        var value = ast.value.runtime;
        var id = this._evalArgValues.indexOf(value);
        if (id === -1) {
            id = this._evalArgValues.length;
            this._evalArgValues.push(value);
            var name = lang_1.isPresent(ast.value.name) ? util_1.sanitizeIdentifier(ast.value.name) : 'val';
            this._evalArgNames.push(util_1.sanitizeIdentifier("jit_" + name + id));
        }
        ctx.print(this._evalArgNames[id]);
        return null;
    };
    return JitEmitterVisitor;
}(abstract_js_emitter_1.AbstractJsEmitterVisitor));

},{"../../src/facade/lang":90,"../util":122,"./abstract_emitter":99,"./abstract_js_emitter":100}],106:[function(require,module,exports){
"use strict";
var exceptions_1 = require('../../src/facade/exceptions');
var lang_1 = require('../../src/facade/lang');
// asset:<package-name>/<realm>/<path-to-module>
var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/g;
/**
 * Interface that defines how import statements should be generated.
 */
var ImportGenerator = (function () {
    function ImportGenerator() {
    }
    ImportGenerator.parseAssetUrl = function (url) { return AssetUrl.parse(url); };
    return ImportGenerator;
}());
exports.ImportGenerator = ImportGenerator;
var AssetUrl = (function () {
    function AssetUrl(packageName, firstLevelDir, modulePath) {
        this.packageName = packageName;
        this.firstLevelDir = firstLevelDir;
        this.modulePath = modulePath;
    }
    AssetUrl.parse = function (url, allowNonMatching) {
        if (allowNonMatching === void 0) { allowNonMatching = true; }
        var match = lang_1.RegExpWrapper.firstMatch(_ASSET_URL_RE, url);
        if (lang_1.isPresent(match)) {
            return new AssetUrl(match[1], match[2], match[3]);
        }
        if (allowNonMatching) {
            return null;
        }
        throw new exceptions_1.BaseException("Url " + url + " is not a valid asset: url");
    };
    return AssetUrl;
}());
exports.AssetUrl = AssetUrl;

},{"../../src/facade/exceptions":89,"../../src/facade/lang":90}],107:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var o = require('./output_ast');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var abstract_emitter_1 = require('./abstract_emitter');
var _debugModuleUrl = 'asset://debug/lib';
function debugOutputAstAsTypeScript(ast) {
    var converter = new _TsEmitterVisitor(_debugModuleUrl);
    var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot([]);
    var asts;
    if (lang_1.isArray(ast)) {
        asts = ast;
    }
    else {
        asts = [ast];
    }
    asts.forEach(function (ast) {
        if (ast instanceof o.Statement) {
            ast.visitStatement(converter, ctx);
        }
        else if (ast instanceof o.Expression) {
            ast.visitExpression(converter, ctx);
        }
        else if (ast instanceof o.Type) {
            ast.visitType(converter, ctx);
        }
        else {
            throw new exceptions_1.BaseException("Don't know how to print debug info for " + ast);
        }
    });
    return ctx.toSource();
}
exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;
var TypeScriptEmitter = (function () {
    function TypeScriptEmitter(_importGenerator) {
        this._importGenerator = _importGenerator;
    }
    TypeScriptEmitter.prototype.emitStatements = function (moduleUrl, stmts, exportedVars) {
        var _this = this;
        var converter = new _TsEmitterVisitor(moduleUrl);
        var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot(exportedVars);
        converter.visitAllStatements(stmts, ctx);
        var srcParts = [];
        converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
            // Note: can't write the real word for import as it screws up system.js auto detection...
            srcParts.push("imp" +
                ("ort * as " + prefix + " from '" + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + "';"));
        });
        srcParts.push(ctx.toSource());
        return srcParts.join('\n');
    };
    return TypeScriptEmitter;
}());
exports.TypeScriptEmitter = TypeScriptEmitter;
var _TsEmitterVisitor = (function (_super) {
    __extends(_TsEmitterVisitor, _super);
    function _TsEmitterVisitor(_moduleUrl) {
        _super.call(this, false);
        this._moduleUrl = _moduleUrl;
        this.importsWithPrefixes = new Map();
    }
    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
        this._visitIdentifier(ast.value, ast.typeParams, ctx);
        return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
        if (ctx.isExportedVar(stmt.name)) {
            ctx.print("export ");
        }
        if (stmt.hasModifier(o.StmtModifier.Final)) {
            ctx.print("const");
        }
        else {
            ctx.print("var");
        }
        ctx.print(" " + stmt.name);
        if (lang_1.isPresent(stmt.type)) {
            ctx.print(":");
            stmt.type.visitType(this, ctx);
        }
        ctx.print(" = ");
        stmt.value.visitExpression(this, ctx);
        ctx.println(";");
        return null;
    };
    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
        ctx.print("(<");
        ast.type.visitType(this, ctx);
        ctx.print(">");
        ast.value.visitExpression(this, ctx);
        ctx.print(")");
        return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
        var _this = this;
        ctx.pushClass(stmt);
        if (ctx.isExportedVar(stmt.name)) {
            ctx.print("export ");
        }
        ctx.print("class " + stmt.name);
        if (lang_1.isPresent(stmt.parent)) {
            ctx.print(" extends ");
            stmt.parent.visitExpression(this, ctx);
        }
        ctx.println(" {");
        ctx.incIndent();
        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });
        if (lang_1.isPresent(stmt.constructorMethod)) {
            this._visitClassConstructor(stmt, ctx);
        }
        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });
        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });
        ctx.decIndent();
        ctx.println("}");
        ctx.popClass();
        return null;
    };
    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {
        if (field.hasModifier(o.StmtModifier.Private)) {
            ctx.print("private ");
        }
        ctx.print(field.name);
        if (lang_1.isPresent(field.type)) {
            ctx.print(":");
            field.type.visitType(this, ctx);
        }
        else {
            ctx.print(": any");
        }
        ctx.println(";");
    };
    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {
        if (getter.hasModifier(o.StmtModifier.Private)) {
            ctx.print("private ");
        }
        ctx.print("get " + getter.name + "()");
        if (lang_1.isPresent(getter.type)) {
            ctx.print(":");
            getter.type.visitType(this, ctx);
        }
        ctx.println(" {");
        ctx.incIndent();
        this.visitAllStatements(getter.body, ctx);
        ctx.decIndent();
        ctx.println("}");
    };
    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
        ctx.print("constructor(");
        this._visitParams(stmt.constructorMethod.params, ctx);
        ctx.println(") {");
        ctx.incIndent();
        this.visitAllStatements(stmt.constructorMethod.body, ctx);
        ctx.decIndent();
        ctx.println("}");
    };
    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {
        if (method.hasModifier(o.StmtModifier.Private)) {
            ctx.print("private ");
        }
        ctx.print(method.name + "(");
        this._visitParams(method.params, ctx);
        ctx.print("):");
        if (lang_1.isPresent(method.type)) {
            method.type.visitType(this, ctx);
        }
        else {
            ctx.print("void");
        }
        ctx.println(" {");
        ctx.incIndent();
        this.visitAllStatements(method.body, ctx);
        ctx.decIndent();
        ctx.println("}");
    };
    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
        ctx.print("(");
        this._visitParams(ast.params, ctx);
        ctx.print("):");
        if (lang_1.isPresent(ast.type)) {
            ast.type.visitType(this, ctx);
        }
        else {
            ctx.print("void");
        }
        ctx.println(" => {");
        ctx.incIndent();
        this.visitAllStatements(ast.statements, ctx);
        ctx.decIndent();
        ctx.print("}");
        return null;
    };
    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
        if (ctx.isExportedVar(stmt.name)) {
            ctx.print("export ");
        }
        ctx.print("function " + stmt.name + "(");
        this._visitParams(stmt.params, ctx);
        ctx.print("):");
        if (lang_1.isPresent(stmt.type)) {
            stmt.type.visitType(this, ctx);
        }
        else {
            ctx.print("void");
        }
        ctx.println(" {");
        ctx.incIndent();
        this.visitAllStatements(stmt.statements, ctx);
        ctx.decIndent();
        ctx.println("}");
        return null;
    };
    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
        ctx.println("try {");
        ctx.incIndent();
        this.visitAllStatements(stmt.bodyStmts, ctx);
        ctx.decIndent();
        ctx.println("} catch (" + abstract_emitter_1.CATCH_ERROR_VAR.name + ") {");
        ctx.incIndent();
        var catchStmts = [
            abstract_emitter_1.CATCH_STACK_VAR.set(abstract_emitter_1.CATCH_ERROR_VAR.prop('stack'))
                .toDeclStmt(null, [o.StmtModifier.Final])
        ].concat(stmt.catchStmts);
        this.visitAllStatements(catchStmts, ctx);
        ctx.decIndent();
        ctx.println("}");
        return null;
    };
    _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {
        var typeStr;
        switch (type.name) {
            case o.BuiltinTypeName.Bool:
                typeStr = 'boolean';
                break;
            case o.BuiltinTypeName.Dynamic:
                typeStr = 'any';
                break;
            case o.BuiltinTypeName.Function:
                typeStr = 'Function';
                break;
            case o.BuiltinTypeName.Number:
                typeStr = 'number';
                break;
            case o.BuiltinTypeName.Int:
                typeStr = 'number';
                break;
            case o.BuiltinTypeName.String:
                typeStr = 'string';
                break;
            default:
                throw new exceptions_1.BaseException("Unsupported builtin type " + type.name);
        }
        ctx.print(typeStr);
        return null;
    };
    _TsEmitterVisitor.prototype.visitExternalType = function (ast, ctx) {
        this._visitIdentifier(ast.value, ast.typeParams, ctx);
        return null;
    };
    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {
        if (lang_1.isPresent(type.of)) {
            type.of.visitType(this, ctx);
        }
        else {
            ctx.print("any");
        }
        ctx.print("[]");
        return null;
    };
    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {
        ctx.print("{[key: string]:");
        if (lang_1.isPresent(type.valueType)) {
            type.valueType.visitType(this, ctx);
        }
        else {
            ctx.print("any");
        }
        ctx.print("}");
        return null;
    };
    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
        var name;
        switch (method) {
            case o.BuiltinMethod.ConcatArray:
                name = 'concat';
                break;
            case o.BuiltinMethod.SubscribeObservable:
                name = 'subscribe';
                break;
            case o.BuiltinMethod.bind:
                name = 'bind';
                break;
            default:
                throw new exceptions_1.BaseException("Unknown builtin method: " + method);
        }
        return name;
    };
    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {
        var _this = this;
        this.visitAllObjects(function (param) {
            ctx.print(param.name);
            if (lang_1.isPresent(param.type)) {
                ctx.print(":");
                param.type.visitType(_this, ctx);
            }
        }, params, ctx, ',');
    };
    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {
        var _this = this;
        if (lang_1.isBlank(value.name)) {
            throw new exceptions_1.BaseException("Internal error: unknown identifier " + value);
        }
        if (lang_1.isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
            var prefix = this.importsWithPrefixes.get(value.moduleUrl);
            if (lang_1.isBlank(prefix)) {
                prefix = "import" + this.importsWithPrefixes.size;
                this.importsWithPrefixes.set(value.moduleUrl, prefix);
            }
            ctx.print(prefix + ".");
        }
        ctx.print(value.name);
        if (lang_1.isPresent(typeParams) && typeParams.length > 0) {
            ctx.print("<");
            this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');
            ctx.print(">");
        }
    };
    return _TsEmitterVisitor;
}(abstract_emitter_1.AbstractEmitterVisitor));

},{"../../src/facade/exceptions":89,"../../src/facade/lang":90,"./abstract_emitter":99,"./output_ast":103}],108:[function(require,module,exports){
"use strict";
var ParseLocation = (function () {
    function ParseLocation(file, offset, line, col) {
        this.file = file;
        this.offset = offset;
        this.line = line;
        this.col = col;
    }
    ParseLocation.prototype.toString = function () { return this.file.url + "@" + this.line + ":" + this.col; };
    return ParseLocation;
}());
exports.ParseLocation = ParseLocation;
var ParseSourceFile = (function () {
    function ParseSourceFile(content, url) {
        this.content = content;
        this.url = url;
    }
    return ParseSourceFile;
}());
exports.ParseSourceFile = ParseSourceFile;
var ParseSourceSpan = (function () {
    function ParseSourceSpan(start, end) {
        this.start = start;
        this.end = end;
    }
    ParseSourceSpan.prototype.toString = function () {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
    };
    return ParseSourceSpan;
}());
exports.ParseSourceSpan = ParseSourceSpan;
(function (ParseErrorLevel) {
    ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
    ParseErrorLevel[ParseErrorLevel["FATAL"] = 1] = "FATAL";
})(exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));
var ParseErrorLevel = exports.ParseErrorLevel;
var ParseError = (function () {
    function ParseError(span, msg, level) {
        if (level === void 0) { level = ParseErrorLevel.FATAL; }
        this.span = span;
        this.msg = msg;
        this.level = level;
    }
    ParseError.prototype.toString = function () {
        var source = this.span.start.file.content;
        var ctxStart = this.span.start.offset;
        if (ctxStart > source.length - 1) {
            ctxStart = source.length - 1;
        }
        var ctxEnd = ctxStart;
        var ctxLen = 0;
        var ctxLines = 0;
        while (ctxLen < 100 && ctxStart > 0) {
            ctxStart--;
            ctxLen++;
            if (source[ctxStart] == "\n") {
                if (++ctxLines == 3) {
                    break;
                }
            }
        }
        ctxLen = 0;
        ctxLines = 0;
        while (ctxLen < 100 && ctxEnd < source.length - 1) {
            ctxEnd++;
            ctxLen++;
            if (source[ctxEnd] == "\n") {
                if (++ctxLines == 3) {
                    break;
                }
            }
        }
        var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' +
            source.substring(this.span.start.offset, ctxEnd + 1);
        return this.msg + " (\"" + context + "\"): " + this.span.start;
    };
    return ParseError;
}());
exports.ParseError = ParseError;

},{}],109:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
function _isPipeMetadata(type) {
    return type instanceof core_1.PipeMetadata;
}
var PipeResolver = (function () {
    function PipeResolver(_reflector) {
        if (lang_1.isPresent(_reflector)) {
            this._reflector = _reflector;
        }
        else {
            this._reflector = core_1.reflector;
        }
    }
    /**
     * Return {@link PipeMetadata} for a given `Type`.
     */
    PipeResolver.prototype.resolve = function (type) {
        var metas = this._reflector.annotations(core_1.resolveForwardRef(type));
        if (lang_1.isPresent(metas)) {
            var annotation = metas.find(_isPipeMetadata);
            if (lang_1.isPresent(annotation)) {
                return annotation;
            }
        }
        throw new exceptions_1.BaseException("No Pipe decorator found on " + lang_1.stringify(type));
    };
    PipeResolver.decorators = [
        { type: core_1.Injectable },
    ];
    PipeResolver.ctorParameters = [
        { type: core_private_1.ReflectorReader, },
    ];
    return PipeResolver;
}());
exports.PipeResolver = PipeResolver;
exports.CODEGEN_PIPE_RESOLVER = new PipeResolver(core_1.reflector);

},{"../core_private":72,"../src/facade/exceptions":89,"../src/facade/lang":90,"@angular/core":140}],110:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../src/facade/lang');
var collection_1 = require('../src/facade/collection');
var template_ast_1 = require('./template_ast');
var compile_metadata_1 = require('./compile_metadata');
var identifiers_1 = require('./identifiers');
var parse_util_1 = require('./parse_util');
var ProviderError = (function (_super) {
    __extends(ProviderError, _super);
    function ProviderError(message, span) {
        _super.call(this, span, message);
    }
    return ProviderError;
}(parse_util_1.ParseError));
exports.ProviderError = ProviderError;
var ProviderViewContext = (function () {
    function ProviderViewContext(component, sourceSpan) {
        var _this = this;
        this.component = component;
        this.sourceSpan = sourceSpan;
        this.errors = [];
        this.viewQueries = _getViewQueries(component);
        this.viewProviders = new compile_metadata_1.CompileTokenMap();
        _normalizeProviders(component.viewProviders, sourceSpan, this.errors)
            .forEach(function (provider) {
            if (lang_1.isBlank(_this.viewProviders.get(provider.token))) {
                _this.viewProviders.add(provider.token, true);
            }
        });
    }
    return ProviderViewContext;
}());
exports.ProviderViewContext = ProviderViewContext;
var ProviderElementContext = (function () {
    function ProviderElementContext(_viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
        var _this = this;
        this._viewContext = _viewContext;
        this._parent = _parent;
        this._isViewRoot = _isViewRoot;
        this._directiveAsts = _directiveAsts;
        this._sourceSpan = _sourceSpan;
        this._transformedProviders = new compile_metadata_1.CompileTokenMap();
        this._seenProviders = new compile_metadata_1.CompileTokenMap();
        this._hasViewContainer = false;
        this._attrs = {};
        attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });
        var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });
        this._allProviders =
            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, _viewContext.errors);
        this._contentQueries = _getContentQueries(directivesMeta);
        var queriedTokens = new compile_metadata_1.CompileTokenMap();
        this._allProviders.values().forEach(function (provider) { _this._addQueryReadsTo(provider.token, queriedTokens); });
        refs.forEach(function (refAst) {
            _this._addQueryReadsTo(new compile_metadata_1.CompileTokenMetadata({ value: refAst.name }), queriedTokens);
        });
        if (lang_1.isPresent(queriedTokens.get(identifiers_1.identifierToken(identifiers_1.Identifiers.ViewContainerRef)))) {
            this._hasViewContainer = true;
        }
        // create the providers that we know are eager first
        this._allProviders.values().forEach(function (provider) {
            var eager = provider.eager || lang_1.isPresent(queriedTokens.get(provider.token));
            if (eager) {
                _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
            }
        });
    }
    ProviderElementContext.prototype.afterElement = function () {
        var _this = this;
        // collect lazy providers
        this._allProviders.values().forEach(function (provider) {
            _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
        });
    };
    Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
        get: function () { return this._transformedProviders.values(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
        get: function () {
            var sortedProviderTypes = this._transformedProviders.values().map(function (provider) { return provider.token.identifier; });
            var sortedDirectives = collection_1.ListWrapper.clone(this._directiveAsts);
            collection_1.ListWrapper.sort(sortedDirectives, function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -
                sortedProviderTypes.indexOf(dir2.directive.type); });
            return sortedDirectives;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
        get: function () { return this._hasViewContainer; },
        enumerable: true,
        configurable: true
    });
    ProviderElementContext.prototype._addQueryReadsTo = function (token, queryReadTokens) {
        this._getQueriesFor(token).forEach(function (query) {
            var queryReadToken = lang_1.isPresent(query.read) ? query.read : token;
            if (lang_1.isBlank(queryReadTokens.get(queryReadToken))) {
                queryReadTokens.add(queryReadToken, true);
            }
        });
    };
    ProviderElementContext.prototype._getQueriesFor = function (token) {
        var result = [];
        var currentEl = this;
        var distance = 0;
        var queries;
        while (currentEl !== null) {
            queries = currentEl._contentQueries.get(token);
            if (lang_1.isPresent(queries)) {
                collection_1.ListWrapper.addAll(result, queries.filter(function (query) { return query.descendants || distance <= 1; }));
            }
            if (currentEl._directiveAsts.length > 0) {
                distance++;
            }
            currentEl = currentEl._parent;
        }
        queries = this._viewContext.viewQueries.get(token);
        if (lang_1.isPresent(queries)) {
            collection_1.ListWrapper.addAll(result, queries);
        }
        return result;
    };
    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {
        var _this = this;
        var resolvedProvider = this._allProviders.get(token);
        if (lang_1.isBlank(resolvedProvider) ||
            ((requestingProviderType === template_ast_1.ProviderAstType.Directive ||
                requestingProviderType === template_ast_1.ProviderAstType.PublicService) &&
                resolvedProvider.providerType === template_ast_1.ProviderAstType.PrivateService) ||
            ((requestingProviderType === template_ast_1.ProviderAstType.PrivateService ||
                requestingProviderType === template_ast_1.ProviderAstType.PublicService) &&
                resolvedProvider.providerType === template_ast_1.ProviderAstType.Builtin)) {
            return null;
        }
        var transformedProviderAst = this._transformedProviders.get(token);
        if (lang_1.isPresent(transformedProviderAst)) {
            return transformedProviderAst;
        }
        if (lang_1.isPresent(this._seenProviders.get(token))) {
            this._viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, this._sourceSpan));
            return null;
        }
        this._seenProviders.add(token, true);
        var transformedProviders = resolvedProvider.providers.map(function (provider) {
            var transformedUseValue = provider.useValue;
            var transformedUseExisting = provider.useExisting;
            var transformedDeps;
            if (lang_1.isPresent(provider.useExisting)) {
                var existingDiDep = _this._getDependency(resolvedProvider.providerType, new compile_metadata_1.CompileDiDependencyMetadata({ token: provider.useExisting }), eager);
                if (lang_1.isPresent(existingDiDep.token)) {
                    transformedUseExisting = existingDiDep.token;
                }
                else {
                    transformedUseExisting = null;
                    transformedUseValue = existingDiDep.value;
                }
            }
            else if (lang_1.isPresent(provider.useFactory)) {
                var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
                transformedDeps =
                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
            }
            else if (lang_1.isPresent(provider.useClass)) {
                var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
                transformedDeps =
                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
            }
            return _transformProvider(provider, {
                useExisting: transformedUseExisting,
                useValue: transformedUseValue,
                deps: transformedDeps
            });
        });
        transformedProviderAst =
            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
        this._transformedProviders.add(token, transformedProviderAst);
        return transformedProviderAst;
    };
    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {
        if (eager === void 0) { eager = null; }
        if (dep.isAttribute) {
            var attrValue = this._attrs[dep.token.value];
            return new compile_metadata_1.CompileDiDependencyMetadata({ isValue: true, value: lang_1.normalizeBlank(attrValue) });
        }
        if (lang_1.isPresent(dep.query) || lang_1.isPresent(dep.viewQuery)) {
            return dep;
        }
        if (lang_1.isPresent(dep.token)) {
            // access builtints
            if ((requestingProviderType === template_ast_1.ProviderAstType.Directive ||
                requestingProviderType === template_ast_1.ProviderAstType.Component)) {
                if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.Renderer)) ||
                    dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ElementRef)) ||
                    dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ChangeDetectorRef)) ||
                    dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.TemplateRef))) {
                    return dep;
                }
                if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ViewContainerRef))) {
                    this._hasViewContainer = true;
                }
            }
            // access the injector
            if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.Injector))) {
                return dep;
            }
            // access providers
            if (lang_1.isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
                return dep;
            }
        }
        return null;
    };
    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {
        if (eager === void 0) { eager = null; }
        var currElement = this;
        var currEager = eager;
        var result = null;
        if (!dep.isSkipSelf) {
            result = this._getLocalDependency(requestingProviderType, dep, eager);
        }
        if (dep.isSelf) {
            if (lang_1.isBlank(result) && dep.isOptional) {
                result = new compile_metadata_1.CompileDiDependencyMetadata({ isValue: true, value: null });
            }
        }
        else {
            // check parent elements
            while (lang_1.isBlank(result) && lang_1.isPresent(currElement._parent)) {
                var prevElement = currElement;
                currElement = currElement._parent;
                if (prevElement._isViewRoot) {
                    currEager = false;
                }
                result = currElement._getLocalDependency(template_ast_1.ProviderAstType.PublicService, dep, currEager);
            }
            // check @Host restriction
            if (lang_1.isBlank(result)) {
                if (!dep.isHost || this._viewContext.component.type.isHost ||
                    identifiers_1.identifierToken(this._viewContext.component.type).equalsTo(dep.token) ||
                    lang_1.isPresent(this._viewContext.viewProviders.get(dep.token))) {
                    result = dep;
                }
                else {
                    result = dep.isOptional ?
                        result = new compile_metadata_1.CompileDiDependencyMetadata({ isValue: true, value: null }) :
                        null;
                }
            }
        }
        if (lang_1.isBlank(result)) {
            this._viewContext.errors.push(new ProviderError("No provider for " + dep.token.name, this._sourceSpan));
        }
        return result;
    };
    return ProviderElementContext;
}());
exports.ProviderElementContext = ProviderElementContext;
function _transformProvider(provider, _a) {
    var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;
    return new compile_metadata_1.CompileProviderMetadata({
        token: provider.token,
        useClass: provider.useClass,
        useExisting: useExisting,
        useFactory: provider.useFactory,
        useValue: useValue,
        deps: deps,
        multi: provider.multi
    });
}
function _transformProviderAst(provider, _a) {
    var eager = _a.eager, providers = _a.providers;
    return new template_ast_1.ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.sourceSpan);
}
function _normalizeProviders(providers, sourceSpan, targetErrors, targetProviders) {
    if (targetProviders === void 0) { targetProviders = null; }
    if (lang_1.isBlank(targetProviders)) {
        targetProviders = [];
    }
    if (lang_1.isPresent(providers)) {
        providers.forEach(function (provider) {
            if (lang_1.isArray(provider)) {
                _normalizeProviders(provider, sourceSpan, targetErrors, targetProviders);
            }
            else {
                var normalizeProvider;
                if (provider instanceof compile_metadata_1.CompileProviderMetadata) {
                    normalizeProvider = provider;
                }
                else if (provider instanceof compile_metadata_1.CompileTypeMetadata) {
                    normalizeProvider = new compile_metadata_1.CompileProviderMetadata({ token: new compile_metadata_1.CompileTokenMetadata({ identifier: provider }), useClass: provider });
                }
                else {
                    targetErrors.push(new ProviderError("Unknown provider type " + provider, sourceSpan));
                }
                if (lang_1.isPresent(normalizeProvider)) {
                    targetProviders.push(normalizeProvider);
                }
            }
        });
    }
    return targetProviders;
}
function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
    var providersByToken = new compile_metadata_1.CompileTokenMap();
    directives.forEach(function (directive) {
        var dirProvider = new compile_metadata_1.CompileProviderMetadata({ token: new compile_metadata_1.CompileTokenMetadata({ identifier: directive.type }), useClass: directive.type });
        _resolveProviders([dirProvider], directive.isComponent ? template_ast_1.ProviderAstType.Component : template_ast_1.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
    });
    // Note: directives need to be able to overwrite providers of a component!
    var directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));
    directivesWithComponentFirst.forEach(function (directive) {
        _resolveProviders(_normalizeProviders(directive.providers, sourceSpan, targetErrors), template_ast_1.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
        _resolveProviders(_normalizeProviders(directive.viewProviders, sourceSpan, targetErrors), template_ast_1.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
    });
    return providersByToken;
}
function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
    providers.forEach(function (provider) {
        var resolvedProvider = targetProvidersByToken.get(provider.token);
        if (lang_1.isPresent(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {
            targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + resolvedProvider.token.name, sourceSpan));
        }
        if (lang_1.isBlank(resolvedProvider)) {
            resolvedProvider = new template_ast_1.ProviderAst(provider.token, provider.multi, eager, [provider], providerType, sourceSpan);
            targetProvidersByToken.add(provider.token, resolvedProvider);
        }
        else {
            if (!provider.multi) {
                collection_1.ListWrapper.clear(resolvedProvider.providers);
            }
            resolvedProvider.providers.push(provider);
        }
    });
}
function _getViewQueries(component) {
    var viewQueries = new compile_metadata_1.CompileTokenMap();
    if (lang_1.isPresent(component.viewQueries)) {
        component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, query); });
    }
    component.type.diDeps.forEach(function (dep) {
        if (lang_1.isPresent(dep.viewQuery)) {
            _addQueryToTokenMap(viewQueries, dep.viewQuery);
        }
    });
    return viewQueries;
}
function _getContentQueries(directives) {
    var contentQueries = new compile_metadata_1.CompileTokenMap();
    directives.forEach(function (directive) {
        if (lang_1.isPresent(directive.queries)) {
            directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, query); });
        }
        directive.type.diDeps.forEach(function (dep) {
            if (lang_1.isPresent(dep.query)) {
                _addQueryToTokenMap(contentQueries, dep.query);
            }
        });
    });
    return contentQueries;
}
function _addQueryToTokenMap(map, query) {
    query.selectors.forEach(function (token) {
        var entry = map.get(token);
        if (lang_1.isBlank(entry)) {
            entry = [];
            map.add(token, entry);
        }
        entry.push(query);
    });
}

},{"../src/facade/collection":87,"../src/facade/lang":90,"./compile_metadata":76,"./identifiers":96,"./parse_util":108,"./template_ast":118}],111:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var collection_1 = require('../src/facade/collection');
var async_1 = require('../src/facade/async');
var compile_metadata_1 = require('./compile_metadata');
var style_compiler_1 = require('./style_compiler');
var view_compiler_1 = require('./view_compiler/view_compiler');
var template_parser_1 = require('./template_parser');
var directive_normalizer_1 = require('./directive_normalizer');
var metadata_resolver_1 = require('./metadata_resolver');
var config_1 = require('./config');
var ir = require('./output/output_ast');
var output_jit_1 = require('./output/output_jit');
var output_interpreter_1 = require('./output/output_interpreter');
var interpretive_view_1 = require('./output/interpretive_view');
var xhr_1 = require('./xhr');
var RuntimeCompiler = (function () {
    function RuntimeCompiler(_metadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _viewCompiler, _xhr, _genConfig) {
        this._metadataResolver = _metadataResolver;
        this._templateNormalizer = _templateNormalizer;
        this._templateParser = _templateParser;
        this._styleCompiler = _styleCompiler;
        this._viewCompiler = _viewCompiler;
        this._xhr = _xhr;
        this._genConfig = _genConfig;
        this._styleCache = new Map();
        this._hostCacheKeys = new Map();
        this._compiledTemplateCache = new Map();
        this._compiledTemplateDone = new Map();
    }
    RuntimeCompiler.prototype.resolveComponent = function (componentType) {
        var compMeta = this._metadataResolver.getDirectiveMetadata(componentType);
        var hostCacheKey = this._hostCacheKeys.get(componentType);
        if (lang_1.isBlank(hostCacheKey)) {
            hostCacheKey = new Object();
            this._hostCacheKeys.set(componentType, hostCacheKey);
            assertComponent(compMeta);
            var hostMeta = compile_metadata_1.createHostComponentMeta(compMeta.type, compMeta.selector);
            this._loadAndCompileComponent(hostCacheKey, hostMeta, [compMeta], [], []);
        }
        return this._compiledTemplateDone.get(hostCacheKey)
            .then(function (compiledTemplate) { return new core_1.ComponentFactory(compMeta.selector, compiledTemplate.viewFactory, componentType); });
    };
    RuntimeCompiler.prototype.clearCache = function () {
        this._styleCache.clear();
        this._compiledTemplateCache.clear();
        this._compiledTemplateDone.clear();
        this._hostCacheKeys.clear();
    };
    RuntimeCompiler.prototype._loadAndCompileComponent = function (cacheKey, compMeta, viewDirectives, pipes, compilingComponentsPath) {
        var _this = this;
        var compiledTemplate = this._compiledTemplateCache.get(cacheKey);
        var done = this._compiledTemplateDone.get(cacheKey);
        if (lang_1.isBlank(compiledTemplate)) {
            compiledTemplate = new CompiledTemplate();
            this._compiledTemplateCache.set(cacheKey, compiledTemplate);
            done =
                async_1.PromiseWrapper.all([this._compileComponentStyles(compMeta)].concat(viewDirectives.map(function (dirMeta) { return _this._templateNormalizer.normalizeDirective(dirMeta); })))
                    .then(function (stylesAndNormalizedViewDirMetas) {
                    var normalizedViewDirMetas = stylesAndNormalizedViewDirMetas.slice(1);
                    var styles = stylesAndNormalizedViewDirMetas[0];
                    var parsedTemplate = _this._templateParser.parse(compMeta, compMeta.template.template, normalizedViewDirMetas, pipes, compMeta.type.name);
                    var childPromises = [];
                    compiledTemplate.init(_this._compileComponent(compMeta, parsedTemplate, styles, pipes, compilingComponentsPath, childPromises));
                    return async_1.PromiseWrapper.all(childPromises).then(function (_) { return compiledTemplate; });
                });
            this._compiledTemplateDone.set(cacheKey, done);
        }
        return compiledTemplate;
    };
    RuntimeCompiler.prototype._compileComponent = function (compMeta, parsedTemplate, styles, pipes, compilingComponentsPath, childPromises) {
        var _this = this;
        var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, new ir.ExternalExpr(new compile_metadata_1.CompileIdentifierMetadata({ runtime: styles })), pipes);
        compileResult.dependencies.forEach(function (dep) {
            var childCompilingComponentsPath = collection_1.ListWrapper.clone(compilingComponentsPath);
            var childCacheKey = dep.comp.type.runtime;
            var childViewDirectives = _this._metadataResolver.getViewDirectivesMetadata(dep.comp.type.runtime);
            var childViewPipes = _this._metadataResolver.getViewPipesMetadata(dep.comp.type.runtime);
            var childIsRecursive = collection_1.ListWrapper.contains(childCompilingComponentsPath, childCacheKey);
            childCompilingComponentsPath.push(childCacheKey);
            var childComp = _this._loadAndCompileComponent(dep.comp.type.runtime, dep.comp, childViewDirectives, childViewPipes, childCompilingComponentsPath);
            dep.factoryPlaceholder.runtime = childComp.proxyViewFactory;
            dep.factoryPlaceholder.name = "viewFactory_" + dep.comp.type.name;
            if (!childIsRecursive) {
                // Only wait for a child if it is not a cycle
                childPromises.push(_this._compiledTemplateDone.get(childCacheKey));
            }
        });
        var factory;
        if (lang_1.IS_DART || !this._genConfig.useJit) {
            factory = output_interpreter_1.interpretStatements(compileResult.statements, compileResult.viewFactoryVar, new interpretive_view_1.InterpretiveAppViewInstanceFactory());
        }
        else {
            factory = output_jit_1.jitStatements(compMeta.type.name + ".template.js", compileResult.statements, compileResult.viewFactoryVar);
        }
        return factory;
    };
    RuntimeCompiler.prototype._compileComponentStyles = function (compMeta) {
        var compileResult = this._styleCompiler.compileComponent(compMeta);
        return this._resolveStylesCompileResult(compMeta.type.name, compileResult);
    };
    RuntimeCompiler.prototype._resolveStylesCompileResult = function (sourceUrl, result) {
        var _this = this;
        var promises = result.dependencies.map(function (dep) { return _this._loadStylesheetDep(dep); });
        return async_1.PromiseWrapper.all(promises)
            .then(function (cssTexts) {
            var nestedCompileResultPromises = [];
            for (var i = 0; i < result.dependencies.length; i++) {
                var dep = result.dependencies[i];
                var cssText = cssTexts[i];
                var nestedCompileResult = _this._styleCompiler.compileStylesheet(dep.moduleUrl, cssText, dep.isShimmed);
                nestedCompileResultPromises.push(_this._resolveStylesCompileResult(dep.moduleUrl, nestedCompileResult));
            }
            return async_1.PromiseWrapper.all(nestedCompileResultPromises);
        })
            .then(function (nestedStylesArr) {
            for (var i = 0; i < result.dependencies.length; i++) {
                var dep = result.dependencies[i];
                dep.valuePlaceholder.runtime = nestedStylesArr[i];
                dep.valuePlaceholder.name = "importedStyles" + i;
            }
            if (lang_1.IS_DART || !_this._genConfig.useJit) {
                return output_interpreter_1.interpretStatements(result.statements, result.stylesVar, new interpretive_view_1.InterpretiveAppViewInstanceFactory());
            }
            else {
                return output_jit_1.jitStatements(sourceUrl + ".css.js", result.statements, result.stylesVar);
            }
        });
    };
    RuntimeCompiler.prototype._loadStylesheetDep = function (dep) {
        var cacheKey = "" + dep.moduleUrl + (dep.isShimmed ? '.shim' : '');
        var cssTextPromise = this._styleCache.get(cacheKey);
        if (lang_1.isBlank(cssTextPromise)) {
            cssTextPromise = this._xhr.get(dep.moduleUrl);
            this._styleCache.set(cacheKey, cssTextPromise);
        }
        return cssTextPromise;
    };
    RuntimeCompiler.decorators = [
        { type: core_1.Injectable },
    ];
    RuntimeCompiler.ctorParameters = [
        { type: metadata_resolver_1.CompileMetadataResolver, },
        { type: directive_normalizer_1.DirectiveNormalizer, },
        { type: template_parser_1.TemplateParser, },
        { type: style_compiler_1.StyleCompiler, },
        { type: view_compiler_1.ViewCompiler, },
        { type: xhr_1.XHR, },
        { type: config_1.CompilerConfig, },
    ];
    return RuntimeCompiler;
}());
exports.RuntimeCompiler = RuntimeCompiler;
var CompiledTemplate = (function () {
    function CompiledTemplate() {
        var _this = this;
        this.viewFactory = null;
        this.proxyViewFactory = function (viewUtils, childInjector, contextEl) {
            return _this.viewFactory(viewUtils, childInjector, contextEl);
        };
    }
    CompiledTemplate.prototype.init = function (viewFactory) { this.viewFactory = viewFactory; };
    return CompiledTemplate;
}());
function assertComponent(meta) {
    if (!meta.isComponent) {
        throw new exceptions_1.BaseException("Could not compile '" + meta.type.name + "' because it is not a component.");
    }
}

},{"../src/facade/async":85,"../src/facade/collection":87,"../src/facade/exceptions":89,"../src/facade/lang":90,"./compile_metadata":76,"./config":78,"./directive_normalizer":80,"./metadata_resolver":97,"./output/interpretive_view":102,"./output/output_ast":103,"./output/output_interpreter":104,"./output/output_jit":105,"./style_compiler":116,"./template_parser":119,"./view_compiler/view_compiler":137,"./xhr":139,"@angular/core":140}],112:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var core_private_1 = require('../../core_private');
var lang_1 = require('../facade/lang');
var collection_1 = require('../facade/collection');
var element_schema_registry_1 = require('./element_schema_registry');
var EVENT = 'event';
var BOOLEAN = 'boolean';
var NUMBER = 'number';
var STRING = 'string';
var OBJECT = 'object';
/**
 * This array represents the DOM schema. It encodes inheritance, properties, and events.
 *
 * ## Overview
 *
 * Each line represents one kind of element. The `element_inheritance` and properties are joined
 * using `element_inheritance|preperties` syntax.
 *
 * ## Element Inheritance
 *
 * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
 * Here the individual elements are separated by `,` (commas). Every element in the list
 * has identical properties.
 *
 * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
 * specified then `""` (blank) element is assumed.
 *
 * NOTE: The blank element inherits from root `*` element, the super element of all elements.
 *
 * NOTE an element prefix such as `@svg:` has no special meaning to the schema.
 *
 * ## Properties
 *
 * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
 * by a special character designating its type:
 *
 * - (no prefix): property is a string.
 * - `*`: property represents an event.
 * - `!`: property is a boolean.
 * - `#`: property is a number.
 * - `%`: property is an object.
 *
 * ## Query
 *
 * The class creates an internal squas representaino which allows to easily answer the query of
 * if a given property exist on a given element.
 *
 * NOTE: We don't yet support querying for types or events.
 * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder.
 */
var SCHEMA = 
/*@ts2dart_const*/ ([
    '*|%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',
    '^*|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*autocomplete,*autocompleteerror,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
    'media|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,#volume',
    '@svg:^*|*abort,*autocomplete,*autocompleteerror,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
    '@svg:graphics^@svg:|',
    '@svg:animation^@svg:|*begin,*end,*repeat',
    '@svg:geometry^@svg:|',
    '@svg:componentTransferFunction^@svg:|',
    '@svg:gradient^@svg:|',
    '@svg:textContent^@svg:graphics|',
    '@svg:textPositioning^@svg:textContent|',
    'a|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,rel,rev,search,shape,target,text,type,username',
    'area|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,search,shape,target,username',
    'audio^media|',
    'br|clear',
    'base|href,target',
    'body|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
    'button|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
    'canvas|#height,#width',
    'content|select',
    'dl|!compact',
    'datalist|',
    'details|!open',
    'dialog|!open,returnValue',
    'dir|!compact',
    'div|align',
    'embed|align,height,name,src,type,width',
    'fieldset|!disabled,name',
    'font|color,face,size',
    'form|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
    'frame|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
    'frameset|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
    'hr|align,color,!noShade,size,width',
    'head|',
    'h1,h2,h3,h4,h5,h6|align',
    'html|version',
    'iframe|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,%sandbox,scrolling,src,srcdoc,width',
    'img|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,sizes,src,srcset,useMap,#vspace,#width',
    'input|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
    'keygen|!autofocus,challenge,!disabled,keytype,name',
    'li|type,#value',
    'label|htmlFor',
    'legend|align',
    'link|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',
    'map|name',
    'marquee|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
    'menu|!compact',
    'meta|content,httpEquiv,name,scheme',
    'meter|#high,#low,#max,#min,#optimum,#value',
    'ins,del|cite,dateTime',
    'ol|!compact,!reversed,#start,type',
    'object|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
    'optgroup|!disabled,label',
    'option|!defaultSelected,!disabled,label,!selected,text,value',
    'output|defaultValue,%htmlFor,name,value',
    'p|align',
    'param|name,type,value,valueType',
    'picture|',
    'pre|#width',
    'progress|#max,#value',
    'q,blockquote,cite|',
    'script|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
    'select|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
    'shadow|',
    'source|media,sizes,src,srcset,type',
    'span|',
    'style|!disabled,media,type',
    'caption|align',
    'th,td|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
    'col,colgroup|align,ch,chOff,#span,vAlign,width',
    'table|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
    'tr|align,bgColor,ch,chOff,vAlign',
    'tfoot,thead,tbody|align,ch,chOff,vAlign',
    'template|',
    'textarea|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
    'title|text',
    'track|!default,kind,label,src,srclang',
    'ul|!compact,type',
    'unknown|',
    'video^media|#height,poster,#width',
    '@svg:a^@svg:graphics|',
    '@svg:animate^@svg:animation|',
    '@svg:animateMotion^@svg:animation|',
    '@svg:animateTransform^@svg:animation|',
    '@svg:circle^@svg:geometry|',
    '@svg:clipPath^@svg:graphics|',
    '@svg:cursor^@svg:|',
    '@svg:defs^@svg:graphics|',
    '@svg:desc^@svg:|',
    '@svg:discard^@svg:|',
    '@svg:ellipse^@svg:geometry|',
    '@svg:feBlend^@svg:|',
    '@svg:feColorMatrix^@svg:|',
    '@svg:feComponentTransfer^@svg:|',
    '@svg:feComposite^@svg:|',
    '@svg:feConvolveMatrix^@svg:|',
    '@svg:feDiffuseLighting^@svg:|',
    '@svg:feDisplacementMap^@svg:|',
    '@svg:feDistantLight^@svg:|',
    '@svg:feDropShadow^@svg:|',
    '@svg:feFlood^@svg:|',
    '@svg:feFuncA^@svg:componentTransferFunction|',
    '@svg:feFuncB^@svg:componentTransferFunction|',
    '@svg:feFuncG^@svg:componentTransferFunction|',
    '@svg:feFuncR^@svg:componentTransferFunction|',
    '@svg:feGaussianBlur^@svg:|',
    '@svg:feImage^@svg:|',
    '@svg:feMerge^@svg:|',
    '@svg:feMergeNode^@svg:|',
    '@svg:feMorphology^@svg:|',
    '@svg:feOffset^@svg:|',
    '@svg:fePointLight^@svg:|',
    '@svg:feSpecularLighting^@svg:|',
    '@svg:feSpotLight^@svg:|',
    '@svg:feTile^@svg:|',
    '@svg:feTurbulence^@svg:|',
    '@svg:filter^@svg:|',
    '@svg:foreignObject^@svg:graphics|',
    '@svg:g^@svg:graphics|',
    '@svg:image^@svg:graphics|',
    '@svg:line^@svg:geometry|',
    '@svg:linearGradient^@svg:gradient|',
    '@svg:mpath^@svg:|',
    '@svg:marker^@svg:|',
    '@svg:mask^@svg:|',
    '@svg:metadata^@svg:|',
    '@svg:path^@svg:geometry|',
    '@svg:pattern^@svg:|',
    '@svg:polygon^@svg:geometry|',
    '@svg:polyline^@svg:geometry|',
    '@svg:radialGradient^@svg:gradient|',
    '@svg:rect^@svg:geometry|',
    '@svg:svg^@svg:graphics|#currentScale,#zoomAndPan',
    '@svg:script^@svg:|type',
    '@svg:set^@svg:animation|',
    '@svg:stop^@svg:|',
    '@svg:style^@svg:|!disabled,media,title,type',
    '@svg:switch^@svg:graphics|',
    '@svg:symbol^@svg:|',
    '@svg:tspan^@svg:textPositioning|',
    '@svg:text^@svg:textPositioning|',
    '@svg:textPath^@svg:textContent|',
    '@svg:title^@svg:|',
    '@svg:use^@svg:graphics|',
    '@svg:view^@svg:|#zoomAndPan'
]);
var attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
};
var DomElementSchemaRegistry = (function (_super) {
    __extends(DomElementSchemaRegistry, _super);
    function DomElementSchemaRegistry() {
        var _this = this;
        _super.call(this);
        this.schema = {};
        SCHEMA.forEach(function (encodedType) {
            var parts = encodedType.split('|');
            var properties = parts[1].split(',');
            var typeParts = (parts[0] + '^').split('^');
            var typeName = typeParts[0];
            var type = {};
            typeName.split(',').forEach(function (tag) { return _this.schema[tag] = type; });
            var superType = _this.schema[typeParts[1]];
            if (lang_1.isPresent(superType)) {
                collection_1.StringMapWrapper.forEach(superType, function (v, k) { return type[k] = v; });
            }
            properties.forEach(function (property) {
                if (property == '') {
                }
                else if (property.startsWith('*')) {
                }
                else if (property.startsWith('!')) {
                    type[property.substring(1)] = BOOLEAN;
                }
                else if (property.startsWith('#')) {
                    type[property.substring(1)] = NUMBER;
                }
                else if (property.startsWith('%')) {
                    type[property.substring(1)] = OBJECT;
                }
                else {
                    type[property] = STRING;
                }
            });
        });
    }
    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) {
        if (tagName.indexOf('-') !== -1) {
            // can't tell now as we don't know which properties a custom element will get
            // once it is instantiated
            return true;
        }
        else {
            var elementProperties = this.schema[tagName.toLowerCase()];
            if (!lang_1.isPresent(elementProperties)) {
                elementProperties = this.schema['unknown'];
            }
            return lang_1.isPresent(elementProperties[propName]);
        }
    };
    /**
     * securityContext returns the security context for the given property on the given DOM tag.
     *
     * Tag and property name are statically known and cannot change at runtime, i.e. it is not
     * possible to bind a value into a changing attribute or tag name.
     *
     * The filtering is white list based. All attributes in the schema above are assumed to have the
     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
     * attack vectors are assigned their appropriate context.
     */
    DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName) {
        // TODO(martinprobst): Fill in missing properties.
        if (propName === 'style')
            return core_private_1.SecurityContext.STYLE;
        if (tagName === 'a' && propName === 'href')
            return core_private_1.SecurityContext.URL;
        if (propName === 'innerHTML')
            return core_private_1.SecurityContext.HTML;
        return core_private_1.SecurityContext.NONE;
    };
    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) {
        var mappedPropName = collection_1.StringMapWrapper.get(attrToPropMap, propName);
        return lang_1.isPresent(mappedPropName) ? mappedPropName : propName;
    };
    DomElementSchemaRegistry.decorators = [
        { type: core_1.Injectable },
    ];
    DomElementSchemaRegistry.ctorParameters = [];
    return DomElementSchemaRegistry;
}(element_schema_registry_1.ElementSchemaRegistry));
exports.DomElementSchemaRegistry = DomElementSchemaRegistry;

},{"../../core_private":72,"../facade/collection":87,"../facade/lang":90,"./element_schema_registry":113,"@angular/core":140}],113:[function(require,module,exports){
"use strict";
var ElementSchemaRegistry = (function () {
    function ElementSchemaRegistry() {
    }
    return ElementSchemaRegistry;
}());
exports.ElementSchemaRegistry = ElementSchemaRegistry;

},{}],114:[function(require,module,exports){
"use strict";
var collection_1 = require('../src/facade/collection');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var _EMPTY_ATTR_VALUE = '';
// TODO: Can't use `const` here as
// in Dart this is not transpiled into `final` yet...
var _SELECTOR_REGEXP = lang_1.RegExpWrapper.create('(\\:not\\()|' +
    '([-\\w]+)|' +
    '(?:\\.([-\\w]+))|' +
    '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' +
    '(\\))|' +
    '(\\s*,\\s*)'); // ","
/**
 * A css selector contains an element name,
 * css classes and attribute/value pairs with the purpose
 * of selecting subsets out of them.
 */
var CssSelector = (function () {
    function CssSelector() {
        this.element = null;
        this.classNames = [];
        this.attrs = [];
        this.notSelectors = [];
    }
    CssSelector.parse = function (selector) {
        var results = [];
        var _addResult = function (res, cssSel) {
            if (cssSel.notSelectors.length > 0 && lang_1.isBlank(cssSel.element) &&
                collection_1.ListWrapper.isEmpty(cssSel.classNames) && collection_1.ListWrapper.isEmpty(cssSel.attrs)) {
                cssSel.element = "*";
            }
            res.push(cssSel);
        };
        var cssSelector = new CssSelector();
        var matcher = lang_1.RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
        var match;
        var current = cssSelector;
        var inNot = false;
        while (lang_1.isPresent(match = lang_1.RegExpMatcherWrapper.next(matcher))) {
            if (lang_1.isPresent(match[1])) {
                if (inNot) {
                    throw new exceptions_1.BaseException('Nesting :not is not allowed in a selector');
                }
                inNot = true;
                current = new CssSelector();
                cssSelector.notSelectors.push(current);
            }
            if (lang_1.isPresent(match[2])) {
                current.setElement(match[2]);
            }
            if (lang_1.isPresent(match[3])) {
                current.addClassName(match[3]);
            }
            if (lang_1.isPresent(match[4])) {
                current.addAttribute(match[4], match[5]);
            }
            if (lang_1.isPresent(match[6])) {
                inNot = false;
                current = cssSelector;
            }
            if (lang_1.isPresent(match[7])) {
                if (inNot) {
                    throw new exceptions_1.BaseException('Multiple selectors in :not are not supported');
                }
                _addResult(results, cssSelector);
                cssSelector = current = new CssSelector();
            }
        }
        _addResult(results, cssSelector);
        return results;
    };
    CssSelector.prototype.isElementSelector = function () {
        return lang_1.isPresent(this.element) && collection_1.ListWrapper.isEmpty(this.classNames) &&
            collection_1.ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
    };
    CssSelector.prototype.setElement = function (element) {
        if (element === void 0) { element = null; }
        this.element = element;
    };
    /** Gets a template string for an element that matches the selector. */
    CssSelector.prototype.getMatchingElementTemplate = function () {
        var tagName = lang_1.isPresent(this.element) ? this.element : 'div';
        var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
        var attrs = '';
        for (var i = 0; i < this.attrs.length; i += 2) {
            var attrName = this.attrs[i];
            var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
            attrs += " " + attrName + attrValue;
        }
        return "<" + tagName + classAttr + attrs + "></" + tagName + ">";
    };
    CssSelector.prototype.addAttribute = function (name, value) {
        if (value === void 0) { value = _EMPTY_ATTR_VALUE; }
        this.attrs.push(name);
        if (lang_1.isPresent(value)) {
            value = value.toLowerCase();
        }
        else {
            value = _EMPTY_ATTR_VALUE;
        }
        this.attrs.push(value);
    };
    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
    CssSelector.prototype.toString = function () {
        var res = '';
        if (lang_1.isPresent(this.element)) {
            res += this.element;
        }
        if (lang_1.isPresent(this.classNames)) {
            for (var i = 0; i < this.classNames.length; i++) {
                res += '.' + this.classNames[i];
            }
        }
        if (lang_1.isPresent(this.attrs)) {
            for (var i = 0; i < this.attrs.length;) {
                var attrName = this.attrs[i++];
                var attrValue = this.attrs[i++];
                res += '[' + attrName;
                if (attrValue.length > 0) {
                    res += '=' + attrValue;
                }
                res += ']';
            }
        }
        this.notSelectors.forEach(function (notSelector) { return res += ":not(" + notSelector + ")"; });
        return res;
    };
    return CssSelector;
}());
exports.CssSelector = CssSelector;
/**
 * Reads a list of CssSelectors and allows to calculate which ones
 * are contained in a given CssSelector.
 */
var SelectorMatcher = (function () {
    function SelectorMatcher() {
        this._elementMap = new collection_1.Map();
        this._elementPartialMap = new collection_1.Map();
        this._classMap = new collection_1.Map();
        this._classPartialMap = new collection_1.Map();
        this._attrValueMap = new collection_1.Map();
        this._attrValuePartialMap = new collection_1.Map();
        this._listContexts = [];
    }
    SelectorMatcher.createNotMatcher = function (notSelectors) {
        var notMatcher = new SelectorMatcher();
        notMatcher.addSelectables(notSelectors, null);
        return notMatcher;
    };
    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
        var listContext = null;
        if (cssSelectors.length > 1) {
            listContext = new SelectorListContext(cssSelectors);
            this._listContexts.push(listContext);
        }
        for (var i = 0; i < cssSelectors.length; i++) {
            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
        }
    };
    /**
     * Add an object that can be found later on by calling `match`.
     * @param cssSelector A css selector
     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
     */
    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
        var matcher = this;
        var element = cssSelector.element;
        var classNames = cssSelector.classNames;
        var attrs = cssSelector.attrs;
        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
        if (lang_1.isPresent(element)) {
            var isTerminal = attrs.length === 0 && classNames.length === 0;
            if (isTerminal) {
                this._addTerminal(matcher._elementMap, element, selectable);
            }
            else {
                matcher = this._addPartial(matcher._elementPartialMap, element);
            }
        }
        if (lang_1.isPresent(classNames)) {
            for (var index = 0; index < classNames.length; index++) {
                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
                var className = classNames[index];
                if (isTerminal) {
                    this._addTerminal(matcher._classMap, className, selectable);
                }
                else {
                    matcher = this._addPartial(matcher._classPartialMap, className);
                }
            }
        }
        if (lang_1.isPresent(attrs)) {
            for (var index = 0; index < attrs.length;) {
                var isTerminal = index === attrs.length - 2;
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                if (isTerminal) {
                    var terminalMap = matcher._attrValueMap;
                    var terminalValuesMap = terminalMap.get(attrName);
                    if (lang_1.isBlank(terminalValuesMap)) {
                        terminalValuesMap = new collection_1.Map();
                        terminalMap.set(attrName, terminalValuesMap);
                    }
                    this._addTerminal(terminalValuesMap, attrValue, selectable);
                }
                else {
                    var parttialMap = matcher._attrValuePartialMap;
                    var partialValuesMap = parttialMap.get(attrName);
                    if (lang_1.isBlank(partialValuesMap)) {
                        partialValuesMap = new collection_1.Map();
                        parttialMap.set(attrName, partialValuesMap);
                    }
                    matcher = this._addPartial(partialValuesMap, attrValue);
                }
            }
        }
    };
    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
        var terminalList = map.get(name);
        if (lang_1.isBlank(terminalList)) {
            terminalList = [];
            map.set(name, terminalList);
        }
        terminalList.push(selectable);
    };
    SelectorMatcher.prototype._addPartial = function (map, name) {
        var matcher = map.get(name);
        if (lang_1.isBlank(matcher)) {
            matcher = new SelectorMatcher();
            map.set(name, matcher);
        }
        return matcher;
    };
    /**
     * Find the objects that have been added via `addSelectable`
     * whose css selector is contained in the given css selector.
     * @param cssSelector A css selector
     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
     * @return boolean true if a match was found
    */
    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
        var result = false;
        var element = cssSelector.element;
        var classNames = cssSelector.classNames;
        var attrs = cssSelector.attrs;
        for (var i = 0; i < this._listContexts.length; i++) {
            this._listContexts[i].alreadyMatched = false;
        }
        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
            result;
        if (lang_1.isPresent(classNames)) {
            for (var index = 0; index < classNames.length; index++) {
                var className = classNames[index];
                result =
                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                result =
                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                        result;
            }
        }
        if (lang_1.isPresent(attrs)) {
            for (var index = 0; index < attrs.length;) {
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                var terminalValuesMap = this._attrValueMap.get(attrName);
                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                    result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
                        result;
                }
                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) ||
                    result;
                var partialValuesMap = this._attrValuePartialMap.get(attrName);
                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                    result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
                        result;
                }
                result =
                    this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
            }
        }
        return result;
    };
    /** @internal */
    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
            return false;
        }
        var selectables = map.get(name);
        var starSelectables = map.get("*");
        if (lang_1.isPresent(starSelectables)) {
            selectables = selectables.concat(starSelectables);
        }
        if (lang_1.isBlank(selectables)) {
            return false;
        }
        var selectable;
        var result = false;
        for (var index = 0; index < selectables.length; index++) {
            selectable = selectables[index];
            result = selectable.finalize(cssSelector, matchedCallback) || result;
        }
        return result;
    };
    /** @internal */
    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback /*: (c: CssSelector, a: any) => void*/) {
        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
            return false;
        }
        var nestedSelector = map.get(name);
        if (lang_1.isBlank(nestedSelector)) {
            return false;
        }
        // TODO(perf): get rid of recursion and measure again
        // TODO(perf): don't pass the whole selector into the recursion,
        // but only the not processed parts
        return nestedSelector.match(cssSelector, matchedCallback);
    };
    return SelectorMatcher;
}());
exports.SelectorMatcher = SelectorMatcher;
var SelectorListContext = (function () {
    function SelectorListContext(selectors) {
        this.selectors = selectors;
        this.alreadyMatched = false;
    }
    return SelectorListContext;
}());
exports.SelectorListContext = SelectorListContext;
// Store context to pass back selector and context when a selector is matched
var SelectorContext = (function () {
    function SelectorContext(selector, cbContext, listContext) {
        this.selector = selector;
        this.cbContext = cbContext;
        this.listContext = listContext;
        this.notSelectors = selector.notSelectors;
    }
    SelectorContext.prototype.finalize = function (cssSelector, callback) {
        var result = true;
        if (this.notSelectors.length > 0 &&
            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
            result = !notMatcher.match(cssSelector, null);
        }
        if (result && lang_1.isPresent(callback) &&
            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
            if (lang_1.isPresent(this.listContext)) {
                this.listContext.alreadyMatched = true;
            }
            callback(this.selector, this.cbContext);
        }
        return result;
    };
    return SelectorContext;
}());
exports.SelectorContext = SelectorContext;

},{"../src/facade/collection":87,"../src/facade/exceptions":89,"../src/facade/lang":90}],115:[function(require,module,exports){
"use strict";
var collection_1 = require('../src/facade/collection');
var lang_1 = require('../src/facade/lang');
/**
 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
 *
 * Please make sure to keep to edits in sync with the source file.
 *
 * Source:
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 *
 * The original file level comment is reproduced below
 */
/*
  This is a limited shim for ShadowDOM css styling.
  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

  The intention here is to support only the styling features which can be
  relatively simply implemented. The goal is to allow users to avoid the
  most obvious pitfalls and do so without compromising performance significantly.
  For ShadowDOM styling that's not covered here, a set of best practices
  can be provided that should allow users to accomplish more complex styling.

  The following is a list of specific ShadowDOM styling features and a brief
  discussion of the approach used to shim.

  Shimmed features:

  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
  element using the :host rule. To shim this feature, the :host styles are
  reformatted and prefixed with a given scope name and promoted to a
  document level stylesheet.
  For example, given a scope name of .foo, a rule like this:

    :host {
        background: red;
      }
    }

  becomes:

    .foo {
      background: red;
    }

  * encapsultion: Styles defined within ShadowDOM, apply only to
  dom inside the ShadowDOM. Polymer uses one of two techniques to implement
  this feature.

  By default, rules are prefixed with the host element tag name
  as a descendant selector. This ensures styling does not leak out of the 'top'
  of the element's ShadowDOM. For example,

  div {
      font-weight: bold;
    }

  becomes:

  x-foo div {
      font-weight: bold;
    }

  becomes:


  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
  selectors are scoped by adding an attribute selector suffix to each
  simple selector that contains the host element tag name. Each element
  in the element's ShadowDOM template is also given the scope attribute.
  Thus, these rules match only elements that have the scope attribute.
  For example, given a scope name of x-foo, a rule like this:

    div {
      font-weight: bold;
    }

  becomes:

    div[x-foo] {
      font-weight: bold;
    }

  Note that elements that are dynamically added to a scope must have the scope
  selector added to them manually.

  * upper/lower bound encapsulation: Styles which are defined outside a
  shadowRoot should not cross the ShadowDOM boundary and should not apply
  inside a shadowRoot.

  This styling behavior is not emulated. Some possible ways to do this that
  were rejected due to complexity and/or performance concerns include: (1) reset
  every possible property for every possible selector for a given scope name;
  (2) re-implement css in javascript.

  As an alternative, users should make sure to use selectors
  specific to the scope in which they are working.

  * ::distributed: This behavior is not emulated. It's often not necessary
  to style the contents of a specific insertion point and instead, descendants
  of the host element can be styled selectively. Users can also create an
  extra node around an insertion point and style that node's contents
  via descendent selectors. For example, with a shadowRoot like this:

    <style>
      ::content(div) {
        background: red;
      }
    </style>
    <content></content>

  could become:

    <style>
      / *@polyfill .content-container div * /
      ::content(div) {
        background: red;
      }
    </style>
    <div class="content-container">
      <content></content>
    </div>

  Note the use of @polyfill in the comment above a ShadowDOM specific style
  declaration. This is a directive to the styling shim to use the selector
  in comments in lieu of the next selector when running under polyfill.
*/
var ShadowCss = (function () {
    function ShadowCss() {
        this.strictStyling = true;
    }
    /*
    * Shim some cssText with the given selector. Returns cssText that can
    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
    *
    * When strictStyling is true:
    * - selector is the attribute added to all elements inside the host,
    * - hostSelector is the attribute added to the host itself.
    */
    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
        if (hostSelector === void 0) { hostSelector = ''; }
        cssText = stripComments(cssText);
        cssText = this._insertDirectives(cssText);
        return this._scopeCssText(cssText, selector, hostSelector);
    };
    ShadowCss.prototype._insertDirectives = function (cssText) {
        cssText = this._insertPolyfillDirectivesInCssText(cssText);
        return this._insertPolyfillRulesInCssText(cssText);
    };
    /*
     * Process styles to convert native ShadowDOM rules that will trip
     * up the css parser; we rely on decorating the stylesheet with inert rules.
     *
     * For example, we convert this rule:
     *
     * polyfill-next-selector { content: ':host menu-item'; }
     * ::content menu-item {
     *
     * to this:
     *
     * scopeName menu-item {
     *
    **/
    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function (m) { return m[1] + '{'; });
    };
    /*
     * Process styles to add rules which will only apply under the polyfill
     *
     * For example, we convert this rule:
     *
     * polyfill-rule {
     *   content: ':host menu-item';
     * ...
     * }
     *
     * to this:
     *
     * scopeName menu-item {...}
     *
    **/
    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function (m) {
            var rule = m[0];
            rule = lang_1.StringWrapper.replace(rule, m[1], '');
            rule = lang_1.StringWrapper.replace(rule, m[2], '');
            return m[3] + rule;
        });
    };
    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
     *
     *  .foo {... }
     *
     *  and converts this to
     *
     *  scopeName .foo { ... }
    */
    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
        var unscoped = this._extractUnscopedRulesFromCssText(cssText);
        cssText = this._insertPolyfillHostInCssText(cssText);
        cssText = this._convertColonHost(cssText);
        cssText = this._convertColonHostContext(cssText);
        cssText = this._convertShadowDOMSelectors(cssText);
        if (lang_1.isPresent(scopeSelector)) {
            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
        }
        cssText = cssText + '\n' + unscoped;
        return cssText.trim();
    };
    /*
     * Process styles to add rules which will only apply under the polyfill
     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
     * occasions, e.g. -webkit-calc on Safari.)
     * For example, we convert this rule:
     *
     * @polyfill-unscoped-rule {
     *   content: 'menu-item';
     * ... }
     *
     * to this:
     *
     * menu-item {...}
     *
    **/
    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
        // Difference with webcomponents.js: does not handle comments
        var r = '', m;
        var matcher = lang_1.RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
        while (lang_1.isPresent(m = lang_1.RegExpMatcherWrapper.next(matcher))) {
            var rule = m[0];
            rule = lang_1.StringWrapper.replace(rule, m[2], '');
            rule = lang_1.StringWrapper.replace(rule, m[1], m[3]);
            r += rule + '\n\n';
        }
        return r;
    };
    /*
     * convert a rule like :host(.foo) > .bar { }
     *
     * to
     *
     * scopeName.foo > .bar
    */
    ShadowCss.prototype._convertColonHost = function (cssText) {
        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
    };
    /*
     * convert a rule like :host-context(.foo) > .bar { }
     *
     * to
     *
     * scopeName.foo > .bar, .foo scopeName > .bar { }
     *
     * and
     *
     * :host-context(.foo:host) .bar { ... }
     *
     * to
     *
     * scopeName.foo .bar { ... }
    */
    ShadowCss.prototype._convertColonHostContext = function (cssText) {
        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
    };
    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
        // p1 = :host, p2 = contents of (), p3 rest of rule
        return lang_1.StringWrapper.replaceAllMapped(cssText, regExp, function (m) {
            if (lang_1.isPresent(m[2])) {
                var parts = m[2].split(','), r = [];
                for (var i = 0; i < parts.length; i++) {
                    var p = parts[i];
                    if (lang_1.isBlank(p))
                        break;
                    p = p.trim();
                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
            }
            else {
                return _polyfillHostNoCombinator + m[3];
            }
        });
    };
    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
        if (lang_1.StringWrapper.contains(part, _polyfillHost)) {
            return this._colonHostPartReplacer(host, part, suffix);
        }
        else {
            return host + part + suffix + ', ' + part + ' ' + host + suffix;
        }
    };
    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
        return host + lang_1.StringWrapper.replace(part, _polyfillHost, '') + suffix;
    };
    /*
     * Convert combinators like ::shadow and pseudo-elements like ::content
     * by replacing with space.
    */
    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
        for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
            cssText = lang_1.StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
        }
        return cssText;
    };
    // change a selector like 'div' to 'name div'
    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {
        var _this = this;
        return processRules(cssText, function (rule) {
            var selector = rule.selector;
            var content = rule.content;
            if (rule.selector[0] != '@' || rule.selector.startsWith('@page')) {
                selector =
                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
            }
            else if (rule.selector.startsWith('@media')) {
                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
            }
            return new CssRule(selector, content);
        });
    };
    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
        var r = [], parts = selector.split(',');
        for (var i = 0; i < parts.length; i++) {
            var p = parts[i].trim();
            var deepParts = lang_1.StringWrapper.split(p, _shadowDeepSelectors);
            var shallowPart = deepParts[0];
            if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                deepParts[0] = strict && !lang_1.StringWrapper.contains(shallowPart, _polyfillHostNoCombinator) ?
                    this._applyStrictSelectorScope(shallowPart, scopeSelector) :
                    this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
            }
            // replace /deep/ with a space for child selectors
            r.push(deepParts.join(' '));
        }
        return r.join(', ');
    };
    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
        var re = this._makeScopeMatcher(scopeSelector);
        return !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(re, selector));
    };
    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
        var lre = /\[/g;
        var rre = /\]/g;
        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, lre, '\\[');
        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, rre, '\\]');
        return lang_1.RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    };
    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
        // Difference from webcomponentsjs: scopeSelector could not be an array
        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    };
    // scope via name and [is=name]
    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
        if (lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
            var replaceBy = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
            selector = lang_1.StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
            return lang_1.StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
        }
        else {
            return scopeSelector + ' ' + selector;
        }
    };
    // return a selector with [name] suffix on each simple selector
    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector) {
        var isRe = /\[is=([^\]]*)\]/g;
        scopeSelector = lang_1.StringWrapper.replaceAllMapped(scopeSelector, isRe, function (m) { return m[1]; });
        var splits = [' ', '>', '+', '~'], scoped = selector, attrName = '[' + scopeSelector + ']';
        for (var i = 0; i < splits.length; i++) {
            var sep = splits[i];
            var parts = scoped.split(sep);
            scoped = parts.map(function (p) {
                // remove :host since it should be unnecessary
                var t = lang_1.StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
                if (t.length > 0 && !collection_1.ListWrapper.contains(splits, t) &&
                    !lang_1.StringWrapper.contains(t, attrName)) {
                    var re = /([^:]*)(:*)(.*)/g;
                    var m = lang_1.RegExpWrapper.firstMatch(re, t);
                    if (lang_1.isPresent(m)) {
                        p = m[1] + attrName + m[2] + m[3];
                    }
                }
                return p;
            })
                .join(sep);
        }
        return scoped;
    };
    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
        return selector;
    };
    return ShadowCss;
}());
exports.ShadowCss = ShadowCss;
var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
var _polyfillHost = '-shadowcsshost';
// note: :host-context pre-processed to -shadowcsshostcontext.
var _polyfillHostContext = '-shadowcsscontext';
var _parenSuffix = ')(?:\\((' +
    '(?:\\([^)(]*\\)|[^)(]*)+?' +
    ')\\))?([^,{]*)';
var _cssColonHostRe = lang_1.RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
var _cssColonHostContextRe = lang_1.RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
var _shadowDOMSelectorsRe = [
    /::shadow/g,
    /::content/g,
    // Deprecated selectors
    // TODO(vicb): see https://github.com/angular/clang-format/issues/16
    // clang-format off
    /\/shadow-deep\//g,
    /\/shadow\//g,
];
var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
var _polyfillHostRe = lang_1.RegExpWrapper.create(_polyfillHost, 'im');
var _colonHostRe = /:host/gim;
var _colonHostContextRe = /:host-context/gim;
var _commentRe = /\/\*[\s\S]*?\*\//g;
function stripComments(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, _commentRe, function (_) { return ''; });
}
var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
var _curlyRe = /([{}])/g;
var OPEN_CURLY = '{';
var CLOSE_CURLY = '}';
var BLOCK_PLACEHOLDER = '%BLOCK%';
var CssRule = (function () {
    function CssRule(selector, content) {
        this.selector = selector;
        this.content = content;
    }
    return CssRule;
}());
exports.CssRule = CssRule;
function processRules(input, ruleCallback) {
    var inputWithEscapedBlocks = escapeBlocks(input);
    var nextBlockIndex = 0;
    return lang_1.StringWrapper.replaceAllMapped(inputWithEscapedBlocks.escapedString, _ruleRe, function (m) {
        var selector = m[2];
        var content = '';
        var suffix = m[4];
        var contentPrefix = '';
        if (lang_1.isPresent(m[4]) && m[4].startsWith('{' + BLOCK_PLACEHOLDER)) {
            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
            suffix = m[4].substring(BLOCK_PLACEHOLDER.length + 1);
            contentPrefix = '{';
        }
        var rule = ruleCallback(new CssRule(selector, content));
        return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
    });
}
exports.processRules = processRules;
var StringWithEscapedBlocks = (function () {
    function StringWithEscapedBlocks(escapedString, blocks) {
        this.escapedString = escapedString;
        this.blocks = blocks;
    }
    return StringWithEscapedBlocks;
}());
function escapeBlocks(input) {
    var inputParts = lang_1.StringWrapper.split(input, _curlyRe);
    var resultParts = [];
    var escapedBlocks = [];
    var bracketCount = 0;
    var currentBlockParts = [];
    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
        var part = inputParts[partIndex];
        if (part == CLOSE_CURLY) {
            bracketCount--;
        }
        if (bracketCount > 0) {
            currentBlockParts.push(part);
        }
        else {
            if (currentBlockParts.length > 0) {
                escapedBlocks.push(currentBlockParts.join(''));
                resultParts.push(BLOCK_PLACEHOLDER);
                currentBlockParts = [];
            }
            resultParts.push(part);
        }
        if (part == OPEN_CURLY) {
            bracketCount++;
        }
    }
    if (currentBlockParts.length > 0) {
        escapedBlocks.push(currentBlockParts.join(''));
        resultParts.push(BLOCK_PLACEHOLDER);
    }
    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
}

},{"../src/facade/collection":87,"../src/facade/lang":90}],116:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var compile_metadata_1 = require('./compile_metadata');
var o = require('./output/output_ast');
var shadow_css_1 = require('./shadow_css');
var url_resolver_1 = require('./url_resolver');
var style_url_resolver_1 = require('./style_url_resolver');
var lang_1 = require('../src/facade/lang');
var COMPONENT_VARIABLE = '%COMP%';
var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
var StylesCompileDependency = (function () {
    function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {
        this.moduleUrl = moduleUrl;
        this.isShimmed = isShimmed;
        this.valuePlaceholder = valuePlaceholder;
    }
    return StylesCompileDependency;
}());
exports.StylesCompileDependency = StylesCompileDependency;
var StylesCompileResult = (function () {
    function StylesCompileResult(statements, stylesVar, dependencies) {
        this.statements = statements;
        this.stylesVar = stylesVar;
        this.dependencies = dependencies;
    }
    return StylesCompileResult;
}());
exports.StylesCompileResult = StylesCompileResult;
var StyleCompiler = (function () {
    function StyleCompiler(_urlResolver) {
        this._urlResolver = _urlResolver;
        this._shadowCss = new shadow_css_1.ShadowCss();
    }
    StyleCompiler.prototype.compileComponent = function (comp) {
        var shim = comp.template.encapsulation === core_1.ViewEncapsulation.Emulated;
        return this._compileStyles(getStylesVarName(comp), comp.template.styles, comp.template.styleUrls, shim);
    };
    StyleCompiler.prototype.compileStylesheet = function (stylesheetUrl, cssText, isShimmed) {
        var styleWithImports = style_url_resolver_1.extractStyleUrls(this._urlResolver, stylesheetUrl, cssText);
        return this._compileStyles(getStylesVarName(null), [styleWithImports.style], styleWithImports.styleUrls, isShimmed);
    };
    StyleCompiler.prototype._compileStyles = function (stylesVar, plainStyles, absUrls, shim) {
        var _this = this;
        var styleExpressions = plainStyles.map(function (plainStyle) { return o.literal(_this._shimIfNeeded(plainStyle, shim)); });
        var dependencies = [];
        for (var i = 0; i < absUrls.length; i++) {
            var identifier = new compile_metadata_1.CompileIdentifierMetadata({ name: getStylesVarName(null) });
            dependencies.push(new StylesCompileDependency(absUrls[i], shim, identifier));
            styleExpressions.push(new o.ExternalExpr(identifier));
        }
        // styles variable contains plain strings and arrays of other styles arrays (recursive),
        // so we set its type to dynamic.
        var stmt = o.variable(stylesVar)
            .set(o.literalArr(styleExpressions, new o.ArrayType(o.DYNAMIC_TYPE, [o.TypeModifier.Const])))
            .toDeclStmt(null, [o.StmtModifier.Final]);
        return new StylesCompileResult([stmt], stylesVar, dependencies);
    };
    StyleCompiler.prototype._shimIfNeeded = function (style, shim) {
        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
    };
    StyleCompiler.decorators = [
        { type: core_1.Injectable },
    ];
    StyleCompiler.ctorParameters = [
        { type: url_resolver_1.UrlResolver, },
    ];
    return StyleCompiler;
}());
exports.StyleCompiler = StyleCompiler;
function getStylesVarName(component) {
    var result = "styles";
    if (lang_1.isPresent(component)) {
        result += "_" + component.type.name;
    }
    return result;
}

},{"../src/facade/lang":90,"./compile_metadata":76,"./output/output_ast":103,"./shadow_css":115,"./style_url_resolver":117,"./url_resolver":121,"@angular/core":140}],117:[function(require,module,exports){
"use strict";
// Some of the code comes from WebComponents.JS
// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js
var lang_1 = require('../src/facade/lang');
var StyleWithImports = (function () {
    function StyleWithImports(style, styleUrls) {
        this.style = style;
        this.styleUrls = styleUrls;
    }
    return StyleWithImports;
}());
exports.StyleWithImports = StyleWithImports;
function isStyleUrlResolvable(url) {
    if (lang_1.isBlank(url) || url.length === 0 || url[0] == '/')
        return false;
    var schemeMatch = lang_1.RegExpWrapper.firstMatch(_urlWithSchemaRe, url);
    return lang_1.isBlank(schemeMatch) || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
}
exports.isStyleUrlResolvable = isStyleUrlResolvable;
/**
 * Rewrites stylesheets by resolving and removing the @import urls that
 * are either relative or don't have a `package:` scheme
 */
function extractStyleUrls(resolver, baseUrl, cssText) {
    var foundUrls = [];
    var modifiedCssText = lang_1.StringWrapper.replaceAllMapped(cssText, _cssImportRe, function (m) {
        var url = lang_1.isPresent(m[1]) ? m[1] : m[2];
        if (!isStyleUrlResolvable(url)) {
            // Do not attempt to resolve non-package absolute URLs with URI scheme
            return m[0];
        }
        foundUrls.push(resolver.resolve(baseUrl, url));
        return '';
    });
    return new StyleWithImports(modifiedCssText, foundUrls);
}
exports.extractStyleUrls = extractStyleUrls;
var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
// TODO: can't use /^[^:/?#.]+:/g due to clang-format bug:
//       https://github.com/angular/angular/issues/4596
var _urlWithSchemaRe = /^([a-zA-Z\-\+\.]+):/g;

},{"../src/facade/lang":90}],118:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
/**
 * A segment of text within the template.
 */
var TextAst = (function () {
    function TextAst(value, ngContentIndex, sourceSpan) {
        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
    }
    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
    return TextAst;
}());
exports.TextAst = TextAst;
/**
 * A bound expression within the text of a template.
 */
var BoundTextAst = (function () {
    function BoundTextAst(value, ngContentIndex, sourceSpan) {
        this.value = value;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
    }
    BoundTextAst.prototype.visit = function (visitor, context) {
        return visitor.visitBoundText(this, context);
    };
    return BoundTextAst;
}());
exports.BoundTextAst = BoundTextAst;
/**
 * A plain attribute on an element.
 */
var AttrAst = (function () {
    function AttrAst(name, value, sourceSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
    return AttrAst;
}());
exports.AttrAst = AttrAst;
/**
 * A binding for an element property (e.g. `[property]="expression"`).
 */
var BoundElementPropertyAst = (function () {
    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
        this.name = name;
        this.type = type;
        this.securityContext = securityContext;
        this.value = value;
        this.unit = unit;
        this.sourceSpan = sourceSpan;
    }
    BoundElementPropertyAst.prototype.visit = function (visitor, context) {
        return visitor.visitElementProperty(this, context);
    };
    return BoundElementPropertyAst;
}());
exports.BoundElementPropertyAst = BoundElementPropertyAst;
/**
 * A binding for an element event (e.g. `(event)="handler()"`).
 */
var BoundEventAst = (function () {
    function BoundEventAst(name, target, handler, sourceSpan) {
        this.name = name;
        this.target = target;
        this.handler = handler;
        this.sourceSpan = sourceSpan;
    }
    BoundEventAst.prototype.visit = function (visitor, context) {
        return visitor.visitEvent(this, context);
    };
    Object.defineProperty(BoundEventAst.prototype, "fullName", {
        get: function () {
            if (lang_1.isPresent(this.target)) {
                return this.target + ":" + this.name;
            }
            else {
                return this.name;
            }
        },
        enumerable: true,
        configurable: true
    });
    return BoundEventAst;
}());
exports.BoundEventAst = BoundEventAst;
/**
 * A reference declaration on an element (e.g. `let someName="expression"`).
 */
var ReferenceAst = (function () {
    function ReferenceAst(name, value, sourceSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    ReferenceAst.prototype.visit = function (visitor, context) {
        return visitor.visitReference(this, context);
    };
    return ReferenceAst;
}());
exports.ReferenceAst = ReferenceAst;
/**
 * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
 */
var VariableAst = (function () {
    function VariableAst(name, value, sourceSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    VariableAst.prototype.visit = function (visitor, context) {
        return visitor.visitVariable(this, context);
    };
    return VariableAst;
}());
exports.VariableAst = VariableAst;
/**
 * An element declaration in a template.
 */
var ElementAst = (function () {
    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
        this.name = name;
        this.attrs = attrs;
        this.inputs = inputs;
        this.outputs = outputs;
        this.references = references;
        this.directives = directives;
        this.providers = providers;
        this.hasViewContainer = hasViewContainer;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
    }
    ElementAst.prototype.visit = function (visitor, context) {
        return visitor.visitElement(this, context);
    };
    return ElementAst;
}());
exports.ElementAst = ElementAst;
/**
 * A `<template>` element included in an Angular template.
 */
var EmbeddedTemplateAst = (function () {
    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
        this.attrs = attrs;
        this.outputs = outputs;
        this.references = references;
        this.variables = variables;
        this.directives = directives;
        this.providers = providers;
        this.hasViewContainer = hasViewContainer;
        this.children = children;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
    }
    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {
        return visitor.visitEmbeddedTemplate(this, context);
    };
    return EmbeddedTemplateAst;
}());
exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
/**
 * A directive property with a bound value (e.g. `*ngIf="condition").
 */
var BoundDirectivePropertyAst = (function () {
    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
        this.directiveName = directiveName;
        this.templateName = templateName;
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {
        return visitor.visitDirectiveProperty(this, context);
    };
    return BoundDirectivePropertyAst;
}());
exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
/**
 * A directive declared on an element.
 */
var DirectiveAst = (function () {
    function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
        this.directive = directive;
        this.inputs = inputs;
        this.hostProperties = hostProperties;
        this.hostEvents = hostEvents;
        this.sourceSpan = sourceSpan;
    }
    DirectiveAst.prototype.visit = function (visitor, context) {
        return visitor.visitDirective(this, context);
    };
    return DirectiveAst;
}());
exports.DirectiveAst = DirectiveAst;
/**
 * A provider declared on an element
 */
var ProviderAst = (function () {
    function ProviderAst(token, multiProvider, eager, providers, providerType, sourceSpan) {
        this.token = token;
        this.multiProvider = multiProvider;
        this.eager = eager;
        this.providers = providers;
        this.providerType = providerType;
        this.sourceSpan = sourceSpan;
    }
    ProviderAst.prototype.visit = function (visitor, context) {
        // No visit method in the visitor for now...
        return null;
    };
    return ProviderAst;
}());
exports.ProviderAst = ProviderAst;
(function (ProviderAstType) {
    ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
    ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
    ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
    ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
    ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
})(exports.ProviderAstType || (exports.ProviderAstType = {}));
var ProviderAstType = exports.ProviderAstType;
/**
 * Position where content is to be projected (instance of `<ng-content>` in a template).
 */
var NgContentAst = (function () {
    function NgContentAst(index, ngContentIndex, sourceSpan) {
        this.index = index;
        this.ngContentIndex = ngContentIndex;
        this.sourceSpan = sourceSpan;
    }
    NgContentAst.prototype.visit = function (visitor, context) {
        return visitor.visitNgContent(this, context);
    };
    return NgContentAst;
}());
exports.NgContentAst = NgContentAst;
/**
 * Enumeration of types of property bindings.
 */
(function (PropertyBindingType) {
    /**
     * A normal binding to a property (e.g. `[property]="expression"`).
     */
    PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
    /**
     * A binding to an element attribute (e.g. `[attr.name]="expression"`).
     */
    PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
    /**
     * A binding to a CSS class (e.g. `[class.name]="condition"`).
     */
    PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
    /**
     * A binding to a style rule (e.g. `[style.rule]="expression"`).
     */
    PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
})(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
var PropertyBindingType = exports.PropertyBindingType;
/**
 * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
 */
function templateVisitAll(visitor, asts, context) {
    if (context === void 0) { context = null; }
    var result = [];
    asts.forEach(function (ast) {
        var astResult = ast.visit(visitor, context);
        if (lang_1.isPresent(astResult)) {
            result.push(astResult);
        }
    });
    return result;
}
exports.templateVisitAll = templateVisitAll;

},{"../src/facade/lang":90}],119:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var collection_1 = require('../src/facade/collection');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var ast_1 = require('./expression_parser/ast');
var parser_1 = require('./expression_parser/parser');
var html_parser_1 = require('./html_parser');
var html_tags_1 = require('./html_tags');
var parse_util_1 = require('./parse_util');
var template_ast_1 = require('./template_ast');
var selector_1 = require('./selector');
var element_schema_registry_1 = require('./schema/element_schema_registry');
var template_preparser_1 = require('./template_preparser');
var style_url_resolver_1 = require('./style_url_resolver');
var html_ast_1 = require('./html_ast');
var util_1 = require('./util');
var identifiers_1 = require('./identifiers');
var provider_parser_1 = require('./provider_parser');
// Group 1 = "bind-"
// Group 2 = "var-"
// Group 3 = "let-"
// Group 4 = "ref-/#"
// Group 5 = "on-"
// Group 6 = "bindon-"
// Group 7 = the identifier after "bind-", "var-/#", or "on-"
// Group 8 = identifier inside [()]
// Group 9 = identifier inside []
// Group 10 = identifier inside ()
var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-)|(let-)|(ref-|#)|(on-)|(bindon-))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
var TEMPLATE_ELEMENT = 'template';
var TEMPLATE_ATTR = 'template';
var TEMPLATE_ATTR_PREFIX = '*';
var CLASS_ATTR = 'class';
var PROPERTY_PARTS_SEPARATOR = '.';
var ATTRIBUTE_PREFIX = 'attr';
var CLASS_PREFIX = 'class';
var STYLE_PREFIX = 'style';
var TEXT_CSS_SELECTOR = selector_1.CssSelector.parse('*')[0];
/**
 * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
 * parsed templates before compilation is invoked, allowing custom expression syntax
 * and other advanced transformations.
 *
 * This is currently an internal-only feature and not meant for general use.
 */
exports.TEMPLATE_TRANSFORMS = new core_1.OpaqueToken('TemplateTransforms');
var TemplateParseError = (function (_super) {
    __extends(TemplateParseError, _super);
    function TemplateParseError(message, span, level) {
        _super.call(this, span, message, level);
    }
    return TemplateParseError;
}(parse_util_1.ParseError));
exports.TemplateParseError = TemplateParseError;
var TemplateParseResult = (function () {
    function TemplateParseResult(templateAst, errors) {
        this.templateAst = templateAst;
        this.errors = errors;
    }
    return TemplateParseResult;
}());
exports.TemplateParseResult = TemplateParseResult;
var TemplateParser = (function () {
    function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
        this._exprParser = _exprParser;
        this._schemaRegistry = _schemaRegistry;
        this._htmlParser = _htmlParser;
        this._console = _console;
        this.transforms = transforms;
    }
    TemplateParser.prototype.parse = function (component, template, directives, pipes, templateUrl) {
        var result = this.tryParse(component, template, directives, pipes, templateUrl);
        var warnings = result.errors.filter(function (error) { return error.level === parse_util_1.ParseErrorLevel.WARNING; });
        var errors = result.errors.filter(function (error) { return error.level === parse_util_1.ParseErrorLevel.FATAL; });
        if (warnings.length > 0) {
            this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
        }
        if (errors.length > 0) {
            var errorString = errors.join('\n');
            throw new exceptions_1.BaseException("Template parse errors:\n" + errorString);
        }
        return result.templateAst;
    };
    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, templateUrl) {
        var htmlAstWithErrors = this._htmlParser.parse(template, templateUrl);
        var errors = htmlAstWithErrors.errors;
        var result;
        if (htmlAstWithErrors.rootNodes.length > 0) {
            var uniqDirectives = removeDuplicates(directives);
            var uniqPipes = removeDuplicates(pipes);
            var providerViewContext = new provider_parser_1.ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
            var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, uniqPipes, this._exprParser, this._schemaRegistry);
            result = html_ast_1.htmlVisitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
            errors = errors.concat(parseVisitor.errors).concat(providerViewContext.errors);
        }
        else {
            result = [];
        }
        if (errors.length > 0) {
            return new TemplateParseResult(result, errors);
        }
        if (lang_1.isPresent(this.transforms)) {
            this.transforms.forEach(function (transform) { result = template_ast_1.templateVisitAll(transform, result); });
        }
        return new TemplateParseResult(result, errors);
    };
    TemplateParser.decorators = [
        { type: core_1.Injectable },
    ];
    TemplateParser.ctorParameters = [
        { type: parser_1.Parser, },
        { type: element_schema_registry_1.ElementSchemaRegistry, },
        { type: html_parser_1.HtmlParser, },
        { type: core_private_1.Console, },
        { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: [exports.TEMPLATE_TRANSFORMS,] },] },
    ];
    return TemplateParser;
}());
exports.TemplateParser = TemplateParser;
var TemplateParseVisitor = (function () {
    function TemplateParseVisitor(providerViewContext, directives, pipes, _exprParser, _schemaRegistry) {
        var _this = this;
        this.providerViewContext = providerViewContext;
        this._exprParser = _exprParser;
        this._schemaRegistry = _schemaRegistry;
        this.errors = [];
        this.directivesIndex = new Map();
        this.ngContentCount = 0;
        this.selectorMatcher = new selector_1.SelectorMatcher();
        collection_1.ListWrapper.forEachWithIndex(directives, function (directive, index) {
            var selector = selector_1.CssSelector.parse(directive.selector);
            _this.selectorMatcher.addSelectables(selector, directive);
            _this.directivesIndex.set(directive, index);
        });
        this.pipesByName = new Map();
        pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });
    }
    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {
        if (level === void 0) { level = parse_util_1.ParseErrorLevel.FATAL; }
        this.errors.push(new TemplateParseError(message, sourceSpan, level));
    };
    TemplateParseVisitor.prototype._parseInterpolation = function (value, sourceSpan) {
        var sourceInfo = sourceSpan.start.toString();
        try {
            var ast = this._exprParser.parseInterpolation(value, sourceInfo);
            this._checkPipes(ast, sourceSpan);
            if (lang_1.isPresent(ast) &&
                ast.ast.expressions.length > core_private_1.MAX_INTERPOLATION_VALUES) {
                throw new exceptions_1.BaseException("Only support at most " + core_private_1.MAX_INTERPOLATION_VALUES + " interpolation values!");
            }
            return ast;
        }
        catch (e) {
            this._reportError("" + e, sourceSpan);
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseAction = function (value, sourceSpan) {
        var sourceInfo = sourceSpan.start.toString();
        try {
            var ast = this._exprParser.parseAction(value, sourceInfo);
            this._checkPipes(ast, sourceSpan);
            return ast;
        }
        catch (e) {
            this._reportError("" + e, sourceSpan);
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseBinding = function (value, sourceSpan) {
        var sourceInfo = sourceSpan.start.toString();
        try {
            var ast = this._exprParser.parseBinding(value, sourceInfo);
            this._checkPipes(ast, sourceSpan);
            return ast;
        }
        catch (e) {
            this._reportError("" + e, sourceSpan);
            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
        }
    };
    TemplateParseVisitor.prototype._parseTemplateBindings = function (value, sourceSpan) {
        var _this = this;
        var sourceInfo = sourceSpan.start.toString();
        try {
            var bindingsResult = this._exprParser.parseTemplateBindings(value, sourceInfo);
            bindingsResult.templateBindings.forEach(function (binding) {
                if (lang_1.isPresent(binding.expression)) {
                    _this._checkPipes(binding.expression, sourceSpan);
                }
            });
            bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, parse_util_1.ParseErrorLevel.WARNING); });
            return bindingsResult.templateBindings;
        }
        catch (e) {
            this._reportError("" + e, sourceSpan);
            return [];
        }
    };
    TemplateParseVisitor.prototype._checkPipes = function (ast, sourceSpan) {
        var _this = this;
        if (lang_1.isPresent(ast)) {
            var collector = new PipeCollector();
            ast.visit(collector);
            collector.pipes.forEach(function (pipeName) {
                if (!_this.pipesByName.has(pipeName)) {
                    _this._reportError("The pipe '" + pipeName + "' could not be found", sourceSpan);
                }
            });
        }
    };
    TemplateParseVisitor.prototype.visitExpansion = function (ast, context) { return null; };
    TemplateParseVisitor.prototype.visitExpansionCase = function (ast, context) { return null; };
    TemplateParseVisitor.prototype.visitText = function (ast, parent) {
        var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
        var expr = this._parseInterpolation(ast.value, ast.sourceSpan);
        if (lang_1.isPresent(expr)) {
            return new template_ast_1.BoundTextAst(expr, ngContentIndex, ast.sourceSpan);
        }
        else {
            return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceSpan);
        }
    };
    TemplateParseVisitor.prototype.visitAttr = function (ast, contex) {
        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceSpan);
    };
    TemplateParseVisitor.prototype.visitComment = function (ast, context) { return null; };
    TemplateParseVisitor.prototype.visitElement = function (element, parent) {
        var _this = this;
        var nodeName = element.name;
        var preparsedElement = template_preparser_1.preparseElement(element);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE) {
            // Skipping <script> for security reasons
            // Skipping <style> as we already processed them
            // in the StyleCompiler
            return null;
        }
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET &&
            style_url_resolver_1.isStyleUrlResolvable(preparsedElement.hrefAttr)) {
            // Skipping stylesheets with either relative urls or package scheme as we already processed
            // them in the StyleCompiler
            return null;
        }
        var matchableAttrs = [];
        var elementOrDirectiveProps = [];
        var elementOrDirectiveRefs = [];
        var elementVars = [];
        var events = [];
        var templateElementOrDirectiveProps = [];
        var templateMatchableAttrs = [];
        var templateElementVars = [];
        var hasInlineTemplates = false;
        var attrs = [];
        var lcElName = html_tags_1.splitNsName(nodeName.toLowerCase())[1];
        var isTemplateElement = lcElName == TEMPLATE_ELEMENT;
        element.attrs.forEach(function (attr) {
            var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);
            var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
            if (!hasBinding && !hasTemplateBinding) {
                // don't include the bindings as attributes as well in the AST
                attrs.push(_this.visitAttr(attr, null));
                matchableAttrs.push([attr.name, attr.value]);
            }
            if (hasTemplateBinding) {
                hasInlineTemplates = true;
            }
        });
        var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
        var directiveMetas = this._parseDirectives(this.selectorMatcher, elementCssSelector);
        var references = [];
        var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
        var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts);
        var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
        var providerContext = new provider_parser_1.ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
        var children = html_ast_1.htmlVisitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
        providerContext.afterElement();
        // Override the actual selector when the `ngProjectAs` attribute is provided
        var projectionSelector = lang_1.isPresent(preparsedElement.projectAs) ?
            selector_1.CssSelector.parse(preparsedElement.projectAs)[0] :
            elementCssSelector;
        var ngContentIndex = parent.findNgContentIndex(projectionSelector);
        var parsedElement;
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {
            if (lang_1.isPresent(element.children) && element.children.length > 0) {
                this._reportError("<ng-content> element cannot have content. <ng-content> must be immediately followed by </ng-content>", element.sourceSpan);
            }
            parsedElement = new template_ast_1.NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
        }
        else if (isTemplateElement) {
            this._assertAllEventsPublishedByDirectives(directiveAsts, events);
            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
            parsedElement = new template_ast_1.EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
        }
        else {
            this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
            var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
            parsedElement = new template_ast_1.ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan);
        }
        if (hasInlineTemplates) {
            var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
            var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector);
            var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
            var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
            var templateProviderContext = new provider_parser_1.ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
            templateProviderContext.afterElement();
            parsedElement = new template_ast_1.EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
        }
        return parsedElement;
    };
    TemplateParseVisitor.prototype._parseInlineTemplateBinding = function (attr, targetMatchableAttrs, targetProps, targetVars) {
        var templateBindingsSource = null;
        if (attr.name == TEMPLATE_ATTR) {
            templateBindingsSource = attr.value;
        }
        else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
            var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length); // remove the star
            templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
        }
        if (lang_1.isPresent(templateBindingsSource)) {
            var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceSpan);
            for (var i = 0; i < bindings.length; i++) {
                var binding = bindings[i];
                if (binding.keyIsVar) {
                    targetVars.push(new template_ast_1.VariableAst(binding.key, binding.name, attr.sourceSpan));
                }
                else if (lang_1.isPresent(binding.expression)) {
                    this._parsePropertyAst(binding.key, binding.expression, attr.sourceSpan, targetMatchableAttrs, targetProps);
                }
                else {
                    targetMatchableAttrs.push([binding.key, '']);
                    this._parseLiteralAttr(binding.key, null, attr.sourceSpan, targetProps);
                }
            }
            return true;
        }
        return false;
    };
    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
        var attrName = this._normalizeAttributeName(attr.name);
        var attrValue = attr.value;
        var bindParts = lang_1.RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
        var hasBinding = false;
        if (lang_1.isPresent(bindParts)) {
            hasBinding = true;
            if (lang_1.isPresent(bindParts[1])) {
                this._parseProperty(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
            }
            else if (lang_1.isPresent(bindParts[2])) {
                var identifier = bindParts[7];
                if (isTemplateElement) {
                    this._reportError("\"var-\" on <template> elements is deprecated. Use \"let-\" instead!", attr.sourceSpan, parse_util_1.ParseErrorLevel.WARNING);
                    this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
                }
                else {
                    this._reportError("\"var-\" on non <template> elements is deprecated. Use \"ref-\" instead!", attr.sourceSpan, parse_util_1.ParseErrorLevel.WARNING);
                    this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
                }
            }
            else if (lang_1.isPresent(bindParts[3])) {
                if (isTemplateElement) {
                    var identifier = bindParts[7];
                    this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
                }
                else {
                    this._reportError("\"let-\" is only supported on template elements.", attr.sourceSpan);
                }
            }
            else if (lang_1.isPresent(bindParts[4])) {
                var identifier = bindParts[7];
                this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
            }
            else if (lang_1.isPresent(bindParts[5])) {
                this._parseEvent(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[6])) {
                this._parseProperty(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
                this._parseAssignmentEvent(bindParts[7], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[8])) {
                this._parseProperty(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
                this._parseAssignmentEvent(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
            }
            else if (lang_1.isPresent(bindParts[9])) {
                this._parseProperty(bindParts[9], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
            }
            else if (lang_1.isPresent(bindParts[10])) {
                this._parseEvent(bindParts[10], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
            }
        }
        else {
            hasBinding = this._parsePropertyInterpolation(attrName, attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
        }
        if (!hasBinding) {
            this._parseLiteralAttr(attrName, attrValue, attr.sourceSpan, targetProps);
        }
        return hasBinding;
    };
    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {
        return attrName.toLowerCase().startsWith('data-') ? attrName.substring(5) : attrName;
    };
    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {
        if (identifier.indexOf('-') > -1) {
            this._reportError("\"-\" is not allowed in variable names", sourceSpan);
        }
        targetVars.push(new template_ast_1.VariableAst(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {
        if (identifier.indexOf('-') > -1) {
            this._reportError("\"-\" is not allowed in reference names", sourceSpan);
        }
        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseProperty = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {
        this._parsePropertyAst(name, this._parseBinding(expression, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
    };
    TemplateParseVisitor.prototype._parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {
        var expr = this._parseInterpolation(value, sourceSpan);
        if (lang_1.isPresent(expr)) {
            this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
            return true;
        }
        return false;
    };
    TemplateParseVisitor.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
        targetMatchableAttrs.push([name, ast.source]);
        targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
        this._parseEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
    };
    TemplateParseVisitor.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
        // long format: 'target: eventName'
        var parts = util_1.splitAtColon(name, [null, name]);
        var target = parts[0];
        var eventName = parts[1];
        var ast = this._parseAction(expression, sourceSpan);
        targetMatchableAttrs.push([name, ast.source]);
        targetEvents.push(new template_ast_1.BoundEventAst(eventName, target, ast, sourceSpan));
        // Don't detect directives for event names for now,
        // so don't add the event name to the matchableAttrs
    };
    TemplateParseVisitor.prototype._parseLiteralAttr = function (name, value, sourceSpan, targetProps) {
        targetProps.push(new BoundElementOrDirectiveProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), true, sourceSpan));
    };
    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {
        var _this = this;
        // Need to sort the directives so that we get consistent results throughout,
        // as selectorMatcher uses Maps inside.
        // Also dedupe directives as they might match more than one time!
        var directives = collection_1.ListWrapper.createFixedSize(this.directivesIndex.size);
        selectorMatcher.match(elementCssSelector, function (selector, directive) {
            directives[_this.directivesIndex.get(directive)] = directive;
        });
        return directives.filter(function (dir) { return lang_1.isPresent(dir); });
    };
    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, sourceSpan, targetReferences) {
        var _this = this;
        var matchedReferences = new Set();
        var component = null;
        var directiveAsts = directives.map(function (directive) {
            if (directive.isComponent) {
                component = directive;
            }
            var hostProperties = [];
            var hostEvents = [];
            var directiveProperties = [];
            _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceSpan, hostProperties);
            _this._createDirectiveHostEventAsts(directive.hostListeners, sourceSpan, hostEvents);
            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
            elementOrDirectiveRefs.forEach(function (elOrDirRef) {
                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||
                    (directive.exportAs == elOrDirRef.value)) {
                    targetReferences.push(new template_ast_1.ReferenceAst(elOrDirRef.name, identifiers_1.identifierToken(directive.type), elOrDirRef.sourceSpan));
                    matchedReferences.add(elOrDirRef.name);
                }
            });
            return new template_ast_1.DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
        });
        elementOrDirectiveRefs.forEach(function (elOrDirRef) {
            if (elOrDirRef.value.length > 0) {
                if (!collection_1.SetWrapper.has(matchedReferences, elOrDirRef.name)) {
                    _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
                }
                ;
            }
            else if (lang_1.isBlank(component)) {
                var refToken = null;
                if (isTemplateElement) {
                    refToken = identifiers_1.identifierToken(identifiers_1.Identifiers.TemplateRef);
                }
                targetReferences.push(new template_ast_1.ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
            }
        }); // fix syntax highlighting issue: `
        return directiveAsts;
    };
    TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function (elementName, hostProps, sourceSpan, targetPropertyAsts) {
        var _this = this;
        if (lang_1.isPresent(hostProps)) {
            collection_1.StringMapWrapper.forEach(hostProps, function (expression, propName) {
                var exprAst = _this._parseBinding(expression, sourceSpan);
                targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceSpan));
            });
        }
    };
    TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function (hostListeners, sourceSpan, targetEventAsts) {
        var _this = this;
        if (lang_1.isPresent(hostListeners)) {
            collection_1.StringMapWrapper.forEach(hostListeners, function (expression, propName) {
                _this._parseEvent(propName, expression, sourceSpan, [], targetEventAsts);
            });
        }
    };
    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {
        if (lang_1.isPresent(directiveProperties)) {
            var boundPropsByName = new Map();
            boundProps.forEach(function (boundProp) {
                var prevValue = boundPropsByName.get(boundProp.name);
                if (lang_1.isBlank(prevValue) || prevValue.isLiteral) {
                    // give [a]="b" a higher precedence than a="b" on the same element
                    boundPropsByName.set(boundProp.name, boundProp);
                }
            });
            collection_1.StringMapWrapper.forEach(directiveProperties, function (elProp, dirProp) {
                var boundProp = boundPropsByName.get(elProp);
                // Bindings are optional, so this binding only needs to be set up if an expression is given.
                if (lang_1.isPresent(boundProp)) {
                    targetBoundDirectiveProps.push(new template_ast_1.BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
                }
            });
        }
    };
    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {
        var _this = this;
        var boundElementProps = [];
        var boundDirectivePropsIndex = new Map();
        directives.forEach(function (directive) {
            directive.inputs.forEach(function (prop) {
                boundDirectivePropsIndex.set(prop.templateName, prop);
            });
        });
        props.forEach(function (prop) {
            if (!prop.isLiteral && lang_1.isBlank(boundDirectivePropsIndex.get(prop.name))) {
                boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceSpan));
            }
        });
        return boundElementProps;
    };
    TemplateParseVisitor.prototype._createElementPropertyAst = function (elementName, name, ast, sourceSpan) {
        var unit = null;
        var bindingType;
        var boundPropertyName;
        var parts = name.split(PROPERTY_PARTS_SEPARATOR);
        var securityContext;
        if (parts.length === 1) {
            boundPropertyName = this._schemaRegistry.getMappedPropName(parts[0]);
            securityContext = this._schemaRegistry.securityContext(elementName, boundPropertyName);
            bindingType = template_ast_1.PropertyBindingType.Property;
            if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName)) {
                this._reportError("Can't bind to '" + boundPropertyName + "' since it isn't a known native property", sourceSpan);
            }
        }
        else {
            if (parts[0] == ATTRIBUTE_PREFIX) {
                boundPropertyName = parts[1];
                if (boundPropertyName.toLowerCase().startsWith('on')) {
                    this._reportError(("Binding to event attribute '" + boundPropertyName + "' is disallowed ") +
                        ("for security reasons, please use (" + boundPropertyName.slice(2) + ")=..."), sourceSpan);
                }
                // NB: For security purposes, use the mapped property name, not the attribute name.
                securityContext = this._schemaRegistry.securityContext(elementName, this._schemaRegistry.getMappedPropName(boundPropertyName));
                var nsSeparatorIdx = boundPropertyName.indexOf(':');
                if (nsSeparatorIdx > -1) {
                    var ns = boundPropertyName.substring(0, nsSeparatorIdx);
                    var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);
                    boundPropertyName = html_tags_1.mergeNsAndName(ns, name_1);
                }
                bindingType = template_ast_1.PropertyBindingType.Attribute;
            }
            else if (parts[0] == CLASS_PREFIX) {
                boundPropertyName = parts[1];
                bindingType = template_ast_1.PropertyBindingType.Class;
                securityContext = core_private_1.SecurityContext.NONE;
            }
            else if (parts[0] == STYLE_PREFIX) {
                unit = parts.length > 2 ? parts[2] : null;
                boundPropertyName = parts[1];
                bindingType = template_ast_1.PropertyBindingType.Style;
                securityContext = core_private_1.SecurityContext.STYLE;
            }
            else {
                this._reportError("Invalid property name '" + name + "'", sourceSpan);
                bindingType = null;
                securityContext = null;
            }
        }
        return new template_ast_1.BoundElementPropertyAst(boundPropertyName, bindingType, securityContext, ast, unit, sourceSpan);
    };
    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {
        var componentTypeNames = [];
        directives.forEach(function (directive) {
            var typeName = directive.directive.type.name;
            if (directive.directive.isComponent) {
                componentTypeNames.push(typeName);
            }
        });
        return componentTypeNames;
    };
    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {
        var componentTypeNames = this._findComponentDirectiveNames(directives);
        if (componentTypeNames.length > 1) {
            this._reportError("More than one component: " + componentTypeNames.join(','), sourceSpan);
        }
    };
    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {
        var _this = this;
        var componentTypeNames = this._findComponentDirectiveNames(directives);
        if (componentTypeNames.length > 0) {
            this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
        }
        elementProps.forEach(function (prop) {
            _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template", sourceSpan);
        });
    };
    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {
        var _this = this;
        var allDirectiveEvents = new Set();
        directives.forEach(function (directive) {
            collection_1.StringMapWrapper.forEach(directive.directive.outputs, function (eventName, _) { allDirectiveEvents.add(eventName); });
        });
        events.forEach(function (event) {
            if (lang_1.isPresent(event.target) || !collection_1.SetWrapper.has(allDirectiveEvents, event.name)) {
                _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template", event.sourceSpan);
            }
        });
    };
    return TemplateParseVisitor;
}());
var NonBindableVisitor = (function () {
    function NonBindableVisitor() {
    }
    NonBindableVisitor.prototype.visitElement = function (ast, parent) {
        var preparsedElement = template_preparser_1.preparseElement(ast);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {
            // Skipping <script> for security reasons
            // Skipping <style> and stylesheets as we already processed them
            // in the StyleCompiler
            return null;
        }
        var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });
        var selector = createElementCssSelector(ast.name, attrNameAndValues);
        var ngContentIndex = parent.findNgContentIndex(selector);
        var children = html_ast_1.htmlVisitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
        return new template_ast_1.ElementAst(ast.name, html_ast_1.htmlVisitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan);
    };
    NonBindableVisitor.prototype.visitComment = function (ast, context) { return null; };
    NonBindableVisitor.prototype.visitAttr = function (ast, context) {
        return new template_ast_1.AttrAst(ast.name, ast.value, ast.sourceSpan);
    };
    NonBindableVisitor.prototype.visitText = function (ast, parent) {
        var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
        return new template_ast_1.TextAst(ast.value, ngContentIndex, ast.sourceSpan);
    };
    NonBindableVisitor.prototype.visitExpansion = function (ast, context) { return ast; };
    NonBindableVisitor.prototype.visitExpansionCase = function (ast, context) { return ast; };
    return NonBindableVisitor;
}());
var BoundElementOrDirectiveProperty = (function () {
    function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceSpan) {
        this.name = name;
        this.expression = expression;
        this.isLiteral = isLiteral;
        this.sourceSpan = sourceSpan;
    }
    return BoundElementOrDirectiveProperty;
}());
var ElementOrDirectiveRef = (function () {
    function ElementOrDirectiveRef(name, value, sourceSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
    }
    return ElementOrDirectiveRef;
}());
function splitClasses(classAttrValue) {
    return lang_1.StringWrapper.split(classAttrValue.trim(), /\s+/g);
}
exports.splitClasses = splitClasses;
var ElementContext = (function () {
    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
        this.isTemplateElement = isTemplateElement;
        this._ngContentIndexMatcher = _ngContentIndexMatcher;
        this._wildcardNgContentIndex = _wildcardNgContentIndex;
        this.providerContext = providerContext;
    }
    ElementContext.create = function (isTemplateElement, directives, providerContext) {
        var matcher = new selector_1.SelectorMatcher();
        var wildcardNgContentIndex = null;
        var component = directives.find(function (directive) { return directive.directive.isComponent; });
        if (lang_1.isPresent(component)) {
            var ngContentSelectors = component.directive.template.ngContentSelectors;
            for (var i = 0; i < ngContentSelectors.length; i++) {
                var selector = ngContentSelectors[i];
                if (lang_1.StringWrapper.equals(selector, '*')) {
                    wildcardNgContentIndex = i;
                }
                else {
                    matcher.addSelectables(selector_1.CssSelector.parse(ngContentSelectors[i]), i);
                }
            }
        }
        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
    };
    ElementContext.prototype.findNgContentIndex = function (selector) {
        var ngContentIndices = [];
        this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });
        collection_1.ListWrapper.sort(ngContentIndices);
        if (lang_1.isPresent(this._wildcardNgContentIndex)) {
            ngContentIndices.push(this._wildcardNgContentIndex);
        }
        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
    };
    return ElementContext;
}());
function createElementCssSelector(elementName, matchableAttrs) {
    var cssSelector = new selector_1.CssSelector();
    var elNameNoNs = html_tags_1.splitNsName(elementName)[1];
    cssSelector.setElement(elNameNoNs);
    for (var i = 0; i < matchableAttrs.length; i++) {
        var attrName = matchableAttrs[i][0];
        var attrNameNoNs = html_tags_1.splitNsName(attrName)[1];
        var attrValue = matchableAttrs[i][1];
        cssSelector.addAttribute(attrNameNoNs, attrValue);
        if (attrName.toLowerCase() == CLASS_ATTR) {
            var classes = splitClasses(attrValue);
            classes.forEach(function (className) { return cssSelector.addClassName(className); });
        }
    }
    return cssSelector;
}
var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new selector_1.SelectorMatcher(), null, null);
var NON_BINDABLE_VISITOR = new NonBindableVisitor();
var PipeCollector = (function (_super) {
    __extends(PipeCollector, _super);
    function PipeCollector() {
        _super.apply(this, arguments);
        this.pipes = new Set();
    }
    PipeCollector.prototype.visitPipe = function (ast, context) {
        this.pipes.add(ast.name);
        ast.exp.visit(this);
        this.visitAll(ast.args, context);
        return null;
    };
    return PipeCollector;
}(ast_1.RecursiveAstVisitor));
exports.PipeCollector = PipeCollector;
function removeDuplicates(items) {
    var res = [];
    items.forEach(function (item) {
        var hasMatch = res.filter(function (r) { return r.type.name == item.type.name && r.type.moduleUrl == item.type.moduleUrl &&
            r.type.runtime == item.type.runtime; })
            .length > 0;
        if (!hasMatch) {
            res.push(item);
        }
    });
    return res;
}

},{"../core_private":72,"../src/facade/collection":87,"../src/facade/exceptions":89,"../src/facade/lang":90,"./expression_parser/ast":82,"./expression_parser/parser":84,"./html_ast":92,"./html_parser":94,"./html_tags":95,"./identifiers":96,"./parse_util":108,"./provider_parser":110,"./schema/element_schema_registry":113,"./selector":114,"./style_url_resolver":117,"./template_ast":118,"./template_preparser":120,"./util":122,"@angular/core":140}],120:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var html_tags_1 = require('./html_tags');
var NG_CONTENT_SELECT_ATTR = 'select';
var NG_CONTENT_ELEMENT = 'ng-content';
var LINK_ELEMENT = 'link';
var LINK_STYLE_REL_ATTR = 'rel';
var LINK_STYLE_HREF_ATTR = 'href';
var LINK_STYLE_REL_VALUE = 'stylesheet';
var STYLE_ELEMENT = 'style';
var SCRIPT_ELEMENT = 'script';
var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
var NG_PROJECT_AS = 'ngProjectAs';
function preparseElement(ast) {
    var selectAttr = null;
    var hrefAttr = null;
    var relAttr = null;
    var nonBindable = false;
    var projectAs = null;
    ast.attrs.forEach(function (attr) {
        var lcAttrName = attr.name.toLowerCase();
        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
            selectAttr = attr.value;
        }
        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
            hrefAttr = attr.value;
        }
        else if (lcAttrName == LINK_STYLE_REL_ATTR) {
            relAttr = attr.value;
        }
        else if (attr.name == NG_NON_BINDABLE_ATTR) {
            nonBindable = true;
        }
        else if (attr.name == NG_PROJECT_AS) {
            if (attr.value.length > 0) {
                projectAs = attr.value;
            }
        }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    var nodeName = ast.name.toLowerCase();
    var type = PreparsedElementType.OTHER;
    if (html_tags_1.splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
        type = PreparsedElementType.NG_CONTENT;
    }
    else if (nodeName == STYLE_ELEMENT) {
        type = PreparsedElementType.STYLE;
    }
    else if (nodeName == SCRIPT_ELEMENT) {
        type = PreparsedElementType.SCRIPT;
    }
    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
        type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
}
exports.preparseElement = preparseElement;
(function (PreparsedElementType) {
    PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
    PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
    PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
    PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
    PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
})(exports.PreparsedElementType || (exports.PreparsedElementType = {}));
var PreparsedElementType = exports.PreparsedElementType;
var PreparsedElement = (function () {
    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
        this.type = type;
        this.selectAttr = selectAttr;
        this.hrefAttr = hrefAttr;
        this.nonBindable = nonBindable;
        this.projectAs = projectAs;
    }
    return PreparsedElement;
}());
exports.PreparsedElement = PreparsedElement;
function normalizeNgContentSelect(selectAttr) {
    if (lang_1.isBlank(selectAttr) || selectAttr.length === 0) {
        return '*';
    }
    return selectAttr;
}

},{"../src/facade/lang":90,"./html_tags":95}],121:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../src/facade/lang');
var _ASSET_SCHEME = 'asset:';
/**
 * Create a {@link UrlResolver} with no package prefix.
 */
function createUrlResolverWithoutPackagePrefix() {
    return new UrlResolver();
}
exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;
function createOfflineCompileUrlResolver() {
    return new UrlResolver(_ASSET_SCHEME);
}
exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
/**
 * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
 */
exports.DEFAULT_PACKAGE_URL_PROVIDER = {
    provide: core_1.PACKAGE_ROOT_URL,
    useValue: "/"
};
var UrlResolver = (function () {
    function UrlResolver(_packagePrefix) {
        if (_packagePrefix === void 0) { _packagePrefix = null; }
        this._packagePrefix = _packagePrefix;
    }
    /**
     * Resolves the `url` given the `baseUrl`:
     * - when the `url` is null, the `baseUrl` is returned,
     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
     * `baseUrl` and `url`,
     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
     * returned as is (ignoring the `baseUrl`)
     *
     * @param {string} baseUrl
     * @param {string} url
     * @returns {string} the resolved URL
     */
    UrlResolver.prototype.resolve = function (baseUrl, url) {
        var resolvedUrl = url;
        if (lang_1.isPresent(baseUrl) && baseUrl.length > 0) {
            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
        }
        var resolvedParts = _split(resolvedUrl);
        var prefix = this._packagePrefix;
        if (lang_1.isPresent(prefix) && lang_1.isPresent(resolvedParts) &&
            resolvedParts[_ComponentIndex.Scheme] == "package") {
            var path = resolvedParts[_ComponentIndex.Path];
            if (this._packagePrefix === _ASSET_SCHEME) {
                var pathSegements = path.split(/\//);
                resolvedUrl = "asset:" + pathSegements[0] + "/lib/" + pathSegements.slice(1).join('/');
            }
            else {
                prefix = lang_1.StringWrapper.stripRight(prefix, '/');
                path = lang_1.StringWrapper.stripLeft(path, '/');
                return prefix + "/" + path;
            }
        }
        return resolvedUrl;
    };
    UrlResolver.decorators = [
        { type: core_1.Injectable },
    ];
    UrlResolver.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Inject, args: [core_1.PACKAGE_ROOT_URL,] },] },
    ];
    return UrlResolver;
}());
exports.UrlResolver = UrlResolver;
/**
 * Extract the scheme of a URL.
 */
function getUrlScheme(url) {
    var match = _split(url);
    return (match && match[_ComponentIndex.Scheme]) || "";
}
exports.getUrlScheme = getUrlScheme;
// The code below is adapted from Traceur:
// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
/**
 * Builds a URI string from already-encoded parts.
 *
 * No encoding is performed.  Any component may be omitted as either null or
 * undefined.
 *
 * @param {?string=} opt_scheme The scheme such as 'http'.
 * @param {?string=} opt_userInfo The user name before the '@'.
 * @param {?string=} opt_domain The domain such as 'www.google.com', already
 *     URI-encoded.
 * @param {(string|null)=} opt_port The port number.
 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
 *     empty, it must begin with a slash.
 * @param {?string=} opt_queryData The URI-encoded query data.
 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
 * @return {string} The fully combined URI.
 */
function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (lang_1.isPresent(opt_scheme)) {
        out.push(opt_scheme + ':');
    }
    if (lang_1.isPresent(opt_domain)) {
        out.push('//');
        if (lang_1.isPresent(opt_userInfo)) {
            out.push(opt_userInfo + '@');
        }
        out.push(opt_domain);
        if (lang_1.isPresent(opt_port)) {
            out.push(':' + opt_port);
        }
    }
    if (lang_1.isPresent(opt_path)) {
        out.push(opt_path);
    }
    if (lang_1.isPresent(opt_queryData)) {
        out.push('?' + opt_queryData);
    }
    if (lang_1.isPresent(opt_fragment)) {
        out.push('#' + opt_fragment);
    }
    return out.join('');
}
/**
 * A regular expression for breaking a URI into its component parts.
 *
 * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
 * As the "first-match-wins" algorithm is identical to the "greedy"
 * disambiguation method used by POSIX regular expressions, it is natural and
 * commonplace to use a regular expression for parsing the potential five
 * components of a URI reference.
 *
 * The following line is the regular expression for breaking-down a
 * well-formed URI reference into its components.
 *
 * <pre>
 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
 *  12            3  4          5       6  7        8 9
 * </pre>
 *
 * The numbers in the second line above are only to assist readability; they
 * indicate the reference points for each subexpression (i.e., each paired
 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
 * For example, matching the above expression to
 * <pre>
 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
 * </pre>
 * results in the following subexpression matches:
 * <pre>
 *    $1 = http:
 *    $2 = http
 *    $3 = //www.ics.uci.edu
 *    $4 = www.ics.uci.edu
 *    $5 = /pub/ietf/uri/
 *    $6 = <undefined>
 *    $7 = <undefined>
 *    $8 = #Related
 *    $9 = Related
 * </pre>
 * where <undefined> indicates that the component is not present, as is the
 * case for the query component in the above example. Therefore, we can
 * determine the value of the five components as
 * <pre>
 *    scheme    = $2
 *    authority = $4
 *    path      = $5
 *    query     = $7
 *    fragment  = $9
 * </pre>
 *
 * The regular expression has been modified slightly to expose the
 * userInfo, domain, and port separately from the authority.
 * The modified version yields
 * <pre>
 *    $1 = http              scheme
 *    $2 = <undefined>       userInfo -\
 *    $3 = www.ics.uci.edu   domain     | authority
 *    $4 = <undefined>       port     -/
 *    $5 = /pub/ietf/uri/    path
 *    $6 = <undefined>       query without ?
 *    $7 = Related           fragment without #
 * </pre>
 * @type {!RegExp}
 * @internal
 */
var _splitRe = lang_1.RegExpWrapper.create('^' +
    '(?:' +
    '([^:/?#.]+)' +
    // used by other URL parts such as :,
    // ?, /, #, and .
    ':)?' +
    '(?://' +
    '(?:([^/?#]*)@)?' +
    '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
    // digits, dashes, dots, percent
    // escapes, and unicode characters.
    '(?::([0-9]+))?' +
    ')?' +
    '([^?#]+)?' +
    '(?:\\?([^#]*))?' +
    '(?:#(.*))?' +
    '$');
/**
 * The index of each URI component in the return value of goog.uri.utils.split.
 * @enum {number}
 */
var _ComponentIndex;
(function (_ComponentIndex) {
    _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
    _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
    _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
    _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
    _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
    _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
    _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
})(_ComponentIndex || (_ComponentIndex = {}));
/**
 * Splits a URI into its component parts.
 *
 * Each component can be accessed via the component indices; for example:
 * <pre>
 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
 * </pre>
 *
 * @param {string} uri The URI string to examine.
 * @return {!Array.<string|undefined>} Each component still URI-encoded.
 *     Each component that is present will contain the encoded value, whereas
 *     components that are not present will be undefined or empty, depending
 *     on the browser's regular expression implementation.  Never null, since
 *     arbitrary strings may still look like path names.
 */
function _split(uri) {
    return lang_1.RegExpWrapper.firstMatch(_splitRe, uri);
}
/**
  * Removes dot segments in given path component, as described in
  * RFC 3986, section 5.2.4.
  *
  * @param {string} path A non-empty path component.
  * @return {string} Path component with removed dot segments.
  */
function _removeDotSegments(path) {
    if (path == '/')
        return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
        var segment = segments[pos];
        switch (segment) {
            case '':
            case '.':
                break;
            case '..':
                if (out.length > 0) {
                    out.pop();
                }
                else {
                    up++;
                }
                break;
            default:
                out.push(segment);
        }
    }
    if (leadingSlash == '') {
        while (up-- > 0) {
            out.unshift('..');
        }
        if (out.length === 0)
            out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
}
/**
 * Takes an array of the parts from split and canonicalizes the path part
 * and then joins all the parts.
 * @param {Array.<string?>} parts
 * @return {string}
 */
function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.Path];
    path = lang_1.isBlank(path) ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.Path] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
}
/**
 * Resolves a URL.
 * @param {string} base The URL acting as the base URL.
 * @param {string} to The URL to resolve.
 * @return {string}
 */
function _resolveUrl(base, url) {
    var parts = _split(encodeURI(url));
    var baseParts = _split(base);
    if (lang_1.isPresent(parts[_ComponentIndex.Scheme])) {
        return _joinAndCanonicalizePath(parts);
    }
    else {
        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
    }
    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
        if (lang_1.isBlank(parts[i])) {
            parts[i] = baseParts[i];
        }
    }
    if (parts[_ComponentIndex.Path][0] == '/') {
        return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.Path];
    if (lang_1.isBlank(path))
        path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
    parts[_ComponentIndex.Path] = path;
    return _joinAndCanonicalizePath(parts);
}

},{"../src/facade/lang":90,"@angular/core":140}],122:[function(require,module,exports){
"use strict";
var lang_1 = require('./facade/lang');
var collection_1 = require('./facade/collection');
exports.MODULE_SUFFIX = lang_1.IS_DART ? '.dart' : '';
var CAMEL_CASE_REGEXP = /([A-Z])/g;
var DASH_CASE_REGEXP = /-([a-z])/g;
function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
}
exports.camelCaseToDashCase = camelCaseToDashCase;
function dashCaseToCamelCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
}
exports.dashCaseToCamelCase = dashCaseToCamelCase;
function splitAtColon(input, defaultValues) {
    var parts = lang_1.StringWrapper.split(input.trim(), /\s*:\s*/g);
    if (parts.length > 1) {
        return parts;
    }
    else {
        return defaultValues;
    }
}
exports.splitAtColon = splitAtColon;
function sanitizeIdentifier(name) {
    return lang_1.StringWrapper.replaceAll(name, /\W/g, '_');
}
exports.sanitizeIdentifier = sanitizeIdentifier;
function visitValue(value, visitor, context) {
    if (lang_1.isArray(value)) {
        return visitor.visitArray(value, context);
    }
    else if (lang_1.isStrictStringMap(value)) {
        return visitor.visitStringMap(value, context);
    }
    else if (lang_1.isBlank(value) || lang_1.isPrimitive(value)) {
        return visitor.visitPrimitive(value, context);
    }
    else {
        return visitor.visitOther(value, context);
    }
}
exports.visitValue = visitValue;
var ValueTransformer = (function () {
    function ValueTransformer() {
    }
    ValueTransformer.prototype.visitArray = function (arr, context) {
        var _this = this;
        return arr.map(function (value) { return visitValue(value, _this, context); });
    };
    ValueTransformer.prototype.visitStringMap = function (map, context) {
        var _this = this;
        var result = {};
        collection_1.StringMapWrapper.forEach(map, function (value, key) { result[key] = visitValue(value, _this, context); });
        return result;
    };
    ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };
    ValueTransformer.prototype.visitOther = function (value, context) { return value; };
    return ValueTransformer;
}());
exports.ValueTransformer = ValueTransformer;
function assetUrl(pkg, path, type) {
    if (path === void 0) { path = null; }
    if (type === void 0) { type = 'src'; }
    if (lang_1.IS_DART) {
        if (path == null) {
            return "asset:angular2/" + pkg + "/" + pkg + ".dart";
        }
        else {
            return "asset:angular2/lib/" + pkg + "/src/" + path + ".dart";
        }
    }
    else {
        if (path == null) {
            return "asset:@angular/lib/" + pkg + "/index";
        }
        else {
            return "asset:@angular/lib/" + pkg + "/src/" + path;
        }
    }
}
exports.assetUrl = assetUrl;

},{"./facade/collection":87,"./facade/lang":90}],123:[function(require,module,exports){
"use strict";
var CompileBinding = (function () {
    function CompileBinding(node, sourceAst) {
        this.node = node;
        this.sourceAst = sourceAst;
    }
    return CompileBinding;
}());
exports.CompileBinding = CompileBinding;

},{}],124:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
var constants_1 = require('./constants');
var template_ast_1 = require('../template_ast');
var compile_metadata_1 = require('../compile_metadata');
var util_1 = require('./util');
var compile_query_1 = require('./compile_query');
var compile_method_1 = require('./compile_method');
var util_2 = require('../util');
var CompileNode = (function () {
    function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
        this.parent = parent;
        this.view = view;
        this.nodeIndex = nodeIndex;
        this.renderNode = renderNode;
        this.sourceAst = sourceAst;
    }
    CompileNode.prototype.isNull = function () { return lang_1.isBlank(this.renderNode); };
    CompileNode.prototype.isRootElement = function () { return this.view != this.parent.view; };
    return CompileNode;
}());
exports.CompileNode = CompileNode;
var CompileElement = (function (_super) {
    __extends(CompileElement, _super);
    function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references) {
        var _this = this;
        _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);
        this.component = component;
        this._directives = _directives;
        this._resolvedProvidersArray = _resolvedProvidersArray;
        this.hasViewContainer = hasViewContainer;
        this.hasEmbeddedView = hasEmbeddedView;
        this._compViewExpr = null;
        this._instances = new compile_metadata_1.CompileTokenMap();
        this._queryCount = 0;
        this._queries = new compile_metadata_1.CompileTokenMap();
        this._componentConstructorViewQueryLists = [];
        this.contentNodesByNgContentIndex = null;
        this.referenceTokens = {};
        references.forEach(function (ref) { return _this.referenceTokens[ref.name] = ref.value; });
        this.elementRef = o.importExpr(identifiers_1.Identifiers.ElementRef).instantiate([this.renderNode]);
        this._instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.ElementRef), this.elementRef);
        this.injector = o.THIS_EXPR.callMethod('injector', [o.literal(this.nodeIndex)]);
        this._instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.Injector), this.injector);
        this._instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.Renderer), o.THIS_EXPR.prop('renderer'));
        if (this.hasViewContainer || this.hasEmbeddedView || lang_1.isPresent(this.component)) {
            this._createAppElement();
        }
    }
    CompileElement.createNull = function () {
        return new CompileElement(null, null, null, null, null, null, [], [], false, false, []);
    };
    CompileElement.prototype._createAppElement = function () {
        var fieldName = "_appEl_" + this.nodeIndex;
        var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
        // private is fine here as no child view will reference an AppElement
        this.view.fields.push(new o.ClassField(fieldName, o.importType(identifiers_1.Identifiers.AppElement), [o.StmtModifier.Private]));
        var statement = o.THIS_EXPR.prop(fieldName)
            .set(o.importExpr(identifiers_1.Identifiers.AppElement)
            .instantiate([
            o.literal(this.nodeIndex),
            o.literal(parentNodeIndex),
            o.THIS_EXPR,
            this.renderNode
        ]))
            .toStmt();
        this.view.createMethod.addStmt(statement);
        this.appElement = o.THIS_EXPR.prop(fieldName);
        this._instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.AppElement), this.appElement);
    };
    CompileElement.prototype.setComponentView = function (compViewExpr) {
        this._compViewExpr = compViewExpr;
        this.contentNodesByNgContentIndex =
            collection_1.ListWrapper.createFixedSize(this.component.template.ngContentSelectors.length);
        for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
            this.contentNodesByNgContentIndex[i] = [];
        }
    };
    CompileElement.prototype.setEmbeddedView = function (embeddedView) {
        this.embeddedView = embeddedView;
        if (lang_1.isPresent(embeddedView)) {
            var createTemplateRefExpr = o.importExpr(identifiers_1.Identifiers.TemplateRef_)
                .instantiate([this.appElement, this.embeddedView.viewFactory]);
            var provider = new compile_metadata_1.CompileProviderMetadata({ token: identifiers_1.identifierToken(identifiers_1.Identifiers.TemplateRef), useValue: createTemplateRefExpr });
            // Add TemplateRef as first provider as it does not have deps on other providers
            this._resolvedProvidersArray.unshift(new template_ast_1.ProviderAst(provider.token, false, true, [provider], template_ast_1.ProviderAstType.Builtin, this.sourceAst.sourceSpan));
        }
    };
    CompileElement.prototype.beforeChildren = function () {
        var _this = this;
        if (this.hasViewContainer) {
            this._instances.add(identifiers_1.identifierToken(identifiers_1.Identifiers.ViewContainerRef), this.appElement.prop('vcRef'));
        }
        this._resolvedProviders = new compile_metadata_1.CompileTokenMap();
        this._resolvedProvidersArray.forEach(function (provider) {
            return _this._resolvedProviders.add(provider.token, provider);
        });
        // create all the provider instances, some in the view constructor,
        // some as getters. We rely on the fact that they are already sorted topologically.
        this._resolvedProviders.values().forEach(function (resolvedProvider) {
            var providerValueExpressions = resolvedProvider.providers.map(function (provider) {
                if (lang_1.isPresent(provider.useExisting)) {
                    return _this._getDependency(resolvedProvider.providerType, new compile_metadata_1.CompileDiDependencyMetadata({ token: provider.useExisting }));
                }
                else if (lang_1.isPresent(provider.useFactory)) {
                    var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
                    var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
                    return o.importExpr(provider.useFactory).callFn(depsExpr);
                }
                else if (lang_1.isPresent(provider.useClass)) {
                    var deps = lang_1.isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
                    var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
                    return o.importExpr(provider.useClass)
                        .instantiate(depsExpr, o.importType(provider.useClass));
                }
                else {
                    return _convertValueToOutputAst(provider.useValue);
                }
            });
            var propName = "_" + resolvedProvider.token.name + "_" + _this.nodeIndex + "_" + _this._instances.size;
            var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);
            _this._instances.add(resolvedProvider.token, instance);
        });
        this.directiveInstances =
            this._directives.map(function (directive) { return _this._instances.get(identifiers_1.identifierToken(directive.type)); });
        for (var i = 0; i < this.directiveInstances.length; i++) {
            var directiveInstance = this.directiveInstances[i];
            var directive = this._directives[i];
            directive.queries.forEach(function (queryMeta) { _this._addQuery(queryMeta, directiveInstance); });
        }
        var queriesWithReads = [];
        this._resolvedProviders.values().forEach(function (resolvedProvider) {
            var queriesForProvider = _this._getQueriesFor(resolvedProvider.token);
            collection_1.ListWrapper.addAll(queriesWithReads, queriesForProvider.map(function (query) { return new _QueryWithRead(query, resolvedProvider.token); }));
        });
        collection_1.StringMapWrapper.forEach(this.referenceTokens, function (_, varName) {
            var token = _this.referenceTokens[varName];
            var varValue;
            if (lang_1.isPresent(token)) {
                varValue = _this._instances.get(token);
            }
            else {
                varValue = _this.renderNode;
            }
            _this.view.locals.set(varName, varValue);
            var varToken = new compile_metadata_1.CompileTokenMetadata({ value: varName });
            collection_1.ListWrapper.addAll(queriesWithReads, _this._getQueriesFor(varToken)
                .map(function (query) { return new _QueryWithRead(query, varToken); }));
        });
        queriesWithReads.forEach(function (queryWithRead) {
            var value;
            if (lang_1.isPresent(queryWithRead.read.identifier)) {
                // query for an identifier
                value = _this._instances.get(queryWithRead.read);
            }
            else {
                // query for a reference
                var token = _this.referenceTokens[queryWithRead.read.value];
                if (lang_1.isPresent(token)) {
                    value = _this._instances.get(token);
                }
                else {
                    value = _this.elementRef;
                }
            }
            if (lang_1.isPresent(value)) {
                queryWithRead.query.addValue(value, _this.view);
            }
        });
        if (lang_1.isPresent(this.component)) {
            var componentConstructorViewQueryList = lang_1.isPresent(this.component) ? o.literalArr(this._componentConstructorViewQueryLists) :
                o.NULL_EXPR;
            var compExpr = lang_1.isPresent(this.getComponent()) ? this.getComponent() : o.NULL_EXPR;
            this.view.createMethod.addStmt(this.appElement.callMethod('initComponent', [compExpr, componentConstructorViewQueryList, this._compViewExpr])
                .toStmt());
        }
    };
    CompileElement.prototype.afterChildren = function (childNodeCount) {
        var _this = this;
        this._resolvedProviders.values().forEach(function (resolvedProvider) {
            // Note: afterChildren is called after recursing into children.
            // This is good so that an injector match in an element that is closer to a requesting element
            // matches first.
            var providerExpr = _this._instances.get(resolvedProvider.token);
            // Note: view providers are only visible on the injector of that element.
            // This is not fully correct as the rules during codegen don't allow a directive
            // to get hold of a view provdier on the same element. We still do this semantic
            // as it simplifies our model to having only one runtime injector per element.
            var providerChildNodeCount = resolvedProvider.providerType === template_ast_1.ProviderAstType.PrivateService ? 0 : childNodeCount;
            _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
        });
        this._queries.values().forEach(function (queries) {
            return queries.forEach(function (query) { return query.afterChildren(_this.view.updateContentQueriesMethod); });
        });
    };
    CompileElement.prototype.addContentNode = function (ngContentIndex, nodeExpr) {
        this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
    };
    CompileElement.prototype.getComponent = function () {
        return lang_1.isPresent(this.component) ? this._instances.get(identifiers_1.identifierToken(this.component.type)) :
            null;
    };
    CompileElement.prototype.getProviderTokens = function () {
        return this._resolvedProviders.values().map(function (resolvedProvider) { return util_1.createDiTokenExpression(resolvedProvider.token); });
    };
    CompileElement.prototype._getQueriesFor = function (token) {
        var result = [];
        var currentEl = this;
        var distance = 0;
        var queries;
        while (!currentEl.isNull()) {
            queries = currentEl._queries.get(token);
            if (lang_1.isPresent(queries)) {
                collection_1.ListWrapper.addAll(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));
            }
            if (currentEl._directives.length > 0) {
                distance++;
            }
            currentEl = currentEl.parent;
        }
        queries = this.view.componentView.viewQueries.get(token);
        if (lang_1.isPresent(queries)) {
            collection_1.ListWrapper.addAll(result, queries);
        }
        return result;
    };
    CompileElement.prototype._addQuery = function (queryMeta, directiveInstance) {
        var propName = "_query_" + queryMeta.selectors[0].name + "_" + this.nodeIndex + "_" + this._queryCount++;
        var queryList = compile_query_1.createQueryList(queryMeta, directiveInstance, propName, this.view);
        var query = new compile_query_1.CompileQuery(queryMeta, queryList, directiveInstance, this.view);
        compile_query_1.addQueryToTokenMap(this._queries, query);
        return query;
    };
    CompileElement.prototype._getLocalDependency = function (requestingProviderType, dep) {
        var result = null;
        // constructor content query
        if (lang_1.isBlank(result) && lang_1.isPresent(dep.query)) {
            result = this._addQuery(dep.query, null).queryList;
        }
        // constructor view query
        if (lang_1.isBlank(result) && lang_1.isPresent(dep.viewQuery)) {
            result = compile_query_1.createQueryList(dep.viewQuery, null, "_viewQuery_" + dep.viewQuery.selectors[0].name + "_" + this.nodeIndex + "_" + this._componentConstructorViewQueryLists.length, this.view);
            this._componentConstructorViewQueryLists.push(result);
        }
        if (lang_1.isPresent(dep.token)) {
            // access builtins with special visibility
            if (lang_1.isBlank(result)) {
                if (dep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ChangeDetectorRef))) {
                    if (requestingProviderType === template_ast_1.ProviderAstType.Component) {
                        return this._compViewExpr.prop('ref');
                    }
                    else {
                        return util_1.getPropertyInView(o.THIS_EXPR.prop('ref'), this.view, this.view.componentView);
                    }
                }
            }
            // access regular providers on the element
            if (lang_1.isBlank(result)) {
                result = this._instances.get(dep.token);
            }
        }
        return result;
    };
    CompileElement.prototype._getDependency = function (requestingProviderType, dep) {
        var currElement = this;
        var result = null;
        if (dep.isValue) {
            result = o.literal(dep.value);
        }
        if (lang_1.isBlank(result) && !dep.isSkipSelf) {
            result = this._getLocalDependency(requestingProviderType, dep);
        }
        // check parent elements
        while (lang_1.isBlank(result) && !currElement.parent.isNull()) {
            currElement = currElement.parent;
            result = currElement._getLocalDependency(template_ast_1.ProviderAstType.PublicService, new compile_metadata_1.CompileDiDependencyMetadata({ token: dep.token }));
        }
        if (lang_1.isBlank(result)) {
            result = util_1.injectFromViewParentInjector(dep.token, dep.isOptional);
        }
        if (lang_1.isBlank(result)) {
            result = o.NULL_EXPR;
        }
        return util_1.getPropertyInView(result, this.view, currElement.view);
    };
    return CompileElement;
}(CompileNode));
exports.CompileElement = CompileElement;
function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
    var indexCondition;
    if (childNodeCount > 0) {
        indexCondition = o.literal(nodeIndex)
            .lowerEquals(constants_1.InjectMethodVars.requestNodeIndex)
            .and(constants_1.InjectMethodVars.requestNodeIndex.lowerEquals(o.literal(nodeIndex + childNodeCount)));
    }
    else {
        indexCondition = o.literal(nodeIndex).identical(constants_1.InjectMethodVars.requestNodeIndex);
    }
    return new o.IfStmt(constants_1.InjectMethodVars.token.identical(util_1.createDiTokenExpression(provider.token)).and(indexCondition), [new o.ReturnStatement(providerExpr)]);
}
function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {
    var view = compileElement.view;
    var resolvedProviderValueExpr;
    var type;
    if (isMulti) {
        resolvedProviderValueExpr = o.literalArr(providerValueExpressions);
        type = new o.ArrayType(o.DYNAMIC_TYPE);
    }
    else {
        resolvedProviderValueExpr = providerValueExpressions[0];
        type = providerValueExpressions[0].type;
    }
    if (lang_1.isBlank(type)) {
        type = o.DYNAMIC_TYPE;
    }
    if (isEager) {
        view.fields.push(new o.ClassField(propName, type));
        view.createMethod.addStmt(o.THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
    }
    else {
        var internalField = "_" + propName;
        view.fields.push(new o.ClassField(internalField, type));
        var getter = new compile_method_1.CompileMethod(view);
        getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
        // Note: Equals is important for JS so that it also checks the undefined case!
        getter.addStmt(new o.IfStmt(o.THIS_EXPR.prop(internalField).isBlank(), [o.THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
        getter.addStmt(new o.ReturnStatement(o.THIS_EXPR.prop(internalField)));
        view.getters.push(new o.ClassGetter(propName, getter.finish(), type));
    }
    return o.THIS_EXPR.prop(propName);
}
var _QueryWithRead = (function () {
    function _QueryWithRead(query, match) {
        this.query = query;
        this.read = lang_1.isPresent(query.meta.read) ? query.meta.read : match;
    }
    return _QueryWithRead;
}());
function _convertValueToOutputAst(value) {
    return util_2.visitValue(value, new _ValueOutputAstTransformer(), null);
}
var _ValueOutputAstTransformer = (function (_super) {
    __extends(_ValueOutputAstTransformer, _super);
    function _ValueOutputAstTransformer() {
        _super.apply(this, arguments);
    }
    _ValueOutputAstTransformer.prototype.visitArray = function (arr, context) {
        var _this = this;
        return o.literalArr(arr.map(function (value) { return util_2.visitValue(value, _this, context); }));
    };
    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, context) {
        var _this = this;
        var entries = [];
        collection_1.StringMapWrapper.forEach(map, function (value, key) { entries.push([key, util_2.visitValue(value, _this, context)]); });
        return o.literalMap(entries);
    };
    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, context) { return o.literal(value); };
    _ValueOutputAstTransformer.prototype.visitOther = function (value, context) {
        if (value instanceof compile_metadata_1.CompileIdentifierMetadata) {
            return o.importExpr(value);
        }
        else if (value instanceof o.Expression) {
            return value;
        }
        else {
            throw new core_1.BaseException("Illegal state: Don't now how to compile value " + value);
        }
    };
    return _ValueOutputAstTransformer;
}(util_2.ValueTransformer));

},{"../../src/facade/collection":87,"../../src/facade/lang":90,"../compile_metadata":76,"../identifiers":96,"../output/output_ast":103,"../template_ast":118,"../util":122,"./compile_method":125,"./compile_query":127,"./constants":129,"./util":134,"@angular/core":140}],125:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var o = require('../output/output_ast');
var _DebugState = (function () {
    function _DebugState(nodeIndex, sourceAst) {
        this.nodeIndex = nodeIndex;
        this.sourceAst = sourceAst;
    }
    return _DebugState;
}());
var NULL_DEBUG_STATE = new _DebugState(null, null);
var CompileMethod = (function () {
    function CompileMethod(_view) {
        this._view = _view;
        this._newState = NULL_DEBUG_STATE;
        this._currState = NULL_DEBUG_STATE;
        this._bodyStatements = [];
        this._debugEnabled = this._view.genConfig.genDebugInfo;
    }
    CompileMethod.prototype._updateDebugContextIfNeeded = function () {
        if (this._newState.nodeIndex !== this._currState.nodeIndex ||
            this._newState.sourceAst !== this._currState.sourceAst) {
            var expr = this._updateDebugContext(this._newState);
            if (lang_1.isPresent(expr)) {
                this._bodyStatements.push(expr.toStmt());
            }
        }
    };
    CompileMethod.prototype._updateDebugContext = function (newState) {
        this._currState = this._newState = newState;
        if (this._debugEnabled) {
            var sourceLocation = lang_1.isPresent(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;
            return o.THIS_EXPR.callMethod('debug', [
                o.literal(newState.nodeIndex),
                lang_1.isPresent(sourceLocation) ? o.literal(sourceLocation.line) : o.NULL_EXPR,
                lang_1.isPresent(sourceLocation) ? o.literal(sourceLocation.col) : o.NULL_EXPR
            ]);
        }
        else {
            return null;
        }
    };
    CompileMethod.prototype.resetDebugInfoExpr = function (nodeIndex, templateAst) {
        var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
        return lang_1.isPresent(res) ? res : o.NULL_EXPR;
    };
    CompileMethod.prototype.resetDebugInfo = function (nodeIndex, templateAst) {
        this._newState = new _DebugState(nodeIndex, templateAst);
    };
    CompileMethod.prototype.addStmt = function (stmt) {
        this._updateDebugContextIfNeeded();
        this._bodyStatements.push(stmt);
    };
    CompileMethod.prototype.addStmts = function (stmts) {
        this._updateDebugContextIfNeeded();
        collection_1.ListWrapper.addAll(this._bodyStatements, stmts);
    };
    CompileMethod.prototype.finish = function () { return this._bodyStatements; };
    CompileMethod.prototype.isEmpty = function () { return this._bodyStatements.length === 0; };
    return CompileMethod;
}());
exports.CompileMethod = CompileMethod;

},{"../../src/facade/collection":87,"../../src/facade/lang":90,"../output/output_ast":103}],126:[function(require,module,exports){
"use strict";
var lang_1 = require('../facade/lang');
var exceptions_1 = require('../facade/exceptions');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
var util_1 = require('./util');
var _PurePipeProxy = (function () {
    function _PurePipeProxy(view, instance, argCount) {
        this.view = view;
        this.instance = instance;
        this.argCount = argCount;
    }
    return _PurePipeProxy;
}());
var CompilePipe = (function () {
    function CompilePipe(view, meta) {
        this.view = view;
        this.meta = meta;
        this._purePipeProxies = [];
        this.instance = o.THIS_EXPR.prop("_pipe_" + meta.name + "_" + view.pipeCount++);
    }
    CompilePipe.call = function (view, name, args) {
        var compView = view.componentView;
        var meta = _findPipeMeta(compView, name);
        var pipe;
        if (meta.pure) {
            // pure pipes live on the component view
            pipe = compView.purePipes.get(name);
            if (lang_1.isBlank(pipe)) {
                pipe = new CompilePipe(compView, meta);
                compView.purePipes.set(name, pipe);
                compView.pipes.push(pipe);
            }
        }
        else {
            // Non pure pipes live on the view that called it
            pipe = new CompilePipe(view, meta);
            view.pipes.push(pipe);
        }
        return pipe._call(view, args);
    };
    Object.defineProperty(CompilePipe.prototype, "pure", {
        get: function () { return this.meta.pure; },
        enumerable: true,
        configurable: true
    });
    CompilePipe.prototype.create = function () {
        var _this = this;
        var deps = this.meta.type.diDeps.map(function (diDep) {
            if (diDep.token.equalsTo(identifiers_1.identifierToken(identifiers_1.Identifiers.ChangeDetectorRef))) {
                return util_1.getPropertyInView(o.THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
            }
            return util_1.injectFromViewParentInjector(diDep.token, false);
        });
        this.view.fields.push(new o.ClassField(this.instance.name, o.importType(this.meta.type)));
        this.view.createMethod.resetDebugInfo(null, null);
        this.view.createMethod.addStmt(o.THIS_EXPR.prop(this.instance.name)
            .set(o.importExpr(this.meta.type).instantiate(deps))
            .toStmt());
        this._purePipeProxies.forEach(function (purePipeProxy) {
            var pipeInstanceSeenFromPureProxy = util_1.getPropertyInView(_this.instance, purePipeProxy.view, _this.view);
            util_1.createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform')
                .callMethod(o.BuiltinMethod.bind, [pipeInstanceSeenFromPureProxy]), purePipeProxy.argCount, purePipeProxy.instance, purePipeProxy.view);
        });
    };
    CompilePipe.prototype._call = function (callingView, args) {
        if (this.meta.pure) {
            // PurePipeProxies live on the view that called them.
            var purePipeProxy = new _PurePipeProxy(callingView, o.THIS_EXPR.prop(this.instance.name + "_" + this._purePipeProxies.length), args.length);
            this._purePipeProxies.push(purePipeProxy);
            return o.importExpr(identifiers_1.Identifiers.castByValue)
                .callFn([
                purePipeProxy.instance,
                util_1.getPropertyInView(this.instance.prop('transform'), callingView, this.view)
            ])
                .callFn(args);
        }
        else {
            return util_1.getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
        }
    };
    return CompilePipe;
}());
exports.CompilePipe = CompilePipe;
function _findPipeMeta(view, name) {
    var pipeMeta = null;
    for (var i = view.pipeMetas.length - 1; i >= 0; i--) {
        var localPipeMeta = view.pipeMetas[i];
        if (localPipeMeta.name == name) {
            pipeMeta = localPipeMeta;
            break;
        }
    }
    if (lang_1.isBlank(pipeMeta)) {
        throw new exceptions_1.BaseException("Illegal state: Could not find pipe " + name + " although the parser should have detected this error!");
    }
    return pipeMeta;
}

},{"../facade/exceptions":89,"../facade/lang":90,"../identifiers":96,"../output/output_ast":103,"./util":134}],127:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
var util_1 = require('./util');
var ViewQueryValues = (function () {
    function ViewQueryValues(view, values) {
        this.view = view;
        this.values = values;
    }
    return ViewQueryValues;
}());
var CompileQuery = (function () {
    function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
        this.meta = meta;
        this.queryList = queryList;
        this.ownerDirectiveExpression = ownerDirectiveExpression;
        this.view = view;
        this._values = new ViewQueryValues(view, []);
    }
    CompileQuery.prototype.addValue = function (value, view) {
        var currentView = view;
        var elPath = [];
        while (lang_1.isPresent(currentView) && currentView !== this.view) {
            var parentEl = currentView.declarationElement;
            elPath.unshift(parentEl);
            currentView = parentEl.view;
        }
        var queryListForDirtyExpr = util_1.getPropertyInView(this.queryList, view, this.view);
        var viewValues = this._values;
        elPath.forEach(function (el) {
            var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
            if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
                viewValues = last;
            }
            else {
                var newViewValues = new ViewQueryValues(el.embeddedView, []);
                viewValues.values.push(newViewValues);
                viewValues = newViewValues;
            }
        });
        viewValues.values.push(value);
        if (elPath.length > 0) {
            view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
        }
    };
    CompileQuery.prototype.afterChildren = function (targetMethod) {
        var values = createQueryValues(this._values);
        var updateStmts = [this.queryList.callMethod('reset', [o.literalArr(values)]).toStmt()];
        if (lang_1.isPresent(this.ownerDirectiveExpression)) {
            var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
            updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
        }
        if (!this.meta.first) {
            updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
        }
        targetMethod.addStmt(new o.IfStmt(this.queryList.prop('dirty'), updateStmts));
    };
    return CompileQuery;
}());
exports.CompileQuery = CompileQuery;
function createQueryValues(viewValues) {
    return collection_1.ListWrapper.flatten(viewValues.values.map(function (entry) {
        if (entry instanceof ViewQueryValues) {
            return mapNestedViews(entry.view.declarationElement.appElement, entry.view, createQueryValues(entry));
        }
        else {
            return entry;
        }
    }));
}
function mapNestedViews(declarationAppElement, view, expressions) {
    var adjustedExpressions = expressions.map(function (expr) {
        return o.replaceVarInExpression(o.THIS_EXPR.name, o.variable('nestedView'), expr);
    });
    return declarationAppElement.callMethod('mapNestedViews', [
        o.variable(view.className),
        o.fn([new o.FnParam('nestedView', view.classType)], [new o.ReturnStatement(o.literalArr(adjustedExpressions))])
    ]);
}
function createQueryList(query, directiveInstance, propertyName, compileView) {
    compileView.fields.push(new o.ClassField(propertyName, o.importType(identifiers_1.Identifiers.QueryList)));
    var expr = o.THIS_EXPR.prop(propertyName);
    compileView.createMethod.addStmt(o.THIS_EXPR.prop(propertyName)
        .set(o.importExpr(identifiers_1.Identifiers.QueryList).instantiate([]))
        .toStmt());
    return expr;
}
exports.createQueryList = createQueryList;
function addQueryToTokenMap(map, query) {
    query.meta.selectors.forEach(function (selector) {
        var entry = map.get(selector);
        if (lang_1.isBlank(entry)) {
            entry = [];
            map.add(selector, entry);
        }
        entry.push(query);
    });
}
exports.addQueryToTokenMap = addQueryToTokenMap;

},{"../../src/facade/collection":87,"../../src/facade/lang":90,"../identifiers":96,"../output/output_ast":103,"./util":134}],128:[function(require,module,exports){
"use strict";
var core_private_1 = require('../../core_private');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var o = require('../output/output_ast');
var constants_1 = require('./constants');
var compile_query_1 = require('./compile_query');
var compile_method_1 = require('./compile_method');
var compile_pipe_1 = require('./compile_pipe');
var compile_metadata_1 = require('../compile_metadata');
var util_1 = require('./util');
var identifiers_1 = require('../identifiers');
var CompileView = (function () {
    function CompileView(component, genConfig, pipeMetas, styles, viewIndex, declarationElement, templateVariableBindings) {
        var _this = this;
        this.component = component;
        this.genConfig = genConfig;
        this.pipeMetas = pipeMetas;
        this.styles = styles;
        this.viewIndex = viewIndex;
        this.declarationElement = declarationElement;
        this.templateVariableBindings = templateVariableBindings;
        this.nodes = [];
        // root nodes or AppElements for ViewContainers
        this.rootNodesOrAppElements = [];
        this.bindings = [];
        this.classStatements = [];
        this.eventHandlerMethods = [];
        this.fields = [];
        this.getters = [];
        this.disposables = [];
        this.subscriptions = [];
        this.purePipes = new Map();
        this.pipes = [];
        this.locals = new Map();
        this.literalArrayCount = 0;
        this.literalMapCount = 0;
        this.pipeCount = 0;
        this.createMethod = new compile_method_1.CompileMethod(this);
        this.injectorGetMethod = new compile_method_1.CompileMethod(this);
        this.updateContentQueriesMethod = new compile_method_1.CompileMethod(this);
        this.dirtyParentQueriesMethod = new compile_method_1.CompileMethod(this);
        this.updateViewQueriesMethod = new compile_method_1.CompileMethod(this);
        this.detectChangesInInputsMethod = new compile_method_1.CompileMethod(this);
        this.detectChangesRenderPropertiesMethod = new compile_method_1.CompileMethod(this);
        this.afterContentLifecycleCallbacksMethod = new compile_method_1.CompileMethod(this);
        this.afterViewLifecycleCallbacksMethod = new compile_method_1.CompileMethod(this);
        this.destroyMethod = new compile_method_1.CompileMethod(this);
        this.viewType = getViewType(component, viewIndex);
        this.className = "_View_" + component.type.name + viewIndex;
        this.classType = o.importType(new compile_metadata_1.CompileIdentifierMetadata({ name: this.className }));
        this.viewFactory = o.variable(util_1.getViewFactoryName(component, viewIndex));
        if (this.viewType === core_private_1.ViewType.COMPONENT || this.viewType === core_private_1.ViewType.HOST) {
            this.componentView = this;
        }
        else {
            this.componentView = this.declarationElement.view.componentView;
        }
        this.componentContext =
            util_1.getPropertyInView(o.THIS_EXPR.prop('context'), this, this.componentView);
        var viewQueries = new compile_metadata_1.CompileTokenMap();
        if (this.viewType === core_private_1.ViewType.COMPONENT) {
            var directiveInstance = o.THIS_EXPR.prop('context');
            collection_1.ListWrapper.forEachWithIndex(this.component.viewQueries, function (queryMeta, queryIndex) {
                var propName = "_viewQuery_" + queryMeta.selectors[0].name + "_" + queryIndex;
                var queryList = compile_query_1.createQueryList(queryMeta, directiveInstance, propName, _this);
                var query = new compile_query_1.CompileQuery(queryMeta, queryList, directiveInstance, _this);
                compile_query_1.addQueryToTokenMap(viewQueries, query);
            });
            var constructorViewQueryCount = 0;
            this.component.type.diDeps.forEach(function (dep) {
                if (lang_1.isPresent(dep.viewQuery)) {
                    var queryList = o.THIS_EXPR.prop('declarationAppElement')
                        .prop('componentConstructorViewQueries')
                        .key(o.literal(constructorViewQueryCount++));
                    var query = new compile_query_1.CompileQuery(dep.viewQuery, queryList, null, _this);
                    compile_query_1.addQueryToTokenMap(viewQueries, query);
                }
            });
        }
        this.viewQueries = viewQueries;
        templateVariableBindings.forEach(function (entry) { _this.locals.set(entry[1], o.THIS_EXPR.prop('context').prop(entry[0])); });
        if (!this.declarationElement.isNull()) {
            this.declarationElement.setEmbeddedView(this);
        }
    }
    CompileView.prototype.callPipe = function (name, input, args) {
        return compile_pipe_1.CompilePipe.call(this, name, [input].concat(args));
    };
    CompileView.prototype.getLocal = function (name) {
        if (name == constants_1.EventHandlerVars.event.name) {
            return constants_1.EventHandlerVars.event;
        }
        var currView = this;
        var result = currView.locals.get(name);
        while (lang_1.isBlank(result) && lang_1.isPresent(currView.declarationElement.view)) {
            currView = currView.declarationElement.view;
            result = currView.locals.get(name);
        }
        if (lang_1.isPresent(result)) {
            return util_1.getPropertyInView(result, this, currView);
        }
        else {
            return null;
        }
    };
    CompileView.prototype.createLiteralArray = function (values) {
        if (values.length === 0) {
            return o.importExpr(identifiers_1.Identifiers.EMPTY_ARRAY);
        }
        var proxyExpr = o.THIS_EXPR.prop("_arr_" + this.literalArrayCount++);
        var proxyParams = [];
        var proxyReturnEntries = [];
        for (var i = 0; i < values.length; i++) {
            var paramName = "p" + i;
            proxyParams.push(new o.FnParam(paramName));
            proxyReturnEntries.push(o.variable(paramName));
        }
        util_1.createPureProxy(o.fn(proxyParams, [new o.ReturnStatement(o.literalArr(proxyReturnEntries))]), values.length, proxyExpr, this);
        return proxyExpr.callFn(values);
    };
    CompileView.prototype.createLiteralMap = function (entries) {
        if (entries.length === 0) {
            return o.importExpr(identifiers_1.Identifiers.EMPTY_MAP);
        }
        var proxyExpr = o.THIS_EXPR.prop("_map_" + this.literalMapCount++);
        var proxyParams = [];
        var proxyReturnEntries = [];
        var values = [];
        for (var i = 0; i < entries.length; i++) {
            var paramName = "p" + i;
            proxyParams.push(new o.FnParam(paramName));
            proxyReturnEntries.push([entries[i][0], o.variable(paramName)]);
            values.push(entries[i][1]);
        }
        util_1.createPureProxy(o.fn(proxyParams, [new o.ReturnStatement(o.literalMap(proxyReturnEntries))]), entries.length, proxyExpr, this);
        return proxyExpr.callFn(values);
    };
    CompileView.prototype.afterNodes = function () {
        var _this = this;
        this.pipes.forEach(function (pipe) { return pipe.create(); });
        this.viewQueries.values().forEach(function (queries) { return queries.forEach(function (query) { return query.afterChildren(_this.updateViewQueriesMethod); }); });
    };
    return CompileView;
}());
exports.CompileView = CompileView;
function getViewType(component, embeddedTemplateIndex) {
    if (embeddedTemplateIndex > 0) {
        return core_private_1.ViewType.EMBEDDED;
    }
    else if (component.type.isHost) {
        return core_private_1.ViewType.HOST;
    }
    else {
        return core_private_1.ViewType.COMPONENT;
    }
}

},{"../../core_private":72,"../../src/facade/collection":87,"../../src/facade/lang":90,"../compile_metadata":76,"../identifiers":96,"../output/output_ast":103,"./compile_method":125,"./compile_pipe":126,"./compile_query":127,"./constants":129,"./util":134}],129:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../../core_private');
var lang_1 = require('../../src/facade/lang');
var compile_metadata_1 = require('../compile_metadata');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
function _enumExpression(classIdentifier, value) {
    if (lang_1.isBlank(value))
        return o.NULL_EXPR;
    var name = lang_1.resolveEnumToken(classIdentifier.runtime, value);
    return o.importExpr(new compile_metadata_1.CompileIdentifierMetadata({
        name: classIdentifier.name + "." + name,
        moduleUrl: classIdentifier.moduleUrl,
        runtime: value
    }));
}
var ViewTypeEnum = (function () {
    function ViewTypeEnum() {
    }
    ViewTypeEnum.fromValue = function (value) {
        return _enumExpression(identifiers_1.Identifiers.ViewType, value);
    };
    ViewTypeEnum.HOST = ViewTypeEnum.fromValue(core_private_1.ViewType.HOST);
    ViewTypeEnum.COMPONENT = ViewTypeEnum.fromValue(core_private_1.ViewType.COMPONENT);
    ViewTypeEnum.EMBEDDED = ViewTypeEnum.fromValue(core_private_1.ViewType.EMBEDDED);
    return ViewTypeEnum;
}());
exports.ViewTypeEnum = ViewTypeEnum;
var ViewEncapsulationEnum = (function () {
    function ViewEncapsulationEnum() {
    }
    ViewEncapsulationEnum.fromValue = function (value) {
        return _enumExpression(identifiers_1.Identifiers.ViewEncapsulation, value);
    };
    ViewEncapsulationEnum.Emulated = ViewEncapsulationEnum.fromValue(core_1.ViewEncapsulation.Emulated);
    ViewEncapsulationEnum.Native = ViewEncapsulationEnum.fromValue(core_1.ViewEncapsulation.Native);
    ViewEncapsulationEnum.None = ViewEncapsulationEnum.fromValue(core_1.ViewEncapsulation.None);
    return ViewEncapsulationEnum;
}());
exports.ViewEncapsulationEnum = ViewEncapsulationEnum;
var ChangeDetectorStateEnum = (function () {
    function ChangeDetectorStateEnum() {
    }
    ChangeDetectorStateEnum.fromValue = function (value) {
        return _enumExpression(identifiers_1.Identifiers.ChangeDetectorState, value);
    };
    ChangeDetectorStateEnum.NeverChecked = ChangeDetectorStateEnum.fromValue(core_private_1.ChangeDetectorState.NeverChecked);
    ChangeDetectorStateEnum.CheckedBefore = ChangeDetectorStateEnum.fromValue(core_private_1.ChangeDetectorState.CheckedBefore);
    ChangeDetectorStateEnum.Errored = ChangeDetectorStateEnum.fromValue(core_private_1.ChangeDetectorState.Errored);
    return ChangeDetectorStateEnum;
}());
exports.ChangeDetectorStateEnum = ChangeDetectorStateEnum;
var ChangeDetectionStrategyEnum = (function () {
    function ChangeDetectionStrategyEnum() {
    }
    ChangeDetectionStrategyEnum.fromValue = function (value) {
        return _enumExpression(identifiers_1.Identifiers.ChangeDetectionStrategy, value);
    };
    ChangeDetectionStrategyEnum.CheckOnce = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.CheckOnce);
    ChangeDetectionStrategyEnum.Checked = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.Checked);
    ChangeDetectionStrategyEnum.CheckAlways = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.CheckAlways);
    ChangeDetectionStrategyEnum.Detached = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.Detached);
    ChangeDetectionStrategyEnum.OnPush = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.OnPush);
    ChangeDetectionStrategyEnum.Default = ChangeDetectionStrategyEnum.fromValue(core_1.ChangeDetectionStrategy.Default);
    return ChangeDetectionStrategyEnum;
}());
exports.ChangeDetectionStrategyEnum = ChangeDetectionStrategyEnum;
var ViewConstructorVars = (function () {
    function ViewConstructorVars() {
    }
    ViewConstructorVars.viewUtils = o.variable('viewUtils');
    ViewConstructorVars.parentInjector = o.variable('parentInjector');
    ViewConstructorVars.declarationEl = o.variable('declarationEl');
    return ViewConstructorVars;
}());
exports.ViewConstructorVars = ViewConstructorVars;
var ViewProperties = (function () {
    function ViewProperties() {
    }
    ViewProperties.renderer = o.THIS_EXPR.prop('renderer');
    ViewProperties.projectableNodes = o.THIS_EXPR.prop('projectableNodes');
    ViewProperties.viewUtils = o.THIS_EXPR.prop('viewUtils');
    return ViewProperties;
}());
exports.ViewProperties = ViewProperties;
var EventHandlerVars = (function () {
    function EventHandlerVars() {
    }
    EventHandlerVars.event = o.variable('$event');
    return EventHandlerVars;
}());
exports.EventHandlerVars = EventHandlerVars;
var InjectMethodVars = (function () {
    function InjectMethodVars() {
    }
    InjectMethodVars.token = o.variable('token');
    InjectMethodVars.requestNodeIndex = o.variable('requestNodeIndex');
    InjectMethodVars.notFoundResult = o.variable('notFoundResult');
    return InjectMethodVars;
}());
exports.InjectMethodVars = InjectMethodVars;
var DetectChangesVars = (function () {
    function DetectChangesVars() {
    }
    DetectChangesVars.throwOnChange = o.variable("throwOnChange");
    DetectChangesVars.changes = o.variable("changes");
    DetectChangesVars.changed = o.variable("changed");
    DetectChangesVars.valUnwrapper = o.variable("valUnwrapper");
    return DetectChangesVars;
}());
exports.DetectChangesVars = DetectChangesVars;

},{"../../core_private":72,"../../src/facade/lang":90,"../compile_metadata":76,"../identifiers":96,"../output/output_ast":103,"@angular/core":140}],130:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var constants_1 = require('./constants');
var o = require('../output/output_ast');
var compile_method_1 = require('./compile_method');
var expression_converter_1 = require('./expression_converter');
var compile_binding_1 = require('./compile_binding');
var CompileEventListener = (function () {
    function CompileEventListener(compileElement, eventTarget, eventName, listenerIndex) {
        this.compileElement = compileElement;
        this.eventTarget = eventTarget;
        this.eventName = eventName;
        this._hasComponentHostListener = false;
        this._actionResultExprs = [];
        this._method = new compile_method_1.CompileMethod(compileElement.view);
        this._methodName =
            "_handle_" + santitizeEventName(eventName) + "_" + compileElement.nodeIndex + "_" + listenerIndex;
        this._eventParam =
            new o.FnParam(constants_1.EventHandlerVars.event.name, o.importType(this.compileElement.view.genConfig.renderTypes.renderEvent));
    }
    CompileEventListener.getOrCreate = function (compileElement, eventTarget, eventName, targetEventListeners) {
        var listener = targetEventListeners.find(function (listener) { return listener.eventTarget == eventTarget &&
            listener.eventName == eventName; });
        if (lang_1.isBlank(listener)) {
            listener = new CompileEventListener(compileElement, eventTarget, eventName, targetEventListeners.length);
            targetEventListeners.push(listener);
        }
        return listener;
    };
    CompileEventListener.prototype.addAction = function (hostEvent, directive, directiveInstance) {
        if (lang_1.isPresent(directive) && directive.isComponent) {
            this._hasComponentHostListener = true;
        }
        this._method.resetDebugInfo(this.compileElement.nodeIndex, hostEvent);
        var context = lang_1.isPresent(directiveInstance) ? directiveInstance :
            this.compileElement.view.componentContext;
        var actionStmts = expression_converter_1.convertCdStatementToIr(this.compileElement.view, context, hostEvent.handler);
        var lastIndex = actionStmts.length - 1;
        if (lastIndex >= 0) {
            var lastStatement = actionStmts[lastIndex];
            var returnExpr = convertStmtIntoExpression(lastStatement);
            var preventDefaultVar = o.variable("pd_" + this._actionResultExprs.length);
            this._actionResultExprs.push(preventDefaultVar);
            if (lang_1.isPresent(returnExpr)) {
                // Note: We need to cast the result of the method call to dynamic,
                // as it might be a void method!
                actionStmts[lastIndex] =
                    preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))
                        .toDeclStmt(null, [o.StmtModifier.Final]);
            }
        }
        this._method.addStmts(actionStmts);
    };
    CompileEventListener.prototype.finishMethod = function () {
        var markPathToRootStart = this._hasComponentHostListener ?
            this.compileElement.appElement.prop('componentView') :
            o.THIS_EXPR;
        var resultExpr = o.literal(true);
        this._actionResultExprs.forEach(function (expr) { resultExpr = resultExpr.and(expr); });
        var stmts = [markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt()]
            .concat(this._method.finish())
            .concat([new o.ReturnStatement(resultExpr)]);
        // private is fine here as no child view will reference the event handler...
        this.compileElement.view.eventHandlerMethods.push(new o.ClassMethod(this._methodName, [this._eventParam], stmts, o.BOOL_TYPE, [o.StmtModifier.Private]));
    };
    CompileEventListener.prototype.listenToRenderer = function () {
        var listenExpr;
        var eventListener = o.THIS_EXPR.callMethod('eventHandler', [o.THIS_EXPR.prop(this._methodName).callMethod(o.BuiltinMethod.bind, [o.THIS_EXPR])]);
        if (lang_1.isPresent(this.eventTarget)) {
            listenExpr = constants_1.ViewProperties.renderer.callMethod('listenGlobal', [o.literal(this.eventTarget), o.literal(this.eventName), eventListener]);
        }
        else {
            listenExpr = constants_1.ViewProperties.renderer.callMethod('listen', [this.compileElement.renderNode, o.literal(this.eventName), eventListener]);
        }
        var disposable = o.variable("disposable_" + this.compileElement.view.disposables.length);
        this.compileElement.view.disposables.push(disposable);
        // private is fine here as no child view will reference the event handler...
        this.compileElement.view.createMethod.addStmt(disposable.set(listenExpr).toDeclStmt(o.FUNCTION_TYPE, [o.StmtModifier.Private]));
    };
    CompileEventListener.prototype.listenToDirective = function (directiveInstance, observablePropName) {
        var subscription = o.variable("subscription_" + this.compileElement.view.subscriptions.length);
        this.compileElement.view.subscriptions.push(subscription);
        var eventListener = o.THIS_EXPR.callMethod('eventHandler', [o.THIS_EXPR.prop(this._methodName).callMethod(o.BuiltinMethod.bind, [o.THIS_EXPR])]);
        this.compileElement.view.createMethod.addStmt(subscription.set(directiveInstance.prop(observablePropName)
            .callMethod(o.BuiltinMethod.SubscribeObservable, [eventListener]))
            .toDeclStmt(null, [o.StmtModifier.Final]));
    };
    return CompileEventListener;
}());
exports.CompileEventListener = CompileEventListener;
function collectEventListeners(hostEvents, dirs, compileElement) {
    var eventListeners = [];
    hostEvents.forEach(function (hostEvent) {
        compileElement.view.bindings.push(new compile_binding_1.CompileBinding(compileElement, hostEvent));
        var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
        listener.addAction(hostEvent, null, null);
    });
    collection_1.ListWrapper.forEachWithIndex(dirs, function (directiveAst, i) {
        var directiveInstance = compileElement.directiveInstances[i];
        directiveAst.hostEvents.forEach(function (hostEvent) {
            compileElement.view.bindings.push(new compile_binding_1.CompileBinding(compileElement, hostEvent));
            var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
            listener.addAction(hostEvent, directiveAst.directive, directiveInstance);
        });
    });
    eventListeners.forEach(function (listener) { return listener.finishMethod(); });
    return eventListeners;
}
exports.collectEventListeners = collectEventListeners;
function bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners) {
    collection_1.StringMapWrapper.forEach(directiveAst.directive.outputs, function (eventName, observablePropName) {
        eventListeners.filter(function (listener) { return listener.eventName == eventName; })
            .forEach(function (listener) { listener.listenToDirective(directiveInstance, observablePropName); });
    });
}
exports.bindDirectiveOutputs = bindDirectiveOutputs;
function bindRenderOutputs(eventListeners) {
    eventListeners.forEach(function (listener) { return listener.listenToRenderer(); });
}
exports.bindRenderOutputs = bindRenderOutputs;
function convertStmtIntoExpression(stmt) {
    if (stmt instanceof o.ExpressionStatement) {
        return stmt.expr;
    }
    else if (stmt instanceof o.ReturnStatement) {
        return stmt.value;
    }
    return null;
}
function santitizeEventName(name) {
    return lang_1.StringWrapper.replaceAll(name, /[^a-zA-Z_]/g, '_');
}

},{"../../src/facade/collection":87,"../../src/facade/lang":90,"../output/output_ast":103,"./compile_binding":123,"./compile_method":125,"./constants":129,"./expression_converter":131}],131:[function(require,module,exports){
"use strict";
var exceptions_1 = require('../../src/facade/exceptions');
var lang_1 = require('../../src/facade/lang');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
var IMPLICIT_RECEIVER = o.variable('#implicit');
var ExpressionWithWrappedValueInfo = (function () {
    function ExpressionWithWrappedValueInfo(expression, needsValueUnwrapper) {
        this.expression = expression;
        this.needsValueUnwrapper = needsValueUnwrapper;
    }
    return ExpressionWithWrappedValueInfo;
}());
exports.ExpressionWithWrappedValueInfo = ExpressionWithWrappedValueInfo;
function convertCdExpressionToIr(nameResolver, implicitReceiver, expression, valueUnwrapper) {
    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, valueUnwrapper);
    var irAst = expression.visit(visitor, _Mode.Expression);
    return new ExpressionWithWrappedValueInfo(irAst, visitor.needsValueUnwrapper);
}
exports.convertCdExpressionToIr = convertCdExpressionToIr;
function convertCdStatementToIr(nameResolver, implicitReceiver, stmt) {
    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, null);
    var statements = [];
    flattenStatements(stmt.visit(visitor, _Mode.Statement), statements);
    return statements;
}
exports.convertCdStatementToIr = convertCdStatementToIr;
var _Mode;
(function (_Mode) {
    _Mode[_Mode["Statement"] = 0] = "Statement";
    _Mode[_Mode["Expression"] = 1] = "Expression";
})(_Mode || (_Mode = {}));
function ensureStatementMode(mode, ast) {
    if (mode !== _Mode.Statement) {
        throw new exceptions_1.BaseException("Expected a statement, but saw " + ast);
    }
}
function ensureExpressionMode(mode, ast) {
    if (mode !== _Mode.Expression) {
        throw new exceptions_1.BaseException("Expected an expression, but saw " + ast);
    }
}
function convertToStatementIfNeeded(mode, expr) {
    if (mode === _Mode.Statement) {
        return expr.toStmt();
    }
    else {
        return expr;
    }
}
var _AstToIrVisitor = (function () {
    function _AstToIrVisitor(_nameResolver, _implicitReceiver, _valueUnwrapper) {
        this._nameResolver = _nameResolver;
        this._implicitReceiver = _implicitReceiver;
        this._valueUnwrapper = _valueUnwrapper;
        this.needsValueUnwrapper = false;
    }
    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {
        var op;
        switch (ast.operation) {
            case '+':
                op = o.BinaryOperator.Plus;
                break;
            case '-':
                op = o.BinaryOperator.Minus;
                break;
            case '*':
                op = o.BinaryOperator.Multiply;
                break;
            case '/':
                op = o.BinaryOperator.Divide;
                break;
            case '%':
                op = o.BinaryOperator.Modulo;
                break;
            case '&&':
                op = o.BinaryOperator.And;
                break;
            case '||':
                op = o.BinaryOperator.Or;
                break;
            case '==':
                op = o.BinaryOperator.Equals;
                break;
            case '!=':
                op = o.BinaryOperator.NotEquals;
                break;
            case '===':
                op = o.BinaryOperator.Identical;
                break;
            case '!==':
                op = o.BinaryOperator.NotIdentical;
                break;
            case '<':
                op = o.BinaryOperator.Lower;
                break;
            case '>':
                op = o.BinaryOperator.Bigger;
                break;
            case '<=':
                op = o.BinaryOperator.LowerEquals;
                break;
            case '>=':
                op = o.BinaryOperator.BiggerEquals;
                break;
            default:
                throw new exceptions_1.BaseException("Unsupported operation " + ast.operation);
        }
        return convertToStatementIfNeeded(mode, new o.BinaryOperatorExpr(op, ast.left.visit(this, _Mode.Expression), ast.right.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {
        ensureStatementMode(mode, ast);
        return this.visitAll(ast.expressions, mode);
    };
    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {
        var value = ast.condition.visit(this, _Mode.Expression);
        return convertToStatementIfNeeded(mode, value.conditional(ast.trueExp.visit(this, _Mode.Expression), ast.falseExp.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {
        var input = ast.exp.visit(this, _Mode.Expression);
        var args = this.visitAll(ast.args, _Mode.Expression);
        var value = this._nameResolver.callPipe(ast.name, input, args);
        this.needsValueUnwrapper = true;
        return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
    };
    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {
        return convertToStatementIfNeeded(mode, ast.target.visit(this, _Mode.Expression)
            .callFn(this.visitAll(ast.args, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {
        ensureExpressionMode(mode, ast);
        return IMPLICIT_RECEIVER;
    };
    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {
        ensureExpressionMode(mode, ast);
        var args = [o.literal(ast.expressions.length)];
        for (var i = 0; i < ast.strings.length - 1; i++) {
            args.push(o.literal(ast.strings[i]));
            args.push(ast.expressions[i].visit(this, _Mode.Expression));
        }
        args.push(o.literal(ast.strings[ast.strings.length - 1]));
        return o.importExpr(identifiers_1.Identifiers.interpolate).callFn(args);
    };
    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {
        return convertToStatementIfNeeded(mode, ast.obj.visit(this, _Mode.Expression).key(ast.key.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {
        var obj = ast.obj.visit(this, _Mode.Expression);
        var key = ast.key.visit(this, _Mode.Expression);
        var value = ast.value.visit(this, _Mode.Expression);
        return convertToStatementIfNeeded(mode, obj.key(key).set(value));
    };
    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {
        return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralArray(this.visitAll(ast.expressions, mode)));
    };
    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {
        var parts = [];
        for (var i = 0; i < ast.keys.length; i++) {
            parts.push([ast.keys[i], ast.values[i].visit(this, _Mode.Expression)]);
        }
        return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralMap(parts));
    };
    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {
        return convertToStatementIfNeeded(mode, o.literal(ast.value));
    };
    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {
        var args = this.visitAll(ast.args, _Mode.Expression);
        var result = null;
        var receiver = ast.receiver.visit(this, _Mode.Expression);
        if (receiver === IMPLICIT_RECEIVER) {
            var varExpr = this._nameResolver.getLocal(ast.name);
            if (lang_1.isPresent(varExpr)) {
                result = varExpr.callFn(args);
            }
            else {
                receiver = this._implicitReceiver;
            }
        }
        if (lang_1.isBlank(result)) {
            result = receiver.callMethod(ast.name, args);
        }
        return convertToStatementIfNeeded(mode, result);
    };
    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {
        return convertToStatementIfNeeded(mode, o.not(ast.expression.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {
        var result = null;
        var receiver = ast.receiver.visit(this, _Mode.Expression);
        if (receiver === IMPLICIT_RECEIVER) {
            result = this._nameResolver.getLocal(ast.name);
            if (lang_1.isBlank(result)) {
                receiver = this._implicitReceiver;
            }
        }
        if (lang_1.isBlank(result)) {
            result = receiver.prop(ast.name);
        }
        return convertToStatementIfNeeded(mode, result);
    };
    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {
        var receiver = ast.receiver.visit(this, _Mode.Expression);
        if (receiver === IMPLICIT_RECEIVER) {
            var varExpr = this._nameResolver.getLocal(ast.name);
            if (lang_1.isPresent(varExpr)) {
                throw new exceptions_1.BaseException('Cannot assign to a reference or variable!');
            }
            receiver = this._implicitReceiver;
        }
        return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(ast.value.visit(this, _Mode.Expression)));
    };
    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {
        var receiver = ast.receiver.visit(this, _Mode.Expression);
        return convertToStatementIfNeeded(mode, receiver.isBlank().conditional(o.NULL_EXPR, receiver.prop(ast.name)));
    };
    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {
        var receiver = ast.receiver.visit(this, _Mode.Expression);
        var args = this.visitAll(ast.args, _Mode.Expression);
        return convertToStatementIfNeeded(mode, receiver.isBlank().conditional(o.NULL_EXPR, receiver.callMethod(ast.name, args)));
    };
    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {
        var _this = this;
        return asts.map(function (ast) { return ast.visit(_this, mode); });
    };
    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {
        throw new exceptions_1.BaseException('Quotes are not supported for evaluation!');
    };
    return _AstToIrVisitor;
}());
function flattenStatements(arg, output) {
    if (lang_1.isArray(arg)) {
        arg.forEach(function (entry) { return flattenStatements(entry, output); });
    }
    else {
        output.push(arg);
    }
}

},{"../../src/facade/exceptions":89,"../../src/facade/lang":90,"../identifiers":96,"../output/output_ast":103}],132:[function(require,module,exports){
"use strict";
var core_private_1 = require('../../core_private');
var o = require('../output/output_ast');
var constants_1 = require('./constants');
var STATE_IS_NEVER_CHECKED = o.THIS_EXPR.prop('cdState').identical(constants_1.ChangeDetectorStateEnum.NeverChecked);
var NOT_THROW_ON_CHANGES = o.not(constants_1.DetectChangesVars.throwOnChange);
function bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement) {
    var view = compileElement.view;
    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
    var lifecycleHooks = directiveAst.directive.lifecycleHooks;
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnChanges) !== -1 && directiveAst.inputs.length > 0) {
        detectChangesInInputsMethod.addStmt(new o.IfStmt(constants_1.DetectChangesVars.changes.notIdentical(o.NULL_EXPR), [directiveInstance.callMethod('ngOnChanges', [constants_1.DetectChangesVars.changes]).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnInit) !== -1) {
        detectChangesInInputsMethod.addStmt(new o.IfStmt(STATE_IS_NEVER_CHECKED.and(NOT_THROW_ON_CHANGES), [directiveInstance.callMethod('ngOnInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.DoCheck) !== -1) {
        detectChangesInInputsMethod.addStmt(new o.IfStmt(NOT_THROW_ON_CHANGES, [directiveInstance.callMethod('ngDoCheck', []).toStmt()]));
    }
}
exports.bindDirectiveDetectChangesLifecycleCallbacks = bindDirectiveDetectChangesLifecycleCallbacks;
function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var view = compileElement.view;
    var lifecycleHooks = directiveMeta.lifecycleHooks;
    var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
    afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterContentInit) !== -1) {
        afterContentLifecycleCallbacksMethod.addStmt(new o.IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterContentChecked) !== -1) {
        afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
    }
}
exports.bindDirectiveAfterContentLifecycleCallbacks = bindDirectiveAfterContentLifecycleCallbacks;
function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var view = compileElement.view;
    var lifecycleHooks = directiveMeta.lifecycleHooks;
    var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
    afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterViewInit) !== -1) {
        afterViewLifecycleCallbacksMethod.addStmt(new o.IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
    }
    if (lifecycleHooks.indexOf(core_private_1.LifecycleHooks.AfterViewChecked) !== -1) {
        afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
    }
}
exports.bindDirectiveAfterViewLifecycleCallbacks = bindDirectiveAfterViewLifecycleCallbacks;
function bindDirectiveDestroyLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
    var onDestroyMethod = compileElement.view.destroyMethod;
    onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    if (directiveMeta.lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnDestroy) !== -1) {
        onDestroyMethod.addStmt(directiveInstance.callMethod('ngOnDestroy', []).toStmt());
    }
}
exports.bindDirectiveDestroyLifecycleCallbacks = bindDirectiveDestroyLifecycleCallbacks;
function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
    var onDestroyMethod = view.destroyMethod;
    if (pipeMeta.lifecycleHooks.indexOf(core_private_1.LifecycleHooks.OnDestroy) !== -1) {
        onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
    }
}
exports.bindPipeDestroyLifecycleCallbacks = bindPipeDestroyLifecycleCallbacks;

},{"../../core_private":72,"../output/output_ast":103,"./constants":129}],133:[function(require,module,exports){
"use strict";
var core_private_1 = require('../../core_private');
var core_private_2 = require('../../core_private');
var lang_1 = require('../../src/facade/lang');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
var constants_1 = require('./constants');
var template_ast_1 = require('../template_ast');
var util_1 = require('../util');
var expression_converter_1 = require('./expression_converter');
var compile_binding_1 = require('./compile_binding');
function createBindFieldExpr(exprIndex) {
    return o.THIS_EXPR.prop("_expr_" + exprIndex);
}
function createCurrValueExpr(exprIndex) {
    return o.variable("currVal_" + exprIndex); // fix syntax highlighting: `
}
function bind(view, currValExpr, fieldExpr, parsedExpression, context, actions, method) {
    var checkExpression = expression_converter_1.convertCdExpressionToIr(view, context, parsedExpression, constants_1.DetectChangesVars.valUnwrapper);
    if (lang_1.isBlank(checkExpression.expression)) {
        // e.g. an empty expression was given
        return;
    }
    // private is fine here as no child view will reference the cached value...
    view.fields.push(new o.ClassField(fieldExpr.name, null, [o.StmtModifier.Private]));
    view.createMethod.addStmt(o.THIS_EXPR.prop(fieldExpr.name).set(o.importExpr(identifiers_1.Identifiers.uninitialized)).toStmt());
    if (checkExpression.needsValueUnwrapper) {
        var initValueUnwrapperStmt = constants_1.DetectChangesVars.valUnwrapper.callMethod('reset', []).toStmt();
        method.addStmt(initValueUnwrapperStmt);
    }
    method.addStmt(currValExpr.set(checkExpression.expression).toDeclStmt(null, [o.StmtModifier.Final]));
    var condition = o.importExpr(identifiers_1.Identifiers.checkBinding)
        .callFn([constants_1.DetectChangesVars.throwOnChange, fieldExpr, currValExpr]);
    if (checkExpression.needsValueUnwrapper) {
        condition = constants_1.DetectChangesVars.valUnwrapper.prop('hasWrappedValue').or(condition);
    }
    method.addStmt(new o.IfStmt(condition, actions.concat([o.THIS_EXPR.prop(fieldExpr.name).set(currValExpr).toStmt()])));
}
function bindRenderText(boundText, compileNode, view) {
    var bindingIndex = view.bindings.length;
    view.bindings.push(new compile_binding_1.CompileBinding(compileNode, boundText));
    var currValExpr = createCurrValueExpr(bindingIndex);
    var valueField = createBindFieldExpr(bindingIndex);
    view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
    bind(view, currValExpr, valueField, boundText.value, view.componentContext, [
        o.THIS_EXPR.prop('renderer')
            .callMethod('setText', [compileNode.renderNode, currValExpr])
            .toStmt()
    ], view.detectChangesRenderPropertiesMethod);
}
exports.bindRenderText = bindRenderText;
function bindAndWriteToRenderer(boundProps, context, compileElement) {
    var view = compileElement.view;
    var renderNode = compileElement.renderNode;
    boundProps.forEach(function (boundProp) {
        var bindingIndex = view.bindings.length;
        view.bindings.push(new compile_binding_1.CompileBinding(compileElement, boundProp));
        view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
        var fieldExpr = createBindFieldExpr(bindingIndex);
        var currValExpr = createCurrValueExpr(bindingIndex);
        var renderMethod;
        var renderValue = sanitizedValue(boundProp, currValExpr);
        var updateStmts = [];
        switch (boundProp.type) {
            case template_ast_1.PropertyBindingType.Property:
                renderMethod = 'setElementProperty';
                if (view.genConfig.logBindingUpdate) {
                    updateStmts.push(logBindingUpdateStmt(renderNode, boundProp.name, currValExpr));
                }
                break;
            case template_ast_1.PropertyBindingType.Attribute:
                renderMethod = 'setElementAttribute';
                renderValue =
                    renderValue.isBlank().conditional(o.NULL_EXPR, renderValue.callMethod('toString', []));
                break;
            case template_ast_1.PropertyBindingType.Class:
                renderMethod = 'setElementClass';
                break;
            case template_ast_1.PropertyBindingType.Style:
                renderMethod = 'setElementStyle';
                var strValue = renderValue.callMethod('toString', []);
                if (lang_1.isPresent(boundProp.unit)) {
                    strValue = strValue.plus(o.literal(boundProp.unit));
                }
                renderValue = renderValue.isBlank().conditional(o.NULL_EXPR, strValue);
                break;
        }
        updateStmts.push(o.THIS_EXPR.prop('renderer')
            .callMethod(renderMethod, [renderNode, o.literal(boundProp.name), renderValue])
            .toStmt());
        bind(view, currValExpr, fieldExpr, boundProp.value, context, updateStmts, view.detectChangesRenderPropertiesMethod);
    });
}
function sanitizedValue(boundProp, renderValue) {
    var enumValue;
    switch (boundProp.securityContext) {
        case core_private_1.SecurityContext.NONE:
            return renderValue; // No sanitization needed.
        case core_private_1.SecurityContext.HTML:
            enumValue = 'HTML';
            break;
        case core_private_1.SecurityContext.STYLE:
            enumValue = 'STYLE';
            break;
        case core_private_1.SecurityContext.SCRIPT:
            enumValue = 'SCRIPT';
            break;
        case core_private_1.SecurityContext.URL:
            enumValue = 'URL';
            break;
        case core_private_1.SecurityContext.RESOURCE_URL:
            enumValue = 'RESOURCE_URL';
            break;
        default:
            throw new Error("internal error, unexpected SecurityContext " + boundProp.securityContext + ".");
    }
    var ctx = constants_1.ViewProperties.viewUtils.prop('sanitizer');
    var args = [o.importExpr(identifiers_1.Identifiers.SecurityContext).prop(enumValue), renderValue];
    return ctx.callMethod('sanitize', args);
}
function bindRenderInputs(boundProps, compileElement) {
    bindAndWriteToRenderer(boundProps, compileElement.view.componentContext, compileElement);
}
exports.bindRenderInputs = bindRenderInputs;
function bindDirectiveHostProps(directiveAst, directiveInstance, compileElement) {
    bindAndWriteToRenderer(directiveAst.hostProperties, directiveInstance, compileElement);
}
exports.bindDirectiveHostProps = bindDirectiveHostProps;
function bindDirectiveInputs(directiveAst, directiveInstance, compileElement) {
    if (directiveAst.inputs.length === 0) {
        return;
    }
    var view = compileElement.view;
    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
    detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
    var lifecycleHooks = directiveAst.directive.lifecycleHooks;
    var calcChangesMap = lifecycleHooks.indexOf(core_private_2.LifecycleHooks.OnChanges) !== -1;
    var isOnPushComp = directiveAst.directive.isComponent &&
        !core_private_2.isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);
    if (calcChangesMap) {
        detectChangesInInputsMethod.addStmt(constants_1.DetectChangesVars.changes.set(o.NULL_EXPR).toStmt());
    }
    if (isOnPushComp) {
        detectChangesInInputsMethod.addStmt(constants_1.DetectChangesVars.changed.set(o.literal(false)).toStmt());
    }
    directiveAst.inputs.forEach(function (input) {
        var bindingIndex = view.bindings.length;
        view.bindings.push(new compile_binding_1.CompileBinding(compileElement, input));
        detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
        var fieldExpr = createBindFieldExpr(bindingIndex);
        var currValExpr = createCurrValueExpr(bindingIndex);
        var statements = [directiveInstance.prop(input.directiveName).set(currValExpr).toStmt()];
        if (calcChangesMap) {
            statements.push(new o.IfStmt(constants_1.DetectChangesVars.changes.identical(o.NULL_EXPR), [
                constants_1.DetectChangesVars.changes.set(o.literalMap([], new o.MapType(o.importType(identifiers_1.Identifiers.SimpleChange))))
                    .toStmt()
            ]));
            statements.push(constants_1.DetectChangesVars.changes.key(o.literal(input.directiveName))
                .set(o.importExpr(identifiers_1.Identifiers.SimpleChange).instantiate([fieldExpr, currValExpr]))
                .toStmt());
        }
        if (isOnPushComp) {
            statements.push(constants_1.DetectChangesVars.changed.set(o.literal(true)).toStmt());
        }
        if (view.genConfig.logBindingUpdate) {
            statements.push(logBindingUpdateStmt(compileElement.renderNode, input.directiveName, currValExpr));
        }
        bind(view, currValExpr, fieldExpr, input.value, view.componentContext, statements, detectChangesInInputsMethod);
    });
    if (isOnPushComp) {
        detectChangesInInputsMethod.addStmt(new o.IfStmt(constants_1.DetectChangesVars.changed, [
            compileElement.appElement.prop('componentView')
                .callMethod('markAsCheckOnce', [])
                .toStmt()
        ]));
    }
}
exports.bindDirectiveInputs = bindDirectiveInputs;
function logBindingUpdateStmt(renderNode, propName, value) {
    return o.THIS_EXPR.prop('renderer')
        .callMethod('setBindingDebugInfo', [
        renderNode,
        o.literal("ng-reflect-" + util_1.camelCaseToDashCase(propName)),
        value.isBlank().conditional(o.NULL_EXPR, value.callMethod('toString', []))
    ])
        .toStmt();
}

},{"../../core_private":72,"../../src/facade/lang":90,"../identifiers":96,"../output/output_ast":103,"../template_ast":118,"../util":122,"./compile_binding":123,"./constants":129,"./expression_converter":131}],134:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
function getPropertyInView(property, callingView, definedView) {
    if (callingView === definedView) {
        return property;
    }
    else {
        var viewProp = o.THIS_EXPR;
        var currView = callingView;
        while (currView !== definedView && lang_1.isPresent(currView.declarationElement.view)) {
            currView = currView.declarationElement.view;
            viewProp = viewProp.prop('parent');
        }
        if (currView !== definedView) {
            throw new exceptions_1.BaseException("Internal error: Could not calculate a property in a parent view: " + property);
        }
        if (property instanceof o.ReadPropExpr) {
            var readPropExpr_1 = property;
            // Note: Don't cast for members of the AppView base class...
            if (definedView.fields.some(function (field) { return field.name == readPropExpr_1.name; }) ||
                definedView.getters.some(function (field) { return field.name == readPropExpr_1.name; })) {
                viewProp = viewProp.cast(definedView.classType);
            }
        }
        return o.replaceVarInExpression(o.THIS_EXPR.name, viewProp, property);
    }
}
exports.getPropertyInView = getPropertyInView;
function injectFromViewParentInjector(token, optional) {
    var args = [createDiTokenExpression(token)];
    if (optional) {
        args.push(o.NULL_EXPR);
    }
    return o.THIS_EXPR.prop('parentInjector').callMethod('get', args);
}
exports.injectFromViewParentInjector = injectFromViewParentInjector;
function getViewFactoryName(component, embeddedTemplateIndex) {
    return "viewFactory_" + component.type.name + embeddedTemplateIndex;
}
exports.getViewFactoryName = getViewFactoryName;
function createDiTokenExpression(token) {
    if (lang_1.isPresent(token.value)) {
        return o.literal(token.value);
    }
    else if (token.identifierIsInstance) {
        return o.importExpr(token.identifier)
            .instantiate([], o.importType(token.identifier, [], [o.TypeModifier.Const]));
    }
    else {
        return o.importExpr(token.identifier);
    }
}
exports.createDiTokenExpression = createDiTokenExpression;
function createFlatArray(expressions) {
    var lastNonArrayExpressions = [];
    var result = o.literalArr([]);
    for (var i = 0; i < expressions.length; i++) {
        var expr = expressions[i];
        if (expr.type instanceof o.ArrayType) {
            if (lastNonArrayExpressions.length > 0) {
                result =
                    result.callMethod(o.BuiltinMethod.ConcatArray, [o.literalArr(lastNonArrayExpressions)]);
                lastNonArrayExpressions = [];
            }
            result = result.callMethod(o.BuiltinMethod.ConcatArray, [expr]);
        }
        else {
            lastNonArrayExpressions.push(expr);
        }
    }
    if (lastNonArrayExpressions.length > 0) {
        result =
            result.callMethod(o.BuiltinMethod.ConcatArray, [o.literalArr(lastNonArrayExpressions)]);
    }
    return result;
}
exports.createFlatArray = createFlatArray;
function createPureProxy(fn, argCount, pureProxyProp, view) {
    view.fields.push(new o.ClassField(pureProxyProp.name, null));
    var pureProxyId = argCount < identifiers_1.Identifiers.pureProxies.length ? identifiers_1.Identifiers.pureProxies[argCount] : null;
    if (lang_1.isBlank(pureProxyId)) {
        throw new exceptions_1.BaseException("Unsupported number of argument for pure functions: " + argCount);
    }
    view.createMethod.addStmt(o.THIS_EXPR.prop(pureProxyProp.name).set(o.importExpr(pureProxyId).callFn([fn])).toStmt());
}
exports.createPureProxy = createPureProxy;

},{"../../src/facade/exceptions":89,"../../src/facade/lang":90,"../identifiers":96,"../output/output_ast":103}],135:[function(require,module,exports){
"use strict";
var collection_1 = require('../../src/facade/collection');
var template_ast_1 = require('../template_ast');
var property_binder_1 = require('./property_binder');
var event_binder_1 = require('./event_binder');
var lifecycle_binder_1 = require('./lifecycle_binder');
function bindView(view, parsedTemplate) {
    var visitor = new ViewBinderVisitor(view);
    template_ast_1.templateVisitAll(visitor, parsedTemplate);
    view.pipes.forEach(function (pipe) { lifecycle_binder_1.bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view); });
}
exports.bindView = bindView;
var ViewBinderVisitor = (function () {
    function ViewBinderVisitor(view) {
        this.view = view;
        this._nodeIndex = 0;
    }
    ViewBinderVisitor.prototype.visitBoundText = function (ast, parent) {
        var node = this.view.nodes[this._nodeIndex++];
        property_binder_1.bindRenderText(ast, node, this.view);
        return null;
    };
    ViewBinderVisitor.prototype.visitText = function (ast, parent) {
        this._nodeIndex++;
        return null;
    };
    ViewBinderVisitor.prototype.visitNgContent = function (ast, parent) { return null; };
    ViewBinderVisitor.prototype.visitElement = function (ast, parent) {
        var compileElement = this.view.nodes[this._nodeIndex++];
        var eventListeners = event_binder_1.collectEventListeners(ast.outputs, ast.directives, compileElement);
        property_binder_1.bindRenderInputs(ast.inputs, compileElement);
        event_binder_1.bindRenderOutputs(eventListeners);
        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {
            var directiveInstance = compileElement.directiveInstances[index];
            property_binder_1.bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
            lifecycle_binder_1.bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
            property_binder_1.bindDirectiveHostProps(directiveAst, directiveInstance, compileElement);
            event_binder_1.bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
        });
        template_ast_1.templateVisitAll(this, ast.children, compileElement);
        // afterContent and afterView lifecycles need to be called bottom up
        // so that children are notified before parents
        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {
            var directiveInstance = compileElement.directiveInstances[index];
            lifecycle_binder_1.bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
            lifecycle_binder_1.bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
            lifecycle_binder_1.bindDirectiveDestroyLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        });
        return null;
    };
    ViewBinderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
        var compileElement = this.view.nodes[this._nodeIndex++];
        var eventListeners = event_binder_1.collectEventListeners(ast.outputs, ast.directives, compileElement);
        collection_1.ListWrapper.forEachWithIndex(ast.directives, function (directiveAst, index) {
            var directiveInstance = compileElement.directiveInstances[index];
            property_binder_1.bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
            lifecycle_binder_1.bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
            event_binder_1.bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
            lifecycle_binder_1.bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
            lifecycle_binder_1.bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
            lifecycle_binder_1.bindDirectiveDestroyLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
        });
        bindView(compileElement.embeddedView, ast.children);
        return null;
    };
    ViewBinderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
    ViewBinderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
    ViewBinderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
        return null;
    };
    ViewBinderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
    ViewBinderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
    ViewBinderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
    ViewBinderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
    return ViewBinderVisitor;
}());

},{"../../src/facade/collection":87,"../template_ast":118,"./event_binder":130,"./lifecycle_binder":132,"./property_binder":133}],136:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../../core_private');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var o = require('../output/output_ast');
var identifiers_1 = require('../identifiers');
var constants_1 = require('./constants');
var compile_view_1 = require('./compile_view');
var compile_element_1 = require('./compile_element');
var template_ast_1 = require('../template_ast');
var util_1 = require('./util');
var compile_metadata_1 = require('../compile_metadata');
var IMPLICIT_TEMPLATE_VAR = '\$implicit';
var CLASS_ATTR = 'class';
var STYLE_ATTR = 'style';
var parentRenderNodeVar = o.variable('parentRenderNode');
var rootSelectorVar = o.variable('rootSelector');
var ViewCompileDependency = (function () {
    function ViewCompileDependency(comp, factoryPlaceholder) {
        this.comp = comp;
        this.factoryPlaceholder = factoryPlaceholder;
    }
    return ViewCompileDependency;
}());
exports.ViewCompileDependency = ViewCompileDependency;
function buildView(view, template, targetDependencies) {
    var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
    template_ast_1.templateVisitAll(builderVisitor, template, view.declarationElement.isNull() ?
        view.declarationElement :
        view.declarationElement.parent);
    return builderVisitor.nestedViewCount;
}
exports.buildView = buildView;
function finishView(view, targetStatements) {
    view.afterNodes();
    createViewTopLevelStmts(view, targetStatements);
    view.nodes.forEach(function (node) {
        if (node instanceof compile_element_1.CompileElement && node.hasEmbeddedView) {
            finishView(node.embeddedView, targetStatements);
        }
    });
}
exports.finishView = finishView;
var ViewBuilderVisitor = (function () {
    function ViewBuilderVisitor(view, targetDependencies) {
        this.view = view;
        this.targetDependencies = targetDependencies;
        this.nestedViewCount = 0;
    }
    ViewBuilderVisitor.prototype._isRootNode = function (parent) { return parent.view !== this.view; };
    ViewBuilderVisitor.prototype._addRootNodeAndProject = function (node, ngContentIndex, parent) {
        var vcAppEl = (node instanceof compile_element_1.CompileElement && node.hasViewContainer) ? node.appElement : null;
        if (this._isRootNode(parent)) {
            // store appElement as root node only for ViewContainers
            if (this.view.viewType !== core_private_1.ViewType.COMPONENT) {
                this.view.rootNodesOrAppElements.push(lang_1.isPresent(vcAppEl) ? vcAppEl : node.renderNode);
            }
        }
        else if (lang_1.isPresent(parent.component) && lang_1.isPresent(ngContentIndex)) {
            parent.addContentNode(ngContentIndex, lang_1.isPresent(vcAppEl) ? vcAppEl : node.renderNode);
        }
    };
    ViewBuilderVisitor.prototype._getParentRenderNode = function (parent) {
        if (this._isRootNode(parent)) {
            if (this.view.viewType === core_private_1.ViewType.COMPONENT) {
                return parentRenderNodeVar;
            }
            else {
                // root node of an embedded/host view
                return o.NULL_EXPR;
            }
        }
        else {
            return lang_1.isPresent(parent.component) &&
                parent.component.template.encapsulation !== core_1.ViewEncapsulation.Native ?
                o.NULL_EXPR :
                parent.renderNode;
        }
    };
    ViewBuilderVisitor.prototype.visitBoundText = function (ast, parent) {
        return this._visitText(ast, '', ast.ngContentIndex, parent);
    };
    ViewBuilderVisitor.prototype.visitText = function (ast, parent) {
        return this._visitText(ast, ast.value, ast.ngContentIndex, parent);
    };
    ViewBuilderVisitor.prototype._visitText = function (ast, value, ngContentIndex, parent) {
        var fieldName = "_text_" + this.view.nodes.length;
        this.view.fields.push(new o.ClassField(fieldName, o.importType(this.view.genConfig.renderTypes.renderText)));
        var renderNode = o.THIS_EXPR.prop(fieldName);
        var compileNode = new compile_element_1.CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
        var createRenderNode = o.THIS_EXPR.prop(fieldName)
            .set(constants_1.ViewProperties.renderer.callMethod('createText', [
            this._getParentRenderNode(parent),
            o.literal(value),
            this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)
        ]))
            .toStmt();
        this.view.nodes.push(compileNode);
        this.view.createMethod.addStmt(createRenderNode);
        this._addRootNodeAndProject(compileNode, ngContentIndex, parent);
        return renderNode;
    };
    ViewBuilderVisitor.prototype.visitNgContent = function (ast, parent) {
        // the projected nodes originate from a different view, so we don't
        // have debug information for them...
        this.view.createMethod.resetDebugInfo(null, ast);
        var parentRenderNode = this._getParentRenderNode(parent);
        var nodesExpression = constants_1.ViewProperties.projectableNodes.key(o.literal(ast.index), new o.ArrayType(o.importType(this.view.genConfig.renderTypes.renderNode)));
        if (parentRenderNode !== o.NULL_EXPR) {
            this.view.createMethod.addStmt(constants_1.ViewProperties.renderer.callMethod('projectNodes', [
                parentRenderNode,
                o.importExpr(identifiers_1.Identifiers.flattenNestedViewRenderNodes)
                    .callFn([nodesExpression])
            ])
                .toStmt());
        }
        else if (this._isRootNode(parent)) {
            if (this.view.viewType !== core_private_1.ViewType.COMPONENT) {
                // store root nodes only for embedded/host views
                this.view.rootNodesOrAppElements.push(nodesExpression);
            }
        }
        else {
            if (lang_1.isPresent(parent.component) && lang_1.isPresent(ast.ngContentIndex)) {
                parent.addContentNode(ast.ngContentIndex, nodesExpression);
            }
        }
        return null;
    };
    ViewBuilderVisitor.prototype.visitElement = function (ast, parent) {
        var nodeIndex = this.view.nodes.length;
        var createRenderNodeExpr;
        var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
        if (nodeIndex === 0 && this.view.viewType === core_private_1.ViewType.HOST) {
            createRenderNodeExpr = o.THIS_EXPR.callMethod('selectOrCreateHostElement', [o.literal(ast.name), rootSelectorVar, debugContextExpr]);
        }
        else {
            createRenderNodeExpr = constants_1.ViewProperties.renderer.callMethod('createElement', [this._getParentRenderNode(parent), o.literal(ast.name), debugContextExpr]);
        }
        var fieldName = "_el_" + nodeIndex;
        this.view.fields.push(new o.ClassField(fieldName, o.importType(this.view.genConfig.renderTypes.renderElement)));
        this.view.createMethod.addStmt(o.THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
        var renderNode = o.THIS_EXPR.prop(fieldName);
        var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
        var component = directives.find(function (directive) { return directive.isComponent; });
        var htmlAttrs = _readHtmlAttrs(ast.attrs);
        var attrNameAndValues = _mergeHtmlAndDirectiveAttrs(htmlAttrs, directives);
        for (var i = 0; i < attrNameAndValues.length; i++) {
            var attrName = attrNameAndValues[i][0];
            var attrValue = attrNameAndValues[i][1];
            this.view.createMethod.addStmt(constants_1.ViewProperties.renderer.callMethod('setElementAttribute', [renderNode, o.literal(attrName), o.literal(attrValue)])
                .toStmt());
        }
        var compileElement = new compile_element_1.CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references);
        this.view.nodes.push(compileElement);
        var compViewExpr = null;
        if (lang_1.isPresent(component)) {
            var nestedComponentIdentifier = new compile_metadata_1.CompileIdentifierMetadata({ name: util_1.getViewFactoryName(component, 0) });
            this.targetDependencies.push(new ViewCompileDependency(component, nestedComponentIdentifier));
            compViewExpr = o.variable("compView_" + nodeIndex); // fix highlighting: `
            compileElement.setComponentView(compViewExpr);
            this.view.createMethod.addStmt(compViewExpr.set(o.importExpr(nestedComponentIdentifier)
                .callFn([
                constants_1.ViewProperties.viewUtils,
                compileElement.injector,
                compileElement.appElement
            ]))
                .toDeclStmt());
        }
        compileElement.beforeChildren();
        this._addRootNodeAndProject(compileElement, ast.ngContentIndex, parent);
        template_ast_1.templateVisitAll(this, ast.children, compileElement);
        compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
        if (lang_1.isPresent(compViewExpr)) {
            var codeGenContentNodes;
            if (this.view.component.type.isHost) {
                codeGenContentNodes = constants_1.ViewProperties.projectableNodes;
            }
            else {
                codeGenContentNodes = o.literalArr(compileElement.contentNodesByNgContentIndex.map(function (nodes) { return util_1.createFlatArray(nodes); }));
            }
            this.view.createMethod.addStmt(compViewExpr.callMethod('create', [compileElement.getComponent(), codeGenContentNodes, o.NULL_EXPR])
                .toStmt());
        }
        return null;
    };
    ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
        var nodeIndex = this.view.nodes.length;
        var fieldName = "_anchor_" + nodeIndex;
        this.view.fields.push(new o.ClassField(fieldName, o.importType(this.view.genConfig.renderTypes.renderComment)));
        this.view.createMethod.addStmt(o.THIS_EXPR.prop(fieldName)
            .set(constants_1.ViewProperties.renderer.callMethod('createTemplateAnchor', [
            this._getParentRenderNode(parent),
            this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)
        ]))
            .toStmt());
        var renderNode = o.THIS_EXPR.prop(fieldName);
        var templateVariableBindings = ast.variables.map(function (varAst) { return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]; });
        var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
        var compileElement = new compile_element_1.CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references);
        this.view.nodes.push(compileElement);
        this.nestedViewCount++;
        var embeddedView = new compile_view_1.CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, o.NULL_EXPR, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);
        this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
        compileElement.beforeChildren();
        this._addRootNodeAndProject(compileElement, ast.ngContentIndex, parent);
        compileElement.afterChildren(0);
        return null;
    };
    ViewBuilderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
    ViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
    ViewBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
        return null;
    };
    ViewBuilderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
    ViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
    ViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
    ViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
    return ViewBuilderVisitor;
}());
function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
    var result = {};
    collection_1.StringMapWrapper.forEach(declaredHtmlAttrs, function (value, key) { result[key] = value; });
    directives.forEach(function (directiveMeta) {
        collection_1.StringMapWrapper.forEach(directiveMeta.hostAttributes, function (value, name) {
            var prevValue = result[name];
            result[name] = lang_1.isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
        });
    });
    return mapToKeyValueArray(result);
}
function _readHtmlAttrs(attrs) {
    var htmlAttrs = {};
    attrs.forEach(function (ast) { htmlAttrs[ast.name] = ast.value; });
    return htmlAttrs;
}
function mergeAttributeValue(attrName, attrValue1, attrValue2) {
    if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {
        return attrValue1 + " " + attrValue2;
    }
    else {
        return attrValue2;
    }
}
function mapToKeyValueArray(data) {
    var entryArray = [];
    collection_1.StringMapWrapper.forEach(data, function (value, name) { entryArray.push([name, value]); });
    // We need to sort to get a defined output order
    // for tests and for caching generated artifacts...
    collection_1.ListWrapper.sort(entryArray, function (entry1, entry2) { return lang_1.StringWrapper.compare(entry1[0], entry2[0]); });
    var keyValueArray = [];
    entryArray.forEach(function (entry) { keyValueArray.push([entry[0], entry[1]]); });
    return keyValueArray;
}
function createViewTopLevelStmts(view, targetStatements) {
    var nodeDebugInfosVar = o.NULL_EXPR;
    if (view.genConfig.genDebugInfo) {
        nodeDebugInfosVar = o.variable("nodeDebugInfos_" + view.component.type.name + view.viewIndex); // fix highlighting: `
        targetStatements.push(nodeDebugInfosVar
            .set(o.literalArr(view.nodes.map(createStaticNodeDebugInfo), new o.ArrayType(new o.ExternalType(identifiers_1.Identifiers.StaticNodeDebugInfo), [o.TypeModifier.Const])))
            .toDeclStmt(null, [o.StmtModifier.Final]));
    }
    var renderCompTypeVar = o.variable("renderType_" + view.component.type.name); // fix highlighting: `
    if (view.viewIndex === 0) {
        targetStatements.push(renderCompTypeVar.set(o.NULL_EXPR)
            .toDeclStmt(o.importType(identifiers_1.Identifiers.RenderComponentType)));
    }
    var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
    targetStatements.push(viewClass);
    targetStatements.push(createViewFactory(view, viewClass, renderCompTypeVar));
}
function createStaticNodeDebugInfo(node) {
    var compileElement = node instanceof compile_element_1.CompileElement ? node : null;
    var providerTokens = [];
    var componentToken = o.NULL_EXPR;
    var varTokenEntries = [];
    if (lang_1.isPresent(compileElement)) {
        providerTokens = compileElement.getProviderTokens();
        if (lang_1.isPresent(compileElement.component)) {
            componentToken = util_1.createDiTokenExpression(identifiers_1.identifierToken(compileElement.component.type));
        }
        collection_1.StringMapWrapper.forEach(compileElement.referenceTokens, function (token, varName) {
            varTokenEntries.push([varName, lang_1.isPresent(token) ? util_1.createDiTokenExpression(token) : o.NULL_EXPR]);
        });
    }
    return o.importExpr(identifiers_1.Identifiers.StaticNodeDebugInfo)
        .instantiate([
        o.literalArr(providerTokens, new o.ArrayType(o.DYNAMIC_TYPE, [o.TypeModifier.Const])),
        componentToken,
        o.literalMap(varTokenEntries, new o.MapType(o.DYNAMIC_TYPE, [o.TypeModifier.Const]))
    ], o.importType(identifiers_1.Identifiers.StaticNodeDebugInfo, null, [o.TypeModifier.Const]));
}
function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
    var viewConstructorArgs = [
        new o.FnParam(constants_1.ViewConstructorVars.viewUtils.name, o.importType(identifiers_1.Identifiers.ViewUtils)),
        new o.FnParam(constants_1.ViewConstructorVars.parentInjector.name, o.importType(identifiers_1.Identifiers.Injector)),
        new o.FnParam(constants_1.ViewConstructorVars.declarationEl.name, o.importType(identifiers_1.Identifiers.AppElement))
    ];
    var superConstructorArgs = [
        o.variable(view.className),
        renderCompTypeVar,
        constants_1.ViewTypeEnum.fromValue(view.viewType),
        constants_1.ViewConstructorVars.viewUtils,
        constants_1.ViewConstructorVars.parentInjector,
        constants_1.ViewConstructorVars.declarationEl,
        constants_1.ChangeDetectionStrategyEnum.fromValue(getChangeDetectionMode(view))
    ];
    if (view.genConfig.genDebugInfo) {
        superConstructorArgs.push(nodeDebugInfosVar);
    }
    var viewConstructor = new o.ClassMethod(null, viewConstructorArgs, [o.SUPER_EXPR.callFn(superConstructorArgs).toStmt()]);
    var viewMethods = [
        new o.ClassMethod('createInternal', [new o.FnParam(rootSelectorVar.name, o.STRING_TYPE)], generateCreateMethod(view), o.importType(identifiers_1.Identifiers.AppElement)),
        new o.ClassMethod('injectorGetInternal', [
            new o.FnParam(constants_1.InjectMethodVars.token.name, o.DYNAMIC_TYPE),
            // Note: Can't use o.INT_TYPE here as the method in AppView uses number
            new o.FnParam(constants_1.InjectMethodVars.requestNodeIndex.name, o.NUMBER_TYPE),
            new o.FnParam(constants_1.InjectMethodVars.notFoundResult.name, o.DYNAMIC_TYPE)
        ], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), constants_1.InjectMethodVars.notFoundResult), o.DYNAMIC_TYPE),
        new o.ClassMethod('detectChangesInternal', [new o.FnParam(constants_1.DetectChangesVars.throwOnChange.name, o.BOOL_TYPE)], generateDetectChangesMethod(view)),
        new o.ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()),
        new o.ClassMethod('destroyInternal', [], view.destroyMethod.finish())
    ].concat(view.eventHandlerMethods);
    var superClass = view.genConfig.genDebugInfo ? identifiers_1.Identifiers.DebugAppView : identifiers_1.Identifiers.AppView;
    var viewClass = new o.ClassStmt(view.className, o.importExpr(superClass, [getContextType(view)]), view.fields, view.getters, viewConstructor, viewMethods.filter(function (method) { return method.body.length > 0; }));
    return viewClass;
}
function createViewFactory(view, viewClass, renderCompTypeVar) {
    var viewFactoryArgs = [
        new o.FnParam(constants_1.ViewConstructorVars.viewUtils.name, o.importType(identifiers_1.Identifiers.ViewUtils)),
        new o.FnParam(constants_1.ViewConstructorVars.parentInjector.name, o.importType(identifiers_1.Identifiers.Injector)),
        new o.FnParam(constants_1.ViewConstructorVars.declarationEl.name, o.importType(identifiers_1.Identifiers.AppElement))
    ];
    var initRenderCompTypeStmts = [];
    var templateUrlInfo;
    if (view.component.template.templateUrl == view.component.type.moduleUrl) {
        templateUrlInfo =
            view.component.type.moduleUrl + " class " + view.component.type.name + " - inline template";
    }
    else {
        templateUrlInfo = view.component.template.templateUrl;
    }
    if (view.viewIndex === 0) {
        initRenderCompTypeStmts = [
            new o.IfStmt(renderCompTypeVar.identical(o.NULL_EXPR), [
                renderCompTypeVar.set(constants_1.ViewConstructorVars
                    .viewUtils.callMethod('createRenderComponentType', [
                    o.literal(templateUrlInfo),
                    o.literal(view.component
                        .template.ngContentSelectors.length),
                    constants_1.ViewEncapsulationEnum
                        .fromValue(view.component.template.encapsulation),
                    view.styles
                ]))
                    .toStmt()
            ])
        ];
    }
    return o.fn(viewFactoryArgs, initRenderCompTypeStmts.concat([
        new o.ReturnStatement(o.variable(viewClass.name)
            .instantiate(viewClass.constructorMethod.params.map(function (param) { return o.variable(param.name); })))
    ]), o.importType(identifiers_1.Identifiers.AppView, [getContextType(view)]))
        .toDeclStmt(view.viewFactory.name, [o.StmtModifier.Final]);
}
function generateCreateMethod(view) {
    var parentRenderNodeExpr = o.NULL_EXPR;
    var parentRenderNodeStmts = [];
    if (view.viewType === core_private_1.ViewType.COMPONENT) {
        parentRenderNodeExpr = constants_1.ViewProperties.renderer.callMethod('createViewRoot', [o.THIS_EXPR.prop('declarationAppElement').prop('nativeElement')]);
        parentRenderNodeStmts = [
            parentRenderNodeVar.set(parentRenderNodeExpr)
                .toDeclStmt(o.importType(view.genConfig.renderTypes.renderNode), [o.StmtModifier.Final])
        ];
    }
    var resultExpr;
    if (view.viewType === core_private_1.ViewType.HOST) {
        resultExpr = view.nodes[0].appElement;
    }
    else {
        resultExpr = o.NULL_EXPR;
    }
    return parentRenderNodeStmts.concat(view.createMethod.finish())
        .concat([
        o.THIS_EXPR.callMethod('init', [
            util_1.createFlatArray(view.rootNodesOrAppElements),
            o.literalArr(view.nodes.map(function (node) { return node.renderNode; })),
            o.literalArr(view.disposables),
            o.literalArr(view.subscriptions)
        ])
            .toStmt(),
        new o.ReturnStatement(resultExpr)
    ]);
}
function generateDetectChangesMethod(view) {
    var stmts = [];
    if (view.detectChangesInInputsMethod.isEmpty() && view.updateContentQueriesMethod.isEmpty() &&
        view.afterContentLifecycleCallbacksMethod.isEmpty() &&
        view.detectChangesRenderPropertiesMethod.isEmpty() &&
        view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty()) {
        return stmts;
    }
    collection_1.ListWrapper.addAll(stmts, view.detectChangesInInputsMethod.finish());
    stmts.push(o.THIS_EXPR.callMethod('detectContentChildrenChanges', [constants_1.DetectChangesVars.throwOnChange])
        .toStmt());
    var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
    if (afterContentStmts.length > 0) {
        stmts.push(new o.IfStmt(o.not(constants_1.DetectChangesVars.throwOnChange), afterContentStmts));
    }
    collection_1.ListWrapper.addAll(stmts, view.detectChangesRenderPropertiesMethod.finish());
    stmts.push(o.THIS_EXPR.callMethod('detectViewChildrenChanges', [constants_1.DetectChangesVars.throwOnChange])
        .toStmt());
    var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
    if (afterViewStmts.length > 0) {
        stmts.push(new o.IfStmt(o.not(constants_1.DetectChangesVars.throwOnChange), afterViewStmts));
    }
    var varStmts = [];
    var readVars = o.findReadVarNames(stmts);
    if (collection_1.SetWrapper.has(readVars, constants_1.DetectChangesVars.changed.name)) {
        varStmts.push(constants_1.DetectChangesVars.changed.set(o.literal(true)).toDeclStmt(o.BOOL_TYPE));
    }
    if (collection_1.SetWrapper.has(readVars, constants_1.DetectChangesVars.changes.name)) {
        varStmts.push(constants_1.DetectChangesVars.changes.set(o.NULL_EXPR)
            .toDeclStmt(new o.MapType(o.importType(identifiers_1.Identifiers.SimpleChange))));
    }
    if (collection_1.SetWrapper.has(readVars, constants_1.DetectChangesVars.valUnwrapper.name)) {
        varStmts.push(constants_1.DetectChangesVars.valUnwrapper.set(o.importExpr(identifiers_1.Identifiers.ValueUnwrapper).instantiate([]))
            .toDeclStmt(null, [o.StmtModifier.Final]));
    }
    return varStmts.concat(stmts);
}
function addReturnValuefNotEmpty(statements, value) {
    if (statements.length > 0) {
        return statements.concat([new o.ReturnStatement(value)]);
    }
    else {
        return statements;
    }
}
function getContextType(view) {
    if (view.viewType === core_private_1.ViewType.COMPONENT) {
        return o.importType(view.component.type);
    }
    return o.DYNAMIC_TYPE;
}
function getChangeDetectionMode(view) {
    var mode;
    if (view.viewType === core_private_1.ViewType.COMPONENT) {
        mode = core_private_1.isDefaultChangeDetectionStrategy(view.component.changeDetection) ?
            core_1.ChangeDetectionStrategy.CheckAlways :
            core_1.ChangeDetectionStrategy.CheckOnce;
    }
    else {
        mode = core_1.ChangeDetectionStrategy.CheckAlways;
    }
    return mode;
}

},{"../../core_private":72,"../../src/facade/collection":87,"../../src/facade/lang":90,"../compile_metadata":76,"../identifiers":96,"../output/output_ast":103,"../template_ast":118,"./compile_element":124,"./compile_view":128,"./constants":129,"./util":134,"@angular/core":140}],137:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var compile_element_1 = require('./compile_element');
var compile_view_1 = require('./compile_view');
var view_builder_1 = require('./view_builder');
var view_binder_1 = require('./view_binder');
var config_1 = require('../config');
var ViewCompileResult = (function () {
    function ViewCompileResult(statements, viewFactoryVar, dependencies) {
        this.statements = statements;
        this.viewFactoryVar = viewFactoryVar;
        this.dependencies = dependencies;
    }
    return ViewCompileResult;
}());
exports.ViewCompileResult = ViewCompileResult;
var ViewCompiler = (function () {
    function ViewCompiler(_genConfig) {
        this._genConfig = _genConfig;
    }
    ViewCompiler.prototype.compileComponent = function (component, template, styles, pipes) {
        var statements = [];
        var dependencies = [];
        var view = new compile_view_1.CompileView(component, this._genConfig, pipes, styles, 0, compile_element_1.CompileElement.createNull(), []);
        view_builder_1.buildView(view, template, dependencies);
        // Need to separate binding from creation to be able to refer to
        // variables that have been declared after usage.
        view_binder_1.bindView(view, template);
        view_builder_1.finishView(view, statements);
        return new ViewCompileResult(statements, view.viewFactory.name, dependencies);
    };
    ViewCompiler.decorators = [
        { type: core_1.Injectable },
    ];
    ViewCompiler.ctorParameters = [
        { type: config_1.CompilerConfig, },
    ];
    return ViewCompiler;
}());
exports.ViewCompiler = ViewCompiler;

},{"../config":78,"./compile_element":124,"./compile_view":128,"./view_binder":135,"./view_builder":136,"@angular/core":140}],138:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var collection_1 = require('../src/facade/collection');
var ViewResolver = (function () {
    function ViewResolver(_reflector) {
        /** @internal */
        this._cache = new collection_1.Map();
        if (lang_1.isPresent(_reflector)) {
            this._reflector = _reflector;
        }
        else {
            this._reflector = core_1.reflector;
        }
    }
    ViewResolver.prototype.resolve = function (component) {
        var view = this._cache.get(component);
        if (lang_1.isBlank(view)) {
            view = this._resolve(component);
            this._cache.set(component, view);
        }
        return view;
    };
    /** @internal */
    ViewResolver.prototype._resolve = function (component) {
        var compMeta;
        var viewMeta;
        this._reflector.annotations(component).forEach(function (m) {
            if (m instanceof core_1.ViewMetadata) {
                viewMeta = m;
            }
            if (m instanceof core_1.ComponentMetadata) {
                compMeta = m;
            }
        });
        if (lang_1.isPresent(compMeta)) {
            if (lang_1.isBlank(compMeta.template) && lang_1.isBlank(compMeta.templateUrl) && lang_1.isBlank(viewMeta)) {
                throw new exceptions_1.BaseException("Component '" + lang_1.stringify(component) + "' must have either 'template' or 'templateUrl' set.");
            }
            else if (lang_1.isPresent(compMeta.template) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("template", component);
            }
            else if (lang_1.isPresent(compMeta.templateUrl) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("templateUrl", component);
            }
            else if (lang_1.isPresent(compMeta.directives) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("directives", component);
            }
            else if (lang_1.isPresent(compMeta.pipes) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("pipes", component);
            }
            else if (lang_1.isPresent(compMeta.encapsulation) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("encapsulation", component);
            }
            else if (lang_1.isPresent(compMeta.styles) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("styles", component);
            }
            else if (lang_1.isPresent(compMeta.styleUrls) && lang_1.isPresent(viewMeta)) {
                this._throwMixingViewAndComponent("styleUrls", component);
            }
            else if (lang_1.isPresent(viewMeta)) {
                return viewMeta;
            }
            else {
                return new core_1.ViewMetadata({
                    templateUrl: compMeta.templateUrl,
                    template: compMeta.template,
                    directives: compMeta.directives,
                    pipes: compMeta.pipes,
                    encapsulation: compMeta.encapsulation,
                    styles: compMeta.styles,
                    styleUrls: compMeta.styleUrls
                });
            }
        }
        else {
            if (lang_1.isBlank(viewMeta)) {
                throw new exceptions_1.BaseException("Could not compile '" + lang_1.stringify(component) + "' because it is not a component.");
            }
            else {
                return viewMeta;
            }
        }
        return null;
    };
    /** @internal */
    ViewResolver.prototype._throwMixingViewAndComponent = function (propertyName, component) {
        throw new exceptions_1.BaseException("Component '" + lang_1.stringify(component) + "' cannot have both '" + propertyName + "' and '@View' set at the same time\"");
    };
    ViewResolver.decorators = [
        { type: core_1.Injectable },
    ];
    ViewResolver.ctorParameters = [
        { type: core_private_1.ReflectorReader, },
    ];
    return ViewResolver;
}());
exports.ViewResolver = ViewResolver;

},{"../core_private":72,"../src/facade/collection":87,"../src/facade/exceptions":89,"../src/facade/lang":90,"@angular/core":140}],139:[function(require,module,exports){
"use strict";
// TODO: vsavkin rename it into TemplateLoader
/**
 * An interface for retrieving documents by URL that the compiler uses
 * to load templates.
 */
var XHR = (function () {
    function XHR() {
    }
    XHR.prototype.get = function (url) { return null; };
    return XHR;
}());
exports.XHR = XHR;

},{}],140:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
* @module
* @description
* Starting point to import all public core APIs.
*/
__export(require('./src/metadata'));
__export(require('./src/util'));
__export(require('./src/di'));
var application_ref_1 = require('./src/application_ref');
exports.createPlatform = application_ref_1.createPlatform;
exports.assertPlatform = application_ref_1.assertPlatform;
exports.disposePlatform = application_ref_1.disposePlatform;
exports.getPlatform = application_ref_1.getPlatform;
exports.coreBootstrap = application_ref_1.coreBootstrap;
exports.coreLoadAndBootstrap = application_ref_1.coreLoadAndBootstrap;
exports.createNgZone = application_ref_1.createNgZone;
exports.PlatformRef = application_ref_1.PlatformRef;
exports.ApplicationRef = application_ref_1.ApplicationRef;
var application_tokens_1 = require('./src/application_tokens');
exports.APP_ID = application_tokens_1.APP_ID;
exports.APP_INITIALIZER = application_tokens_1.APP_INITIALIZER;
exports.PACKAGE_ROOT_URL = application_tokens_1.PACKAGE_ROOT_URL;
exports.PLATFORM_INITIALIZER = application_tokens_1.PLATFORM_INITIALIZER;
__export(require('./src/zone'));
__export(require('./src/render'));
__export(require('./src/linker'));
var debug_node_1 = require('./src/debug/debug_node');
exports.DebugElement = debug_node_1.DebugElement;
exports.DebugNode = debug_node_1.DebugNode;
exports.asNativeElements = debug_node_1.asNativeElements;
exports.getDebugNode = debug_node_1.getDebugNode;
__export(require('./src/testability/testability'));
__export(require('./src/change_detection'));
__export(require('./src/platform_directives_and_pipes'));
__export(require('./src/platform_common_providers'));
__export(require('./src/application_common_providers'));
__export(require('./src/reflection/reflection'));
var profile_1 = require('./src/profile/profile');
exports.wtfCreateScope = profile_1.wtfCreateScope;
exports.wtfLeave = profile_1.wtfLeave;
exports.wtfStartTimeRange = profile_1.wtfStartTimeRange;
exports.wtfEndTimeRange = profile_1.wtfEndTimeRange;
var lang_1 = require("./src/facade/lang");
exports.Type = lang_1.Type;
exports.enableProdMode = lang_1.enableProdMode;
var async_1 = require("./src/facade/async");
exports.EventEmitter = async_1.EventEmitter;
var exceptions_1 = require("./src/facade/exceptions");
exports.ExceptionHandler = exceptions_1.ExceptionHandler;
exports.WrappedException = exceptions_1.WrappedException;
exports.BaseException = exceptions_1.BaseException;
__export(require('./private_export'));

},{"./private_export":141,"./src/application_common_providers":142,"./src/application_ref":143,"./src/application_tokens":144,"./src/change_detection":145,"./src/debug/debug_node":155,"./src/di":157,"./src/facade/async":169,"./src/facade/exceptions":173,"./src/facade/lang":174,"./src/linker":176,"./src/metadata":192,"./src/platform_common_providers":197,"./src/platform_directives_and_pipes":198,"./src/profile/profile":199,"./src/reflection/reflection":202,"./src/render":206,"./src/testability/testability":209,"./src/util":210,"./src/zone":212}],141:[function(require,module,exports){
"use strict";
var constants = require('./src/change_detection/constants');
var security = require('./src/security');
var reflective_provider = require('./src/di/reflective_provider');
var lifecycle_hooks = require('./src/metadata/lifecycle_hooks');
var reflector_reader = require('./src/reflection/reflector_reader');
var component_resolver = require('./src/linker/component_resolver');
var element = require('./src/linker/element');
var view = require('./src/linker/view');
var view_type = require('./src/linker/view_type');
var view_utils = require('./src/linker/view_utils');
var metadata_view = require('./src/metadata/view');
var debug_context = require('./src/linker/debug_context');
var change_detection_util = require('./src/change_detection/change_detection_util');
var api = require('./src/render/api');
var template_ref = require('./src/linker/template_ref');
var wtf_init = require('./src/profile/wtf_init');
var reflection_capabilities = require('./src/reflection/reflection_capabilities');
var decorators = require('./src/util/decorators');
var debug = require('./src/debug/debug_renderer');
var provider_util = require('./src/di/provider_util');
var console = require('./src/console');
exports.__core_private__ = {
    isDefaultChangeDetectionStrategy: constants.isDefaultChangeDetectionStrategy,
    ChangeDetectorState: constants.ChangeDetectorState,
    CHANGE_DETECTION_STRATEGY_VALUES: constants.CHANGE_DETECTION_STRATEGY_VALUES,
    constructDependencies: reflective_provider.constructDependencies,
    LifecycleHooks: lifecycle_hooks.LifecycleHooks,
    LIFECYCLE_HOOKS_VALUES: lifecycle_hooks.LIFECYCLE_HOOKS_VALUES,
    ReflectorReader: reflector_reader.ReflectorReader,
    ReflectorComponentResolver: component_resolver.ReflectorComponentResolver,
    AppElement: element.AppElement,
    AppView: view.AppView,
    DebugAppView: view.DebugAppView,
    ViewType: view_type.ViewType,
    MAX_INTERPOLATION_VALUES: view_utils.MAX_INTERPOLATION_VALUES,
    checkBinding: view_utils.checkBinding,
    flattenNestedViewRenderNodes: view_utils.flattenNestedViewRenderNodes,
    interpolate: view_utils.interpolate,
    ViewUtils: view_utils.ViewUtils,
    VIEW_ENCAPSULATION_VALUES: metadata_view.VIEW_ENCAPSULATION_VALUES,
    DebugContext: debug_context.DebugContext,
    StaticNodeDebugInfo: debug_context.StaticNodeDebugInfo,
    devModeEqual: change_detection_util.devModeEqual,
    uninitialized: change_detection_util.uninitialized,
    ValueUnwrapper: change_detection_util.ValueUnwrapper,
    RenderDebugInfo: api.RenderDebugInfo,
    SecurityContext: security.SecurityContext,
    SanitizationService: security.SanitizationService,
    TemplateRef_: template_ref.TemplateRef_,
    wtfInit: wtf_init.wtfInit,
    ReflectionCapabilities: reflection_capabilities.ReflectionCapabilities,
    makeDecorator: decorators.makeDecorator,
    DebugDomRootRenderer: debug.DebugDomRootRenderer,
    createProvider: provider_util.createProvider,
    isProviderLiteral: provider_util.isProviderLiteral,
    EMPTY_ARRAY: view_utils.EMPTY_ARRAY,
    EMPTY_MAP: view_utils.EMPTY_MAP,
    pureProxy1: view_utils.pureProxy1,
    pureProxy2: view_utils.pureProxy2,
    pureProxy3: view_utils.pureProxy3,
    pureProxy4: view_utils.pureProxy4,
    pureProxy5: view_utils.pureProxy5,
    pureProxy6: view_utils.pureProxy6,
    pureProxy7: view_utils.pureProxy7,
    pureProxy8: view_utils.pureProxy8,
    pureProxy9: view_utils.pureProxy9,
    pureProxy10: view_utils.pureProxy10,
    castByValue: view_utils.castByValue,
    Console: console.Console,
};

},{"./src/change_detection/change_detection_util":147,"./src/change_detection/constants":149,"./src/console":154,"./src/debug/debug_renderer":156,"./src/di/provider_util":164,"./src/di/reflective_provider":168,"./src/linker/component_resolver":178,"./src/linker/debug_context":179,"./src/linker/element":181,"./src/linker/template_ref":186,"./src/linker/view":187,"./src/linker/view_type":190,"./src/linker/view_utils":191,"./src/metadata/lifecycle_hooks":195,"./src/metadata/view":196,"./src/profile/wtf_init":201,"./src/reflection/reflection_capabilities":203,"./src/reflection/reflector_reader":205,"./src/render/api":207,"./src/security":208,"./src/util/decorators":211}],142:[function(require,module,exports){
"use strict";
var application_tokens_1 = require('./application_tokens');
var application_ref_1 = require('./application_ref');
var change_detection_1 = require('./change_detection/change_detection');
var view_utils_1 = require('./linker/view_utils');
var component_resolver_1 = require('./linker/component_resolver');
var dynamic_component_loader_1 = require('./linker/dynamic_component_loader');
var __unused; // avoid unused import when Type union types are erased
/**
 * A default set of providers which should be included in any Angular
 * application, regardless of the platform it runs onto.
 */
exports.APPLICATION_COMMON_PROVIDERS = 
/*@ts2dart_const*/ [
    application_ref_1.APPLICATION_CORE_PROVIDERS,
    /* @ts2dart_Provider */ { provide: component_resolver_1.ComponentResolver, useClass: component_resolver_1.ReflectorComponentResolver },
    application_tokens_1.APP_ID_RANDOM_PROVIDER,
    view_utils_1.ViewUtils,
    /* @ts2dart_Provider */ { provide: change_detection_1.IterableDiffers, useValue: change_detection_1.defaultIterableDiffers },
    /* @ts2dart_Provider */ { provide: change_detection_1.KeyValueDiffers, useValue: change_detection_1.defaultKeyValueDiffers },
    /* @ts2dart_Provider */ { provide: dynamic_component_loader_1.DynamicComponentLoader, useClass: dynamic_component_loader_1.DynamicComponentLoader_ }
];

},{"./application_ref":143,"./application_tokens":144,"./change_detection/change_detection":146,"./linker/component_resolver":178,"./linker/dynamic_component_loader":180,"./linker/view_utils":191}],143:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ng_zone_1 = require('./zone/ng_zone');
var lang_1 = require('../src/facade/lang');
var di_1 = require('./di');
var application_tokens_1 = require('./application_tokens');
var async_1 = require('../src/facade/async');
var collection_1 = require('../src/facade/collection');
var testability_1 = require('./testability/testability');
var component_resolver_1 = require('./linker/component_resolver');
var exceptions_1 = require('../src/facade/exceptions');
var console_1 = require('./console');
var profile_1 = require('./profile/profile');
/**
 * Create an Angular zone.
 */
function createNgZone() {
    return new ng_zone_1.NgZone({ enableLongStackTrace: lang_1.assertionsEnabled() });
}
exports.createNgZone = createNgZone;
var _platform;
var _inPlatformCreate = false;
/**
 * Creates a platform.
 * Platforms have to be eagerly created via this function.
 */
function createPlatform(injector) {
    if (_inPlatformCreate) {
        throw new exceptions_1.BaseException('Already creating a platform...');
    }
    if (lang_1.isPresent(_platform) && !_platform.disposed) {
        throw new exceptions_1.BaseException("There can be only one platform. Destroy the previous one to create a new one.");
    }
    lang_1.lockMode();
    _inPlatformCreate = true;
    try {
        _platform = injector.get(PlatformRef);
    }
    finally {
        _inPlatformCreate = false;
    }
    return _platform;
}
exports.createPlatform = createPlatform;
/**
 * Checks that there currently is a platform
 * which contains the given token as a provider.
 */
function assertPlatform(requiredToken) {
    var platform = getPlatform();
    if (lang_1.isBlank(platform)) {
        throw new exceptions_1.BaseException('Not platform exists!');
    }
    if (lang_1.isPresent(platform) && lang_1.isBlank(platform.injector.get(requiredToken, null))) {
        throw new exceptions_1.BaseException('A platform with a different configuration has been created. Please destroy it first.');
    }
    return platform;
}
exports.assertPlatform = assertPlatform;
/**
 * Dispose the existing platform.
 */
function disposePlatform() {
    if (lang_1.isPresent(_platform) && !_platform.disposed) {
        _platform.dispose();
    }
}
exports.disposePlatform = disposePlatform;
/**
 * Returns the current platform.
 */
function getPlatform() {
    return lang_1.isPresent(_platform) && !_platform.disposed ? _platform : null;
}
exports.getPlatform = getPlatform;
/**
 * Shortcut for ApplicationRef.bootstrap.
 * Requires a platform the be created first.
 */
function coreBootstrap(injector, componentFactory) {
    var appRef = injector.get(ApplicationRef);
    return appRef.bootstrap(componentFactory);
}
exports.coreBootstrap = coreBootstrap;
/**
 * Resolves the componentFactory for the given component,
 * waits for asynchronous initializers and bootstraps the component.
 * Requires a platform the be created first.
 */
function coreLoadAndBootstrap(injector, componentType) {
    var appRef = injector.get(ApplicationRef);
    return appRef.run(function () {
        var componentResolver = injector.get(component_resolver_1.ComponentResolver);
        return async_1.PromiseWrapper
            .all([componentResolver.resolveComponent(componentType), appRef.waitForAsyncInitializers()])
            .then(function (arr) { return appRef.bootstrap(arr[0]); });
    });
}
exports.coreLoadAndBootstrap = coreLoadAndBootstrap;
/**
 * The Angular platform is the entry point for Angular on a web page. Each page
 * has exactly one platform, and services (such as reflection) which are common
 * to every Angular application running on the page are bound in its scope.
 *
 * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
 * explicitly by calling {@link createPlatform}().
 */
var PlatformRef = (function () {
    function PlatformRef() {
    }
    Object.defineProperty(PlatformRef.prototype, "injector", {
        /**
         * Retrieve the platform {@link Injector}, which is the parent injector for
         * every Angular application on the page and provides singleton providers.
         */
        get: function () { throw exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PlatformRef.prototype, "disposed", {
        get: function () { throw exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return PlatformRef;
}());
exports.PlatformRef = PlatformRef;
var PlatformRef_ = (function (_super) {
    __extends(PlatformRef_, _super);
    function PlatformRef_(_injector) {
        _super.call(this);
        this._injector = _injector;
        /** @internal */
        this._applications = [];
        /** @internal */
        this._disposeListeners = [];
        this._disposed = false;
        if (!_inPlatformCreate) {
            throw new exceptions_1.BaseException('Platforms have to be created via `createPlatform`!');
        }
        var inits = _injector.get(application_tokens_1.PLATFORM_INITIALIZER, null);
        if (lang_1.isPresent(inits))
            inits.forEach(function (init) { return init(); });
    }
    PlatformRef_.prototype.registerDisposeListener = function (dispose) { this._disposeListeners.push(dispose); };
    Object.defineProperty(PlatformRef_.prototype, "injector", {
        get: function () { return this._injector; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PlatformRef_.prototype, "disposed", {
        get: function () { return this._disposed; },
        enumerable: true,
        configurable: true
    });
    PlatformRef_.prototype.addApplication = function (appRef) { this._applications.push(appRef); };
    PlatformRef_.prototype.dispose = function () {
        collection_1.ListWrapper.clone(this._applications).forEach(function (app) { return app.dispose(); });
        this._disposeListeners.forEach(function (dispose) { return dispose(); });
        this._disposed = true;
    };
    /** @internal */
    PlatformRef_.prototype._applicationDisposed = function (app) { collection_1.ListWrapper.remove(this._applications, app); };
    PlatformRef_.decorators = [
        { type: di_1.Injectable },
    ];
    PlatformRef_.ctorParameters = [
        { type: di_1.Injector, },
    ];
    return PlatformRef_;
}(PlatformRef));
exports.PlatformRef_ = PlatformRef_;
/**
 * A reference to an Angular application running on a page.
 *
 * For more about Angular applications, see the documentation for {@link bootstrap}.
 */
var ApplicationRef = (function () {
    function ApplicationRef() {
    }
    Object.defineProperty(ApplicationRef.prototype, "injector", {
        /**
         * Retrieve the application {@link Injector}.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "zone", {
        /**
         * Retrieve the application {@link NgZone}.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
        /**
         * Get a list of component types registered to this application.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ApplicationRef;
}());
exports.ApplicationRef = ApplicationRef;
var ApplicationRef_ = (function (_super) {
    __extends(ApplicationRef_, _super);
    function ApplicationRef_(_platform, _zone, _injector) {
        var _this = this;
        _super.call(this);
        this._platform = _platform;
        this._zone = _zone;
        this._injector = _injector;
        /** @internal */
        this._bootstrapListeners = [];
        /** @internal */
        this._disposeListeners = [];
        /** @internal */
        this._rootComponents = [];
        /** @internal */
        this._rootComponentTypes = [];
        /** @internal */
        this._changeDetectorRefs = [];
        /** @internal */
        this._runningTick = false;
        /** @internal */
        this._enforceNoNewChanges = false;
        var zone = _injector.get(ng_zone_1.NgZone);
        this._enforceNoNewChanges = lang_1.assertionsEnabled();
        zone.run(function () { _this._exceptionHandler = _injector.get(exceptions_1.ExceptionHandler); });
        this._asyncInitDonePromise = this.run(function () {
            var inits = _injector.get(application_tokens_1.APP_INITIALIZER, null);
            var asyncInitResults = [];
            var asyncInitDonePromise;
            if (lang_1.isPresent(inits)) {
                for (var i = 0; i < inits.length; i++) {
                    var initResult = inits[i]();
                    if (lang_1.isPromise(initResult)) {
                        asyncInitResults.push(initResult);
                    }
                }
            }
            if (asyncInitResults.length > 0) {
                asyncInitDonePromise =
                    async_1.PromiseWrapper.all(asyncInitResults).then(function (_) { return _this._asyncInitDone = true; });
                _this._asyncInitDone = false;
            }
            else {
                _this._asyncInitDone = true;
                asyncInitDonePromise = async_1.PromiseWrapper.resolve(true);
            }
            return asyncInitDonePromise;
        });
        async_1.ObservableWrapper.subscribe(zone.onError, function (error) {
            _this._exceptionHandler.call(error.error, error.stackTrace);
        });
        async_1.ObservableWrapper.subscribe(this._zone.onMicrotaskEmpty, function (_) { _this._zone.run(function () { _this.tick(); }); });
    }
    ApplicationRef_.prototype.registerBootstrapListener = function (listener) {
        this._bootstrapListeners.push(listener);
    };
    ApplicationRef_.prototype.registerDisposeListener = function (dispose) { this._disposeListeners.push(dispose); };
    ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {
        this._changeDetectorRefs.push(changeDetector);
    };
    ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {
        collection_1.ListWrapper.remove(this._changeDetectorRefs, changeDetector);
    };
    ApplicationRef_.prototype.waitForAsyncInitializers = function () { return this._asyncInitDonePromise; };
    ApplicationRef_.prototype.run = function (callback) {
        var _this = this;
        var zone = this.injector.get(ng_zone_1.NgZone);
        var result;
        // Note: Don't use zone.runGuarded as we want to know about
        // the thrown exception!
        // Note: the completer needs to be created outside
        // of `zone.run` as Dart swallows rejected promises
        // via the onError callback of the promise.
        var completer = async_1.PromiseWrapper.completer();
        zone.run(function () {
            try {
                result = callback();
                if (lang_1.isPromise(result)) {
                    async_1.PromiseWrapper.then(result, function (ref) { completer.resolve(ref); }, function (err, stackTrace) {
                        completer.reject(err, stackTrace);
                        _this._exceptionHandler.call(err, stackTrace);
                    });
                }
            }
            catch (e) {
                _this._exceptionHandler.call(e, e.stack);
                throw e;
            }
        });
        return lang_1.isPromise(result) ? completer.promise : result;
    };
    ApplicationRef_.prototype.bootstrap = function (componentFactory) {
        var _this = this;
        if (!this._asyncInitDone) {
            throw new exceptions_1.BaseException('Cannot bootstrap as there are still asynchronous initializers running. Wait for them using waitForAsyncInitializers().');
        }
        return this.run(function () {
            _this._rootComponentTypes.push(componentFactory.componentType);
            var compRef = componentFactory.create(_this._injector, [], componentFactory.selector);
            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
            var testability = compRef.injector.get(testability_1.Testability, null);
            if (lang_1.isPresent(testability)) {
                compRef.injector.get(testability_1.TestabilityRegistry)
                    .registerApplication(compRef.location.nativeElement, testability);
            }
            _this._loadComponent(compRef);
            var c = _this._injector.get(console_1.Console);
            if (lang_1.assertionsEnabled()) {
                c.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
            }
            return compRef;
        });
    };
    /** @internal */
    ApplicationRef_.prototype._loadComponent = function (componentRef) {
        this._changeDetectorRefs.push(componentRef.changeDetectorRef);
        this.tick();
        this._rootComponents.push(componentRef);
        this._bootstrapListeners.forEach(function (listener) { return listener(componentRef); });
    };
    /** @internal */
    ApplicationRef_.prototype._unloadComponent = function (componentRef) {
        if (!collection_1.ListWrapper.contains(this._rootComponents, componentRef)) {
            return;
        }
        this.unregisterChangeDetector(componentRef.changeDetectorRef);
        collection_1.ListWrapper.remove(this._rootComponents, componentRef);
    };
    Object.defineProperty(ApplicationRef_.prototype, "injector", {
        get: function () { return this._injector; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ApplicationRef_.prototype, "zone", {
        get: function () { return this._zone; },
        enumerable: true,
        configurable: true
    });
    ApplicationRef_.prototype.tick = function () {
        if (this._runningTick) {
            throw new exceptions_1.BaseException("ApplicationRef.tick is called recursively");
        }
        var s = ApplicationRef_._tickScope();
        try {
            this._runningTick = true;
            this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });
            if (this._enforceNoNewChanges) {
                this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });
            }
        }
        finally {
            this._runningTick = false;
            profile_1.wtfLeave(s);
        }
    };
    ApplicationRef_.prototype.dispose = function () {
        // TODO(alxhub): Dispose of the NgZone.
        collection_1.ListWrapper.clone(this._rootComponents).forEach(function (ref) { return ref.destroy(); });
        this._disposeListeners.forEach(function (dispose) { return dispose(); });
        this._platform._applicationDisposed(this);
    };
    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
        get: function () { return this._rootComponentTypes; },
        enumerable: true,
        configurable: true
    });
    /** @internal */
    ApplicationRef_._tickScope = profile_1.wtfCreateScope('ApplicationRef#tick()');
    ApplicationRef_.decorators = [
        { type: di_1.Injectable },
    ];
    ApplicationRef_.ctorParameters = [
        { type: PlatformRef_, },
        { type: ng_zone_1.NgZone, },
        { type: di_1.Injector, },
    ];
    return ApplicationRef_;
}(ApplicationRef));
exports.ApplicationRef_ = ApplicationRef_;
/**
 * @internal
 */
exports.PLATFORM_CORE_PROVIDERS = 
/*@ts2dart_const*/ [
    PlatformRef_,
    /*@ts2dart_const*/ (
    /* @ts2dart_Provider */ { provide: PlatformRef, useExisting: PlatformRef_ })
];
/**
 * @internal
 */
exports.APPLICATION_CORE_PROVIDERS = [
    /* @ts2dart_Provider */ { provide: ng_zone_1.NgZone, useFactory: createNgZone, deps: [] },
    ApplicationRef_,
    /* @ts2dart_Provider */ { provide: ApplicationRef, useExisting: ApplicationRef_ }
];

},{"../src/facade/async":169,"../src/facade/collection":171,"../src/facade/exceptions":173,"../src/facade/lang":174,"./application_tokens":144,"./console":154,"./di":157,"./linker/component_resolver":178,"./profile/profile":199,"./testability/testability":209,"./zone/ng_zone":213}],144:[function(require,module,exports){
"use strict";
var di_1 = require('./di');
var lang_1 = require('../src/facade/lang');
/**
 * A DI Token representing a unique string id assigned to the application by Angular and used
 * primarily for prefixing application attributes and CSS styles when
 * {@link ViewEncapsulation#Emulated} is being used.
 *
 * If you need to avoid randomly generated value to be used as an application id, you can provide
 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
 * using this token.
 */
exports.APP_ID = new di_1.OpaqueToken('AppId');
function _appIdRandomProviderFactory() {
    return "" + _randomChar() + _randomChar() + _randomChar();
}
/**
 * Providers that will generate a random APP_ID_TOKEN.
 */
exports.APP_ID_RANDOM_PROVIDER = 
/*@ts2dart_const*/ /* @ts2dart_Provider */ {
    provide: exports.APP_ID,
    useFactory: _appIdRandomProviderFactory,
    deps: []
};
function _randomChar() {
    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));
}
/**
 * A function that will be executed when a platform is initialized.
 */
exports.PLATFORM_INITIALIZER = 
/*@ts2dart_const*/ new di_1.OpaqueToken("Platform Initializer");
/**
 * A function that will be executed when an application is initialized.
 */
exports.APP_INITIALIZER = 
/*@ts2dart_const*/ new di_1.OpaqueToken("Application Initializer");
/**
 * A token which indicates the root directory of the application
 */
exports.PACKAGE_ROOT_URL = 
/*@ts2dart_const*/ new di_1.OpaqueToken("Application Packages Root URL");

},{"../src/facade/lang":174,"./di":157}],145:[function(require,module,exports){
"use strict";
/**
* @module
* @description
* Change detection enables data binding in Angular.
*/
var change_detection_1 = require('./change_detection/change_detection');
exports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;
exports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;
exports.WrappedValue = change_detection_1.WrappedValue;
exports.SimpleChange = change_detection_1.SimpleChange;
exports.DefaultIterableDiffer = change_detection_1.DefaultIterableDiffer;
exports.IterableDiffers = change_detection_1.IterableDiffers;
exports.KeyValueDiffers = change_detection_1.KeyValueDiffers;
exports.CollectionChangeRecord = change_detection_1.CollectionChangeRecord;
exports.KeyValueChangeRecord = change_detection_1.KeyValueChangeRecord;

},{"./change_detection/change_detection":146}],146:[function(require,module,exports){
"use strict";
var iterable_differs_1 = require('./differs/iterable_differs');
var default_iterable_differ_1 = require('./differs/default_iterable_differ');
var keyvalue_differs_1 = require('./differs/keyvalue_differs');
var default_keyvalue_differ_1 = require('./differs/default_keyvalue_differ');
var default_keyvalue_differ_2 = require('./differs/default_keyvalue_differ');
exports.DefaultKeyValueDifferFactory = default_keyvalue_differ_2.DefaultKeyValueDifferFactory;
exports.KeyValueChangeRecord = default_keyvalue_differ_2.KeyValueChangeRecord;
var default_iterable_differ_2 = require('./differs/default_iterable_differ');
exports.DefaultIterableDifferFactory = default_iterable_differ_2.DefaultIterableDifferFactory;
exports.CollectionChangeRecord = default_iterable_differ_2.CollectionChangeRecord;
var constants_1 = require('./constants');
exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
exports.CHANGE_DETECTION_STRATEGY_VALUES = constants_1.CHANGE_DETECTION_STRATEGY_VALUES;
exports.ChangeDetectorState = constants_1.ChangeDetectorState;
exports.CHANGE_DETECTOR_STATE_VALUES = constants_1.CHANGE_DETECTOR_STATE_VALUES;
exports.isDefaultChangeDetectionStrategy = constants_1.isDefaultChangeDetectionStrategy;
var change_detector_ref_1 = require('./change_detector_ref');
exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
var iterable_differs_2 = require('./differs/iterable_differs');
exports.IterableDiffers = iterable_differs_2.IterableDiffers;
var keyvalue_differs_2 = require('./differs/keyvalue_differs');
exports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;
var default_iterable_differ_3 = require('./differs/default_iterable_differ');
exports.DefaultIterableDiffer = default_iterable_differ_3.DefaultIterableDiffer;
var change_detection_util_1 = require('./change_detection_util');
exports.WrappedValue = change_detection_util_1.WrappedValue;
exports.ValueUnwrapper = change_detection_util_1.ValueUnwrapper;
exports.SimpleChange = change_detection_util_1.SimpleChange;
exports.devModeEqual = change_detection_util_1.devModeEqual;
exports.looseIdentical = change_detection_util_1.looseIdentical;
exports.uninitialized = change_detection_util_1.uninitialized;
/**
 * Structural diffing for `Object`s and `Map`s.
 */
exports.keyValDiff = 
/*@ts2dart_const*/ [new default_keyvalue_differ_1.DefaultKeyValueDifferFactory()];
/**
 * Structural diffing for `Iterable` types such as `Array`s.
 */
exports.iterableDiff = 
/*@ts2dart_const*/ [new default_iterable_differ_1.DefaultIterableDifferFactory()];
exports.defaultIterableDiffers = new iterable_differs_1.IterableDiffers(exports.iterableDiff);
exports.defaultKeyValueDiffers = new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff);

},{"./change_detection_util":147,"./change_detector_ref":148,"./constants":149,"./differs/default_iterable_differ":150,"./differs/default_keyvalue_differ":151,"./differs/iterable_differs":152,"./differs/keyvalue_differs":153}],147:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var lang_2 = require('../../src/facade/lang');
exports.looseIdentical = lang_2.looseIdentical;
exports.uninitialized = new Object();
function devModeEqual(a, b) {
    if (collection_1.isListLikeIterable(a) && collection_1.isListLikeIterable(b)) {
        return collection_1.areIterablesEqual(a, b, devModeEqual);
    }
    else if (!collection_1.isListLikeIterable(a) && !lang_1.isPrimitive(a) && !collection_1.isListLikeIterable(b) &&
        !lang_1.isPrimitive(b)) {
        return true;
    }
    else {
        return lang_1.looseIdentical(a, b);
    }
}
exports.devModeEqual = devModeEqual;
/**
 * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
 * reference
 * has not changed.
 *
 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
 *
 * Example:
 *
 * ```
 * if (this._latestValue === this._latestReturnedValue) {
 *    return this._latestReturnedValue;
 *  } else {
 *    this._latestReturnedValue = this._latestValue;
 *    return WrappedValue.wrap(this._latestValue); // this will force update
 *  }
 * ```
 */
var WrappedValue = (function () {
    function WrappedValue(wrapped) {
        this.wrapped = wrapped;
    }
    WrappedValue.wrap = function (value) { return new WrappedValue(value); };
    return WrappedValue;
}());
exports.WrappedValue = WrappedValue;
/**
 * Helper class for unwrapping WrappedValue s
 */
var ValueUnwrapper = (function () {
    function ValueUnwrapper() {
        this.hasWrappedValue = false;
    }
    ValueUnwrapper.prototype.unwrap = function (value) {
        if (value instanceof WrappedValue) {
            this.hasWrappedValue = true;
            return value.wrapped;
        }
        return value;
    };
    ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
    return ValueUnwrapper;
}());
exports.ValueUnwrapper = ValueUnwrapper;
/**
 * Represents a basic change from a previous to a new value.
 */
var SimpleChange = (function () {
    function SimpleChange(previousValue, currentValue) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
    }
    /**
     * Check whether the new value is the first value assigned.
     */
    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === exports.uninitialized; };
    return SimpleChange;
}());
exports.SimpleChange = SimpleChange;

},{"../../src/facade/collection":171,"../../src/facade/lang":174}],148:[function(require,module,exports){
"use strict";
var ChangeDetectorRef = (function () {
    function ChangeDetectorRef() {
    }
    return ChangeDetectorRef;
}());
exports.ChangeDetectorRef = ChangeDetectorRef;

},{}],149:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
/**
 * Describes the current state of the change detector.
 */
(function (ChangeDetectorState) {
    /**
     * `NeverChecked` means that the change detector has not been checked yet, and
     * initialization methods should be called during detection.
     */
    ChangeDetectorState[ChangeDetectorState["NeverChecked"] = 0] = "NeverChecked";
    /**
     * `CheckedBefore` means that the change detector has successfully completed at least
     * one detection previously.
     */
    ChangeDetectorState[ChangeDetectorState["CheckedBefore"] = 1] = "CheckedBefore";
    /**
     * `Errored` means that the change detector encountered an error checking a binding
     * or calling a directive lifecycle method and is now in an inconsistent state. Change
     * detectors in this state will no longer detect changes.
     */
    ChangeDetectorState[ChangeDetectorState["Errored"] = 2] = "Errored";
})(exports.ChangeDetectorState || (exports.ChangeDetectorState = {}));
var ChangeDetectorState = exports.ChangeDetectorState;
/**
 * Describes within the change detector which strategy will be used the next time change
 * detection is triggered.
 */
(function (ChangeDetectionStrategy) {
    /**
     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
     * will become `Checked`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckOnce"] = 0] = "CheckOnce";
    /**
     * `Checked` means that the change detector should be skipped until its mode changes to
     * `CheckOnce`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Checked"] = 1] = "Checked";
    /**
     * `CheckAlways` means that after calling detectChanges the mode of the change detector
     * will remain `CheckAlways`.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckAlways"] = 2] = "CheckAlways";
    /**
     * `Detached` means that the change detector sub tree is not a part of the main tree and
     * should be skipped.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Detached"] = 3] = "Detached";
    /**
     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 4] = "OnPush";
    /**
     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
     */
    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 5] = "Default";
})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
var ChangeDetectionStrategy = exports.ChangeDetectionStrategy;
/**
 * List of possible {@link ChangeDetectionStrategy} values.
 */
exports.CHANGE_DETECTION_STRATEGY_VALUES = [
    ChangeDetectionStrategy.CheckOnce,
    ChangeDetectionStrategy.Checked,
    ChangeDetectionStrategy.CheckAlways,
    ChangeDetectionStrategy.Detached,
    ChangeDetectionStrategy.OnPush,
    ChangeDetectionStrategy.Default
];
/**
 * List of possible {@link ChangeDetectorState} values.
 */
exports.CHANGE_DETECTOR_STATE_VALUES = [
    ChangeDetectorState.NeverChecked,
    ChangeDetectorState.CheckedBefore,
    ChangeDetectorState.Errored
];
function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return lang_1.isBlank(changeDetectionStrategy) ||
        changeDetectionStrategy === ChangeDetectionStrategy.Default;
}
exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;

},{"../../src/facade/lang":174}],150:[function(require,module,exports){
"use strict";
var exceptions_1 = require('../../../src/facade/exceptions');
var collection_1 = require('../../../src/facade/collection');
var lang_1 = require('../../../src/facade/lang');
/* @ts2dart_const */
var DefaultIterableDifferFactory = (function () {
    function DefaultIterableDifferFactory() {
    }
    DefaultIterableDifferFactory.prototype.supports = function (obj) { return collection_1.isListLikeIterable(obj); };
    DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
        return new DefaultIterableDiffer(trackByFn);
    };
    return DefaultIterableDifferFactory;
}());
exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
var trackByIdentity = function (index, item) { return item; };
var DefaultIterableDiffer = (function () {
    function DefaultIterableDiffer(_trackByFn) {
        this._trackByFn = _trackByFn;
        this._length = null;
        this._collection = null;
        // Keeps track of the used records at any point in time (during & across `_check()` calls)
        this._linkedRecords = null;
        // Keeps track of the removed records at any point in time during `_check()` calls.
        this._unlinkedRecords = null;
        this._previousItHead = null;
        this._itHead = null;
        this._itTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._movesHead = null;
        this._movesTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
        // Keeps track of records where custom track by is the same, but item identity has changed
        this._identityChangesHead = null;
        this._identityChangesTail = null;
        this._trackByFn = lang_1.isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;
    }
    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
        get: function () { return this._collection; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
        get: function () { return this._length; },
        enumerable: true,
        configurable: true
    });
    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
        var record;
        for (record = this._itHead; record !== null; record = record._next) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
        var record;
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
        var record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
        var record;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
        var record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
        var record;
        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
            fn(record);
        }
    };
    DefaultIterableDiffer.prototype.diff = function (collection) {
        if (lang_1.isBlank(collection))
            collection = [];
        if (!collection_1.isListLikeIterable(collection)) {
            throw new exceptions_1.BaseException("Error trying to diff '" + collection + "'");
        }
        if (this.check(collection)) {
            return this;
        }
        else {
            return null;
        }
    };
    DefaultIterableDiffer.prototype.onDestroy = function () { };
    // todo(vicb): optim for UnmodifiableListView (frozen arrays)
    DefaultIterableDiffer.prototype.check = function (collection) {
        var _this = this;
        this._reset();
        var record = this._itHead;
        var mayBeDirty = false;
        var index;
        var item;
        var itemTrackBy;
        if (lang_1.isArray(collection)) {
            var list = collection;
            this._length = collection.length;
            for (index = 0; index < this._length; index++) {
                item = list[index];
                itemTrackBy = this._trackByFn(index, item);
                if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
                    record = this._mismatch(record, item, itemTrackBy, index);
                    mayBeDirty = true;
                }
                else {
                    if (mayBeDirty) {
                        // TODO(misko): can we limit this to duplicates only?
                        record = this._verifyReinsertion(record, item, itemTrackBy, index);
                    }
                    if (!lang_1.looseIdentical(record.item, item))
                        this._addIdentityChange(record, item);
                }
                record = record._next;
            }
        }
        else {
            index = 0;
            collection_1.iterateListLike(collection, function (item) {
                itemTrackBy = _this._trackByFn(index, item);
                if (record === null || !lang_1.looseIdentical(record.trackById, itemTrackBy)) {
                    record = _this._mismatch(record, item, itemTrackBy, index);
                    mayBeDirty = true;
                }
                else {
                    if (mayBeDirty) {
                        // TODO(misko): can we limit this to duplicates only?
                        record = _this._verifyReinsertion(record, item, itemTrackBy, index);
                    }
                    if (!lang_1.looseIdentical(record.item, item))
                        _this._addIdentityChange(record, item);
                }
                record = record._next;
                index++;
            });
            this._length = index;
        }
        this._truncate(record);
        this._collection = collection;
        return this.isDirty;
    };
    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
        /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
         * changes.
         */
        get: function () {
            return this._additionsHead !== null || this._movesHead !== null ||
                this._removalsHead !== null || this._identityChangesHead !== null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reset the state of the change objects to show no changes. This means set previousKey to
     * currentKey, and clear all of the queues (additions, moves, removals).
     * Set the previousIndexes of moved and added items to their currentIndexes
     * Reset the list of additions, moves and removals
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._reset = function () {
        if (this.isDirty) {
            var record;
            var nextRecord;
            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                record.previousIndex = record.currentIndex;
            }
            this._additionsHead = this._additionsTail = null;
            for (record = this._movesHead; record !== null; record = nextRecord) {
                record.previousIndex = record.currentIndex;
                nextRecord = record._nextMoved;
            }
            this._movesHead = this._movesTail = null;
            this._removalsHead = this._removalsTail = null;
            this._identityChangesHead = this._identityChangesTail = null;
        }
    };
    /**
     * This is the core function which handles differences between collections.
     *
     * - `record` is the record which we saw at this position last time. If null then it is a new
     *   item.
     * - `item` is the current item in the collection
     * - `index` is the position of the item in the collection
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
        // The previous record after which we will append the current one.
        var previousRecord;
        if (record === null) {
            previousRecord = this._itTail;
        }
        else {
            previousRecord = record._prev;
            // Remove the record from the collection since we know it does not match the item.
            this._remove(record);
        }
        // Attempt to see if we have seen the item before.
        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
        if (record !== null) {
            // We have seen this before, we need to move it forward in the collection.
            // But first we need to check if identity changed, so we can update in view if necessary
            if (!lang_1.looseIdentical(record.item, item))
                this._addIdentityChange(record, item);
            this._moveAfter(record, previousRecord, index);
        }
        else {
            // Never seen it, check evicted list.
            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
            if (record !== null) {
                // It is an item which we have evicted earlier: reinsert it back into the list.
                // But first we need to check if identity changed, so we can update in view if necessary
                if (!lang_1.looseIdentical(record.item, item))
                    this._addIdentityChange(record, item);
                this._reinsertAfter(record, previousRecord, index);
            }
            else {
                // It is a new item: add it.
                record =
                    this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
            }
        }
        return record;
    };
    /**
     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
     *
     * Use case: `[a, a]` => `[b, a, a]`
     *
     * If we did not have this check then the insertion of `b` would:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) leave `a` at index `1` as is. <-- this is wrong!
     *   3) reinsert `a` at index 2. <-- this is wrong!
     *
     * The correct behavior is:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) reinsert `a` at index 1.
     *   3) move `a` at from `1` to `2`.
     *
     *
     * Double check that we have not evicted a duplicate item. We need to check if the item type may
     * have already been removed:
     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
     * at the end.
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
        if (reinsertRecord !== null) {
            record = this._reinsertAfter(reinsertRecord, record._prev, index);
        }
        else if (record.currentIndex != index) {
            record.currentIndex = index;
            this._addToMoves(record, index);
        }
        return record;
    };
    /**
     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
     *
     * - `record` The first excess {@link CollectionChangeRecord}.
     *
     * @internal
     */
    DefaultIterableDiffer.prototype._truncate = function (record) {
        // Anything after that needs to be removed;
        while (record !== null) {
            var nextRecord = record._next;
            this._addToRemovals(this._unlink(record));
            record = nextRecord;
        }
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.clear();
        }
        if (this._additionsTail !== null) {
            this._additionsTail._nextAdded = null;
        }
        if (this._movesTail !== null) {
            this._movesTail._nextMoved = null;
        }
        if (this._itTail !== null) {
            this._itTail._next = null;
        }
        if (this._removalsTail !== null) {
            this._removalsTail._nextRemoved = null;
        }
        if (this._identityChangesTail !== null) {
            this._identityChangesTail._nextIdentityChange = null;
        }
    };
    /** @internal */
    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.remove(record);
        }
        var prev = record._prevRemoved;
        var next = record._nextRemoved;
        if (prev === null) {
            this._removalsHead = next;
        }
        else {
            prev._nextRemoved = next;
        }
        if (next === null) {
            this._removalsTail = prev;
        }
        else {
            next._prevRemoved = prev;
        }
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) {
            // todo(vicb)
            // assert(this._additionsHead === null);
            this._additionsTail = this._additionsHead = record;
        }
        else {
            // todo(vicb)
            // assert(_additionsTail._nextAdded === null);
            // assert(record._nextAdded === null);
            this._additionsTail = this._additionsTail._nextAdded = record;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
        // todo(vicb)
        // assert(record != prevRecord);
        // assert(record._next === null);
        // assert(record._prev === null);
        var next = prevRecord === null ? this._itHead : prevRecord._next;
        // todo(vicb)
        // assert(next != record);
        // assert(prevRecord != record);
        record._next = next;
        record._prev = prevRecord;
        if (next === null) {
            this._itTail = record;
        }
        else {
            next._prev = record;
        }
        if (prevRecord === null) {
            this._itHead = record;
        }
        else {
            prevRecord._next = record;
        }
        if (this._linkedRecords === null) {
            this._linkedRecords = new _DuplicateMap();
        }
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._remove = function (record) {
        return this._addToRemovals(this._unlink(record));
    };
    /** @internal */
    DefaultIterableDiffer.prototype._unlink = function (record) {
        if (this._linkedRecords !== null) {
            this._linkedRecords.remove(record);
        }
        var prev = record._prev;
        var next = record._next;
        // todo(vicb)
        // assert((record._prev = null) === null);
        // assert((record._next = null) === null);
        if (prev === null) {
            this._itHead = next;
        }
        else {
            prev._next = next;
        }
        if (next === null) {
            this._itTail = prev;
        }
        else {
            next._prev = prev;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
        // todo(vicb)
        // assert(record._nextMoved === null);
        if (record.previousIndex === toIndex) {
            return record;
        }
        if (this._movesTail === null) {
            // todo(vicb)
            // assert(_movesHead === null);
            this._movesTail = this._movesHead = record;
        }
        else {
            // todo(vicb)
            // assert(_movesTail._nextMoved === null);
            this._movesTail = this._movesTail._nextMoved = record;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
        if (this._unlinkedRecords === null) {
            this._unlinkedRecords = new _DuplicateMap();
        }
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
            // todo(vicb)
            // assert(_removalsHead === null);
            this._removalsTail = this._removalsHead = record;
            record._prevRemoved = null;
        }
        else {
            // todo(vicb)
            // assert(_removalsTail._nextRemoved === null);
            // assert(record._nextRemoved === null);
            record._prevRemoved = this._removalsTail;
            this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
    };
    /** @internal */
    DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
        record.item = item;
        if (this._identityChangesTail === null) {
            this._identityChangesTail = this._identityChangesHead = record;
        }
        else {
            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
        }
        return record;
    };
    DefaultIterableDiffer.prototype.toString = function () {
        var list = [];
        this.forEachItem(function (record) { return list.push(record); });
        var previous = [];
        this.forEachPreviousItem(function (record) { return previous.push(record); });
        var additions = [];
        this.forEachAddedItem(function (record) { return additions.push(record); });
        var moves = [];
        this.forEachMovedItem(function (record) { return moves.push(record); });
        var removals = [];
        this.forEachRemovedItem(function (record) { return removals.push(record); });
        var identityChanges = [];
        this.forEachIdentityChange(function (record) { return identityChanges.push(record); });
        return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
            "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" +
            "removals: " + removals.join(', ') + "\n" + "identityChanges: " +
            identityChanges.join(', ') + "\n";
    };
    return DefaultIterableDiffer;
}());
exports.DefaultIterableDiffer = DefaultIterableDiffer;
var CollectionChangeRecord = (function () {
    function CollectionChangeRecord(item, trackById) {
        this.item = item;
        this.trackById = trackById;
        this.currentIndex = null;
        this.previousIndex = null;
        /** @internal */
        this._nextPrevious = null;
        /** @internal */
        this._prev = null;
        /** @internal */
        this._next = null;
        /** @internal */
        this._prevDup = null;
        /** @internal */
        this._nextDup = null;
        /** @internal */
        this._prevRemoved = null;
        /** @internal */
        this._nextRemoved = null;
        /** @internal */
        this._nextAdded = null;
        /** @internal */
        this._nextMoved = null;
        /** @internal */
        this._nextIdentityChange = null;
    }
    CollectionChangeRecord.prototype.toString = function () {
        return this.previousIndex === this.currentIndex ?
            lang_1.stringify(this.item) :
            lang_1.stringify(this.item) + '[' + lang_1.stringify(this.previousIndex) + '->' +
                lang_1.stringify(this.currentIndex) + ']';
    };
    return CollectionChangeRecord;
}());
exports.CollectionChangeRecord = CollectionChangeRecord;
// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
var _DuplicateItemRecordList = (function () {
    function _DuplicateItemRecordList() {
        /** @internal */
        this._head = null;
        /** @internal */
        this._tail = null;
    }
    /**
     * Append the record to the list of duplicates.
     *
     * Note: by design all records in the list of duplicates hold the same value in record.item.
     */
    _DuplicateItemRecordList.prototype.add = function (record) {
        if (this._head === null) {
            this._head = this._tail = record;
            record._nextDup = null;
            record._prevDup = null;
        }
        else {
            // todo(vicb)
            // assert(record.item ==  _head.item ||
            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
            this._tail._nextDup = record;
            record._prevDup = this._tail;
            record._nextDup = null;
            this._tail = record;
        }
    };
    // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and
    // CollectionChangeRecord.currentIndex >= afterIndex
    _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
        var record;
        for (record = this._head; record !== null; record = record._nextDup) {
            if ((afterIndex === null || afterIndex < record.currentIndex) &&
                lang_1.looseIdentical(record.trackById, trackById)) {
                return record;
            }
        }
        return null;
    };
    /**
     * Remove one {@link CollectionChangeRecord} from the list of duplicates.
     *
     * Returns whether the list of duplicates is empty.
     */
    _DuplicateItemRecordList.prototype.remove = function (record) {
        // todo(vicb)
        // assert(() {
        //  // verify that the record being removed is in the list.
        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
        //    if (identical(cursor, record)) return true;
        //  }
        //  return false;
        //});
        var prev = record._prevDup;
        var next = record._nextDup;
        if (prev === null) {
            this._head = next;
        }
        else {
            prev._nextDup = next;
        }
        if (next === null) {
            this._tail = prev;
        }
        else {
            next._prevDup = prev;
        }
        return this._head === null;
    };
    return _DuplicateItemRecordList;
}());
var _DuplicateMap = (function () {
    function _DuplicateMap() {
        this.map = new Map();
    }
    _DuplicateMap.prototype.put = function (record) {
        // todo(vicb) handle corner cases
        var key = lang_1.getMapKey(record.trackById);
        var duplicates = this.map.get(key);
        if (!lang_1.isPresent(duplicates)) {
            duplicates = new _DuplicateItemRecordList();
            this.map.set(key, duplicates);
        }
        duplicates.add(record);
    };
    /**
     * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
     * have already iterated over, we use the afterIndex to pretend it is not there.
     *
     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
     * have any more `a`s needs to return the last `a` not the first or second.
     */
    _DuplicateMap.prototype.get = function (trackById, afterIndex) {
        if (afterIndex === void 0) { afterIndex = null; }
        var key = lang_1.getMapKey(trackById);
        var recordList = this.map.get(key);
        return lang_1.isBlank(recordList) ? null : recordList.get(trackById, afterIndex);
    };
    /**
     * Removes a {@link CollectionChangeRecord} from the list of duplicates.
     *
     * The list of duplicates also is removed from the map if it gets empty.
     */
    _DuplicateMap.prototype.remove = function (record) {
        var key = lang_1.getMapKey(record.trackById);
        // todo(vicb)
        // assert(this.map.containsKey(key));
        var recordList = this.map.get(key);
        // Remove the list of duplicates when it gets empty
        if (recordList.remove(record)) {
            this.map.delete(key);
        }
        return record;
    };
    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
        get: function () { return this.map.size === 0; },
        enumerable: true,
        configurable: true
    });
    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + lang_1.stringify(this.map) + ')'; };
    return _DuplicateMap;
}());

},{"../../../src/facade/collection":171,"../../../src/facade/exceptions":173,"../../../src/facade/lang":174}],151:[function(require,module,exports){
"use strict";
var collection_1 = require('../../../src/facade/collection');
var lang_1 = require('../../../src/facade/lang');
var exceptions_1 = require('../../../src/facade/exceptions');
/* @ts2dart_const */
var DefaultKeyValueDifferFactory = (function () {
    function DefaultKeyValueDifferFactory() {
    }
    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || lang_1.isJsObject(obj); };
    DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
    return DefaultKeyValueDifferFactory;
}());
exports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;
var DefaultKeyValueDiffer = (function () {
    function DefaultKeyValueDiffer() {
        this._records = new Map();
        this._mapHead = null;
        this._previousMapHead = null;
        this._changesHead = null;
        this._changesTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
    }
    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
        get: function () {
            return this._additionsHead !== null || this._changesHead !== null ||
                this._removalsHead !== null;
        },
        enumerable: true,
        configurable: true
    });
    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
        var record;
        for (record = this._mapHead; record !== null; record = record._next) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
        var record;
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
        var record;
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
        var record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
        var record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            fn(record);
        }
    };
    DefaultKeyValueDiffer.prototype.diff = function (map) {
        if (lang_1.isBlank(map))
            map = collection_1.MapWrapper.createFromPairs([]);
        if (!(map instanceof Map || lang_1.isJsObject(map))) {
            throw new exceptions_1.BaseException("Error trying to diff '" + map + "'");
        }
        if (this.check(map)) {
            return this;
        }
        else {
            return null;
        }
    };
    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
    DefaultKeyValueDiffer.prototype.check = function (map) {
        var _this = this;
        this._reset();
        var records = this._records;
        var oldSeqRecord = this._mapHead;
        var lastOldSeqRecord = null;
        var lastNewSeqRecord = null;
        var seqChanged = false;
        this._forEach(map, function (value, key) {
            var newSeqRecord;
            if (oldSeqRecord !== null && key === oldSeqRecord.key) {
                newSeqRecord = oldSeqRecord;
                if (!lang_1.looseIdentical(value, oldSeqRecord.currentValue)) {
                    oldSeqRecord.previousValue = oldSeqRecord.currentValue;
                    oldSeqRecord.currentValue = value;
                    _this._addToChanges(oldSeqRecord);
                }
            }
            else {
                seqChanged = true;
                if (oldSeqRecord !== null) {
                    oldSeqRecord._next = null;
                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                    _this._addToRemovals(oldSeqRecord);
                }
                if (records.has(key)) {
                    newSeqRecord = records.get(key);
                }
                else {
                    newSeqRecord = new KeyValueChangeRecord(key);
                    records.set(key, newSeqRecord);
                    newSeqRecord.currentValue = value;
                    _this._addToAdditions(newSeqRecord);
                }
            }
            if (seqChanged) {
                if (_this._isInRemovals(newSeqRecord)) {
                    _this._removeFromRemovals(newSeqRecord);
                }
                if (lastNewSeqRecord == null) {
                    _this._mapHead = newSeqRecord;
                }
                else {
                    lastNewSeqRecord._next = newSeqRecord;
                }
            }
            lastOldSeqRecord = oldSeqRecord;
            lastNewSeqRecord = newSeqRecord;
            oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
        });
        this._truncate(lastOldSeqRecord, oldSeqRecord);
        return this.isDirty;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._reset = function () {
        if (this.isDirty) {
            var record;
            // Record the state of the mapping
            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                record.previousValue = record.currentValue;
            }
            for (record = this._additionsHead; record != null; record = record._nextAdded) {
                record.previousValue = record.currentValue;
            }
            // todo(vicb) once assert is supported
            // assert(() {
            //  var r = _changesHead;
            //  while (r != null) {
            //    var nextRecord = r._nextChanged;
            //    r._nextChanged = null;
            //    r = nextRecord;
            //  }
            //
            //  r = _additionsHead;
            //  while (r != null) {
            //    var nextRecord = r._nextAdded;
            //    r._nextAdded = null;
            //    r = nextRecord;
            //  }
            //
            //  r = _removalsHead;
            //  while (r != null) {
            //    var nextRecord = r._nextRemoved;
            //    r._nextRemoved = null;
            //    r = nextRecord;
            //  }
            //
            //  return true;
            //});
            this._changesHead = this._changesTail = null;
            this._additionsHead = this._additionsTail = null;
            this._removalsHead = this._removalsTail = null;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
        while (record !== null) {
            if (lastRecord === null) {
                this._mapHead = null;
            }
            else {
                lastRecord._next = null;
            }
            var nextRecord = record._next;
            // todo(vicb) assert
            // assert((() {
            //  record._next = null;
            //  return true;
            //}));
            this._addToRemovals(record);
            lastRecord = record;
            record = nextRecord;
        }
        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
            rec.previousValue = rec.currentValue;
            rec.currentValue = null;
            this._records.delete(rec.key);
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
        return record === this._removalsHead || record._nextRemoved !== null ||
            record._prevRemoved !== null;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
        // todo(vicb) assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._removalsHead === null) {
            this._removalsHead = this._removalsTail = record;
        }
        else {
            this._removalsTail._nextRemoved = record;
            record._prevRemoved = this._removalsTail;
            this._removalsTail = record;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
        var next = record._next;
        if (prev === null) {
            this._mapHead = next;
        }
        else {
            prev._next = next;
        }
        // todo(vicb) assert
        // assert((() {
        //  record._next = null;
        //  return true;
        //})());
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
        // todo(vicb) assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        var prev = record._prevRemoved;
        var next = record._nextRemoved;
        if (prev === null) {
            this._removalsHead = next;
        }
        else {
            prev._nextRemoved = next;
        }
        if (next === null) {
            this._removalsTail = prev;
        }
        else {
            next._prevRemoved = prev;
        }
        record._prevRemoved = record._nextRemoved = null;
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
        // todo(vicb): assert
        // assert(record._next == null);
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._additionsHead === null) {
            this._additionsHead = this._additionsTail = record;
        }
        else {
            this._additionsTail._nextAdded = record;
            this._additionsTail = record;
        }
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
        // todo(vicb) assert
        // assert(record._nextAdded == null);
        // assert(record._nextChanged == null);
        // assert(record._nextRemoved == null);
        // assert(record._prevRemoved == null);
        if (this._changesHead === null) {
            this._changesHead = this._changesTail = record;
        }
        else {
            this._changesTail._nextChanged = record;
            this._changesTail = record;
        }
    };
    DefaultKeyValueDiffer.prototype.toString = function () {
        var items = [];
        var previous = [];
        var changes = [];
        var additions = [];
        var removals = [];
        var record;
        for (record = this._mapHead; record !== null; record = record._next) {
            items.push(lang_1.stringify(record));
        }
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
            previous.push(lang_1.stringify(record));
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
            changes.push(lang_1.stringify(record));
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            additions.push(lang_1.stringify(record));
        }
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            removals.push(lang_1.stringify(record));
        }
        return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
            "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" +
            "removals: " + removals.join(', ') + "\n";
    };
    /** @internal */
    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
        if (obj instanceof Map) {
            obj.forEach(fn);
        }
        else {
            collection_1.StringMapWrapper.forEach(obj, fn);
        }
    };
    return DefaultKeyValueDiffer;
}());
exports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;
var KeyValueChangeRecord = (function () {
    function KeyValueChangeRecord(key) {
        this.key = key;
        this.previousValue = null;
        this.currentValue = null;
        /** @internal */
        this._nextPrevious = null;
        /** @internal */
        this._next = null;
        /** @internal */
        this._nextAdded = null;
        /** @internal */
        this._nextRemoved = null;
        /** @internal */
        this._prevRemoved = null;
        /** @internal */
        this._nextChanged = null;
    }
    KeyValueChangeRecord.prototype.toString = function () {
        return lang_1.looseIdentical(this.previousValue, this.currentValue) ?
            lang_1.stringify(this.key) :
            (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' +
                lang_1.stringify(this.currentValue) + ']');
    };
    return KeyValueChangeRecord;
}());
exports.KeyValueChangeRecord = KeyValueChangeRecord;

},{"../../../src/facade/collection":171,"../../../src/facade/exceptions":173,"../../../src/facade/lang":174}],152:[function(require,module,exports){
"use strict";
var lang_1 = require('../../../src/facade/lang');
var exceptions_1 = require('../../../src/facade/exceptions');
var collection_1 = require('../../../src/facade/collection');
var di_1 = require('../../di');
/**
 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
 * @ts2dart_const
 */
var IterableDiffers = (function () {
    /*@ts2dart_const*/
    function IterableDiffers(factories) {
        this.factories = factories;
    }
    IterableDiffers.create = function (factories, parent) {
        if (lang_1.isPresent(parent)) {
            var copied = collection_1.ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new IterableDiffers(factories);
        }
        else {
            return new IterableDiffers(factories);
        }
    };
    /**
     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
     * inherited {@link IterableDiffers} instance with the provided factories and return a new
     * {@link IterableDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link IterableDiffer} available.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     IterableDiffers.extend([new ImmutableListDiffer()])
     *   ]
     * })
     * ```
     */
    IterableDiffers.extend = function (factories) {
        return new di_1.Provider(IterableDiffers, {
            useFactory: function (parent) {
                if (lang_1.isBlank(parent)) {
                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
                    // to
                    // bootstrap(), which would override default pipes instead of extending them.
                    throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');
                }
                return IterableDiffers.create(factories, parent);
            },
            // Dependency technically isn't optional, but we can provide a better error message this way.
            deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
        });
    };
    IterableDiffers.prototype.find = function (iterable) {
        var factory = this.factories.find(function (f) { return f.supports(iterable); });
        if (lang_1.isPresent(factory)) {
            return factory;
        }
        else {
            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + iterable + "' of type '" + lang_1.getTypeNameForDebugging(iterable) + "'");
        }
    };
    return IterableDiffers;
}());
exports.IterableDiffers = IterableDiffers;

},{"../../../src/facade/collection":171,"../../../src/facade/exceptions":173,"../../../src/facade/lang":174,"../../di":157}],153:[function(require,module,exports){
"use strict";
var lang_1 = require('../../../src/facade/lang');
var exceptions_1 = require('../../../src/facade/exceptions');
var collection_1 = require('../../../src/facade/collection');
var di_1 = require('../../di');
/**
 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
 * @ts2dart_const
 */
var KeyValueDiffers = (function () {
    /*@ts2dart_const*/
    function KeyValueDiffers(factories) {
        this.factories = factories;
    }
    KeyValueDiffers.create = function (factories, parent) {
        if (lang_1.isPresent(parent)) {
            var copied = collection_1.ListWrapper.clone(parent.factories);
            factories = factories.concat(copied);
            return new KeyValueDiffers(factories);
        }
        else {
            return new KeyValueDiffers(factories);
        }
    };
    /**
     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
     * {@link KeyValueDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link KeyValueDiffer} available.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
     *   ]
     * })
     * ```
     */
    KeyValueDiffers.extend = function (factories) {
        return new di_1.Provider(KeyValueDiffers, {
            useFactory: function (parent) {
                if (lang_1.isBlank(parent)) {
                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
                    // to
                    // bootstrap(), which would override default pipes instead of extending them.
                    throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');
                }
                return KeyValueDiffers.create(factories, parent);
            },
            // Dependency technically isn't optional, but we can provide a better error message this way.
            deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
        });
    };
    KeyValueDiffers.prototype.find = function (kv) {
        var factory = this.factories.find(function (f) { return f.supports(kv); });
        if (lang_1.isPresent(factory)) {
            return factory;
        }
        else {
            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + kv + "'");
        }
    };
    return KeyValueDiffers;
}());
exports.KeyValueDiffers = KeyValueDiffers;

},{"../../../src/facade/collection":171,"../../../src/facade/exceptions":173,"../../../src/facade/lang":174,"../../di":157}],154:[function(require,module,exports){
"use strict";
var lang_1 = require('./facade/lang');
var decorators_1 = require('./di/decorators');
// Note: Need to rename warn as in Dart
// class members and imports can't use the same name.
var _warnImpl = lang_1.warn;
var Console = (function () {
    function Console() {
    }
    Console.prototype.log = function (message) { lang_1.print(message); };
    // Note: for reporting errors use `DOM.logError()` as it is platform specific
    Console.prototype.warn = function (message) { _warnImpl(message); };
    Console.decorators = [
        { type: decorators_1.Injectable },
    ];
    return Console;
}());
exports.Console = Console;

},{"./di/decorators":158,"./facade/lang":174}],155:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var EventListener = (function () {
    function EventListener(name, callback) {
        this.name = name;
        this.callback = callback;
    }
    ;
    return EventListener;
}());
exports.EventListener = EventListener;
var DebugNode = (function () {
    function DebugNode(nativeNode, parent, _debugInfo) {
        this._debugInfo = _debugInfo;
        this.nativeNode = nativeNode;
        if (lang_1.isPresent(parent) && parent instanceof DebugElement) {
            parent.addChild(this);
        }
        else {
            this.parent = null;
        }
        this.listeners = [];
    }
    Object.defineProperty(DebugNode.prototype, "injector", {
        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.injector : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "componentInstance", {
        get: function () {
            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.component : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "context", {
        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.context : null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "references", {
        get: function () {
            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.references : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "providerTokens", {
        get: function () {
            return lang_1.isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugNode.prototype, "source", {
        get: function () { return lang_1.isPresent(this._debugInfo) ? this._debugInfo.source : null; },
        enumerable: true,
        configurable: true
    });
    /**
     * Use injector.get(token) instead.
     *
     * @deprecated
     */
    DebugNode.prototype.inject = function (token) { return this.injector.get(token); };
    return DebugNode;
}());
exports.DebugNode = DebugNode;
var DebugElement = (function (_super) {
    __extends(DebugElement, _super);
    function DebugElement(nativeNode, parent, _debugInfo) {
        _super.call(this, nativeNode, parent, _debugInfo);
        this.properties = {};
        this.attributes = {};
        this.childNodes = [];
        this.nativeElement = nativeNode;
    }
    DebugElement.prototype.addChild = function (child) {
        if (lang_1.isPresent(child)) {
            this.childNodes.push(child);
            child.parent = this;
        }
    };
    DebugElement.prototype.removeChild = function (child) {
        var childIndex = this.childNodes.indexOf(child);
        if (childIndex !== -1) {
            child.parent = null;
            this.childNodes.splice(childIndex, 1);
        }
    };
    DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
        var siblingIndex = this.childNodes.indexOf(child);
        if (siblingIndex !== -1) {
            var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
            var nextChildren = this.childNodes.slice(siblingIndex + 1);
            this.childNodes =
                collection_1.ListWrapper.concat(collection_1.ListWrapper.concat(previousChildren, newChildren), nextChildren);
            for (var i = 0; i < newChildren.length; ++i) {
                var newChild = newChildren[i];
                if (lang_1.isPresent(newChild.parent)) {
                    newChild.parent.removeChild(newChild);
                }
                newChild.parent = this;
            }
        }
    };
    DebugElement.prototype.query = function (predicate) {
        var results = this.queryAll(predicate);
        return results.length > 0 ? results[0] : null;
    };
    DebugElement.prototype.queryAll = function (predicate) {
        var matches = [];
        _queryElementChildren(this, predicate, matches);
        return matches;
    };
    DebugElement.prototype.queryAllNodes = function (predicate) {
        var matches = [];
        _queryNodeChildren(this, predicate, matches);
        return matches;
    };
    Object.defineProperty(DebugElement.prototype, "children", {
        get: function () {
            var children = [];
            this.childNodes.forEach(function (node) {
                if (node instanceof DebugElement) {
                    children.push(node);
                }
            });
            return children;
        },
        enumerable: true,
        configurable: true
    });
    DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
        this.listeners.forEach(function (listener) {
            if (listener.name == eventName) {
                listener.callback(eventObj);
            }
        });
    };
    return DebugElement;
}(DebugNode));
exports.DebugElement = DebugElement;
function asNativeElements(debugEls) {
    return debugEls.map(function (el) { return el.nativeElement; });
}
exports.asNativeElements = asNativeElements;
function _queryElementChildren(element, predicate, matches) {
    element.childNodes.forEach(function (node) {
        if (node instanceof DebugElement) {
            if (predicate(node)) {
                matches.push(node);
            }
            _queryElementChildren(node, predicate, matches);
        }
    });
}
function _queryNodeChildren(parentNode, predicate, matches) {
    if (parentNode instanceof DebugElement) {
        parentNode.childNodes.forEach(function (node) {
            if (predicate(node)) {
                matches.push(node);
            }
            if (node instanceof DebugElement) {
                _queryNodeChildren(node, predicate, matches);
            }
        });
    }
}
// Need to keep the nodes in a global Map so that multiple angular apps are supported.
var _nativeNodeToDebugNode = new Map();
function getDebugNode(nativeNode) {
    return _nativeNodeToDebugNode.get(nativeNode);
}
exports.getDebugNode = getDebugNode;
function getAllDebugNodes() {
    return collection_1.MapWrapper.values(_nativeNodeToDebugNode);
}
exports.getAllDebugNodes = getAllDebugNodes;
function indexDebugNode(node) {
    _nativeNodeToDebugNode.set(node.nativeNode, node);
}
exports.indexDebugNode = indexDebugNode;
function removeDebugNodeFromIndex(node) {
    _nativeNodeToDebugNode.delete(node.nativeNode);
}
exports.removeDebugNodeFromIndex = removeDebugNodeFromIndex;

},{"../../src/facade/collection":171,"../../src/facade/lang":174}],156:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var debug_node_1 = require('./debug_node');
var DebugDomRootRenderer = (function () {
    function DebugDomRootRenderer(_delegate) {
        this._delegate = _delegate;
    }
    DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
        return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
    };
    return DebugDomRootRenderer;
}());
exports.DebugDomRootRenderer = DebugDomRootRenderer;
var DebugDomRenderer = (function () {
    function DebugDomRenderer(_delegate) {
        this._delegate = _delegate;
    }
    DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
        var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
        var debugEl = new debug_node_1.DebugElement(nativeEl, null, debugInfo);
        debug_node_1.indexDebugNode(debugEl);
        return nativeEl;
    };
    DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
        var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
        var debugEl = new debug_node_1.DebugElement(nativeEl, debug_node_1.getDebugNode(parentElement), debugInfo);
        debugEl.name = name;
        debug_node_1.indexDebugNode(debugEl);
        return nativeEl;
    };
    DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
    DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
        var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
        var debugEl = new debug_node_1.DebugNode(comment, debug_node_1.getDebugNode(parentElement), debugInfo);
        debug_node_1.indexDebugNode(debugEl);
        return comment;
    };
    DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
        var text = this._delegate.createText(parentElement, value, debugInfo);
        var debugEl = new debug_node_1.DebugNode(text, debug_node_1.getDebugNode(parentElement), debugInfo);
        debug_node_1.indexDebugNode(debugEl);
        return text;
    };
    DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
        var debugParent = debug_node_1.getDebugNode(parentElement);
        if (lang_1.isPresent(debugParent) && debugParent instanceof debug_node_1.DebugElement) {
            var debugElement_1 = debugParent;
            nodes.forEach(function (node) { debugElement_1.addChild(debug_node_1.getDebugNode(node)); });
        }
        this._delegate.projectNodes(parentElement, nodes);
    };
    DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
        var debugNode = debug_node_1.getDebugNode(node);
        if (lang_1.isPresent(debugNode)) {
            var debugParent = debugNode.parent;
            if (viewRootNodes.length > 0 && lang_1.isPresent(debugParent)) {
                var debugViewRootNodes = [];
                viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes.push(debug_node_1.getDebugNode(rootNode)); });
                debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
            }
        }
        this._delegate.attachViewAfter(node, viewRootNodes);
    };
    DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
        viewRootNodes.forEach(function (node) {
            var debugNode = debug_node_1.getDebugNode(node);
            if (lang_1.isPresent(debugNode) && lang_1.isPresent(debugNode.parent)) {
                debugNode.parent.removeChild(debugNode);
            }
        });
        this._delegate.detachView(viewRootNodes);
    };
    DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
        viewAllNodes.forEach(function (node) { debug_node_1.removeDebugNodeFromIndex(debug_node_1.getDebugNode(node)); });
        this._delegate.destroyView(hostElement, viewAllNodes);
    };
    DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
        var debugEl = debug_node_1.getDebugNode(renderElement);
        if (lang_1.isPresent(debugEl)) {
            debugEl.listeners.push(new debug_node_1.EventListener(name, callback));
        }
        return this._delegate.listen(renderElement, name, callback);
    };
    DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
        return this._delegate.listenGlobal(target, name, callback);
    };
    DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
        var debugEl = debug_node_1.getDebugNode(renderElement);
        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
            debugEl.properties[propertyName] = propertyValue;
        }
        this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
    };
    DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
        var debugEl = debug_node_1.getDebugNode(renderElement);
        if (lang_1.isPresent(debugEl) && debugEl instanceof debug_node_1.DebugElement) {
            debugEl.attributes[attributeName] = attributeValue;
        }
        this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
    };
    DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
        this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
    };
    DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
        this._delegate.setElementClass(renderElement, className, isAdd);
    };
    DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
        this._delegate.setElementStyle(renderElement, styleName, styleValue);
    };
    DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
        this._delegate.invokeElementMethod(renderElement, methodName, args);
    };
    DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
    return DebugDomRenderer;
}());
exports.DebugDomRenderer = DebugDomRenderer;

},{"../../src/facade/lang":174,"./debug_node":155}],157:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/**
* @module
* @description
* The `di` module provides dependency injection container services.
*/
var metadata_1 = require('./di/metadata');
exports.InjectMetadata = metadata_1.InjectMetadata;
exports.OptionalMetadata = metadata_1.OptionalMetadata;
exports.InjectableMetadata = metadata_1.InjectableMetadata;
exports.SelfMetadata = metadata_1.SelfMetadata;
exports.HostMetadata = metadata_1.HostMetadata;
exports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;
exports.DependencyMetadata = metadata_1.DependencyMetadata;
// we have to reexport * because Dart and TS export two different sets of types
__export(require('./di/decorators'));
var forward_ref_1 = require('./di/forward_ref');
exports.forwardRef = forward_ref_1.forwardRef;
exports.resolveForwardRef = forward_ref_1.resolveForwardRef;
var injector_1 = require('./di/injector');
exports.Injector = injector_1.Injector;
var reflective_injector_1 = require('./di/reflective_injector');
exports.ReflectiveInjector = reflective_injector_1.ReflectiveInjector;
var provider_1 = require('./di/provider');
exports.Binding = provider_1.Binding;
exports.ProviderBuilder = provider_1.ProviderBuilder;
exports.bind = provider_1.bind;
exports.Provider = provider_1.Provider;
exports.provide = provider_1.provide;
var reflective_provider_1 = require('./di/reflective_provider');
exports.ResolvedReflectiveFactory = reflective_provider_1.ResolvedReflectiveFactory;
exports.ReflectiveDependency = reflective_provider_1.ReflectiveDependency;
var reflective_key_1 = require('./di/reflective_key');
exports.ReflectiveKey = reflective_key_1.ReflectiveKey;
var reflective_exceptions_1 = require('./di/reflective_exceptions');
exports.NoProviderError = reflective_exceptions_1.NoProviderError;
exports.AbstractProviderError = reflective_exceptions_1.AbstractProviderError;
exports.CyclicDependencyError = reflective_exceptions_1.CyclicDependencyError;
exports.InstantiationError = reflective_exceptions_1.InstantiationError;
exports.InvalidProviderError = reflective_exceptions_1.InvalidProviderError;
exports.NoAnnotationError = reflective_exceptions_1.NoAnnotationError;
exports.OutOfBoundsError = reflective_exceptions_1.OutOfBoundsError;
var opaque_token_1 = require('./di/opaque_token');
exports.OpaqueToken = opaque_token_1.OpaqueToken;

},{"./di/decorators":158,"./di/forward_ref":159,"./di/injector":160,"./di/metadata":161,"./di/opaque_token":162,"./di/provider":163,"./di/reflective_exceptions":165,"./di/reflective_injector":166,"./di/reflective_key":167,"./di/reflective_provider":168}],158:[function(require,module,exports){
"use strict";
var metadata_1 = require('./metadata');
var decorators_1 = require('../util/decorators');
/**
 * Factory for creating {@link InjectMetadata}.
 */
exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);
/**
 * Factory for creating {@link OptionalMetadata}.
 */
exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
/**
 * Factory for creating {@link InjectableMetadata}.
 */
exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
/**
 * Factory for creating {@link SelfMetadata}.
 */
exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
/**
 * Factory for creating {@link HostMetadata}.
 */
exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
/**
 * Factory for creating {@link SkipSelfMetadata}.
 */
exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);

},{"../util/decorators":211,"./metadata":161}],159:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared,
 * but not yet defined. It is also used when the `token` which we use when creating a query is not
 * yet defined.
 *
 * ### Example
 * {@example core/di/ts/forward_ref/forward_ref.ts region='forward_ref'}
 */
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () { return lang_1.stringify(this()); };
    return forwardRefFn;
}
exports.forwardRef = forwardRef;
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
 *
 * ```typescript
 * var ref = forwardRef(() => "refValue");
 * expect(resolveForwardRef(ref)).toEqual("refValue");
 * expect(resolveForwardRef("regularValue")).toEqual("regularValue");
 * ```
 *
 * See: {@link forwardRef}
 */
function resolveForwardRef(type) {
    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') &&
        type.__forward_ref__ === forwardRef) {
        return type();
    }
    else {
        return type;
    }
}
exports.resolveForwardRef = resolveForwardRef;

},{"../../src/facade/lang":174}],160:[function(require,module,exports){
"use strict";
var exceptions_1 = require('../../src/facade/exceptions');
var _THROW_IF_NOT_FOUND = new Object();
exports.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
var Injector = (function () {
    function Injector() {
    }
    /**
     * Retrieves an instance from the injector based on the provided token.
     * If not found:
     * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
     * Injector.THROW_IF_NOT_FOUND is given
     * - Returns the `notFoundValue` otherwise
     *
     * ### Example ([live demo](http://plnkr.co/edit/HeXSHg?p=preview))
     *
     * ```typescript
     * var injector = ReflectiveInjector.resolveAndCreate([
     *   provide("validToken", {useValue: "Value"})
     * ]);
     * expect(injector.get("validToken")).toEqual("Value");
     * expect(() => injector.get("invalidToken")).toThrowError();
     * ```
     *
     * `Injector` returns itself when given `Injector` as a token.
     *
     * ```typescript
     * var injector = ReflectiveInjector.resolveAndCreate([]);
     * expect(injector.get(Injector)).toBe(injector);
     * ```
     */
    Injector.prototype.get = function (token, notFoundValue) { return exceptions_1.unimplemented(); };
    Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    return Injector;
}());
exports.Injector = Injector;

},{"../../src/facade/exceptions":173}],161:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
/**
 * A parameter metadata that specifies a dependency.
 *
 * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Inject("MyEngine") engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([
 *  provide("MyEngine", {useClass: Engine}),
 *  Car
 * ]);
 *
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 *
 * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.
 *
 * ### Example
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)
 * }
 *
 * var injector = Injector.resolveAndCreate([Engine, Car]);
 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
 * ```
 * @ts2dart_const
 */
var InjectMetadata = (function () {
    function InjectMetadata(token) {
        this.token = token;
    }
    InjectMetadata.prototype.toString = function () { return "@Inject(" + lang_1.stringify(this.token) + ")"; };
    return InjectMetadata;
}());
exports.InjectMetadata = InjectMetadata;
/**
 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
 * the dependency is not found.
 *
 * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))
 *
 * ```typescript
 * class Engine {}
 *
 * @Injectable()
 * class Car {
 *   engine;
 *   constructor(@Optional() engine:Engine) {
 *     this.engine = engine;
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([Car]);
 * expect(injector.get(Car).engine).toBeNull();
 * ```
 * @ts2dart_const
 */
var OptionalMetadata = (function () {
    function OptionalMetadata() {
    }
    OptionalMetadata.prototype.toString = function () { return "@Optional()"; };
    return OptionalMetadata;
}());
exports.OptionalMetadata = OptionalMetadata;
/**
 * `DependencyMetadata` is used by the framework to extend DI.
 * This is internal to Angular and should not be used directly.
 * @ts2dart_const
 */
var DependencyMetadata = (function () {
    function DependencyMetadata() {
    }
    Object.defineProperty(DependencyMetadata.prototype, "token", {
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return DependencyMetadata;
}());
exports.DependencyMetadata = DependencyMetadata;
/**
 * A marker metadata that marks a class as available to {@link Injector} for creation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))
 *
 * ```typescript
 * @Injectable()
 * class UsefulService {}
 *
 * @Injectable()
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
 * ```
 * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
 * does not have `@Injectable` marker, as shown in the example below.
 *
 * ```typescript
 * class UsefulService {}
 *
 * class NeedsService {
 *   constructor(public service:UsefulService) {}
 * }
 *
 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
 * expect(() => injector.get(NeedsService)).toThrowError();
 * ```
 * @ts2dart_const
 */
var InjectableMetadata = (function () {
    function InjectableMetadata() {
    }
    return InjectableMetadata;
}());
exports.InjectableMetadata = InjectableMetadata;
/**
 * Specifies that an {@link Injector} should retrieve a dependency only from itself.
 *
 * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;
 *   constructor(@Self() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * var nd = inj.get(NeedsDependency);
 *
 * expect(nd.dependency instanceof Dependency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency]);
 * var child = inj.resolveAndCreateChild([NeedsDependency]);
 * expect(() => child.get(NeedsDependency)).toThrowError();
 * ```
 * @ts2dart_const
 */
var SelfMetadata = (function () {
    function SelfMetadata() {
    }
    SelfMetadata.prototype.toString = function () { return "@Self()"; };
    return SelfMetadata;
}());
exports.SelfMetadata = SelfMetadata;
/**
 * Specifies that the dependency resolution should start from the parent injector.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))
 *
 * ```typescript
 * class Dependency {
 * }
 *
 * @Injectable()
 * class NeedsDependency {
 *   dependency;
 *   constructor(@SkipSelf() dependency:Dependency) {
 *     this.dependency = dependency;
 *   }
 * }
 *
 * var parent = Injector.resolveAndCreate([Dependency]);
 * var child = parent.resolveAndCreateChild([NeedsDependency]);
 * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);
 *
 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
 * expect(() => inj.get(NeedsDependency)).toThrowError();
 * ```
 * @ts2dart_const
 */
var SkipSelfMetadata = (function () {
    function SkipSelfMetadata() {
    }
    SkipSelfMetadata.prototype.toString = function () { return "@SkipSelf()"; };
    return SkipSelfMetadata;
}());
exports.SkipSelfMetadata = SkipSelfMetadata;
/**
 * Specifies that an injector should retrieve a dependency from any injector until reaching the
 * closest host.
 *
 * In Angular, a component element is automatically declared as a host for all the injectors in
 * its view.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))
 *
 * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.
 * So `ParentCmp` is the host of `ChildDirective`.
 *
 * `ChildDirective` depends on two services: `HostService` and `OtherService`.
 * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.
 *
 *```typescript
 * class OtherService {}
 * class HostService {}
 *
 * @Directive({
 *   selector: 'child-directive'
 * })
 * class ChildDirective {
 *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){
 *     console.log("os is null", os);
 *     console.log("hs is NOT null", hs);
 *   }
 * }
 *
 * @Component({
 *   selector: 'parent-cmp',
 *   providers: [HostService],
 *   template: `
 *     Dir: <child-directive></child-directive>
 *   `,
 *   directives: [ChildDirective]
 * })
 * class ParentCmp {
 * }
 *
 * @Component({
 *   selector: 'app',
 *   providers: [OtherService],
 *   template: `
 *     Parent: <parent-cmp></parent-cmp>
 *   `,
 *   directives: [ParentCmp]
 * })
 * class App {
 * }
 *
 * bootstrap(App);
 *```
 * @ts2dart_const
 */
var HostMetadata = (function () {
    function HostMetadata() {
    }
    HostMetadata.prototype.toString = function () { return "@Host()"; };
    return HostMetadata;
}());
exports.HostMetadata = HostMetadata;

},{"../../src/facade/lang":174}],162:[function(require,module,exports){
"use strict";
/**
* Creates a token that can be used in a DI Provider.
*
* ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
*
* ```typescript
* var t = new OpaqueToken("value");
*
* var injector = Injector.resolveAndCreate([
*   provide(t, {useValue: "bindingValue"})
* ]);
*
* expect(injector.get(t)).toEqual("bindingValue");
* ```
*
* Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
* caused by multiple providers using the same string as two different tokens.
*
* Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
* error messages.
* @ts2dart_const
*/
var OpaqueToken = (function () {
    function OpaqueToken(_desc) {
        this._desc = _desc;
    }
    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
    return OpaqueToken;
}());
exports.OpaqueToken = OpaqueToken;

},{}],163:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
/**
 * Describes how the {@link Injector} should instantiate a given token.
 *
 * See {@link provide}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))
 *
 * ```javascript
 * var injector = Injector.resolveAndCreate([
 *   new Provider("message", { useValue: 'Hello' })
 * ]);
 *
 * expect(injector.get("message")).toEqual('Hello');
 * ```
 * @ts2dart_const
 */
var Provider = (function () {
    function Provider(token, _a) {
        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
        this.token = token;
        this.useClass = useClass;
        this.useValue = useValue;
        this.useExisting = useExisting;
        this.useFactory = useFactory;
        this.dependencies = deps;
        this._multi = multi;
    }
    Object.defineProperty(Provider.prototype, "multi", {
        // TODO: Provide a full working example after alpha38 is released.
        /**
         * Creates multiple providers matching the same token (a multi-provider).
         *
         * Multi-providers are used for creating pluggable service, where the system comes
         * with some default providers, and the user can register additional providers.
         * The combination of the default providers and the additional providers will be
         * used to drive the behavior of the system.
         *
         * ### Example
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true}),
         *   new Provider("Strings", { useValue: "String2", multi: true})
         * ]);
         *
         * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
         * ```
         *
         * Multi-providers and regular providers cannot be mixed. The following
         * will throw an exception:
         *
         * ```typescript
         * var injector = Injector.resolveAndCreate([
         *   new Provider("Strings", { useValue: "String1", multi: true }),
         *   new Provider("Strings", { useValue: "String2"})
         * ]);
         * ```
         */
        get: function () { return lang_1.normalizeBool(this._multi); },
        enumerable: true,
        configurable: true
    });
    return Provider;
}());
exports.Provider = Provider;
/**
 * See {@link Provider} instead.
 *
 * @deprecated
 * @ts2dart_const
 */
var Binding = (function (_super) {
    __extends(Binding, _super);
    function Binding(token, _a) {
        var toClass = _a.toClass, toValue = _a.toValue, toAlias = _a.toAlias, toFactory = _a.toFactory, deps = _a.deps, multi = _a.multi;
        _super.call(this, token, {
            useClass: toClass,
            useValue: toValue,
            useExisting: toAlias,
            useFactory: toFactory,
            deps: deps,
            multi: multi
        });
    }
    Object.defineProperty(Binding.prototype, "toClass", {
        /**
         * @deprecated
         */
        get: function () { return this.useClass; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toAlias", {
        /**
         * @deprecated
         */
        get: function () { return this.useExisting; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toFactory", {
        /**
         * @deprecated
         */
        get: function () { return this.useFactory; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "toValue", {
        /**
         * @deprecated
         */
        get: function () { return this.useValue; },
        enumerable: true,
        configurable: true
    });
    return Binding;
}(Provider));
exports.Binding = Binding;
/**
 * Creates a {@link Provider}.
 *
 * To construct a {@link Provider}, bind a `token` to either a class, a value, a factory function,
 * or
 * to an existing `token`.
 * See {@link ProviderBuilder} for more details.
 *
 * The `token` is most commonly a class or {@link OpaqueToken-class.html}.
 *
 * @deprecated
 */
function bind(token) {
    return new ProviderBuilder(token);
}
exports.bind = bind;
/**
 * Helper class for the {@link bind} function.
 */
var ProviderBuilder = (function () {
    function ProviderBuilder(token) {
        this.token = token;
    }
    /**
     * Binds a DI token to a class.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview))
     *
     * Because `toAlias` and `toClass` are often confused, the example contains
     * both use cases for easy comparison.
     *
     * ```typescript
     * class Vehicle {}
     *
     * class Car extends Vehicle {}
     *
     * var injectorClass = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useClass: Car})
     * ]);
     * var injectorAlias = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useExisting: Car})
     * ]);
     *
     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
     *
     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
     * ```
     */
    ProviderBuilder.prototype.toClass = function (type) {
        if (!lang_1.isType(type)) {
            throw new exceptions_1.BaseException("Trying to create a class provider but \"" + lang_1.stringify(type) + "\" is not a class!");
        }
        return new Provider(this.token, { useClass: type });
    };
    /**
     * Binds a DI token to a value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide('message', {useValue: 'Hello'})
     * ]);
     *
     * expect(injector.get('message')).toEqual('Hello');
     * ```
     */
    ProviderBuilder.prototype.toValue = function (value) { return new Provider(this.token, { useValue: value }); };
    /**
     * Binds a DI token to an existing token.
     *
     * Angular will return the same instance as if the provided token was used. (This is
     * in contrast to `useClass` where a separate instance of `useClass` will be returned.)
     *
     * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview))
     *
     * Because `toAlias` and `toClass` are often confused, the example contains
     * both use cases for easy comparison.
     *
     * ```typescript
     * class Vehicle {}
     *
     * class Car extends Vehicle {}
     *
     * var injectorAlias = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useExisting: Car})
     * ]);
     * var injectorClass = Injector.resolveAndCreate([
     *   Car,
     *   provide(Vehicle, {useClass: Car})
     * ]);
     *
     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
     *
     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
     * ```
     */
    ProviderBuilder.prototype.toAlias = function (aliasToken) {
        if (lang_1.isBlank(aliasToken)) {
            throw new exceptions_1.BaseException("Can not alias " + lang_1.stringify(this.token) + " to a blank value!");
        }
        return new Provider(this.token, { useExisting: aliasToken });
    };
    /**
     * Binds a DI token to a function which computes the value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   provide(Number, {useFactory: () => { return 1+2; }}),
     *   provide(String, {useFactory: (v) => { return "Value: " + v; }, deps: [Number]})
     * ]);
     *
     * expect(injector.get(Number)).toEqual(3);
     * expect(injector.get(String)).toEqual('Value: 3');
     * ```
     */
    ProviderBuilder.prototype.toFactory = function (factory, dependencies) {
        if (!lang_1.isFunction(factory)) {
            throw new exceptions_1.BaseException("Trying to create a factory provider but \"" + lang_1.stringify(factory) + "\" is not a function!");
        }
        return new Provider(this.token, { useFactory: factory, deps: dependencies });
    };
    return ProviderBuilder;
}());
exports.ProviderBuilder = ProviderBuilder;
/**
 * Creates a {@link Provider}.
 *
 * See {@link Provider} for more details.
 *
 * <!-- TODO: improve the docs -->
 */
function provide(token, _a) {
    var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
    return new Provider(token, {
        useClass: useClass,
        useValue: useValue,
        useExisting: useExisting,
        useFactory: useFactory,
        deps: deps,
        multi: multi
    });
}
exports.provide = provide;

},{"../../src/facade/exceptions":173,"../../src/facade/lang":174}],164:[function(require,module,exports){
"use strict";
var provider_1 = require('./provider');
function isProviderLiteral(obj) {
    return obj && typeof obj == 'object' && obj.provide;
}
exports.isProviderLiteral = isProviderLiteral;
function createProvider(obj) {
    return new provider_1.Provider(obj.provide, obj);
}
exports.createProvider = createProvider;

},{"./provider":163}],165:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
        if (collection_1.ListWrapper.contains(res, keys[i])) {
            res.push(keys[i]);
            return res;
        }
        else {
            res.push(keys[i]);
        }
    }
    return res;
}
function constructResolvingPath(keys) {
    if (keys.length > 1) {
        var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));
        var tokenStrs = reversed.map(function (k) { return lang_1.stringify(k.token); });
        return " (" + tokenStrs.join(' -> ') + ")";
    }
    else {
        return "";
    }
}
/**
 * Base class for all errors arising from misconfigured providers.
 */
var AbstractProviderError = (function (_super) {
    __extends(AbstractProviderError, _super);
    function AbstractProviderError(injector, key, constructResolvingMessage) {
        _super.call(this, "DI Exception");
        this.keys = [key];
        this.injectors = [injector];
        this.constructResolvingMessage = constructResolvingMessage;
        this.message = this.constructResolvingMessage(this.keys);
    }
    AbstractProviderError.prototype.addKey = function (injector, key) {
        this.injectors.push(injector);
        this.keys.push(key);
        this.message = this.constructResolvingMessage(this.keys);
    };
    Object.defineProperty(AbstractProviderError.prototype, "context", {
        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
        enumerable: true,
        configurable: true
    });
    return AbstractProviderError;
}(exceptions_1.BaseException));
exports.AbstractProviderError = AbstractProviderError;
/**
 * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
 * {@link Injector} does not have a {@link Provider} for {@link Key}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor(b:B) {}
 * }
 *
 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
 * ```
 */
var NoProviderError = (function (_super) {
    __extends(NoProviderError, _super);
    function NoProviderError(injector, key) {
        _super.call(this, injector, key, function (keys) {
            var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);
            return "No provider for " + first + "!" + constructResolvingPath(keys);
        });
    }
    return NoProviderError;
}(AbstractProviderError));
exports.NoProviderError = NoProviderError;
/**
 * Thrown when dependencies form a cycle.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
 *
 * ```typescript
 * var injector = Injector.resolveAndCreate([
 *   provide("one", {useFactory: (two) => "two", deps: [[new Inject("two")]]}),
 *   provide("two", {useFactory: (one) => "one", deps: [[new Inject("one")]]})
 * ]);
 *
 * expect(() => injector.get("one")).toThrowError();
 * ```
 *
 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
 */
var CyclicDependencyError = (function (_super) {
    __extends(CyclicDependencyError, _super);
    function CyclicDependencyError(injector, key) {
        _super.call(this, injector, key, function (keys) {
            return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
        });
    }
    return CyclicDependencyError;
}(AbstractProviderError));
exports.CyclicDependencyError = CyclicDependencyError;
/**
 * Thrown when a constructing type returns with an Error.
 *
 * The `InstantiationError` class contains the original error plus the dependency graph which caused
 * this object to be instantiated.
 *
 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor() {
 *     throw new Error('message');
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([A]);

 * try {
 *   injector.get(A);
 * } catch (e) {
 *   expect(e instanceof InstantiationError).toBe(true);
 *   expect(e.originalException.message).toEqual("message");
 *   expect(e.originalStack).toBeDefined();
 * }
 * ```
 */
var InstantiationError = (function (_super) {
    __extends(InstantiationError, _super);
    function InstantiationError(injector, originalException, originalStack, key) {
        _super.call(this, "DI Exception", originalException, originalStack, null);
        this.keys = [key];
        this.injectors = [injector];
    }
    InstantiationError.prototype.addKey = function (injector, key) {
        this.injectors.push(injector);
        this.keys.push(key);
    };
    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
        get: function () {
            var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);
            return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "causeKey", {
        get: function () { return this.keys[0]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstantiationError.prototype, "context", {
        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
        enumerable: true,
        configurable: true
    });
    return InstantiationError;
}(exceptions_1.WrappedException));
exports.InstantiationError = InstantiationError;
/**
 * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
 * creation.
 *
 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
 *
 * ```typescript
 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
 * ```
 */
var InvalidProviderError = (function (_super) {
    __extends(InvalidProviderError, _super);
    function InvalidProviderError(provider) {
        _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " +
            provider.toString());
    }
    return InvalidProviderError;
}(exceptions_1.BaseException));
exports.InvalidProviderError = InvalidProviderError;
/**
 * Thrown when the class has no annotation information.
 *
 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
 * need to be injected into the constructor.
 *
 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
 *
 * ```typescript
 * class A {
 *   constructor(b) {}
 * }
 *
 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
 * ```
 *
 * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
 *
 * ```typescript
 * class B {}
 *
 * class A {
 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
 * }
 *
 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
 * ```
 */
var NoAnnotationError = (function (_super) {
    __extends(NoAnnotationError, _super);
    function NoAnnotationError(typeOrFunc, params) {
        _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
    }
    NoAnnotationError._genMessage = function (typeOrFunc, params) {
        var signature = [];
        for (var i = 0, ii = params.length; i < ii; i++) {
            var parameter = params[i];
            if (lang_1.isBlank(parameter) || parameter.length == 0) {
                signature.push('?');
            }
            else {
                signature.push(parameter.map(lang_1.stringify).join(' '));
            }
        }
        return "Cannot resolve all parameters for '" + lang_1.stringify(typeOrFunc) + "'(" +
            signature.join(', ') + "). " +
            "Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" +
            lang_1.stringify(typeOrFunc) + "' is decorated with Injectable.";
    };
    return NoAnnotationError;
}(exceptions_1.BaseException));
exports.NoAnnotationError = NoAnnotationError;
/**
 * Thrown when getting an object by index.
 *
 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
 *
 * ```typescript
 * class A {}
 *
 * var injector = Injector.resolveAndCreate([A]);
 *
 * expect(() => injector.getAt(100)).toThrowError();
 * ```
 */
var OutOfBoundsError = (function (_super) {
    __extends(OutOfBoundsError, _super);
    function OutOfBoundsError(index) {
        _super.call(this, "Index " + index + " is out-of-bounds.");
    }
    return OutOfBoundsError;
}(exceptions_1.BaseException));
exports.OutOfBoundsError = OutOfBoundsError;
// TODO: add a working example after alpha38 is released
/**
 * Thrown when a multi provider and a regular provider are bound to the same token.
 *
 * ### Example
 *
 * ```typescript
 * expect(() => Injector.resolveAndCreate([
 *   new Provider("Strings", {useValue: "string1", multi: true}),
 *   new Provider("Strings", {useValue: "string2", multi: false})
 * ])).toThrowError();
 * ```
 */
var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
    __extends(MixingMultiProvidersWithRegularProvidersError, _super);
    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
        _super.call(this, "Cannot mix multi providers and regular providers, got: " + provider1.toString() + " " +
            provider2.toString());
    }
    return MixingMultiProvidersWithRegularProvidersError;
}(exceptions_1.BaseException));
exports.MixingMultiProvidersWithRegularProvidersError = MixingMultiProvidersWithRegularProvidersError;

},{"../../src/facade/collection":171,"../../src/facade/exceptions":173,"../../src/facade/lang":174}],166:[function(require,module,exports){
"use strict";
var collection_1 = require('../../src/facade/collection');
var reflective_provider_1 = require('./reflective_provider');
var reflective_exceptions_1 = require('./reflective_exceptions');
var exceptions_1 = require('../../src/facade/exceptions');
var reflective_key_1 = require('./reflective_key');
var metadata_1 = require('./metadata');
var injector_1 = require('./injector');
var __unused; // avoid unused import when Type union types are erased
// Threshold for the dynamic version
var _MAX_CONSTRUCTION_COUNTER = 10;
var UNDEFINED = new Object();
var ReflectiveProtoInjectorInlineStrategy = (function () {
    function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
        this.provider0 = null;
        this.provider1 = null;
        this.provider2 = null;
        this.provider3 = null;
        this.provider4 = null;
        this.provider5 = null;
        this.provider6 = null;
        this.provider7 = null;
        this.provider8 = null;
        this.provider9 = null;
        this.keyId0 = null;
        this.keyId1 = null;
        this.keyId2 = null;
        this.keyId3 = null;
        this.keyId4 = null;
        this.keyId5 = null;
        this.keyId6 = null;
        this.keyId7 = null;
        this.keyId8 = null;
        this.keyId9 = null;
        var length = providers.length;
        if (length > 0) {
            this.provider0 = providers[0];
            this.keyId0 = providers[0].key.id;
        }
        if (length > 1) {
            this.provider1 = providers[1];
            this.keyId1 = providers[1].key.id;
        }
        if (length > 2) {
            this.provider2 = providers[2];
            this.keyId2 = providers[2].key.id;
        }
        if (length > 3) {
            this.provider3 = providers[3];
            this.keyId3 = providers[3].key.id;
        }
        if (length > 4) {
            this.provider4 = providers[4];
            this.keyId4 = providers[4].key.id;
        }
        if (length > 5) {
            this.provider5 = providers[5];
            this.keyId5 = providers[5].key.id;
        }
        if (length > 6) {
            this.provider6 = providers[6];
            this.keyId6 = providers[6].key.id;
        }
        if (length > 7) {
            this.provider7 = providers[7];
            this.keyId7 = providers[7].key.id;
        }
        if (length > 8) {
            this.provider8 = providers[8];
            this.keyId8 = providers[8].key.id;
        }
        if (length > 9) {
            this.provider9 = providers[9];
            this.keyId9 = providers[9].key.id;
        }
    }
    ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
        if (index == 0)
            return this.provider0;
        if (index == 1)
            return this.provider1;
        if (index == 2)
            return this.provider2;
        if (index == 3)
            return this.provider3;
        if (index == 4)
            return this.provider4;
        if (index == 5)
            return this.provider5;
        if (index == 6)
            return this.provider6;
        if (index == 7)
            return this.provider7;
        if (index == 8)
            return this.provider8;
        if (index == 9)
            return this.provider9;
        throw new reflective_exceptions_1.OutOfBoundsError(index);
    };
    ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
        return new ReflectiveInjectorInlineStrategy(injector, this);
    };
    return ReflectiveProtoInjectorInlineStrategy;
}());
exports.ReflectiveProtoInjectorInlineStrategy = ReflectiveProtoInjectorInlineStrategy;
var ReflectiveProtoInjectorDynamicStrategy = (function () {
    function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
        this.providers = providers;
        var len = providers.length;
        this.keyIds = collection_1.ListWrapper.createFixedSize(len);
        for (var i = 0; i < len; i++) {
            this.keyIds[i] = providers[i].key.id;
        }
    }
    ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
        if (index < 0 || index >= this.providers.length) {
            throw new reflective_exceptions_1.OutOfBoundsError(index);
        }
        return this.providers[index];
    };
    ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
        return new ReflectiveInjectorDynamicStrategy(this, ei);
    };
    return ReflectiveProtoInjectorDynamicStrategy;
}());
exports.ReflectiveProtoInjectorDynamicStrategy = ReflectiveProtoInjectorDynamicStrategy;
var ReflectiveProtoInjector = (function () {
    function ReflectiveProtoInjector(providers) {
        this.numberOfProviders = providers.length;
        this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
            new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
            new ReflectiveProtoInjectorInlineStrategy(this, providers);
    }
    ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
        return new ReflectiveProtoInjector(providers);
    };
    ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
        return this._strategy.getProviderAtIndex(index);
    };
    return ReflectiveProtoInjector;
}());
exports.ReflectiveProtoInjector = ReflectiveProtoInjector;
var ReflectiveInjectorInlineStrategy = (function () {
    function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
        this.injector = injector;
        this.protoStrategy = protoStrategy;
        this.obj0 = UNDEFINED;
        this.obj1 = UNDEFINED;
        this.obj2 = UNDEFINED;
        this.obj3 = UNDEFINED;
        this.obj4 = UNDEFINED;
        this.obj5 = UNDEFINED;
        this.obj6 = UNDEFINED;
        this.obj7 = UNDEFINED;
        this.obj8 = UNDEFINED;
        this.obj9 = UNDEFINED;
    }
    ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
    ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
        return this.injector._new(provider);
    };
    ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
        var p = this.protoStrategy;
        var inj = this.injector;
        if (p.keyId0 === keyId) {
            if (this.obj0 === UNDEFINED) {
                this.obj0 = inj._new(p.provider0);
            }
            return this.obj0;
        }
        if (p.keyId1 === keyId) {
            if (this.obj1 === UNDEFINED) {
                this.obj1 = inj._new(p.provider1);
            }
            return this.obj1;
        }
        if (p.keyId2 === keyId) {
            if (this.obj2 === UNDEFINED) {
                this.obj2 = inj._new(p.provider2);
            }
            return this.obj2;
        }
        if (p.keyId3 === keyId) {
            if (this.obj3 === UNDEFINED) {
                this.obj3 = inj._new(p.provider3);
            }
            return this.obj3;
        }
        if (p.keyId4 === keyId) {
            if (this.obj4 === UNDEFINED) {
                this.obj4 = inj._new(p.provider4);
            }
            return this.obj4;
        }
        if (p.keyId5 === keyId) {
            if (this.obj5 === UNDEFINED) {
                this.obj5 = inj._new(p.provider5);
            }
            return this.obj5;
        }
        if (p.keyId6 === keyId) {
            if (this.obj6 === UNDEFINED) {
                this.obj6 = inj._new(p.provider6);
            }
            return this.obj6;
        }
        if (p.keyId7 === keyId) {
            if (this.obj7 === UNDEFINED) {
                this.obj7 = inj._new(p.provider7);
            }
            return this.obj7;
        }
        if (p.keyId8 === keyId) {
            if (this.obj8 === UNDEFINED) {
                this.obj8 = inj._new(p.provider8);
            }
            return this.obj8;
        }
        if (p.keyId9 === keyId) {
            if (this.obj9 === UNDEFINED) {
                this.obj9 = inj._new(p.provider9);
            }
            return this.obj9;
        }
        return UNDEFINED;
    };
    ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
        if (index == 0)
            return this.obj0;
        if (index == 1)
            return this.obj1;
        if (index == 2)
            return this.obj2;
        if (index == 3)
            return this.obj3;
        if (index == 4)
            return this.obj4;
        if (index == 5)
            return this.obj5;
        if (index == 6)
            return this.obj6;
        if (index == 7)
            return this.obj7;
        if (index == 8)
            return this.obj8;
        if (index == 9)
            return this.obj9;
        throw new reflective_exceptions_1.OutOfBoundsError(index);
    };
    ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
    return ReflectiveInjectorInlineStrategy;
}());
exports.ReflectiveInjectorInlineStrategy = ReflectiveInjectorInlineStrategy;
var ReflectiveInjectorDynamicStrategy = (function () {
    function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
        this.protoStrategy = protoStrategy;
        this.injector = injector;
        this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.providers.length);
        collection_1.ListWrapper.fill(this.objs, UNDEFINED);
    }
    ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
    ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
        return this.injector._new(provider);
    };
    ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
        var p = this.protoStrategy;
        for (var i = 0; i < p.keyIds.length; i++) {
            if (p.keyIds[i] === keyId) {
                if (this.objs[i] === UNDEFINED) {
                    this.objs[i] = this.injector._new(p.providers[i]);
                }
                return this.objs[i];
            }
        }
        return UNDEFINED;
    };
    ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
        if (index < 0 || index >= this.objs.length) {
            throw new reflective_exceptions_1.OutOfBoundsError(index);
        }
        return this.objs[index];
    };
    ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
    return ReflectiveInjectorDynamicStrategy;
}());
exports.ReflectiveInjectorDynamicStrategy = ReflectiveInjectorDynamicStrategy;
/**
 * A ReflectiveDependency injection container used for instantiating objects and resolving
 * dependencies.
 *
 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
 * constructor dependencies.
 *
 * In typical use, application code asks for the dependencies in the constructor and they are
 * resolved by the `Injector`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
 *
 * The following example creates an `Injector` configured to create `Engine` and `Car`.
 *
 * ```typescript
 * @Injectable()
 * class Engine {
 * }
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine:Engine) {}
 * }
 *
 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
 * var car = injector.get(Car);
 * expect(car instanceof Car).toBe(true);
 * expect(car.engine instanceof Engine).toBe(true);
 * ```
 *
 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
 * resolve all of the object's dependencies automatically.
 */
var ReflectiveInjector = (function () {
    function ReflectiveInjector() {
    }
    /**
     * Turns an array of provider definitions into an array of resolved providers.
     *
     * A resolution is a process of flattening multiple nested arrays and converting individual
     * providers into an array of {@link ResolvedReflectiveProvider}s.
     *
     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
     *
     * expect(providers.length).toEqual(2);
     *
     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
     * expect(providers[0].key.displayName).toBe("Car");
     * expect(providers[0].dependencies.length).toEqual(1);
     * expect(providers[0].factory).toBeDefined();
     *
     * expect(providers[1].key.displayName).toBe("Engine");
     * });
     * ```
     *
     * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
     */
    ReflectiveInjector.resolve = function (providers) {
        return reflective_provider_1.resolveReflectiveProviders(providers);
    };
    /**
     * Resolves an array of providers and creates an injector from those providers.
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     *
     * This function is slower than the corresponding `fromResolvedProviders`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
     */
    ReflectiveInjector.resolveAndCreate = function (providers, parent) {
        if (parent === void 0) { parent = null; }
        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
    };
    /**
     * Creates an injector from previously resolved providers.
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = ReflectiveInjector.resolve([Car, Engine]);
     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     */
    ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
        if (parent === void 0) { parent = null; }
        return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
    };
    /**
     * @deprecated
     */
    ReflectiveInjector.fromResolvedBindings = function (providers) {
        return ReflectiveInjector.fromResolvedProviders(providers);
    };
    Object.defineProperty(ReflectiveInjector.prototype, "parent", {
        /**
         * Parent of this injector.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
         *
         * ```typescript
         * var parent = ReflectiveInjector.resolveAndCreate([]);
         * var child = parent.resolveAndCreateChild([]);
         * expect(child.parent).toBe(parent);
         * ```
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    ReflectiveInjector.prototype.debugContext = function () { return null; };
    /**
     * Resolves an array of providers and creates a child injector from those providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
     * var child = parent.resolveAndCreateChild([ChildProvider]);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     *
     * This function is slower than the corresponding `createChildFromResolved`
     * because it needs to resolve the passed-in providers first.
     * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
     */
    ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) {
        return exceptions_1.unimplemented();
    };
    /**
     * Creates a child injector from previously resolved providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
     *
     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
     * var child = parent.createChildFromResolved(childProviders);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     */
    ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
        return exceptions_1.unimplemented();
    };
    /**
     * Resolves a provider and instantiates an object in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
     *
     * var car = injector.resolveAndInstantiate(Car);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
     * ```
     */
    ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return exceptions_1.unimplemented(); };
    /**
     * Instantiates an object using a resolved provider in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
     * var carProvider = ReflectiveInjector.resolve([Car])[0];
     * var car = injector.instantiateResolved(carProvider);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
     * ```
     */
    ReflectiveInjector.prototype.instantiateResolved = function (provider) { return exceptions_1.unimplemented(); };
    return ReflectiveInjector;
}());
exports.ReflectiveInjector = ReflectiveInjector;
var ReflectiveInjector_ = (function () {
    /**
     * Private
     */
    function ReflectiveInjector_(_proto /* ProtoInjector */, _parent, _debugContext) {
        if (_parent === void 0) { _parent = null; }
        if (_debugContext === void 0) { _debugContext = null; }
        this._debugContext = _debugContext;
        /** @internal */
        this._constructionCounter = 0;
        this._proto = _proto;
        this._parent = _parent;
        this._strategy = _proto._strategy.createInjectorStrategy(this);
    }
    /**
     * @internal
     */
    ReflectiveInjector_.prototype.debugContext = function () { return this._debugContext(); };
    ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = injector_1.THROW_IF_NOT_FOUND; }
        return this._getByKey(reflective_key_1.ReflectiveKey.get(token), null, null, notFoundValue);
    };
    ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
        /**
         * @internal
         * Internal. Do not use.
         * We return `any` not to export the InjectorStrategy type.
         */
        get: function () { return this._strategy; },
        enumerable: true,
        configurable: true
    });
    ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
        var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
        return this.createChildFromResolved(ResolvedReflectiveProviders);
    };
    ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
        var proto = new ReflectiveProtoInjector(providers);
        var inj = new ReflectiveInjector_(proto);
        inj._parent = this;
        return inj;
    };
    ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
    };
    ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
        return this._instantiateProvider(provider);
    };
    /** @internal */
    ReflectiveInjector_.prototype._new = function (provider) {
        if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
            throw new reflective_exceptions_1.CyclicDependencyError(this, provider.key);
        }
        return this._instantiateProvider(provider);
    };
    ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
        if (provider.multiProvider) {
            var res = collection_1.ListWrapper.createFixedSize(provider.resolvedFactories.length);
            for (var i = 0; i < provider.resolvedFactories.length; ++i) {
                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
            }
            return res;
        }
        else {
            return this._instantiate(provider, provider.resolvedFactories[0]);
        }
    };
    ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
        var factory = ResolvedReflectiveFactory.factory;
        var deps = ResolvedReflectiveFactory.dependencies;
        var length = deps.length;
        var d0;
        var d1;
        var d2;
        var d3;
        var d4;
        var d5;
        var d6;
        var d7;
        var d8;
        var d9;
        var d10;
        var d11;
        var d12;
        var d13;
        var d14;
        var d15;
        var d16;
        var d17;
        var d18;
        var d19;
        try {
            d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
            d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
            d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
            d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
            d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
            d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
            d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
            d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
            d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
            d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
            d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
            d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
            d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
            d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
            d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
            d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
            d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
            d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
            d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
            d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
        }
        catch (e) {
            if (e instanceof reflective_exceptions_1.AbstractProviderError || e instanceof reflective_exceptions_1.InstantiationError) {
                e.addKey(this, provider.key);
            }
            throw e;
        }
        var obj;
        try {
            switch (length) {
                case 0:
                    obj = factory();
                    break;
                case 1:
                    obj = factory(d0);
                    break;
                case 2:
                    obj = factory(d0, d1);
                    break;
                case 3:
                    obj = factory(d0, d1, d2);
                    break;
                case 4:
                    obj = factory(d0, d1, d2, d3);
                    break;
                case 5:
                    obj = factory(d0, d1, d2, d3, d4);
                    break;
                case 6:
                    obj = factory(d0, d1, d2, d3, d4, d5);
                    break;
                case 7:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6);
                    break;
                case 8:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                    break;
                case 9:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                    break;
                case 10:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                    break;
                case 11:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                    break;
                case 12:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                    break;
                case 13:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                    break;
                case 14:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                    break;
                case 15:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                    break;
                case 16:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                    break;
                case 17:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                    break;
                case 18:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                    break;
                case 19:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                    break;
                case 20:
                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                    break;
                default:
                    throw new exceptions_1.BaseException("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
            }
        }
        catch (e) {
            throw new reflective_exceptions_1.InstantiationError(this, e, e.stack, provider.key);
        }
        return obj;
    };
    ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
        return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : injector_1.THROW_IF_NOT_FOUND);
    };
    ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
        if (key === INJECTOR_KEY) {
            return this;
        }
        if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {
            return this._getByKeySelf(key, notFoundValue);
        }
        else {
            return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
        }
    };
    /** @internal */
    ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
        if (notFoundValue !== injector_1.THROW_IF_NOT_FOUND) {
            return notFoundValue;
        }
        else {
            throw new reflective_exceptions_1.NoProviderError(this, key);
        }
    };
    /** @internal */
    ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
        var obj = this._strategy.getObjByKeyId(key.id);
        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
    };
    /** @internal */
    ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
        var inj;
        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
            inj = this._parent;
        }
        else {
            inj = this;
        }
        while (inj instanceof ReflectiveInjector_) {
            var inj_ = inj;
            var obj = inj_._strategy.getObjByKeyId(key.id);
            if (obj !== UNDEFINED)
                return obj;
            inj = inj_._parent;
        }
        if (inj !== null) {
            return inj.get(key.token, notFoundValue);
        }
        else {
            return this._throwOrNull(key, notFoundValue);
        }
    };
    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
        get: function () {
            return "ReflectiveInjector(providers: [" + _mapProviders(this, function (b) { return (" \"" + b.key.displayName + "\" "); }).join(", ") + "])";
        },
        enumerable: true,
        configurable: true
    });
    ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
    return ReflectiveInjector_;
}());
exports.ReflectiveInjector_ = ReflectiveInjector_;
var INJECTOR_KEY = reflective_key_1.ReflectiveKey.get(injector_1.Injector);
function _mapProviders(injector, fn) {
    var res = [];
    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
        res.push(fn(injector._proto.getProviderAtIndex(i)));
    }
    return res;
}

},{"../../src/facade/collection":171,"../../src/facade/exceptions":173,"./injector":160,"./metadata":161,"./reflective_exceptions":165,"./reflective_key":167,"./reflective_provider":168}],167:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var forward_ref_1 = require('./forward_ref');
/**
 * A unique object used for retrieving items from the {@link ReflectiveInjector}.
 *
 * Keys have:
 * - a system-wide unique `id`.
 * - a `token`.
 *
 * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
 * the
 * injector to store created objects in a more efficient way.
 *
 * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
 * resolving
 * providers.
 */
var ReflectiveKey = (function () {
    /**
     * Private
     */
    function ReflectiveKey(token, id) {
        this.token = token;
        this.id = id;
        if (lang_1.isBlank(token)) {
            throw new exceptions_1.BaseException('Token must be defined!');
        }
    }
    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
        /**
         * Returns a stringified token.
         */
        get: function () { return lang_1.stringify(this.token); },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves a `Key` for a token.
     */
    ReflectiveKey.get = function (token) {
        return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token));
    };
    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
        /**
         * @returns the number of keys registered in the system.
         */
        get: function () { return _globalKeyRegistry.numberOfKeys; },
        enumerable: true,
        configurable: true
    });
    return ReflectiveKey;
}());
exports.ReflectiveKey = ReflectiveKey;
/**
 * @internal
 */
var KeyRegistry = (function () {
    function KeyRegistry() {
        this._allKeys = new Map();
    }
    KeyRegistry.prototype.get = function (token) {
        if (token instanceof ReflectiveKey)
            return token;
        if (this._allKeys.has(token)) {
            return this._allKeys.get(token);
        }
        var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
        this._allKeys.set(token, newKey);
        return newKey;
    };
    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
        get: function () { return this._allKeys.size; },
        enumerable: true,
        configurable: true
    });
    return KeyRegistry;
}());
exports.KeyRegistry = KeyRegistry;
var _globalKeyRegistry = new KeyRegistry();

},{"../../src/facade/exceptions":173,"../../src/facade/lang":174,"./forward_ref":159}],168:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var reflection_1 = require('../reflection/reflection');
var reflective_key_1 = require('./reflective_key');
var metadata_1 = require('./metadata');
var reflective_exceptions_1 = require('./reflective_exceptions');
var forward_ref_1 = require('./forward_ref');
var provider_1 = require('./provider');
var provider_util_1 = require('./provider_util');
/**
 * `Dependency` is used by the framework to extend DI.
 * This is internal to Angular and should not be used directly.
 */
var ReflectiveDependency = (function () {
    function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
        this.key = key;
        this.optional = optional;
        this.lowerBoundVisibility = lowerBoundVisibility;
        this.upperBoundVisibility = upperBoundVisibility;
        this.properties = properties;
    }
    ReflectiveDependency.fromKey = function (key) {
        return new ReflectiveDependency(key, false, null, null, []);
    };
    return ReflectiveDependency;
}());
exports.ReflectiveDependency = ReflectiveDependency;
var _EMPTY_LIST = [];
var ResolvedReflectiveProvider_ = (function () {
    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
        this.key = key;
        this.resolvedFactories = resolvedFactories;
        this.multiProvider = multiProvider;
    }
    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
        get: function () { return this.resolvedFactories[0]; },
        enumerable: true,
        configurable: true
    });
    return ResolvedReflectiveProvider_;
}());
exports.ResolvedReflectiveProvider_ = ResolvedReflectiveProvider_;
/**
 * An internal resolved representation of a factory function created by resolving {@link Provider}.
 */
var ResolvedReflectiveFactory = (function () {
    function ResolvedReflectiveFactory(
        /**
         * Factory function which can return an instance of an object represented by a key.
         */
        factory, 
        /**
         * Arguments (dependencies) to the `factory` function.
         */
        dependencies) {
        this.factory = factory;
        this.dependencies = dependencies;
    }
    return ResolvedReflectiveFactory;
}());
exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
/**
 * Resolve a single provider.
 */
function resolveReflectiveFactory(provider) {
    var factoryFn;
    var resolvedDeps;
    if (lang_1.isPresent(provider.useClass)) {
        var useClass = forward_ref_1.resolveForwardRef(provider.useClass);
        factoryFn = reflection_1.reflector.factory(useClass);
        resolvedDeps = _dependenciesFor(useClass);
    }
    else if (lang_1.isPresent(provider.useExisting)) {
        factoryFn = function (aliasInstance) { return aliasInstance; };
        resolvedDeps = [ReflectiveDependency.fromKey(reflective_key_1.ReflectiveKey.get(provider.useExisting))];
    }
    else if (lang_1.isPresent(provider.useFactory)) {
        factoryFn = provider.useFactory;
        resolvedDeps = constructDependencies(provider.useFactory, provider.dependencies);
    }
    else {
        factoryFn = function () { return provider.useValue; };
        resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
}
exports.resolveReflectiveFactory = resolveReflectiveFactory;
/**
 * Converts the {@link Provider} into {@link ResolvedProvider}.
 *
 * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
 * convenience provider syntax.
 */
function resolveReflectiveProvider(provider) {
    return new ResolvedReflectiveProvider_(reflective_key_1.ReflectiveKey.get(provider.token), [resolveReflectiveFactory(provider)], provider.multi);
}
exports.resolveReflectiveProvider = resolveReflectiveProvider;
/**
 * Resolve a list of Providers.
 */
function resolveReflectiveProviders(providers) {
    var normalized = _normalizeProviders(providers, []);
    var resolved = normalized.map(resolveReflectiveProvider);
    return collection_1.MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
}
exports.resolveReflectiveProviders = resolveReflectiveProviders;
/**
 * Merges a list of ResolvedProviders into a list where
 * each key is contained exactly once and multi providers
 * have been merged.
 */
function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
    for (var i = 0; i < providers.length; i++) {
        var provider = providers[i];
        var existing = normalizedProvidersMap.get(provider.key.id);
        if (lang_1.isPresent(existing)) {
            if (provider.multiProvider !== existing.multiProvider) {
                throw new reflective_exceptions_1.MixingMultiProvidersWithRegularProvidersError(existing, provider);
            }
            if (provider.multiProvider) {
                for (var j = 0; j < provider.resolvedFactories.length; j++) {
                    existing.resolvedFactories.push(provider.resolvedFactories[j]);
                }
            }
            else {
                normalizedProvidersMap.set(provider.key.id, provider);
            }
        }
        else {
            var resolvedProvider;
            if (provider.multiProvider) {
                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, collection_1.ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
            }
            else {
                resolvedProvider = provider;
            }
            normalizedProvidersMap.set(provider.key.id, resolvedProvider);
        }
    }
    return normalizedProvidersMap;
}
exports.mergeResolvedReflectiveProviders = mergeResolvedReflectiveProviders;
function _normalizeProviders(providers, res) {
    providers.forEach(function (b) {
        if (b instanceof lang_1.Type) {
            res.push(provider_1.provide(b, { useClass: b }));
        }
        else if (b instanceof provider_1.Provider) {
            res.push(b);
        }
        else if (provider_util_1.isProviderLiteral(b)) {
            res.push(provider_util_1.createProvider(b));
        }
        else if (b instanceof Array) {
            _normalizeProviders(b, res);
        }
        else if (b instanceof provider_1.ProviderBuilder) {
            throw new reflective_exceptions_1.InvalidProviderError(b.token);
        }
        else {
            throw new reflective_exceptions_1.InvalidProviderError(b);
        }
    });
    return res;
}
function constructDependencies(typeOrFunc, dependencies) {
    if (lang_1.isBlank(dependencies)) {
        return _dependenciesFor(typeOrFunc);
    }
    else {
        var params = dependencies.map(function (t) { return [t]; });
        return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params); });
    }
}
exports.constructDependencies = constructDependencies;
function _dependenciesFor(typeOrFunc) {
    var params = reflection_1.reflector.parameters(typeOrFunc);
    if (lang_1.isBlank(params))
        return [];
    if (params.some(lang_1.isBlank)) {
        throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
    }
    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
}
function _extractToken(typeOrFunc, metadata /*any[] | any*/, params) {
    var depProps = [];
    var token = null;
    var optional = false;
    if (!lang_1.isArray(metadata)) {
        if (metadata instanceof metadata_1.InjectMetadata) {
            return _createDependency(metadata.token, optional, null, null, depProps);
        }
        else {
            return _createDependency(metadata, optional, null, null, depProps);
        }
    }
    var lowerBoundVisibility = null;
    var upperBoundVisibility = null;
    for (var i = 0; i < metadata.length; ++i) {
        var paramMetadata = metadata[i];
        if (paramMetadata instanceof lang_1.Type) {
            token = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.InjectMetadata) {
            token = paramMetadata.token;
        }
        else if (paramMetadata instanceof metadata_1.OptionalMetadata) {
            optional = true;
        }
        else if (paramMetadata instanceof metadata_1.SelfMetadata) {
            upperBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.HostMetadata) {
            upperBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {
            lowerBoundVisibility = paramMetadata;
        }
        else if (paramMetadata instanceof metadata_1.DependencyMetadata) {
            if (lang_1.isPresent(paramMetadata.token)) {
                token = paramMetadata.token;
            }
            depProps.push(paramMetadata);
        }
    }
    token = forward_ref_1.resolveForwardRef(token);
    if (lang_1.isPresent(token)) {
        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    }
    else {
        throw new reflective_exceptions_1.NoAnnotationError(typeOrFunc, params);
    }
}
function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
    return new ReflectiveDependency(reflective_key_1.ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
}

},{"../../src/facade/collection":171,"../../src/facade/lang":174,"../reflection/reflection":202,"./forward_ref":159,"./metadata":161,"./provider":163,"./provider_util":164,"./reflective_exceptions":165,"./reflective_key":167}],169:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./lang":174,"./promise":175,"dup":20,"rxjs/Observable":290,"rxjs/Subject":292,"rxjs/observable/PromiseObservable":296,"rxjs/operator/toPromise":297}],170:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],171:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./lang":174,"dup":22}],172:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./base_wrapped_exception":170,"./collection":171,"./lang":174,"dup":23}],173:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./base_wrapped_exception":170,"./exception_handler":172,"dup":24}],174:[function(require,module,exports){
(function (global){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
exports.scheduleMicroTask = scheduleMicroTask;
exports.IS_DART = false;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    if (type['name']) {
        return type['name'];
    }
    return typeof type;
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var _devMode = true;
var _modeLocked = false;
function lockMode() {
    _modeLocked = true;
}
exports.lockMode = lockMode;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 */
function enableProdMode() {
    if (_modeLocked) {
        // Cannot use BaseException as that ends up importing from facade/lang.
        throw 'Cannot enable prod mode after platform setup.';
    }
    _devMode = false;
}
exports.enableProdMode = enableProdMode;
function assertionsEnabled() {
    return _devMode;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    // TODO: to be fixed properly via #2830, noop for now
};
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isBoolean(obj) {
    return typeof obj === "boolean";
}
exports.isBoolean = isBoolean;
function isNumber(obj) {
    return typeof obj === "number";
}
exports.isNumber = isNumber;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
var STRING_MAP_PROTO = Object.getPrototypeOf({});
function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
}
exports.isStrictStringMap = isStrictStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function noop() { }
exports.noop = noop;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    if (token.overriddenName) {
        return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
function resolveEnumToken(enumValue, val) {
    return enumValue[val];
}
exports.resolveEnumToken = resolveEnumToken;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.stripLeft = function (s, charVal) {
        if (s && s.length) {
            var pos = 0;
            for (var i = 0; i < s.length; i++) {
                if (s[i] != charVal)
                    break;
                pos++;
            }
            s = s.substring(pos);
        }
        return s;
    };
    StringWrapper.stripRight = function (s, charVal) {
        if (s && s.length) {
            var pos = s.length;
            for (var i = s.length - 1; i >= 0; i--) {
                if (s[i] != charVal)
                    break;
                pos--;
            }
            s = s.substring(0, pos);
        }
        return s;
    };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
}());
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
}());
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
}(Error));
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
}());
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    RegExpWrapper.replaceAll = function (regExp, input, replace) {
        var c = regExp.exec(input);
        var res = '';
        regExp.lastIndex = 0;
        var prev = 0;
        while (c) {
            res += input.substring(prev, c.index);
            res += replace(c);
            prev = c.index + c[0].length;
            regExp.lastIndex = prev;
            c = regExp.exec(input);
        }
        res += input.substring(prev);
        return res;
    };
    return RegExpWrapper;
}());
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
}());
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
}());
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
function warn(obj) {
    console.warn(obj);
}
exports.warn = warn;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
}());
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
}());
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;
function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
        fnArgNames.push(argName);
        fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
}
exports.evalExpression = evalExpression;
function isPrimitive(obj) {
    return !isJsObject(obj);
}
exports.isPrimitive = isPrimitive;
function hasConstructor(value, type) {
    return value.constructor === type;
}
exports.hasConstructor = hasConstructor;
function bitWiseOr(values) {
    return values.reduce(function (a, b) { return a | b; });
}
exports.bitWiseOr = bitWiseOr;
function bitWiseAnd(values) {
    return values.reduce(function (a, b) { return a & b; });
}
exports.bitWiseAnd = bitWiseAnd;
function escape(s) {
    return _global.encodeURI(s);
}
exports.escape = escape;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],175:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],176:[function(require,module,exports){
"use strict";
// Public API for compiler
var component_resolver_1 = require('./linker/component_resolver');
exports.ComponentResolver = component_resolver_1.ComponentResolver;
var query_list_1 = require('./linker/query_list');
exports.QueryList = query_list_1.QueryList;
var dynamic_component_loader_1 = require('./linker/dynamic_component_loader');
exports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;
var element_ref_1 = require('./linker/element_ref');
exports.ElementRef = element_ref_1.ElementRef;
var template_ref_1 = require('./linker/template_ref');
exports.TemplateRef = template_ref_1.TemplateRef;
var view_ref_1 = require('./linker/view_ref');
exports.EmbeddedViewRef = view_ref_1.EmbeddedViewRef;
exports.ViewRef = view_ref_1.ViewRef;
var view_container_ref_1 = require('./linker/view_container_ref');
exports.ViewContainerRef = view_container_ref_1.ViewContainerRef;
var component_factory_1 = require('./linker/component_factory');
exports.ComponentRef = component_factory_1.ComponentRef;
exports.ComponentFactory = component_factory_1.ComponentFactory;
var exceptions_1 = require('./linker/exceptions');
exports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;

},{"./linker/component_factory":177,"./linker/component_resolver":178,"./linker/dynamic_component_loader":180,"./linker/element_ref":183,"./linker/exceptions":184,"./linker/query_list":185,"./linker/template_ref":186,"./linker/view_container_ref":188,"./linker/view_ref":189}],177:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var view_utils_1 = require('./view_utils');
/**
 * Represents an instance of a Component created via a {@link ComponentFactory}.
 *
 * `ComponentRef` provides access to the Component Instance as well other objects related to this
 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
 * method.
 */
var ComponentRef = (function () {
    function ComponentRef() {
    }
    Object.defineProperty(ComponentRef.prototype, "location", {
        /**
         * Location of the Host Element of this Component Instance.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "injector", {
        /**
         * The injector on which the component instance exists.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "instance", {
        /**
         * The instance of the Component.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentRef.prototype, "hostView", {
        /**
         * The {@link ViewRef} of the Host View of this Component instance.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
        /**
         * The {@link ChangeDetectorRef} of the Component instance.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentRef.prototype, "componentType", {
        /**
         * The component type.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return ComponentRef;
}());
exports.ComponentRef = ComponentRef;
var ComponentRef_ = (function (_super) {
    __extends(ComponentRef_, _super);
    function ComponentRef_(_hostElement, _componentType) {
        _super.call(this);
        this._hostElement = _hostElement;
        this._componentType = _componentType;
    }
    Object.defineProperty(ComponentRef_.prototype, "location", {
        get: function () { return this._hostElement.elementRef; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "injector", {
        get: function () { return this._hostElement.injector; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentRef_.prototype, "instance", {
        get: function () { return this._hostElement.component; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "hostView", {
        get: function () { return this._hostElement.parentView.ref; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
        get: function () { return this._hostElement.parentView.ref; },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(ComponentRef_.prototype, "componentType", {
        get: function () { return this._componentType; },
        enumerable: true,
        configurable: true
    });
    ComponentRef_.prototype.destroy = function () { this._hostElement.parentView.destroy(); };
    ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
    return ComponentRef_;
}(ComponentRef));
exports.ComponentRef_ = ComponentRef_;
var EMPTY_CONTEXT = new Object();
/*@ts2dart_const*/
var ComponentFactory = (function () {
    function ComponentFactory(selector, _viewFactory, _componentType) {
        this.selector = selector;
        this._viewFactory = _viewFactory;
        this._componentType = _componentType;
    }
    Object.defineProperty(ComponentFactory.prototype, "componentType", {
        get: function () { return this._componentType; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new component.
     */
    ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
        if (projectableNodes === void 0) { projectableNodes = null; }
        if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
        var vu = injector.get(view_utils_1.ViewUtils);
        if (lang_1.isBlank(projectableNodes)) {
            projectableNodes = [];
        }
        // Note: Host views don't need a declarationAppElement!
        var hostView = this._viewFactory(vu, injector, null);
        var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
        return new ComponentRef_(hostElement, this._componentType);
    };
    return ComponentFactory;
}());
exports.ComponentFactory = ComponentFactory;

},{"../../src/facade/exceptions":173,"../../src/facade/lang":174,"./view_utils":191}],178:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var async_1 = require('../../src/facade/async');
var reflection_1 = require('../reflection/reflection');
var component_factory_1 = require('./component_factory');
var decorators_1 = require('../di/decorators');
/**
 * Low-level service for loading {@link ComponentFactory}s, which
 * can later be used to create and render a Component instance.
 */
var ComponentResolver = (function () {
    function ComponentResolver() {
    }
    return ComponentResolver;
}());
exports.ComponentResolver = ComponentResolver;
function _isComponentFactory(type) {
    return type instanceof component_factory_1.ComponentFactory;
}
var ReflectorComponentResolver = (function (_super) {
    __extends(ReflectorComponentResolver, _super);
    function ReflectorComponentResolver() {
        _super.apply(this, arguments);
    }
    ReflectorComponentResolver.prototype.resolveComponent = function (componentType) {
        var metadatas = reflection_1.reflector.annotations(componentType);
        var componentFactory = metadatas.find(_isComponentFactory);
        if (lang_1.isBlank(componentFactory)) {
            throw new exceptions_1.BaseException("No precompiled component " + lang_1.stringify(componentType) + " found");
        }
        return async_1.PromiseWrapper.resolve(componentFactory);
    };
    ReflectorComponentResolver.prototype.clearCache = function () { };
    ReflectorComponentResolver.decorators = [
        { type: decorators_1.Injectable },
    ];
    return ReflectorComponentResolver;
}(ComponentResolver));
exports.ReflectorComponentResolver = ReflectorComponentResolver;

},{"../../src/facade/async":169,"../../src/facade/exceptions":173,"../../src/facade/lang":174,"../di/decorators":158,"../reflection/reflection":202,"./component_factory":177}],179:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var view_type_1 = require('./view_type');
/* @ts2dart_const */
var StaticNodeDebugInfo = (function () {
    function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
        this.providerTokens = providerTokens;
        this.componentToken = componentToken;
        this.refTokens = refTokens;
    }
    return StaticNodeDebugInfo;
}());
exports.StaticNodeDebugInfo = StaticNodeDebugInfo;
var DebugContext = (function () {
    function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
        this._view = _view;
        this._nodeIndex = _nodeIndex;
        this._tplRow = _tplRow;
        this._tplCol = _tplCol;
    }
    Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
        get: function () {
            return lang_1.isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "context", {
        get: function () { return this._view.context; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "component", {
        get: function () {
            var staticNodeInfo = this._staticNodeInfo;
            if (lang_1.isPresent(staticNodeInfo) && lang_1.isPresent(staticNodeInfo.componentToken)) {
                return this.injector.get(staticNodeInfo.componentToken);
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
        get: function () {
            var componentView = this._view;
            while (lang_1.isPresent(componentView.declarationAppElement) &&
                componentView.type !== view_type_1.ViewType.COMPONENT) {
                componentView = componentView.declarationAppElement.parentView;
            }
            return lang_1.isPresent(componentView.declarationAppElement) ?
                componentView.declarationAppElement.nativeElement :
                null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "injector", {
        get: function () { return this._view.injector(this._nodeIndex); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "renderNode", {
        get: function () {
            if (lang_1.isPresent(this._nodeIndex) && lang_1.isPresent(this._view.allNodes)) {
                return this._view.allNodes[this._nodeIndex];
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "providerTokens", {
        get: function () {
            var staticNodeInfo = this._staticNodeInfo;
            return lang_1.isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "source", {
        get: function () {
            return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DebugContext.prototype, "references", {
        get: function () {
            var _this = this;
            var varValues = {};
            var staticNodeInfo = this._staticNodeInfo;
            if (lang_1.isPresent(staticNodeInfo)) {
                var refs = staticNodeInfo.refTokens;
                collection_1.StringMapWrapper.forEach(refs, function (refToken, refName) {
                    var varValue;
                    if (lang_1.isBlank(refToken)) {
                        varValue = lang_1.isPresent(_this._view.allNodes) ? _this._view.allNodes[_this._nodeIndex] : null;
                    }
                    else {
                        varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
                    }
                    varValues[refName] = varValue;
                });
            }
            return varValues;
        },
        enumerable: true,
        configurable: true
    });
    return DebugContext;
}());
exports.DebugContext = DebugContext;

},{"../../src/facade/collection":171,"../../src/facade/lang":174,"./view_type":190}],180:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var component_resolver_1 = require('./component_resolver');
var lang_1 = require('../../src/facade/lang');
var reflective_injector_1 = require('../di/reflective_injector');
var decorators_1 = require('../di/decorators');
/**
 * Use ComponentResolver and ViewContainerRef directly.
 *
 * @deprecated
 */
var DynamicComponentLoader = (function () {
    function DynamicComponentLoader() {
    }
    return DynamicComponentLoader;
}());
exports.DynamicComponentLoader = DynamicComponentLoader;
var DynamicComponentLoader_ = (function (_super) {
    __extends(DynamicComponentLoader_, _super);
    function DynamicComponentLoader_(_compiler) {
        _super.call(this);
        this._compiler = _compiler;
    }
    DynamicComponentLoader_.prototype.loadAsRoot = function (type, overrideSelectorOrNode, injector, onDispose, projectableNodes) {
        return this._compiler.resolveComponent(type).then(function (componentFactory) {
            var componentRef = componentFactory.create(injector, projectableNodes, lang_1.isPresent(overrideSelectorOrNode) ? overrideSelectorOrNode : componentFactory.selector);
            if (lang_1.isPresent(onDispose)) {
                componentRef.onDestroy(onDispose);
            }
            return componentRef;
        });
    };
    DynamicComponentLoader_.prototype.loadNextToLocation = function (type, location, providers, projectableNodes) {
        if (providers === void 0) { providers = null; }
        if (projectableNodes === void 0) { projectableNodes = null; }
        return this._compiler.resolveComponent(type).then(function (componentFactory) {
            var contextInjector = location.parentInjector;
            var childInjector = lang_1.isPresent(providers) && providers.length > 0 ?
                reflective_injector_1.ReflectiveInjector.fromResolvedProviders(providers, contextInjector) :
                contextInjector;
            return location.createComponent(componentFactory, location.length, childInjector, projectableNodes);
        });
    };
    DynamicComponentLoader_.decorators = [
        { type: decorators_1.Injectable },
    ];
    DynamicComponentLoader_.ctorParameters = [
        { type: component_resolver_1.ComponentResolver, },
    ];
    return DynamicComponentLoader_;
}(DynamicComponentLoader));
exports.DynamicComponentLoader_ = DynamicComponentLoader_;

},{"../../src/facade/lang":174,"../di/decorators":158,"../di/reflective_injector":166,"./component_resolver":178}],181:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var exceptions_1 = require('../../src/facade/exceptions');
var view_type_1 = require('./view_type');
var element_ref_1 = require('./element_ref');
var view_container_ref_1 = require('./view_container_ref');
/**
 * An AppElement is created for elements that have a ViewContainerRef,
 * a nested component or a <template> element to keep data around
 * that is needed for later instantiations.
 */
var AppElement = (function () {
    function AppElement(index, parentIndex, parentView, nativeElement) {
        this.index = index;
        this.parentIndex = parentIndex;
        this.parentView = parentView;
        this.nativeElement = nativeElement;
        this.nestedViews = null;
        this.componentView = null;
    }
    Object.defineProperty(AppElement.prototype, "elementRef", {
        get: function () { return new element_ref_1.ElementRef(this.nativeElement); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppElement.prototype, "vcRef", {
        get: function () { return new view_container_ref_1.ViewContainerRef_(this); },
        enumerable: true,
        configurable: true
    });
    AppElement.prototype.initComponent = function (component, componentConstructorViewQueries, view) {
        this.component = component;
        this.componentConstructorViewQueries = componentConstructorViewQueries;
        this.componentView = view;
    };
    Object.defineProperty(AppElement.prototype, "parentInjector", {
        get: function () { return this.parentView.injector(this.parentIndex); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppElement.prototype, "injector", {
        get: function () { return this.parentView.injector(this.index); },
        enumerable: true,
        configurable: true
    });
    AppElement.prototype.mapNestedViews = function (nestedViewClass, callback) {
        var result = [];
        if (lang_1.isPresent(this.nestedViews)) {
            this.nestedViews.forEach(function (nestedView) {
                if (nestedView.clazz === nestedViewClass) {
                    result.push(callback(nestedView));
                }
            });
        }
        return result;
    };
    AppElement.prototype.attachView = function (view, viewIndex) {
        if (view.type === view_type_1.ViewType.COMPONENT) {
            throw new exceptions_1.BaseException("Component views can't be moved!");
        }
        var nestedViews = this.nestedViews;
        if (nestedViews == null) {
            nestedViews = [];
            this.nestedViews = nestedViews;
        }
        collection_1.ListWrapper.insert(nestedViews, viewIndex, view);
        var refRenderNode;
        if (viewIndex > 0) {
            var prevView = nestedViews[viewIndex - 1];
            refRenderNode = prevView.lastRootNode;
        }
        else {
            refRenderNode = this.nativeElement;
        }
        if (lang_1.isPresent(refRenderNode)) {
            view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
        }
        view.addToContentChildren(this);
    };
    AppElement.prototype.detachView = function (viewIndex) {
        var view = collection_1.ListWrapper.removeAt(this.nestedViews, viewIndex);
        if (view.type === view_type_1.ViewType.COMPONENT) {
            throw new exceptions_1.BaseException("Component views can't be moved!");
        }
        view.renderer.detachView(view.flatRootNodes);
        view.removeFromContentChildren(this);
        return view;
    };
    return AppElement;
}());
exports.AppElement = AppElement;

},{"../../src/facade/collection":171,"../../src/facade/exceptions":173,"../../src/facade/lang":174,"./element_ref":183,"./view_container_ref":188,"./view_type":190}],182:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var injector_1 = require('../di/injector');
var _UNDEFINED = new Object();
var ElementInjector = (function (_super) {
    __extends(ElementInjector, _super);
    function ElementInjector(_view, _nodeIndex) {
        _super.call(this);
        this._view = _view;
        this._nodeIndex = _nodeIndex;
    }
    ElementInjector.prototype.get = function (token, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = injector_1.THROW_IF_NOT_FOUND; }
        var result = _UNDEFINED;
        if (result === _UNDEFINED) {
            result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED);
        }
        if (result === _UNDEFINED) {
            result = this._view.parentInjector.get(token, notFoundValue);
        }
        return result;
    };
    return ElementInjector;
}(injector_1.Injector));
exports.ElementInjector = ElementInjector;

},{"../di/injector":160}],183:[function(require,module,exports){
"use strict";
/**
* A wrapper around a native element inside of a View.
*
* An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
* element.
*/
// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
// i.e. users have to ask for what they need. With that, we can build better analysis tools
// and could do better codegen in the future.
var ElementRef = (function () {
    function ElementRef(nativeElement) {
        this.nativeElement = nativeElement;
    }
    return ElementRef;
}());
exports.ElementRef = ElementRef;

},{}],184:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('../../src/facade/exceptions');
/**
 * An error thrown if application changes model breaking the top-down data flow.
 *
 * This exception is only thrown in dev mode.
 *
 * <!-- TODO: Add a link once the dev mode option is configurable -->
 *
 * ### Example
 *
 * ```typescript
 * @Component({
 *   selector: 'parent',
 *   template: `
 *     <child [prop]="parentProp"></child>
 *   `,
 *   directives: [forwardRef(() => Child)]
 * })
 * class Parent {
 *   parentProp = "init";
 * }
 *
 * @Directive({selector: 'child', inputs: ['prop']})
 * class Child {
 *   constructor(public parent: Parent) {}
 *
 *   set prop(v) {
 *     // this updates the parent property, which is disallowed during change detection
 *     // this will result in ExpressionChangedAfterItHasBeenCheckedException
 *     this.parent.parentProp = "updated";
 *   }
 * }
 * ```
 */
var ExpressionChangedAfterItHasBeenCheckedException = (function (_super) {
    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
    function ExpressionChangedAfterItHasBeenCheckedException(oldValue, currValue, context) {
        _super.call(this, "Expression has changed after it was checked. " +
            ("Previous value: '" + oldValue + "'. Current value: '" + currValue + "'"));
    }
    return ExpressionChangedAfterItHasBeenCheckedException;
}(exceptions_1.BaseException));
exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
/**
 * Thrown when an exception was raised during view creation, change detection or destruction.
 *
 * This error wraps the original exception to attach additional contextual information that can
 * be useful for debugging.
 */
var ViewWrappedException = (function (_super) {
    __extends(ViewWrappedException, _super);
    function ViewWrappedException(originalException, originalStack, context) {
        _super.call(this, "Error in " + context.source, originalException, originalStack, context);
    }
    return ViewWrappedException;
}(exceptions_1.WrappedException));
exports.ViewWrappedException = ViewWrappedException;
/**
 * Thrown when a destroyed view is used.
 *
 * This error indicates a bug in the framework.
 *
 * This is an internal Angular error.
 */
var ViewDestroyedException = (function (_super) {
    __extends(ViewDestroyedException, _super);
    function ViewDestroyedException(details) {
        _super.call(this, "Attempt to use a destroyed view: " + details);
    }
    return ViewDestroyedException;
}(exceptions_1.BaseException));
exports.ViewDestroyedException = ViewDestroyedException;

},{"../../src/facade/exceptions":173}],185:[function(require,module,exports){
"use strict";
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var async_1 = require('../../src/facade/async');
/**
 * An unmodifiable list of items that Angular keeps up to date when the state
 * of the application changes.
 *
 * The type of object that {@link QueryMetadata} and {@link ViewQueryMetadata} provide.
 *
 * Implements an iterable interface, therefore it can be used in both ES6
 * javascript `for (var i of items)` loops as well as in Angular templates with
 * `*ngFor="let i of myList"`.
 *
 * Changes can be observed by subscribing to the changes `Observable`.
 *
 * NOTE: In the future this class will implement an `Observable` interface.
 *
 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
 * ```typescript
 * @Component({...})
 * class Container {
 *   constructor(@Query(Item) items: QueryList<Item>) {
 *     items.changes.subscribe(_ => console.log(items.length));
 *   }
 * }
 * ```
 */
var QueryList = (function () {
    function QueryList() {
        this._dirty = true;
        this._results = [];
        this._emitter = new async_1.EventEmitter();
    }
    Object.defineProperty(QueryList.prototype, "changes", {
        get: function () { return this._emitter; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "length", {
        get: function () { return this._results.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "first", {
        get: function () { return collection_1.ListWrapper.first(this._results); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryList.prototype, "last", {
        get: function () { return collection_1.ListWrapper.last(this._results); },
        enumerable: true,
        configurable: true
    });
    /**
     * returns a new array with the passed in function applied to each element.
     */
    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
    /**
     * returns a filtered array.
     */
    QueryList.prototype.filter = function (fn) { return this._results.filter(fn); };
    /**
     * returns a reduced value.
     */
    QueryList.prototype.reduce = function (fn, init) { return this._results.reduce(fn, init); };
    /**
     * executes function for each element in a query.
     */
    QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
    /**
     * converts QueryList into an array
     */
    QueryList.prototype.toArray = function () { return collection_1.ListWrapper.clone(this._results); };
    QueryList.prototype[lang_1.getSymbolIterator()] = function () { return this._results[lang_1.getSymbolIterator()](); };
    QueryList.prototype.toString = function () { return this._results.toString(); };
    /**
     * @internal
     */
    QueryList.prototype.reset = function (res) {
        this._results = collection_1.ListWrapper.flatten(res);
        this._dirty = false;
    };
    /** @internal */
    QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
    /** internal */
    QueryList.prototype.setDirty = function () { this._dirty = true; };
    Object.defineProperty(QueryList.prototype, "dirty", {
        /** internal */
        get: function () { return this._dirty; },
        enumerable: true,
        configurable: true
    });
    return QueryList;
}());
exports.QueryList = QueryList;

},{"../../src/facade/async":169,"../../src/facade/collection":171,"../../src/facade/lang":174}],186:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../facade/lang');
var EMPTY_CONTEXT = new Object();
/**
 * Represents an Embedded Template that can be used to instantiate Embedded Views.
 *
 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
 * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
 * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
 * `TemplateRef` from a Component or a Directive via {@link Query}.
 *
 * To instantiate Embedded Views based on a Template, use
 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
 * View Container.
 */
var TemplateRef = (function () {
    function TemplateRef() {
    }
    Object.defineProperty(TemplateRef.prototype, "elementRef", {
        /**
         * The location in the View where the Embedded View logically belongs to.
         *
         * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
         * inherit from the contexts of this location.
         *
         * Typically new Embedded Views are attached to the View Container of this location, but in
         * advanced use-cases, the View can be attached to a different container while keeping the
         * data-binding and injection context from the original location.
         *
         */
        // TODO(i): rename to anchor or location
        get: function () { return null; },
        enumerable: true,
        configurable: true
    });
    return TemplateRef;
}());
exports.TemplateRef = TemplateRef;
var TemplateRef_ = (function (_super) {
    __extends(TemplateRef_, _super);
    function TemplateRef_(_appElement, _viewFactory) {
        _super.call(this);
        this._appElement = _appElement;
        this._viewFactory = _viewFactory;
    }
    TemplateRef_.prototype.createEmbeddedView = function (context) {
        var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
        if (lang_1.isBlank(context)) {
            context = EMPTY_CONTEXT;
        }
        view.create(context, null, null);
        return view.ref;
    };
    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
        get: function () { return this._appElement.elementRef; },
        enumerable: true,
        configurable: true
    });
    return TemplateRef_;
}(TemplateRef));
exports.TemplateRef_ = TemplateRef_;

},{"../facade/lang":174}],187:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('../../src/facade/collection');
var element_1 = require('./element');
var lang_1 = require('../../src/facade/lang');
var async_1 = require('../../src/facade/async');
var view_ref_1 = require('./view_ref');
var view_type_1 = require('./view_type');
var view_utils_1 = require('./view_utils');
var change_detection_1 = require('../change_detection/change_detection');
var profile_1 = require('../profile/profile');
var exceptions_1 = require('./exceptions');
var debug_context_1 = require('./debug_context');
var element_injector_1 = require('./element_injector');
var _scope_check = profile_1.wtfCreateScope("AppView#check(ascii id)");
/**
 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
 *
 */
var AppView = (function () {
    function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
        this.clazz = clazz;
        this.componentType = componentType;
        this.type = type;
        this.viewUtils = viewUtils;
        this.parentInjector = parentInjector;
        this.declarationAppElement = declarationAppElement;
        this.cdMode = cdMode;
        this.contentChildren = [];
        this.viewChildren = [];
        this.viewContainerElement = null;
        // The names of the below fields must be kept in sync with codegen_name_util.ts or
        // change detection will fail.
        this.cdState = change_detection_1.ChangeDetectorState.NeverChecked;
        this.destroyed = false;
        this.ref = new view_ref_1.ViewRef_(this);
        if (type === view_type_1.ViewType.COMPONENT || type === view_type_1.ViewType.HOST) {
            this.renderer = viewUtils.renderComponent(componentType);
        }
        else {
            this.renderer = declarationAppElement.parentView.renderer;
        }
    }
    AppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
        this.context = context;
        var projectableNodes;
        switch (this.type) {
            case view_type_1.ViewType.COMPONENT:
                projectableNodes = view_utils_1.ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
                break;
            case view_type_1.ViewType.EMBEDDED:
                projectableNodes = this.declarationAppElement.parentView.projectableNodes;
                break;
            case view_type_1.ViewType.HOST:
                // Note: Don't ensure the slot count for the projectableNodes as we store
                // them only for the contained component view (which will later check the slot count...)
                projectableNodes = givenProjectableNodes;
                break;
        }
        this._hasExternalHostElement = lang_1.isPresent(rootSelectorOrNode);
        this.projectableNodes = projectableNodes;
        return this.createInternal(rootSelectorOrNode);
    };
    /**
     * Overwritten by implementations.
     * Returns the AppElement for the host element for ViewType.HOST.
     */
    AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
    AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, subscriptions) {
        this.rootNodesOrAppElements = rootNodesOrAppElements;
        this.allNodes = allNodes;
        this.disposables = disposables;
        this.subscriptions = subscriptions;
        if (this.type === view_type_1.ViewType.COMPONENT) {
            // Note: the render nodes have been attached to their host element
            // in the ViewFactory already.
            this.declarationAppElement.parentView.viewChildren.push(this);
            this.dirtyParentQueriesInternal();
        }
    };
    AppView.prototype.selectOrCreateHostElement = function (elementName, rootSelectorOrNode, debugInfo) {
        var hostElement;
        if (lang_1.isPresent(rootSelectorOrNode)) {
            hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
        }
        else {
            hostElement = this.renderer.createElement(null, elementName, debugInfo);
        }
        return hostElement;
    };
    AppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
        return this.injectorGetInternal(token, nodeIndex, notFoundResult);
    };
    /**
     * Overwritten by implementations
     */
    AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
        return notFoundResult;
    };
    AppView.prototype.injector = function (nodeIndex) {
        if (lang_1.isPresent(nodeIndex)) {
            return new element_injector_1.ElementInjector(this, nodeIndex);
        }
        else {
            return this.parentInjector;
        }
    };
    AppView.prototype.destroy = function () {
        if (this._hasExternalHostElement) {
            this.renderer.detachView(this.flatRootNodes);
        }
        else if (lang_1.isPresent(this.viewContainerElement)) {
            this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
        }
        this._destroyRecurse();
    };
    AppView.prototype._destroyRecurse = function () {
        if (this.destroyed) {
            return;
        }
        var children = this.contentChildren;
        for (var i = 0; i < children.length; i++) {
            children[i]._destroyRecurse();
        }
        children = this.viewChildren;
        for (var i = 0; i < children.length; i++) {
            children[i]._destroyRecurse();
        }
        this.destroyLocal();
        this.destroyed = true;
    };
    AppView.prototype.destroyLocal = function () {
        var hostElement = this.type === view_type_1.ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
        for (var i = 0; i < this.disposables.length; i++) {
            this.disposables[i]();
        }
        for (var i = 0; i < this.subscriptions.length; i++) {
            async_1.ObservableWrapper.dispose(this.subscriptions[i]);
        }
        this.destroyInternal();
        if (this._hasExternalHostElement) {
            this.renderer.detachView(this.flatRootNodes);
        }
        else if (lang_1.isPresent(this.viewContainerElement)) {
            this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
        }
        else {
            this.dirtyParentQueriesInternal();
        }
        this.renderer.destroyView(hostElement, this.allNodes);
    };
    /**
     * Overwritten by implementations
     */
    AppView.prototype.destroyInternal = function () { };
    Object.defineProperty(AppView.prototype, "changeDetectorRef", {
        get: function () { return this.ref; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppView.prototype, "parent", {
        get: function () {
            return lang_1.isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppView.prototype, "flatRootNodes", {
        get: function () { return view_utils_1.flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppView.prototype, "lastRootNode", {
        get: function () {
            var lastNode = this.rootNodesOrAppElements.length > 0 ?
                this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] :
                null;
            return _findLastRenderNode(lastNode);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Overwritten by implementations
     */
    AppView.prototype.dirtyParentQueriesInternal = function () { };
    AppView.prototype.detectChanges = function (throwOnChange) {
        var s = _scope_check(this.clazz);
        if (this.cdMode === change_detection_1.ChangeDetectionStrategy.Detached ||
            this.cdMode === change_detection_1.ChangeDetectionStrategy.Checked ||
            this.cdState === change_detection_1.ChangeDetectorState.Errored)
            return;
        if (this.destroyed) {
            this.throwDestroyedError('detectChanges');
        }
        this.detectChangesInternal(throwOnChange);
        if (this.cdMode === change_detection_1.ChangeDetectionStrategy.CheckOnce)
            this.cdMode = change_detection_1.ChangeDetectionStrategy.Checked;
        this.cdState = change_detection_1.ChangeDetectorState.CheckedBefore;
        profile_1.wtfLeave(s);
    };
    /**
     * Overwritten by implementations
     */
    AppView.prototype.detectChangesInternal = function (throwOnChange) {
        this.detectContentChildrenChanges(throwOnChange);
        this.detectViewChildrenChanges(throwOnChange);
    };
    AppView.prototype.detectContentChildrenChanges = function (throwOnChange) {
        for (var i = 0; i < this.contentChildren.length; ++i) {
            this.contentChildren[i].detectChanges(throwOnChange);
        }
    };
    AppView.prototype.detectViewChildrenChanges = function (throwOnChange) {
        for (var i = 0; i < this.viewChildren.length; ++i) {
            this.viewChildren[i].detectChanges(throwOnChange);
        }
    };
    AppView.prototype.addToContentChildren = function (renderAppElement) {
        renderAppElement.parentView.contentChildren.push(this);
        this.viewContainerElement = renderAppElement;
        this.dirtyParentQueriesInternal();
    };
    AppView.prototype.removeFromContentChildren = function (renderAppElement) {
        collection_1.ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
        this.dirtyParentQueriesInternal();
        this.viewContainerElement = null;
    };
    AppView.prototype.markAsCheckOnce = function () { this.cdMode = change_detection_1.ChangeDetectionStrategy.CheckOnce; };
    AppView.prototype.markPathToRootAsCheckOnce = function () {
        var c = this;
        while (lang_1.isPresent(c) && c.cdMode !== change_detection_1.ChangeDetectionStrategy.Detached) {
            if (c.cdMode === change_detection_1.ChangeDetectionStrategy.Checked) {
                c.cdMode = change_detection_1.ChangeDetectionStrategy.CheckOnce;
            }
            var parentEl = c.type === view_type_1.ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
            c = lang_1.isPresent(parentEl) ? parentEl.parentView : null;
        }
    };
    AppView.prototype.eventHandler = function (cb) { return cb; };
    AppView.prototype.throwDestroyedError = function (details) { throw new exceptions_1.ViewDestroyedException(details); };
    return AppView;
}());
exports.AppView = AppView;
var DebugAppView = (function (_super) {
    __extends(DebugAppView, _super);
    function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
        _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
        this.staticNodeDebugInfos = staticNodeDebugInfos;
        this._currentDebugContext = null;
    }
    DebugAppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
        this._resetDebug();
        try {
            return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
        }
        catch (e) {
            this._rethrowWithContext(e, e.stack);
            throw e;
        }
    };
    DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
        this._resetDebug();
        try {
            return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
        }
        catch (e) {
            this._rethrowWithContext(e, e.stack);
            throw e;
        }
    };
    DebugAppView.prototype.destroyLocal = function () {
        this._resetDebug();
        try {
            _super.prototype.destroyLocal.call(this);
        }
        catch (e) {
            this._rethrowWithContext(e, e.stack);
            throw e;
        }
    };
    DebugAppView.prototype.detectChanges = function (throwOnChange) {
        this._resetDebug();
        try {
            _super.prototype.detectChanges.call(this, throwOnChange);
        }
        catch (e) {
            this._rethrowWithContext(e, e.stack);
            throw e;
        }
    };
    DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
    DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
        return this._currentDebugContext = new debug_context_1.DebugContext(this, nodeIndex, rowNum, colNum);
    };
    DebugAppView.prototype._rethrowWithContext = function (e, stack) {
        if (!(e instanceof exceptions_1.ViewWrappedException)) {
            if (!(e instanceof exceptions_1.ExpressionChangedAfterItHasBeenCheckedException)) {
                this.cdState = change_detection_1.ChangeDetectorState.Errored;
            }
            if (lang_1.isPresent(this._currentDebugContext)) {
                throw new exceptions_1.ViewWrappedException(e, stack, this._currentDebugContext);
            }
        }
    };
    DebugAppView.prototype.eventHandler = function (cb) {
        var _this = this;
        var superHandler = _super.prototype.eventHandler.call(this, cb);
        return function (event) {
            _this._resetDebug();
            try {
                return superHandler(event);
            }
            catch (e) {
                _this._rethrowWithContext(e, e.stack);
                throw e;
            }
        };
    };
    return DebugAppView;
}(AppView));
exports.DebugAppView = DebugAppView;
function _findLastRenderNode(node) {
    var lastNode;
    if (node instanceof element_1.AppElement) {
        var appEl = node;
        lastNode = appEl.nativeElement;
        if (lang_1.isPresent(appEl.nestedViews)) {
            // Note: Views might have no root nodes at all!
            for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
                var nestedView = appEl.nestedViews[i];
                if (nestedView.rootNodesOrAppElements.length > 0) {
                    lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
                }
            }
        }
    }
    else {
        lastNode = node;
    }
    return lastNode;
}

},{"../../src/facade/async":169,"../../src/facade/collection":171,"../../src/facade/lang":174,"../change_detection/change_detection":146,"../profile/profile":199,"./debug_context":179,"./element":181,"./element_injector":182,"./exceptions":184,"./view_ref":189,"./view_type":190,"./view_utils":191}],188:[function(require,module,exports){
"use strict";
var collection_1 = require('../../src/facade/collection');
var exceptions_1 = require('../../src/facade/exceptions');
var lang_1 = require('../../src/facade/lang');
var profile_1 = require('../profile/profile');
/**
 * Represents a container where one or more Views can be attached.
 *
 * The container can contain two kinds of Views. Host Views, created by instantiating a
 * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
 *
 * The location of the View Container within the containing View is specified by the Anchor
 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
 * have a single View Container.
 *
 * Root elements of Views attached to this container become siblings of the Anchor Element in
 * the Rendered View.
 *
 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
 * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
 */
var ViewContainerRef = (function () {
    function ViewContainerRef() {
    }
    Object.defineProperty(ViewContainerRef.prototype, "element", {
        /**
         * Anchor element that specifies the location of this container in the containing View.
         * <!-- TODO: rename to anchorElement -->
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "injector", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewContainerRef.prototype, "length", {
        /**
         * Returns the number of Views currently attached to this container.
         */
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return ViewContainerRef;
}());
exports.ViewContainerRef = ViewContainerRef;
var ViewContainerRef_ = (function () {
    function ViewContainerRef_(_element) {
        this._element = _element;
        /** @internal */
        this._createComponentInContainerScope = profile_1.wtfCreateScope('ViewContainerRef#createComponent()');
        /** @internal */
        this._insertScope = profile_1.wtfCreateScope('ViewContainerRef#insert()');
        /** @internal */
        this._removeScope = profile_1.wtfCreateScope('ViewContainerRef#remove()');
        /** @internal */
        this._detachScope = profile_1.wtfCreateScope('ViewContainerRef#detach()');
    }
    ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
    Object.defineProperty(ViewContainerRef_.prototype, "length", {
        get: function () {
            var views = this._element.nestedViews;
            return lang_1.isPresent(views) ? views.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "element", {
        get: function () { return this._element.elementRef; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
        get: function () { return this._element.injector; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
        get: function () { return this._element.parentInjector; },
        enumerable: true,
        configurable: true
    });
    // TODO(rado): profile and decide whether bounds checks should be added
    // to the methods below.
    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
        if (context === void 0) { context = null; }
        if (index === void 0) { index = -1; }
        var viewRef = templateRef.createEmbeddedView(context);
        this.insert(viewRef, index);
        return viewRef;
    };
    ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
        if (index === void 0) { index = -1; }
        if (injector === void 0) { injector = null; }
        if (projectableNodes === void 0) { projectableNodes = null; }
        var s = this._createComponentInContainerScope();
        var contextInjector = lang_1.isPresent(injector) ? injector : this._element.parentInjector;
        var componentRef = componentFactory.create(contextInjector, projectableNodes);
        this.insert(componentRef.hostView, index);
        return profile_1.wtfLeave(s, componentRef);
    };
    // TODO(i): refactor insert+remove into move
    ViewContainerRef_.prototype.insert = function (viewRef, index) {
        if (index === void 0) { index = -1; }
        var s = this._insertScope();
        if (index == -1)
            index = this.length;
        var viewRef_ = viewRef;
        this._element.attachView(viewRef_.internalView, index);
        return profile_1.wtfLeave(s, viewRef_);
    };
    ViewContainerRef_.prototype.indexOf = function (viewRef) {
        return collection_1.ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
    };
    // TODO(i): rename to destroy
    ViewContainerRef_.prototype.remove = function (index) {
        if (index === void 0) { index = -1; }
        var s = this._removeScope();
        if (index == -1)
            index = this.length - 1;
        var view = this._element.detachView(index);
        view.destroy();
        // view is intentionally not returned to the client.
        profile_1.wtfLeave(s);
    };
    // TODO(i): refactor insert+remove into move
    ViewContainerRef_.prototype.detach = function (index) {
        if (index === void 0) { index = -1; }
        var s = this._detachScope();
        if (index == -1)
            index = this.length - 1;
        var view = this._element.detachView(index);
        return profile_1.wtfLeave(s, view.ref);
    };
    ViewContainerRef_.prototype.clear = function () {
        for (var i = this.length - 1; i >= 0; i--) {
            this.remove(i);
        }
    };
    return ViewContainerRef_;
}());
exports.ViewContainerRef_ = ViewContainerRef_;

},{"../../src/facade/collection":171,"../../src/facade/exceptions":173,"../../src/facade/lang":174,"../profile/profile":199}],189:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var exceptions_1 = require('../../src/facade/exceptions');
var constants_1 = require('../change_detection/constants');
var ViewRef = (function () {
    function ViewRef() {
    }
    Object.defineProperty(ViewRef.prototype, "destroyed", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return ViewRef;
}());
exports.ViewRef = ViewRef;
/**
 * Represents an Angular View.
 *
 * <!-- TODO: move the next two paragraphs to the dev guide -->
 * A View is a fundamental building block of the application UI. It is the smallest grouping of
 * Elements which are created and destroyed together.
 *
 * Properties of elements in a View can change, but the structure (number and order) of elements in
 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
 * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
 * <!-- /TODO -->
 *
 * ### Example
 *
 * Given this template...
 *
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <li *ngFor="let  item of items">{{item}}</li>
 * </ul>
 * ```
 *
 * ... we have two {@link TemplateRef}s:
 *
 * Outer {@link TemplateRef}:
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <template ngFor let-item [ngForOf]="items"></template>
 * </ul>
 * ```
 *
 * Inner {@link TemplateRef}:
 * ```
 *   <li>{{item}}</li>
 * ```
 *
 * Notice that the original template is broken down into two separate {@link TemplateRef}s.
 *
 * The outer/inner {@link TemplateRef}s are then assembled into views like so:
 *
 * ```
 * <!-- ViewRef: outer-0 -->
 * Count: 2
 * <ul>
 *   <template view-container-ref></template>
 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
 * </ul>
 * <!-- /ViewRef: outer-0 -->
 * ```
 */
var EmbeddedViewRef = (function (_super) {
    __extends(EmbeddedViewRef, _super);
    function EmbeddedViewRef() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(EmbeddedViewRef.prototype, "context", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    ;
    return EmbeddedViewRef;
}(ViewRef));
exports.EmbeddedViewRef = EmbeddedViewRef;
var ViewRef_ = (function () {
    function ViewRef_(_view) {
        this._view = _view;
        this._view = _view;
    }
    Object.defineProperty(ViewRef_.prototype, "internalView", {
        get: function () { return this._view; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
        get: function () { return this._view.flatRootNodes; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "context", {
        get: function () { return this._view.context; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRef_.prototype, "destroyed", {
        get: function () { return this._view.destroyed; },
        enumerable: true,
        configurable: true
    });
    ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
    ViewRef_.prototype.detach = function () { this._view.cdMode = constants_1.ChangeDetectionStrategy.Detached; };
    ViewRef_.prototype.detectChanges = function () { this._view.detectChanges(false); };
    ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
    ViewRef_.prototype.reattach = function () {
        this._view.cdMode = constants_1.ChangeDetectionStrategy.CheckAlways;
        this.markForCheck();
    };
    ViewRef_.prototype.onDestroy = function (callback) { this._view.disposables.push(callback); };
    ViewRef_.prototype.destroy = function () { this._view.destroy(); };
    return ViewRef_;
}());
exports.ViewRef_ = ViewRef_;

},{"../../src/facade/exceptions":173,"../change_detection/constants":149}],190:[function(require,module,exports){
"use strict";
(function (ViewType) {
    // A view that contains the host element with bound component directive.
    // Contains a COMPONENT view
    ViewType[ViewType["HOST"] = 0] = "HOST";
    // The view of the component
    // Can contain 0 to n EMBEDDED views
    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
    // A view that is embedded into another View via a <template> element
    // inside of a COMPONENT view
    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
})(exports.ViewType || (exports.ViewType = {}));
var ViewType = exports.ViewType;

},{}],191:[function(require,module,exports){
"use strict";
var security_1 = require('../security');
var lang_1 = require('../../src/facade/lang');
var collection_1 = require('../../src/facade/collection');
var exceptions_1 = require('../../src/facade/exceptions');
var element_1 = require('./element');
var exceptions_2 = require('./exceptions');
var change_detection_1 = require('../change_detection/change_detection');
var api_1 = require('../render/api');
var application_tokens_1 = require('../application_tokens');
var decorators_1 = require('../di/decorators');
var change_detection_util_1 = require("../change_detection/change_detection_util");
var ViewUtils = (function () {
    function ViewUtils(_renderer, _appId, sanitizer) {
        this._renderer = _renderer;
        this._appId = _appId;
        this._nextCompTypeId = 0;
        this.sanitizer = sanitizer;
    }
    /**
     * Used by the generated code
     */
    ViewUtils.prototype.createRenderComponentType = function (templateUrl, slotCount, encapsulation, styles) {
        return new api_1.RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles);
    };
    /** @internal */
    ViewUtils.prototype.renderComponent = function (renderComponentType) {
        return this._renderer.renderComponent(renderComponentType);
    };
    ViewUtils.decorators = [
        { type: decorators_1.Injectable },
    ];
    ViewUtils.ctorParameters = [
        { type: api_1.RootRenderer, },
        { type: undefined, decorators: [{ type: decorators_1.Inject, args: [application_tokens_1.APP_ID,] },] },
        { type: security_1.SanitizationService, },
    ];
    return ViewUtils;
}());
exports.ViewUtils = ViewUtils;
function flattenNestedViewRenderNodes(nodes) {
    return _flattenNestedViewRenderNodes(nodes, []);
}
exports.flattenNestedViewRenderNodes = flattenNestedViewRenderNodes;
function _flattenNestedViewRenderNodes(nodes, renderNodes) {
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node instanceof element_1.AppElement) {
            var appEl = node;
            renderNodes.push(appEl.nativeElement);
            if (lang_1.isPresent(appEl.nestedViews)) {
                for (var k = 0; k < appEl.nestedViews.length; k++) {
                    _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
                }
            }
        }
        else {
            renderNodes.push(node);
        }
    }
    return renderNodes;
}
var EMPTY_ARR = [];
function ensureSlotCount(projectableNodes, expectedSlotCount) {
    var res;
    if (lang_1.isBlank(projectableNodes)) {
        res = EMPTY_ARR;
    }
    else if (projectableNodes.length < expectedSlotCount) {
        var givenSlotCount = projectableNodes.length;
        res = collection_1.ListWrapper.createFixedSize(expectedSlotCount);
        for (var i = 0; i < expectedSlotCount; i++) {
            res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
        }
    }
    else {
        res = projectableNodes;
    }
    return res;
}
exports.ensureSlotCount = ensureSlotCount;
exports.MAX_INTERPOLATION_VALUES = 9;
function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
    switch (valueCount) {
        case 1:
            return c0 + _toStringWithNull(a1) + c1;
        case 2:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
        case 3:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                c3;
        case 4:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                c3 + _toStringWithNull(a4) + c4;
        case 5:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
        case 6:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                c6;
        case 7:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                c6 + _toStringWithNull(a7) + c7;
        case 8:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
        case 9:
            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) +
                c9;
        default:
            throw new exceptions_1.BaseException("Does not support more than 9 expressions");
    }
}
exports.interpolate = interpolate;
function _toStringWithNull(v) {
    return v != null ? v.toString() : '';
}
function checkBinding(throwOnChange, oldValue, newValue) {
    if (throwOnChange) {
        if (!change_detection_1.devModeEqual(oldValue, newValue)) {
            throw new exceptions_2.ExpressionChangedAfterItHasBeenCheckedException(oldValue, newValue, null);
        }
        return false;
    }
    else {
        return !lang_1.looseIdentical(oldValue, newValue);
    }
}
exports.checkBinding = checkBinding;
function arrayLooseIdentical(a, b) {
    if (a.length != b.length)
        return false;
    for (var i = 0; i < a.length; ++i) {
        if (!lang_1.looseIdentical(a[i], b[i]))
            return false;
    }
    return true;
}
exports.arrayLooseIdentical = arrayLooseIdentical;
function mapLooseIdentical(m1, m2) {
    var k1 = collection_1.StringMapWrapper.keys(m1);
    var k2 = collection_1.StringMapWrapper.keys(m2);
    if (k1.length != k2.length) {
        return false;
    }
    var key;
    for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (!lang_1.looseIdentical(m1[key], m2[key])) {
            return false;
        }
    }
    return true;
}
exports.mapLooseIdentical = mapLooseIdentical;
function castByValue(input, value) {
    return input;
}
exports.castByValue = castByValue;
exports.EMPTY_ARRAY = [];
exports.EMPTY_MAP = {};
function pureProxy1(fn) {
    var result;
    var v0;
    v0 = change_detection_util_1.uninitialized;
    return function (p0) {
        if (!lang_1.looseIdentical(v0, p0)) {
            v0 = p0;
            result = fn(p0);
        }
        return result;
    };
}
exports.pureProxy1 = pureProxy1;
function pureProxy2(fn) {
    var result;
    var v0, v1;
    v0 = v1 = change_detection_util_1.uninitialized;
    return function (p0, p1) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1)) {
            v0 = p0;
            v1 = p1;
            result = fn(p0, p1);
        }
        return result;
    };
}
exports.pureProxy2 = pureProxy2;
function pureProxy3(fn) {
    var result;
    var v0, v1, v2;
    v0 = v1 = v2 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            result = fn(p0, p1, p2);
        }
        return result;
    };
}
exports.pureProxy3 = pureProxy3;
function pureProxy4(fn) {
    var result;
    var v0, v1, v2, v3;
    v0 = v1 = v2 = v3 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2, p3) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
            !lang_1.looseIdentical(v3, p3)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            v3 = p3;
            result = fn(p0, p1, p2, p3);
        }
        return result;
    };
}
exports.pureProxy4 = pureProxy4;
function pureProxy5(fn) {
    var result;
    var v0, v1, v2, v3, v4;
    v0 = v1 = v2 = v3 = v4 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2, p3, p4) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            v3 = p3;
            v4 = p4;
            result = fn(p0, p1, p2, p3, p4);
        }
        return result;
    };
}
exports.pureProxy5 = pureProxy5;
function pureProxy6(fn) {
    var result;
    var v0, v1, v2, v3, v4, v5;
    v0 = v1 = v2 = v3 = v4 = v5 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2, p3, p4, p5) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            v3 = p3;
            v4 = p4;
            v5 = p5;
            result = fn(p0, p1, p2, p3, p4, p5);
        }
        return result;
    };
}
exports.pureProxy6 = pureProxy6;
function pureProxy7(fn) {
    var result;
    var v0, v1, v2, v3, v4, v5, v6;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2, p3, p4, p5, p6) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
            !lang_1.looseIdentical(v6, p6)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            v3 = p3;
            v4 = p4;
            v5 = p5;
            v6 = p6;
            result = fn(p0, p1, p2, p3, p4, p5, p6);
        }
        return result;
    };
}
exports.pureProxy7 = pureProxy7;
function pureProxy8(fn) {
    var result;
    var v0, v1, v2, v3, v4, v5, v6, v7;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2, p3, p4, p5, p6, p7) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            v3 = p3;
            v4 = p4;
            v5 = p5;
            v6 = p6;
            v7 = p7;
            result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
        }
        return result;
    };
}
exports.pureProxy8 = pureProxy8;
function pureProxy9(fn) {
    var result;
    var v0, v1, v2, v3, v4, v5, v6, v7, v8;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            v3 = p3;
            v4 = p4;
            v5 = p5;
            v6 = p6;
            v7 = p7;
            v8 = p8;
            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
        }
        return result;
    };
}
exports.pureProxy9 = pureProxy9;
function pureProxy10(fn) {
    var result;
    var v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;
    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = change_detection_util_1.uninitialized;
    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
        if (!lang_1.looseIdentical(v0, p0) || !lang_1.looseIdentical(v1, p1) || !lang_1.looseIdentical(v2, p2) ||
            !lang_1.looseIdentical(v3, p3) || !lang_1.looseIdentical(v4, p4) || !lang_1.looseIdentical(v5, p5) ||
            !lang_1.looseIdentical(v6, p6) || !lang_1.looseIdentical(v7, p7) || !lang_1.looseIdentical(v8, p8) ||
            !lang_1.looseIdentical(v9, p9)) {
            v0 = p0;
            v1 = p1;
            v2 = p2;
            v3 = p3;
            v4 = p4;
            v5 = p5;
            v6 = p6;
            v7 = p7;
            v8 = p8;
            v9 = p9;
            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
        }
        return result;
    };
}
exports.pureProxy10 = pureProxy10;

},{"../../src/facade/collection":171,"../../src/facade/exceptions":173,"../../src/facade/lang":174,"../application_tokens":144,"../change_detection/change_detection":146,"../change_detection/change_detection_util":147,"../di/decorators":158,"../render/api":207,"../security":208,"./element":181,"./exceptions":184}],192:[function(require,module,exports){
"use strict";
/**
* This indirection is needed to free up Component, etc symbols in the public API
* to be used by the decorator versions of these annotations.
*/
var di_1 = require('./metadata/di');
exports.QueryMetadata = di_1.QueryMetadata;
exports.ContentChildrenMetadata = di_1.ContentChildrenMetadata;
exports.ContentChildMetadata = di_1.ContentChildMetadata;
exports.ViewChildrenMetadata = di_1.ViewChildrenMetadata;
exports.ViewQueryMetadata = di_1.ViewQueryMetadata;
exports.ViewChildMetadata = di_1.ViewChildMetadata;
exports.AttributeMetadata = di_1.AttributeMetadata;
var directives_1 = require('./metadata/directives');
exports.ComponentMetadata = directives_1.ComponentMetadata;
exports.DirectiveMetadata = directives_1.DirectiveMetadata;
exports.PipeMetadata = directives_1.PipeMetadata;
exports.InputMetadata = directives_1.InputMetadata;
exports.OutputMetadata = directives_1.OutputMetadata;
exports.HostBindingMetadata = directives_1.HostBindingMetadata;
exports.HostListenerMetadata = directives_1.HostListenerMetadata;
var view_1 = require('./metadata/view');
exports.ViewMetadata = view_1.ViewMetadata;
exports.ViewEncapsulation = view_1.ViewEncapsulation;
var di_2 = require('./metadata/di');
var directives_2 = require('./metadata/directives');
var view_2 = require('./metadata/view');
var decorators_1 = require('./util/decorators');
// TODO(alexeagle): remove the duplication of this doc. It is copied from ComponentMetadata.
/**
 * Declare reusable UI building blocks for an application.
 *
 * Each Angular component requires a single `@Component` annotation. The `@Component`
 * annotation specifies when a component is instantiated, and which properties and hostListeners it
 * binds to.
 *
 * When a component is instantiated, Angular
 * - creates a shadow DOM for the component.
 * - loads the selected template into the shadow DOM.
 * - creates all the injectable objects configured with `providers` and `viewProviders`.
 *
 * All template expressions and statements are then evaluated against the component instance.
 *
 * ## Lifecycle hooks
 *
 * When the component class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
 * are called by the change detection at defined points in time during the life of the component.
 *
 * ### Example
 *
 * {@example core/ts/metadata/metadata.ts region='component'}
 */
exports.Component = decorators_1.makeDecorator(directives_2.ComponentMetadata, function (fn) { return fn.View = View; });
// TODO(alexeagle): remove the duplication of this doc. It is copied from DirectiveMetadata.
/**
 * Directives allow you to attach behavior to elements in the DOM.
 *
 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
 *
 * A directive consists of a single directive annotation and a controller class. When the
 * directive's `selector` matches
 * elements in the DOM, the following steps occur:
 *
 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
 * arguments.
 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
 * depth-first order,
 *    as declared in the HTML.
 *
 * ## Understanding How Injection Works
 *
 * There are three stages of injection resolution.
 * - *Pre-existing Injectors*:
 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
 * the dependency was
 *     specified as `@Optional`, returns `null`.
 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
 * location, and others.
 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
 * the same parent-child hierarchy
 *     as the component instances in the DOM.
 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
 * element has an `ElementInjector`
 *     which follow the same parent-child hierarchy as the DOM elements themselves.
 *
 * When a template is instantiated, it also must instantiate the corresponding directives in a
 * depth-first order. The
 * current `ElementInjector` resolves the constructor dependencies for each directive.
 *
 * Angular then resolves dependencies as follows, according to the order in which they appear in the
 * {@link ViewMetadata}:
 *
 * 1. Dependencies on the current element
 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
 * 3. Dependencies on component injectors and their parents until it encounters the root component
 * 4. Dependencies on pre-existing injectors
 *
 *
 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
 * delegate to the parent
 * injector.
 *
 * To inject other directives, declare the constructor parameter as:
 * - `directive:DirectiveType`: a directive on the current element only
 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
 * element and the
 *    Shadow DOM root.
 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
 * directives.
 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
 * child directives.
 *
 * To inject element-specific special objects, declare the constructor parameter as:
 * - `element: ElementRef` to obtain a reference to logical element in the view.
 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
 * {@link DirectiveMetadata} directives only
 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
 *
 * ### Example
 *
 * The following example demonstrates how dependency injection resolves constructor arguments in
 * practice.
 *
 *
 * Assume this HTML template:
 *
 * ```
 * <div dependency="1">
 *   <div dependency="2">
 *     <div dependency="3" my-directive>
 *       <div dependency="4">
 *         <div dependency="5"></div>
 *       </div>
 *       <div dependency="6"></div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * With the following `dependency` decorator and `SomeService` injectable class.
 *
 * ```
 * @Injectable()
 * class SomeService {
 * }
 *
 * @Directive({
 *   selector: '[dependency]',
 *   inputs: [
 *     'id: dependency'
 *   ]
 * })
 * class Dependency {
 *   id:string;
 * }
 * ```
 *
 * Let's step through the different ways in which `MyDirective` could be declared...
 *
 *
 * ### No injection
 *
 * Here the constructor is declared with no arguments, therefore nothing is injected into
 * `MyDirective`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor() {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with no dependencies.
 *
 *
 * ### Component-level injection
 *
 * Directives can inject any injectable instance from the closest component injector or any of its
 * parents.
 *
 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
 * from the parent
 * component's injector.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(someService: SomeService) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a dependency on `SomeService`.
 *
 *
 * ### Injecting a directive from the current element
 *
 * Directives can inject other directives declared on the current element.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(dependency: Dependency) {
 *     expect(dependency.id).toEqual(3);
 *   }
 * }
 * ```
 * This directive would be instantiated with `Dependency` declared at the same element, in this case
 * `dependency="3"`.
 *
 * ### Injecting a directive from any ancestor elements
 *
 * Directives can inject other directives declared on any ancestor element (in the current Shadow
 * DOM), i.e. on the current element, the
 * parent element, or its parents.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Host() dependency: Dependency) {
 *     expect(dependency.id).toEqual(2);
 *   }
 * }
 * ```
 *
 * `@Host` checks the current element, the parent, as well as its parents recursively. If
 * `dependency="2"` didn't
 * exist on the direct parent, this injection would
 * have returned
 * `dependency="1"`.
 *
 *
 * ### Injecting a live collection of direct child directives
 *
 *
 * A directive can also query for other child directives. Since parent directives are instantiated
 * before child directives, a directive can't simply inject the list of child directives. Instead,
 * the directive injects a {@link QueryList}, which updates its contents as children are added,
 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
 * `ngIf`, or an `ngSwitch`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
 *
 * ### Injecting a live collection of descendant directives
 *
 * By passing the descendant flag to `@Query` above, we can include the children of the child
 * elements.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
 *
 * ### Optional injection
 *
 * The normal behavior of directives is to return an error when a specified dependency cannot be
 * resolved. If you
 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
 * with `@Optional()`.
 * This explicitly permits the author of a template to treat some of the surrounding directives as
 * optional.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Optional() dependency:Dependency) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a `Dependency` directive found on the current element.
 * If none can be
 * found, the injector supplies `null` instead of throwing an error.
 *
 * ### Example
 *
 * Here we use a decorator directive to simply define basic tool-tip behavior.
 *
 * ```
 * @Directive({
 *   selector: '[tooltip]',
 *   inputs: [
 *     'text: tooltip'
 *   ],
 *   host: {
 *     '(mouseenter)': 'onMouseEnter()',
 *     '(mouseleave)': 'onMouseLeave()'
 *   }
 * })
 * class Tooltip{
 *   text:string;
 *   overlay:Overlay; // NOT YET IMPLEMENTED
 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
 *
 *   constructor(overlayManager:OverlayManager) {
 *     this.overlay = overlay;
 *   }
 *
 *   onMouseEnter() {
 *     // exact signature to be determined
 *     this.overlay = this.overlayManager.open(text, ...);
 *   }
 *
 *   onMouseLeave() {
 *     this.overlay.close();
 *     this.overlay = null;
 *   }
 * }
 * ```
 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
 * `tooltip` selector,
 * like so:
 *
 * ```
 * <div tooltip="some text here"></div>
 * ```
 *
 * Directives can also control the instantiation, destruction, and positioning of inline template
 * elements:
 *
 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
 * runtime.
 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
 * location in the current view
 * where these actions are performed.
 *
 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
 * `<template>` element. Thus a
 * directive in a child view cannot inject the directive that created it.
 *
 * Since directives that create views via ViewContainers are common in Angular, and using the full
 * `<template>` element syntax is wordy, Angular
 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
 * equivalent.
 *
 * Thus,
 *
 * ```
 * <ul>
 *   <li *foo="bar" title="text"></li>
 * </ul>
 * ```
 *
 * Expands in use to:
 *
 * ```
 * <ul>
 *   <template [foo]="bar">
 *     <li title="text"></li>
 *   </template>
 * </ul>
 * ```
 *
 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
 * the directive
 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
 *
 * ## Lifecycle hooks
 *
 * When the directive class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
 * are called by the change detection at defined points in time during the life of the directive.
 *
 * ### Example
 *
 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
 *
 * Here is a simple directive that triggers on an `unless` selector:
 *
 * ```
 * @Directive({
 *   selector: '[unless]',
 *   inputs: ['unless']
 * })
 * export class Unless {
 *   viewContainer: ViewContainerRef;
 *   templateRef: TemplateRef;
 *   prevCondition: boolean;
 *
 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
 *     this.viewContainer = viewContainer;
 *     this.templateRef = templateRef;
 *     this.prevCondition = null;
 *   }
 *
 *   set unless(newCondition) {
 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
 *       this.prevCondition = true;
 *       this.viewContainer.clear();
 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
 *       this.prevCondition = false;
 *       this.viewContainer.create(this.templateRef);
 *     }
 *   }
 * }
 * ```
 *
 * We can then use this `unless` selector in a template:
 * ```
 * <ul>
 *   <li *unless="expr"></li>
 * </ul>
 * ```
 *
 * Once the directive instantiates the child view, the shorthand notation for the template expands
 * and the result is:
 *
 * ```
 * <ul>
 *   <template [unless]="exp">
 *     <li></li>
 *   </template>
 *   <li></li>
 * </ul>
 * ```
 *
 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
 * the instantiated
 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
 */
exports.Directive = decorators_1.makeDecorator(directives_2.DirectiveMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewMetadata.
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 */
var View = decorators_1.makeDecorator(view_2.ViewMetadata, function (fn) { return fn.View = View; });
/**
 * Specifies that a constant attribute value should be injected.
 *
 * The directive can inject constant string literals of host element attributes.
 *
 * ### Example
 *
 * Suppose we have an `<input>` element and want to know its `type`.
 *
 * ```html
 * <input type="text">
 * ```
 *
 * A decorator can inject string literal `text` like so:
 *
 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
 */
exports.Attribute = decorators_1.makeParamDecorator(di_2.AttributeMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from QueryMetadata.
/**
 * Declares an injectable parameter to be a live list of directives or variable
 * bindings from the content children of a directive.
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 *
 * Assume that `<tabs>` component would like to get a list its children `<pane>`
 * components as shown in this example:
 *
 * ```html
 * <tabs>
 *   <pane title="Overview">...</pane>
 *   <pane *ngFor="let o of objects" [title]="o.title">{{o.text}}</pane>
 * </tabs>
 * ```
 *
 * The preferred solution is to query for `Pane` directives using this decorator.
 *
 * ```javascript
 * @Component({
 *   selector: 'pane',
 *   inputs: ['title']
 * })
 * class Pane {
 *   title:string;
 * }
 *
 * @Component({
 *  selector: 'tabs',
 *  template: `
 *    <ul>
 *      <li *ngFor="let pane of panes">{{pane.title}}</li>
 *    </ul>
 *    <ng-content></ng-content>
 *  `
 * })
 * class Tabs {
 *   panes: QueryList<Pane>;
 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
 *     this.panes = panes;
 *   }
 * }
 * ```
 *
 * A query can look for variable bindings by passing in a string with desired binding symbol.
 *
 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
 * ```html
 * <seeker>
 *   <div #findme>...</div>
 * </seeker>
 *
 * @Component({ selector: 'seeker' })
 * class seeker {
 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * In this case the object that is injected depend on the type of the variable
 * binding. It can be an ElementRef, a directive or a component.
 *
 * Passing in a comma separated list of variable bindings will query for all of them.
 *
 * ```html
 * <seeker>
 *   <div #findMe>...</div>
 *   <div #findMeToo>...</div>
 * </seeker>
 *
 *  @Component({
 *   selector: 'seeker'
 * })
 * class Seeker {
 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * Configure whether query looks for direct children or all descendants
 * of the querying element, by using the `descendants` parameter.
 * It is set to `false` by default.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
 * ```html
 * <container #first>
 *   <item>a</item>
 *   <item>b</item>
 *   <container #second>
 *     <item>c</item>
 *   </container>
 * </container>
 * ```
 *
 * When querying for items, the first container will see only `a` and `b` by default,
 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
 *
 * The queried directives are kept in a depth-first pre-order with respect to their
 * positions in the DOM.
 *
 * Query does not look deep into any subcomponent views.
 *
 * Query is updated as part of the change-detection cycle. Since change detection
 * happens after construction of a directive, QueryList will always be empty when observed in the
 * constructor.
 *
 * The injected object is an unmodifiable live list.
 * See {@link QueryList} for more details.
 */
exports.Query = decorators_1.makeParamDecorator(di_2.QueryMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildrenMetadata.
/**
 * Configures a content query.
 *
 * Content queries are set before the `ngAfterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
 *
 *   ngAfterContentInit() {
 *     // contentChildren is set
 *   }
 * }
 * ```
 */
exports.ContentChildren = decorators_1.makePropDecorator(di_2.ContentChildrenMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildMetadata.
/**
 * Configures a content query.
 *
 * Content queries are set before the `ngAfterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChild(ChildDirective) contentChild;
 *
 *   ngAfterContentInit() {
 *     // contentChild is set
 *   }
 * }
 * ```
 */
exports.ContentChild = decorators_1.makePropDecorator(di_2.ContentChildMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildrenMetadata.
/**
 * Declares a list of child element references.
 *
 * Angular automatically updates the list when the DOM is updated.
 *
 * `ViewChildren` takes a argument to select elements.
 *
 * - If the argument is a type, directives or components with the type will be bound.
 *
 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
 * bound.
 *
 * View children are set before the `ngAfterViewInit` callback is called.
 *
 * ### Example
 *
 * With type selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: `
 *     <child-cmp></child-cmp>
 *     <child-cmp></child-cmp>
 *     <child-cmp></child-cmp>
 *   `,
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
 *
 *   ngAfterViewInit() {
 *     // children are set
 *     this.children.toArray().forEach((child)=>child.doSomething());
 *   }
 * }
 * ```
 *
 * With string selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: `
 *     <child-cmp #child1></child-cmp>
 *     <child-cmp #child2></child-cmp>
 *     <child-cmp #child3></child-cmp>
 *   `,
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
 *
 *   ngAfterViewInit() {
 *     // children are set
 *     this.children.toArray().forEach((child)=>child.doSomething());
 *   }
 * }
 * ```
 *
 * See also: [ViewChildrenMetadata]
 */
exports.ViewChildren = decorators_1.makePropDecorator(di_2.ViewChildrenMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildMetadata.
/**
 * Declares a reference to a child element.
 *
 * `ViewChildren` takes a argument to select elements.
 *
 * - If the argument is a type, a directive or a component with the type will be bound.
 *
 * - If the argument is a string, the string is interpreted as a selector. An element containing the
 * matching template variable (e.g. `#child`) will be bound.
 *
 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
 * multiple matches.
 *
 * View child is set before the `ngAfterViewInit` callback is called.
 *
 * ### Example
 *
 * With type selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: '<child-cmp></child-cmp>',
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChild(ChildCmp) child:ChildCmp;
 *
 *   ngAfterViewInit() {
 *     // child is set
 *     this.child.doSomething();
 *   }
 * }
 * ```
 *
 * With string selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: '<child-cmp #child></child-cmp>',
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChild('child') child:ChildCmp;
 *
 *   ngAfterViewInit() {
 *     // child is set
 *     this.child.doSomething();
 *   }
 * }
 * ```
 * See also: [ViewChildMetadata]
 */
exports.ViewChild = decorators_1.makePropDecorator(di_2.ViewChildMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewQueryMetadata.
/**
 * Similar to {@link QueryMetadata}, but querying the component view, instead of
 * the content children.
 *
 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
 *
 * ```javascript
 * @Component({
 *   ...,
 *   template: `
 *     <item> a </item>
 *     <item> b </item>
 *     <item> c </item>
 *   `
 * })
 * class MyComponent {
 *   shown: boolean;
 *
 *   constructor(private @Query(Item) items:QueryList<Item>) {
 *     items.changes.subscribe(() => console.log(items.length));
 *   }
 * }
 * ```
 *
 * Supports the same querying parameters as {@link QueryMetadata}, except
 * `descendants`. This always queries the whole view.
 *
 * As `shown` is flipped between true and false, items will contain zero of one
 * items.
 *
 * Specifies that a {@link QueryList} should be injected.
 *
 * The injected object is an iterable and observable live list.
 * See {@link QueryList} for more details.
 */
exports.ViewQuery = decorators_1.makeParamDecorator(di_2.ViewQueryMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from PipeMetadata.
/**
 * Declare reusable pipe function.
 *
 * ### Example
 *
 * {@example core/ts/metadata/metadata.ts region='pipe'}
 */
exports.Pipe = decorators_1.makeDecorator(directives_2.PipeMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from InputMetadata.
/**
 * Declares a data-bound input property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `InputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * The following example creates a component with two input properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{bankName}}
 *     Account Id: {{id}}
 *   `
 * })
 * class BankAccount {
 *   @Input() bankName: string;
 *   @Input('account-id') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `,
 *   directives: [BankAccount]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
exports.Input = decorators_1.makePropDecorator(directives_2.InputMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from OutputMetadata.
/**
 * Declares an event-bound output property.
 *
 * When an output property emits an event, an event handler attached to that event
 * the template is invoked.
 *
 * `OutputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * ```typescript
 * @Directive({
 *   selector: 'interval-dir',
 * })
 * class IntervalDir {
 *   @Output() everySecond = new EventEmitter();
 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
 *
 *   constructor() {
 *     setInterval(() => this.everySecond.emit("event"), 1000);
 *     setInterval(() => this.five5Secs.emit("event"), 5000);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
 *     </interval-dir>
 *   `,
 *   directives: [IntervalDir]
 * })
 * class App {
 *   everySecond() { console.log('second'); }
 *   everyFiveSeconds() { console.log('five seconds'); }
 * }
 * bootstrap(App);
 * ```
 */
exports.Output = decorators_1.makePropDecorator(directives_2.OutputMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from HostBindingMetadata.
/**
 * Declares a host property binding.
 *
 * Angular automatically checks host property bindings during change detection.
 * If a binding changes, it will update the host element of the directive.
 *
 * `HostBindingMetadata` takes an optional parameter that specifies the property
 * name of the host element that will be updated. When not provided,
 * the class property name is used.
 *
 * ### Example
 *
 * The following example creates a directive that sets the `valid` and `invalid` classes
 * on the DOM element that has ngModel directive on it.
 *
 * ```typescript
 * @Directive({selector: '[ngModel]'})
 * class NgModelStatus {
 *   constructor(public control:NgModel) {}
 *   @HostBinding('[class.valid]') get valid { return this.control.valid; }
 *   @HostBinding('[class.invalid]') get invalid { return this.control.invalid; }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<input [(ngModel)]="prop">`,
 *   directives: [FORM_DIRECTIVES, NgModelStatus]
 * })
 * class App {
 *   prop;
 * }
 *
 * bootstrap(App);
 * ```
 */
exports.HostBinding = decorators_1.makePropDecorator(directives_2.HostBindingMetadata);
// TODO(alexeagle): remove the duplication of this doc. It is copied from HostListenerMetadata.
/**
 * Declares a host listener.
 *
 * Angular will invoke the decorated method when the host element emits the specified event.
 *
 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
 * event.
 *
 * ### Example
 *
 * The following example declares a directive that attaches a click listener to the button and
 * counts clicks.
 *
 * ```typescript
 * @Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 *   @HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<button counting>Increment</button>`,
 *   directives: [CountClicks]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 */
exports.HostListener = decorators_1.makePropDecorator(directives_2.HostListenerMetadata);

},{"./metadata/di":193,"./metadata/directives":194,"./metadata/view":196,"./util/decorators":211}],193:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var metadata_1 = require('../di/metadata');
var forward_ref_1 = require('../di/forward_ref');
/**
 * Specifies that a constant attribute value should be injected.
 *
 * The directive can inject constant string literals of host element attributes.
 *
 * ### Example
 *
 * Suppose we have an `<input>` element and want to know its `type`.
 *
 * ```html
 * <input type="text">
 * ```
 *
 * A decorator can inject string literal `text` like so:
 *
 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
 * @ts2dart_const
 */
var AttributeMetadata = (function (_super) {
    __extends(AttributeMetadata, _super);
    function AttributeMetadata(attributeName) {
        _super.call(this);
        this.attributeName = attributeName;
    }
    Object.defineProperty(AttributeMetadata.prototype, "token", {
        get: function () {
            // Normally one would default a token to a type of an injected value but here
            // the type of a variable is "string" and we can't use primitive type as a return value
            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
            // account.
            return this;
        },
        enumerable: true,
        configurable: true
    });
    AttributeMetadata.prototype.toString = function () { return "@Attribute(" + lang_1.stringify(this.attributeName) + ")"; };
    return AttributeMetadata;
}(metadata_1.DependencyMetadata));
exports.AttributeMetadata = AttributeMetadata;
/**
 * Declares an injectable parameter to be a live list of directives or variable
 * bindings from the content children of a directive.
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 *
 * Assume that `<tabs>` component would like to get a list its children `<pane>`
 * components as shown in this example:
 *
 * ```html
 * <tabs>
 *   <pane title="Overview">...</pane>
 *   <pane *ngFor="let o of objects" [title]="o.title">{{o.text}}</pane>
 * </tabs>
 * ```
 *
 * The preferred solution is to query for `Pane` directives using this decorator.
 *
 * ```javascript
 * @Component({
 *   selector: 'pane',
 *   inputs: ['title']
 * })
 * class Pane {
 *   title:string;
 * }
 *
 * @Component({
 *  selector: 'tabs',
 *  template: `
 *    <ul>
 *      <li *ngFor="let pane of panes">{{pane.title}}</li>
 *    </ul>
 *    <ng-content></ng-content>
 *  `
 * })
 * class Tabs {
 *   panes: QueryList<Pane>;
 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
  *    this.panes = panes;
  *  }
 * }
 * ```
 *
 * A query can look for variable bindings by passing in a string with desired binding symbol.
 *
 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
 * ```html
 * <seeker>
 *   <div #findme>...</div>
 * </seeker>
 *
 * @Component({ selector: 'seeker' })
 * class Seeker {
 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * In this case the object that is injected depend on the type of the variable
 * binding. It can be an ElementRef, a directive or a component.
 *
 * Passing in a comma separated list of variable bindings will query for all of them.
 *
 * ```html
 * <seeker>
 *   <div #find-me>...</div>
 *   <div #find-me-too>...</div>
 * </seeker>
 *
 *  @Component({
 *   selector: 'seeker'
 * })
 * class Seeker {
 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
 * }
 * ```
 *
 * Configure whether query looks for direct children or all descendants
 * of the querying element, by using the `descendants` parameter.
 * It is set to `false` by default.
 *
 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
 * ```html
 * <container #first>
 *   <item>a</item>
 *   <item>b</item>
 *   <container #second>
 *     <item>c</item>
 *   </container>
 * </container>
 * ```
 *
 * When querying for items, the first container will see only `a` and `b` by default,
 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
 *
 * The queried directives are kept in a depth-first pre-order with respect to their
 * positions in the DOM.
 *
 * Query does not look deep into any subcomponent views.
 *
 * Query is updated as part of the change-detection cycle. Since change detection
 * happens after construction of a directive, QueryList will always be empty when observed in the
 * constructor.
 *
 * The injected object is an unmodifiable live list.
 * See {@link QueryList} for more details.
 * @ts2dart_const
 */
var QueryMetadata = (function (_super) {
    __extends(QueryMetadata, _super);
    function QueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d, _e = _b.read, read = _e === void 0 ? null : _e;
        _super.call(this);
        this._selector = _selector;
        this.descendants = descendants;
        this.first = first;
        this.read = read;
    }
    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
        /**
         * always `false` to differentiate it with {@link ViewQueryMetadata}.
         */
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "selector", {
        /**
         * what this is querying for.
         */
        get: function () { return forward_ref_1.resolveForwardRef(this._selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
        /**
         * whether this is querying for a variable binding or a directive.
         */
        get: function () { return lang_1.isString(this.selector); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
        /**
         * returns a list of variable bindings this is querying for.
         * Only applicable if this is a variable bindings query.
         */
        get: function () { return this.selector.split(','); },
        enumerable: true,
        configurable: true
    });
    QueryMetadata.prototype.toString = function () { return "@Query(" + lang_1.stringify(this.selector) + ")"; };
    return QueryMetadata;
}(metadata_1.DependencyMetadata));
exports.QueryMetadata = QueryMetadata;
// TODO: add an example after ContentChildren and ViewChildren are in master
/**
 * Configures a content query.
 *
 * Content queries are set before the `ngAfterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
 *
 *   ngAfterContentInit() {
 *     // contentChildren is set
 *   }
 * }
 * ```
 * @ts2dart_const
 */
var ContentChildrenMetadata = (function (_super) {
    __extends(ContentChildrenMetadata, _super);
    function ContentChildrenMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.read, read = _d === void 0 ? null : _d;
        _super.call(this, _selector, { descendants: descendants, read: read });
    }
    return ContentChildrenMetadata;
}(QueryMetadata));
exports.ContentChildrenMetadata = ContentChildrenMetadata;
// TODO: add an example after ContentChild and ViewChild are in master
/**
 * Configures a content query.
 *
 * Content queries are set before the `ngAfterContentInit` callback is called.
 *
 * ### Example
 *
 * ```
 * @Directive({
 *   selector: 'someDir'
 * })
 * class SomeDir {
 *   @ContentChild(ChildDirective) contentChild;
 *
 *   ngAfterContentInit() {
 *     // contentChild is set
 *   }
 * }
 * ```
 * @ts2dart_const
 */
var ContentChildMetadata = (function (_super) {
    __extends(ContentChildMetadata, _super);
    function ContentChildMetadata(_selector, _a) {
        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
        _super.call(this, _selector, { descendants: true, first: true, read: read });
    }
    return ContentChildMetadata;
}(QueryMetadata));
exports.ContentChildMetadata = ContentChildMetadata;
/**
 * Similar to {@link QueryMetadata}, but querying the component view, instead of
 * the content children.
 *
 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
 *
 * ```javascript
 * @Component({
 *   ...,
 *   template: `
 *     <item> a </item>
 *     <item> b </item>
 *     <item> c </item>
 *   `
 * })
 * class MyComponent {
 *   shown: boolean;
 *
 *   constructor(private @ViewQuery(Item) items:QueryList<Item>) {
 *     items.changes.subscribe(() => console.log(items.length));
 *   }
 * }
 * ```
 *
 * Supports the same querying parameters as {@link QueryMetadata}, except
 * `descendants`. This always queries the whole view.
 *
 * As `shown` is flipped between true and false, items will contain zero of one
 * items.
 *
 * Specifies that a {@link QueryList} should be injected.
 *
 * The injected object is an iterable and observable live list.
 * See {@link QueryList} for more details.
 * @ts2dart_const
 */
var ViewQueryMetadata = (function (_super) {
    __extends(ViewQueryMetadata, _super);
    function ViewQueryMetadata(_selector, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.descendants, descendants = _c === void 0 ? false : _c, _d = _b.first, first = _d === void 0 ? false : _d, _e = _b.read, read = _e === void 0 ? null : _e;
        _super.call(this, _selector, { descendants: descendants, first: first, read: read });
    }
    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
        /**
         * always `true` to differentiate it with {@link QueryMetadata}.
         */
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    ViewQueryMetadata.prototype.toString = function () { return "@ViewQuery(" + lang_1.stringify(this.selector) + ")"; };
    return ViewQueryMetadata;
}(QueryMetadata));
exports.ViewQueryMetadata = ViewQueryMetadata;
/**
 * Declares a list of child element references.
 *
 * Angular automatically updates the list when the DOM is updated.
 *
 * `ViewChildren` takes an argument to select elements.
 *
 * - If the argument is a type, directives or components with the type will be bound.
 *
 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
 * bound.
 *
 * View children are set before the `ngAfterViewInit` callback is called.
 *
 * ### Example
 *
 * With type selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: `
 *     <child-cmp></child-cmp>
 *     <child-cmp></child-cmp>
 *     <child-cmp></child-cmp>
 *   `,
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
 *
 *   ngAfterViewInit() {
 *     // children are set
 *     this.children.toArray().forEach((child)=>child.doSomething());
 *   }
 * }
 * ```
 *
 * With string selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: `
 *     <child-cmp #child1></child-cmp>
 *     <child-cmp #child2></child-cmp>
 *     <child-cmp #child3></child-cmp>
 *   `,
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
 *
 *   ngAfterViewInit() {
 *     // children are set
 *     this.children.toArray().forEach((child)=>child.doSomething());
 *   }
 * }
 * ```
 * @ts2dart_const
 */
var ViewChildrenMetadata = (function (_super) {
    __extends(ViewChildrenMetadata, _super);
    function ViewChildrenMetadata(_selector, _a) {
        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
        _super.call(this, _selector, { descendants: true, read: read });
    }
    return ViewChildrenMetadata;
}(ViewQueryMetadata));
exports.ViewChildrenMetadata = ViewChildrenMetadata;
/**
 *
 * Declares a reference of child element.
 *
 * `ViewChildren` takes an argument to select elements.
 *
 * - If the argument is a type, a directive or a component with the type will be bound.
 *
 If the argument is a string, the string is interpreted as a selector. An element containing the
 matching template variable (e.g. `#child`) will be bound.
 *
 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
 multiple matches.
 *
 * View child is set before the `ngAfterViewInit` callback is called.
 *
 * ### Example
 *
 * With type selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: '<child-cmp></child-cmp>',
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChild(ChildCmp) child:ChildCmp;
 *
 *   ngAfterViewInit() {
 *     // child is set
 *     this.child.doSomething();
 *   }
 * }
 * ```
 *
 * With string selector:
 *
 * ```
 * @Component({
 *   selector: 'child-cmp',
 *   template: '<p>child</p>'
 * })
 * class ChildCmp {
 *   doSomething() {}
 * }
 *
 * @Component({
 *   selector: 'some-cmp',
 *   template: '<child-cmp #child></child-cmp>',
 *   directives: [ChildCmp]
 * })
 * class SomeCmp {
 *   @ViewChild('child') child:ChildCmp;
 *
 *   ngAfterViewInit() {
 *     // child is set
 *     this.child.doSomething();
 *   }
 * }
 * ```
 * @ts2dart_const
 */
var ViewChildMetadata = (function (_super) {
    __extends(ViewChildMetadata, _super);
    function ViewChildMetadata(_selector, _a) {
        var _b = (_a === void 0 ? {} : _a).read, read = _b === void 0 ? null : _b;
        _super.call(this, _selector, { descendants: true, first: true, read: read });
    }
    return ViewChildMetadata;
}(ViewQueryMetadata));
exports.ViewChildMetadata = ViewChildMetadata;

},{"../../src/facade/lang":174,"../di/forward_ref":159,"../di/metadata":161}],194:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var metadata_1 = require('../di/metadata');
var constants_1 = require('../change_detection/constants');
/**
 * Directives allow you to attach behavior to elements in the DOM.
 *
 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
 *
 * A directive consists of a single directive annotation and a controller class. When the
 * directive's `selector` matches
 * elements in the DOM, the following steps occur:
 *
 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
 * arguments.
 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
 * depth-first order,
 *    as declared in the HTML.
 *
 * ## Understanding How Injection Works
 *
 * There are three stages of injection resolution.
 * - *Pre-existing Injectors*:
 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
 * the dependency was
 *     specified as `@Optional`, returns `null`.
 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
 * location, and others.
 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
 * the same parent-child hierarchy
 *     as the component instances in the DOM.
 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
 * element has an `ElementInjector`
 *     which follow the same parent-child hierarchy as the DOM elements themselves.
 *
 * When a template is instantiated, it also must instantiate the corresponding directives in a
 * depth-first order. The
 * current `ElementInjector` resolves the constructor dependencies for each directive.
 *
 * Angular then resolves dependencies as follows, according to the order in which they appear in the
 * {@link ViewMetadata}:
 *
 * 1. Dependencies on the current element
 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
 * 3. Dependencies on component injectors and their parents until it encounters the root component
 * 4. Dependencies on pre-existing injectors
 *
 *
 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
 * delegate to the parent
 * injector.
 *
 * To inject other directives, declare the constructor parameter as:
 * - `directive:DirectiveType`: a directive on the current element only
 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
 * element and the
 *    Shadow DOM root.
 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
 * directives.
 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
 * child directives.
 *
 * To inject element-specific special objects, declare the constructor parameter as:
 * - `element: ElementRef` to obtain a reference to logical element in the view.
 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
 * {@link DirectiveMetadata} directives only
 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
 *
 * ### Example
 *
 * The following example demonstrates how dependency injection resolves constructor arguments in
 * practice.
 *
 *
 * Assume this HTML template:
 *
 * ```
 * <div dependency="1">
 *   <div dependency="2">
 *     <div dependency="3" my-directive>
 *       <div dependency="4">
 *         <div dependency="5"></div>
 *       </div>
 *       <div dependency="6"></div>
 *     </div>
 *   </div>
 * </div>
 * ```
 *
 * With the following `dependency` decorator and `SomeService` injectable class.
 *
 * ```
 * @Injectable()
 * class SomeService {
 * }
 *
 * @Directive({
 *   selector: '[dependency]',
 *   inputs: [
 *     'id: dependency'
 *   ]
 * })
 * class Dependency {
 *   id:string;
 * }
 * ```
 *
 * Let's step through the different ways in which `MyDirective` could be declared...
 *
 *
 * ### No injection
 *
 * Here the constructor is declared with no arguments, therefore nothing is injected into
 * `MyDirective`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor() {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with no dependencies.
 *
 *
 * ### Component-level injection
 *
 * Directives can inject any injectable instance from the closest component injector or any of its
 * parents.
 *
 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
 * from the parent
 * component's injector.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(someService: SomeService) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a dependency on `SomeService`.
 *
 *
 * ### Injecting a directive from the current element
 *
 * Directives can inject other directives declared on the current element.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(dependency: Dependency) {
 *     expect(dependency.id).toEqual(3);
 *   }
 * }
 * ```
 * This directive would be instantiated with `Dependency` declared at the same element, in this case
 * `dependency="3"`.
 *
 * ### Injecting a directive from any ancestor elements
 *
 * Directives can inject other directives declared on any ancestor element (in the current Shadow
 * DOM), i.e. on the current element, the
 * parent element, or its parents.
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Host() dependency: Dependency) {
 *     expect(dependency.id).toEqual(2);
 *   }
 * }
 * ```
 *
 * `@Host` checks the current element, the parent, as well as its parents recursively. If
 * `dependency="2"` didn't
 * exist on the direct parent, this injection would
 * have returned
 * `dependency="1"`.
 *
 *
 * ### Injecting a live collection of direct child directives
 *
 *
 * A directive can also query for other child directives. Since parent directives are instantiated
 * before child directives, a directive can't simply inject the list of child directives. Instead,
 * the directive injects a {@link QueryList}, which updates its contents as children are added,
 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
 * `ngIf`, or an `ngSwitch`.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
 * `Dependency` 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
 *
 * ### Injecting a live collection of descendant directives
 *
 * By passing the descendant flag to `@Query` above, we can include the children of the child
 * elements.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
 *
 * ### Optional injection
 *
 * The normal behavior of directives is to return an error when a specified dependency cannot be
 * resolved. If you
 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
 * with `@Optional()`.
 * This explicitly permits the author of a template to treat some of the surrounding directives as
 * optional.
 *
 * ```
 * @Directive({ selector: '[my-directive]' })
 * class MyDirective {
 *   constructor(@Optional() dependency:Dependency) {
 *   }
 * }
 * ```
 *
 * This directive would be instantiated with a `Dependency` directive found on the current element.
 * If none can be
 * found, the injector supplies `null` instead of throwing an error.
 *
 * ### Example
 *
 * Here we use a decorator directive to simply define basic tool-tip behavior.
 *
 * ```
 * @Directive({
 *   selector: '[tooltip]',
 *   inputs: [
 *     'text: tooltip'
 *   ],
 *   host: {
 *     '(mouseenter)': 'onMouseEnter()',
 *     '(mouseleave)': 'onMouseLeave()'
 *   }
 * })
 * class Tooltip{
 *   text:string;
 *   overlay:Overlay; // NOT YET IMPLEMENTED
 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
 *
 *   constructor(overlayManager:OverlayManager) {
 *     this.overlay = overlay;
 *   }
 *
 *   onMouseEnter() {
 *     // exact signature to be determined
 *     this.overlay = this.overlayManager.open(text, ...);
 *   }
 *
 *   onMouseLeave() {
 *     this.overlay.close();
 *     this.overlay = null;
 *   }
 * }
 * ```
 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
 * `tooltip` selector,
 * like so:
 *
 * ```
 * <div tooltip="some text here"></div>
 * ```
 *
 * Directives can also control the instantiation, destruction, and positioning of inline template
 * elements:
 *
 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
 * runtime.
 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
 * location in the current view
 * where these actions are performed.
 *
 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
 * `<template>` element. Thus a
 * directive in a child view cannot inject the directive that created it.
 *
 * Since directives that create views via ViewContainers are common in Angular, and using the full
 * `<template>` element syntax is wordy, Angular
 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
 * equivalent.
 *
 * Thus,
 *
 * ```
 * <ul>
 *   <li *foo="bar" title="text"></li>
 * </ul>
 * ```
 *
 * Expands in use to:
 *
 * ```
 * <ul>
 *   <template [foo]="bar">
 *     <li title="text"></li>
 *   </template>
 * </ul>
 * ```
 *
 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
 * the directive
 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
 *
 * ## Lifecycle hooks
 *
 * When the directive class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
 * are called by the change detection at defined points in time during the life of the directive.
 *
 * ### Example
 *
 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
 *
 * Here is a simple directive that triggers on an `unless` selector:
 *
 * ```
 * @Directive({
 *   selector: '[unless]',
 *   inputs: ['unless']
 * })
 * export class Unless {
 *   viewContainer: ViewContainerRef;
 *   templateRef: TemplateRef;
 *   prevCondition: boolean;
 *
 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
 *     this.viewContainer = viewContainer;
 *     this.templateRef = templateRef;
 *     this.prevCondition = null;
 *   }
 *
 *   set unless(newCondition) {
 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
 *       this.prevCondition = true;
 *       this.viewContainer.clear();
 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
 *       this.prevCondition = false;
 *       this.viewContainer.create(this.templateRef);
 *     }
 *   }
 * }
 * ```
 *
 * We can then use this `unless` selector in a template:
 * ```
 * <ul>
 *   <li *unless="expr"></li>
 * </ul>
 * ```
 *
 * Once the directive instantiates the child view, the shorthand notation for the template expands
 * and the result is:
 *
 * ```
 * <ul>
 *   <template [unless]="exp">
 *     <li></li>
 *   </template>
 *   <li></li>
 * </ul>
 * ```
 *
 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
 * the instantiated
 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
 * @ts2dart_const
 */
var DirectiveMetadata = (function (_super) {
    __extends(DirectiveMetadata, _super);
    function DirectiveMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, bindings = _b.bindings, providers = _b.providers, exportAs = _b.exportAs, queries = _b.queries;
        _super.call(this);
        this.selector = selector;
        this._inputs = inputs;
        this._properties = properties;
        this._outputs = outputs;
        this._events = events;
        this.host = host;
        this.exportAs = exportAs;
        this.queries = queries;
        this._providers = providers;
        this._bindings = bindings;
    }
    Object.defineProperty(DirectiveMetadata.prototype, "inputs", {
        /**
         * Enumerates the set of data-bound input properties for a directive
         *
         * Angular automatically updates input properties during change detection.
         *
         * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property where the value is written.
         * - `bindingProperty` specifies the DOM property where the value is read from.
         *
         * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
         *
         * The following example creates a component with two data-bound properties.
         *
         * ```typescript
         * @Component({
         *   selector: 'bank-account',
         *   inputs: ['bankName', 'id: account-id'],
         *   template: `
         *     Bank Name: {{bankName}}
         *     Account Id: {{id}}
         *   `
         * })
         * class BankAccount {
         *   bankName: string;
         *   id: string;
         *
         *   // this property is not bound, and won't be automatically updated by Angular
         *   normalizedBankName: string;
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
         *   `,
         *   directives: [BankAccount]
         * })
         * class App {}
         *
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return lang_1.isPresent(this._properties) && this._properties.length > 0 ? this._properties :
                this._inputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "properties", {
        get: function () { return this.inputs; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "outputs", {
        /**
         * Enumerates the set of event-bound output properties.
         *
         * When an output property emits an event, an event handler attached to that event
         * the template is invoked.
         *
         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
         * configuration:
         *
         * - `directiveProperty` specifies the component property that emits events.
         * - `bindingProperty` specifies the DOM property the event handler is attached to.
         *
         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
         *
         * ```typescript
         * @Directive({
         *   selector: 'interval-dir',
         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
         * })
         * class IntervalDir {
         *   everySecond = new EventEmitter();
         *   five5Secs = new EventEmitter();
         *
         *   constructor() {
         *     setInterval(() => this.everySecond.emit("event"), 1000);
         *     setInterval(() => this.five5Secs.emit("event"), 5000);
         *   }
         * }
         *
         * @Component({
         *   selector: 'app',
         *   template: `
         *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
         *     </interval-dir>
         *   `,
         *   directives: [IntervalDir]
         * })
         * class App {
         *   everySecond() { console.log('second'); }
         *   everyFiveSeconds() { console.log('five seconds'); }
         * }
         * bootstrap(App);
         * ```
         *
         */
        get: function () {
            return lang_1.isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "events", {
        get: function () { return this.outputs; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "providers", {
        /**
         * Defines the set of injectable objects that are visible to a Directive and its light DOM
         * children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'greet',
         *   bindings: [
         *     Greeter
         *   ]
         * })
         * class HelloWorld {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         * ```
         */
        get: function () {
            return lang_1.isPresent(this._bindings) && this._bindings.length > 0 ? this._bindings :
                this._providers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectiveMetadata.prototype, "bindings", {
        /** @deprecated */
        get: function () { return this.providers; },
        enumerable: true,
        configurable: true
    });
    return DirectiveMetadata;
}(metadata_1.InjectableMetadata));
exports.DirectiveMetadata = DirectiveMetadata;
/**
 * Declare reusable UI building blocks for an application.
 *
 * Each Angular component requires a single `@Component` annotation. The
 * `@Component`
 * annotation specifies when a component is instantiated, and which properties and hostListeners it
 * binds to.
 *
 * When a component is instantiated, Angular
 * - creates a shadow DOM for the component.
 * - loads the selected template into the shadow DOM.
 * - creates all the injectable objects configured with `providers` and `viewProviders`.
 *
 * All template expressions and statements are then evaluated against the component instance.
 *
 * For details on the `@View` annotation, see {@link ViewMetadata}.
 *
 * ## Lifecycle hooks
 *
 * When the component class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
 * are called by the change detection at defined points in time during the life of the component.
 *
 * ### Example
 *
 * {@example core/ts/metadata/metadata.ts region='component'}
 * @ts2dart_const
 */
var ComponentMetadata = (function (_super) {
    __extends(ComponentMetadata, _super);
    function ComponentMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, selector = _b.selector, inputs = _b.inputs, outputs = _b.outputs, properties = _b.properties, events = _b.events, host = _b.host, exportAs = _b.exportAs, moduleId = _b.moduleId, bindings = _b.bindings, providers = _b.providers, viewBindings = _b.viewBindings, viewProviders = _b.viewProviders, _c = _b.changeDetection, changeDetection = _c === void 0 ? constants_1.ChangeDetectionStrategy.Default : _c, queries = _b.queries, templateUrl = _b.templateUrl, template = _b.template, styleUrls = _b.styleUrls, styles = _b.styles, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation;
        _super.call(this, {
            selector: selector,
            inputs: inputs,
            outputs: outputs,
            properties: properties,
            events: events,
            host: host,
            exportAs: exportAs,
            bindings: bindings,
            providers: providers,
            queries: queries
        });
        this.changeDetection = changeDetection;
        this._viewProviders = viewProviders;
        this._viewBindings = viewBindings;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.pipes = pipes;
        this.encapsulation = encapsulation;
        this.moduleId = moduleId;
    }
    Object.defineProperty(ComponentMetadata.prototype, "viewProviders", {
        /**
         * Defines the set of injectable objects that are visible to its view DOM children.
         *
         * ## Simple Example
         *
         * Here is an example of a class that can be injected:
         *
         * ```
         * class Greeter {
         *    greet(name:string) {
         *      return 'Hello ' + name + '!';
         *    }
         * }
         *
         * @Directive({
         *   selector: 'needs-greeter'
         * })
         * class NeedsGreeter {
         *   greeter:Greeter;
         *
         *   constructor(greeter:Greeter) {
         *     this.greeter = greeter;
         *   }
         * }
         *
         * @Component({
         *   selector: 'greet',
         *   viewProviders: [
         *     Greeter
         *   ],
         *   template: `<needs-greeter></needs-greeter>`,
         *   directives: [NeedsGreeter]
         * })
         * class HelloWorld {
         * }
         *
         * ```
         */
        get: function () {
            return lang_1.isPresent(this._viewBindings) && this._viewBindings.length > 0 ? this._viewBindings :
                this._viewProviders;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ComponentMetadata.prototype, "viewBindings", {
        get: function () { return this.viewProviders; },
        enumerable: true,
        configurable: true
    });
    return ComponentMetadata;
}(DirectiveMetadata));
exports.ComponentMetadata = ComponentMetadata;
/**
 * Declare reusable pipe function.
 *
 * A "pure" pipe is only re-evaluated when either the input or any of the arguments change.
 *
 * When not specified, pipes default to being pure.
 *
 * ### Example
 *
 * {@example core/ts/metadata/metadata.ts region='pipe'}
 * @ts2dart_const
 */
var PipeMetadata = (function (_super) {
    __extends(PipeMetadata, _super);
    function PipeMetadata(_a) {
        var name = _a.name, pure = _a.pure;
        _super.call(this);
        this.name = name;
        this._pure = pure;
    }
    Object.defineProperty(PipeMetadata.prototype, "pure", {
        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },
        enumerable: true,
        configurable: true
    });
    return PipeMetadata;
}(metadata_1.InjectableMetadata));
exports.PipeMetadata = PipeMetadata;
/**
 * Declares a data-bound input property.
 *
 * Angular automatically updates data-bound properties during change detection.
 *
 * `InputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * The following example creates a component with two input properties.
 *
 * ```typescript
 * @Component({
 *   selector: 'bank-account',
 *   template: `
 *     Bank Name: {{bankName}}
 *     Account Id: {{id}}
 *   `
 * })
 * class BankAccount {
 *   @Input() bankName: string;
 *   @Input('account-id') id: string;
 *
 *   // this property is not bound, and won't be automatically updated by Angular
 *   normalizedBankName: string;
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
 *   `,
 *   directives: [BankAccount]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 * @ts2dart_const
 */
var InputMetadata = (function () {
    function InputMetadata(
        /**
         * Name used when instantiating a component in the template.
         */
        bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    return InputMetadata;
}());
exports.InputMetadata = InputMetadata;
/**
 * Declares an event-bound output property.
 *
 * When an output property emits an event, an event handler attached to that event
 * the template is invoked.
 *
 * `OutputMetadata` takes an optional parameter that specifies the name
 * used when instantiating a component in the template. When not provided,
 * the name of the decorated property is used.
 *
 * ### Example
 *
 * ```typescript
 * @Directive({
 *   selector: 'interval-dir',
 * })
 * class IntervalDir {
 *   @Output() everySecond = new EventEmitter();
 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
 *
 *   constructor() {
 *     setInterval(() => this.everySecond.emit("event"), 1000);
 *     setInterval(() => this.five5Secs.emit("event"), 5000);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `
 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
 *     </interval-dir>
 *   `,
 *   directives: [IntervalDir]
 * })
 * class App {
 *   everySecond() { console.log('second'); }
 *   everyFiveSeconds() { console.log('five seconds'); }
 * }
 * bootstrap(App);
 * ```
 * @ts2dart_const
 */
var OutputMetadata = (function () {
    function OutputMetadata(bindingPropertyName) {
        this.bindingPropertyName = bindingPropertyName;
    }
    return OutputMetadata;
}());
exports.OutputMetadata = OutputMetadata;
/**
 * Declares a host property binding.
 *
 * Angular automatically checks host property bindings during change detection.
 * If a binding changes, it will update the host element of the directive.
 *
 * `HostBindingMetadata` takes an optional parameter that specifies the property
 * name of the host element that will be updated. When not provided,
 * the class property name is used.
 *
 * ### Example
 *
 * The following example creates a directive that sets the `valid` and `invalid` classes
 * on the DOM element that has ngModel directive on it.
 *
 * ```typescript
 * @Directive({selector: '[ngModel]'})
 * class NgModelStatus {
 *   constructor(public control:NgModel) {}
 *   @HostBinding('class.valid') get valid { return this.control.valid; }
 *   @HostBinding('class.invalid') get invalid { return this.control.invalid; }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<input [(ngModel)]="prop">`,
 *   directives: [FORM_DIRECTIVES, NgModelStatus]
 * })
 * class App {
 *   prop;
 * }
 *
 * bootstrap(App);
 * ```
 * @ts2dart_const
 */
var HostBindingMetadata = (function () {
    function HostBindingMetadata(hostPropertyName) {
        this.hostPropertyName = hostPropertyName;
    }
    return HostBindingMetadata;
}());
exports.HostBindingMetadata = HostBindingMetadata;
/**
 * Declares a host listener.
 *
 * Angular will invoke the decorated method when the host element emits the specified event.
 *
 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
 * event.
 *
 * ### Example
 *
 * The following example declares a directive that attaches a click listener to the button and
 * counts clicks.
 *
 * ```typescript
 * @Directive({selector: 'button[counting]'})
 * class CountClicks {
 *   numberOfClicks = 0;
 *
 *   @HostListener('click', ['$event.target'])
 *   onClick(btn) {
 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
 *   }
 * }
 *
 * @Component({
 *   selector: 'app',
 *   template: `<button counting>Increment</button>`,
 *   directives: [CountClicks]
 * })
 * class App {}
 *
 * bootstrap(App);
 * ```
 * @ts2dart_const
 */
var HostListenerMetadata = (function () {
    function HostListenerMetadata(eventName, args) {
        this.eventName = eventName;
        this.args = args;
    }
    return HostListenerMetadata;
}());
exports.HostListenerMetadata = HostListenerMetadata;

},{"../../src/facade/lang":174,"../change_detection/constants":149,"../di/metadata":161}],195:[function(require,module,exports){
"use strict";
(function (LifecycleHooks) {
    LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
    LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
    LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
    LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
    LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
    LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
    LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
    LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
})(exports.LifecycleHooks || (exports.LifecycleHooks = {}));
var LifecycleHooks = exports.LifecycleHooks;
/**
 * @internal
 */
exports.LIFECYCLE_HOOKS_VALUES = [
    LifecycleHooks.OnInit,
    LifecycleHooks.OnDestroy,
    LifecycleHooks.DoCheck,
    LifecycleHooks.OnChanges,
    LifecycleHooks.AfterContentInit,
    LifecycleHooks.AfterContentChecked,
    LifecycleHooks.AfterViewInit,
    LifecycleHooks.AfterViewChecked
];

},{}],196:[function(require,module,exports){
"use strict";
/**
 * Defines template and style encapsulation options available for Component's {@link View}.
 *
 * See {@link ViewMetadata#encapsulation}.
 */
(function (ViewEncapsulation) {
    /**
     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
     * Element and pre-processing the style rules provided via
     * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
     * attribute to all selectors.
     *
     * This is the default option.
     */
    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
    /**
     * Use the native encapsulation mechanism of the renderer.
     *
     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
     * creating a ShadowRoot for Component's Host Element.
     */
    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
    /**
     * Don't provide any template or style encapsulation.
     */
    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
var ViewEncapsulation = exports.ViewEncapsulation;
exports.VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];
/**
 * Metadata properties available for configuring Views.
 *
 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
 * within the template.
 *
 * When a component is instantiated, the template is loaded into the component's shadow root, and
 * the expressions and statements in the template are evaluated against the component.
 *
 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 *   directives: [GreetUser, Bold]
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 * @ts2dart_const
 */
var ViewMetadata = (function () {
    function ViewMetadata(_a) {
        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.pipes = pipes;
        this.encapsulation = encapsulation;
    }
    return ViewMetadata;
}());
exports.ViewMetadata = ViewMetadata;

},{}],197:[function(require,module,exports){
"use strict";
var console_1 = require('./console');
var reflection_1 = require('./reflection/reflection');
var reflector_reader_1 = require('./reflection/reflector_reader');
var testability_1 = require('./testability/testability');
var application_ref_1 = require('./application_ref');
function _reflector() {
    return reflection_1.reflector;
}
var __unused; // prevent missing use Dart warning.
/**
 * A default set of providers which should be included in any Angular platform.
 */
exports.PLATFORM_COMMON_PROVIDERS = [
    application_ref_1.PLATFORM_CORE_PROVIDERS,
    /*@ts2dart_Provider*/ { provide: reflection_1.Reflector, useFactory: _reflector, deps: [] },
    /*@ts2dart_Provider*/ { provide: reflector_reader_1.ReflectorReader, useExisting: reflection_1.Reflector },
    testability_1.TestabilityRegistry,
    console_1.Console
];

},{"./application_ref":143,"./console":154,"./reflection/reflection":202,"./reflection/reflector_reader":205,"./testability/testability":209}],198:[function(require,module,exports){
"use strict";
var di_1 = require('./di');
/**
 * A token that can be provided when bootstraping an application to make an array of directives
 * available in every component of the application.
 *
 * ### Example
 *
 * ```typescript
 * import {PLATFORM_DIRECTIVES} from '@angular/core';
 * import {OtherDirective} from './myDirectives';
 *
 * @Component({
 *   selector: 'my-component',
 *   template: `
 *     <!-- can use other directive even though the component does not list it in `directives` -->
 *     <other-directive></other-directive>
 *   `
 * })
 * export class MyComponent {
 *   ...
 * }
 *
 * bootstrap(MyComponent, [provide(PLATFORM_DIRECTIVES, {useValue: [OtherDirective], multi:true})]);
 * ```
 */
exports.PLATFORM_DIRECTIVES = 
/*@ts2dart_const*/ new di_1.OpaqueToken("Platform Directives");
/**
 * A token that can be provided when bootstraping an application to make an array of pipes
 * available in every component of the application.
 *
 * ### Example
 *
 * ```typescript
 * import {PLATFORM_PIPES} from '@angular/core';
 * import {OtherPipe} from './myPipe';
 *
 * @Component({
 *   selector: 'my-component',
 *   template: `
 *     {{123 | other-pipe}}
 *   `
 * })
 * export class MyComponent {
 *   ...
 * }
 *
 * bootstrap(MyComponent, [provide(PLATFORM_PIPES, {useValue: [OtherPipe], multi:true})]);
 * ```
 */
exports.PLATFORM_PIPES = new di_1.OpaqueToken("Platform Pipes");

},{"./di":157}],199:[function(require,module,exports){
"use strict";
var impl = require('./wtf_impl');
// Change exports to const once https://github.com/angular/ts2dart/issues/150
/**
 * True if WTF is enabled.
 */
exports.wtfEnabled = impl.detectWTF();
function noopScope(arg0, arg1) {
    return null;
}
/**
 * Create trace scope.
 *
 * Scopes must be strictly nested and are analogous to stack frames, but
 * do not have to follow the stack frames. Instead it is recommended that they follow logical
 * nesting. You may want to use
 * [Event
 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
 * as they are defined in WTF.
 *
 * Used to mark scope entry. The return value is used to leave the scope.
 *
 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
 *
 *     someMethod() {
 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
 *        // DO SOME WORK HERE
 *        return wtfLeave(s, 123); // Return value 123
 *     }
 *
 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
 * negatively impact the performance of your application. For this reason we recommend that
 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
 * exception, will produce incorrect trace, but presence of exception signifies logic error which
 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
 * an exception is expected during normal execution while profiling.
 *
 */
exports.wtfCreateScope = exports.wtfEnabled ? impl.createScope : function (signature, flags) { return noopScope; };
/**
 * Used to mark end of Scope.
 *
 * - `scope` to end.
 * - `returnValue` (optional) to be passed to the WTF.
 *
 * Returns the `returnValue for easy chaining.
 */
exports.wtfLeave = exports.wtfEnabled ? impl.leave : function (s, r) { return r; };
/**
 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
 * enabled.
 *
 *     someMethod() {
 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
 *        var future = new Future.delay(5).then((_) {
 *          wtfEndTimeRange(s);
 *        });
 *     }
 */
exports.wtfStartTimeRange = exports.wtfEnabled ? impl.startTimeRange : function (rangeType, action) { return null; };
/**
 * Ends a async time range operation.
 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
 * enabled.
 */
exports.wtfEndTimeRange = exports.wtfEnabled ? impl.endTimeRange : function (r) {
    return null;
};

},{"./wtf_impl":200}],200:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var trace;
var events;
function detectWTF() {
    var wtf = lang_1.global['wtf'];
    if (wtf) {
        trace = wtf['trace'];
        if (trace) {
            events = trace['events'];
            return true;
        }
    }
    return false;
}
exports.detectWTF = detectWTF;
function createScope(signature, flags) {
    if (flags === void 0) { flags = null; }
    return events.createScope(signature, flags);
}
exports.createScope = createScope;
function leave(scope, returnValue) {
    trace.leaveScope(scope, returnValue);
    return returnValue;
}
exports.leave = leave;
function startTimeRange(rangeType, action) {
    return trace.beginTimeRange(rangeType, action);
}
exports.startTimeRange = startTimeRange;
function endTimeRange(range) {
    trace.endTimeRange(range);
}
exports.endTimeRange = endTimeRange;

},{"../../src/facade/lang":174}],201:[function(require,module,exports){
"use strict";
/**
* This is here because DART requires it. It is noop in JS.
*/
function wtfInit() { }
exports.wtfInit = wtfInit;

},{}],202:[function(require,module,exports){
"use strict";
var reflector_1 = require('./reflector');
var reflector_2 = require('./reflector');
exports.Reflector = reflector_2.Reflector;
exports.ReflectionInfo = reflector_2.ReflectionInfo;
var reflection_capabilities_1 = require('./reflection_capabilities');
/**
 * The {@link Reflector} used internally in Angular to access metadata
 * about symbols.
 */
exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());

},{"./reflection_capabilities":203,"./reflector":204}],203:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var ReflectionCapabilities = (function () {
    function ReflectionCapabilities(reflect) {
        this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;
    }
    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
    ReflectionCapabilities.prototype.factory = function (t) {
        switch (t.length) {
            case 0:
                return function () { return new t(); };
            case 1:
                return function (a1) { return new t(a1); };
            case 2:
                return function (a1, a2) { return new t(a1, a2); };
            case 3:
                return function (a1, a2, a3) { return new t(a1, a2, a3); };
            case 4:
                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };
            case 5:
                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };
            case 6:
                return function (a1, a2, a3, a4, a5, a6) {
                    return new t(a1, a2, a3, a4, a5, a6);
                };
            case 7:
                return function (a1, a2, a3, a4, a5, a6, a7) {
                    return new t(a1, a2, a3, a4, a5, a6, a7);
                };
            case 8:
                return function (a1, a2, a3, a4, a5, a6, a7, a8) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8);
                };
            case 9:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
                };
            case 10:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                };
            case 11:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
                };
            case 12:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
                };
            case 13:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
                };
            case 14:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
                };
            case 15:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
                };
            case 16:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
                };
            case 17:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
                };
            case 18:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
                };
            case 19:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                };
            case 20:
                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
                };
        }
        ;
        throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
    };
    /** @internal */
    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
        var result;
        if (typeof paramTypes === 'undefined') {
            result = new Array(paramAnnotations.length);
        }
        else {
            result = new Array(paramTypes.length);
        }
        for (var i = 0; i < result.length; i++) {
            // TS outputs Object for parameters without types, while Traceur omits
            // the annotations. For now we preserve the Traceur behavior to aid
            // migration, but this can be revisited.
            if (typeof paramTypes === 'undefined') {
                result[i] = [];
            }
            else if (paramTypes[i] != Object) {
                result[i] = [paramTypes[i]];
            }
            else {
                result[i] = [];
            }
            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
                result[i] = result[i].concat(paramAnnotations[i]);
            }
        }
        return result;
    };
    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.parameters)) {
            return typeOrFunc.parameters;
        }
        // API of tsickle for lowering decorators to properties on the class.
        if (lang_1.isPresent(typeOrFunc.ctorParameters)) {
            var ctorParameters = typeOrFunc.ctorParameters;
            var paramTypes_1 = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
            var paramAnnotations_1 = ctorParameters.map(function (ctorParam) { return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators); });
            return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);
        }
        // API for metadata created by invoking the decorators.
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
            }
        }
        // The array has to be filled with `undefined` because holes would be skipped by `some`
        var parameters = new Array(typeOrFunc.length);
        parameters.fill(undefined);
        return parameters;
    };
    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.annotations)) {
            var annotations = typeOrFunc.annotations;
            if (lang_1.isFunction(annotations) && annotations.annotations) {
                annotations = annotations.annotations;
            }
            return annotations;
        }
        // API of tsickle for lowering decorators to properties on the class.
        if (lang_1.isPresent(typeOrFunc.decorators)) {
            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
        }
        // API for metadata created by invoking the decorators.
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
            if (lang_1.isPresent(annotations))
                return annotations;
        }
        return [];
    };
    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
        // Prefer the direct API.
        if (lang_1.isPresent(typeOrFunc.propMetadata)) {
            var propMetadata = typeOrFunc.propMetadata;
            if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {
                propMetadata = propMetadata.propMetadata;
            }
            return propMetadata;
        }
        // API of tsickle for lowering decorators to properties on the class.
        if (lang_1.isPresent(typeOrFunc.propDecorators)) {
            var propDecorators_1 = typeOrFunc.propDecorators;
            var propMetadata_1 = {};
            Object.keys(propDecorators_1)
                .forEach(function (prop) {
                propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
            });
            return propMetadata_1;
        }
        // API for metadata created by invoking the decorators.
        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
            var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
            if (lang_1.isPresent(propMetadata))
                return propMetadata;
        }
        return {};
    };
    ReflectionCapabilities.prototype.interfaces = function (type) {
        throw new exceptions_1.BaseException("JavaScript does not support interfaces");
    };
    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
    ReflectionCapabilities.prototype.setter = function (name) {
        return new Function('o', 'v', 'return o.' + name + ' = v;');
    };
    ReflectionCapabilities.prototype.method = function (name) {
        var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
        return new Function('o', 'args', functionBody);
    };
    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
    ReflectionCapabilities.prototype.importUri = function (type) { return "./" + lang_1.stringify(type); };
    return ReflectionCapabilities;
}());
exports.ReflectionCapabilities = ReflectionCapabilities;
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) {
        return [];
    }
    return decoratorInvocations.map(function (decoratorInvocation) {
        var decoratorType = decoratorInvocation.type;
        var annotationCls = decoratorType.annotationCls;
        var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
        var annotation = Object.create(annotationCls.prototype);
        annotationCls.apply(annotation, annotationArgs);
        return annotation;
    });
}

},{"../../src/facade/exceptions":173,"../../src/facade/lang":174}],204:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var collection_1 = require('../../src/facade/collection');
var reflector_reader_1 = require('./reflector_reader');
/**
 * Reflective information about a symbol, including annotations, interfaces, and other metadata.
 */
var ReflectionInfo = (function () {
    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
        this.annotations = annotations;
        this.parameters = parameters;
        this.factory = factory;
        this.interfaces = interfaces;
        this.propMetadata = propMetadata;
    }
    return ReflectionInfo;
}());
exports.ReflectionInfo = ReflectionInfo;
/**
 * Provides access to reflection data about symbols. Used internally by Angular
 * to power dependency injection and compilation.
 */
var Reflector = (function (_super) {
    __extends(Reflector, _super);
    function Reflector(reflectionCapabilities) {
        _super.call(this);
        /** @internal */
        this._injectableInfo = new collection_1.Map();
        /** @internal */
        this._getters = new collection_1.Map();
        /** @internal */
        this._setters = new collection_1.Map();
        /** @internal */
        this._methods = new collection_1.Map();
        this._usedKeys = null;
        this.reflectionCapabilities = reflectionCapabilities;
    }
    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
    /**
     * Causes `this` reflector to track keys used to access
     * {@link ReflectionInfo} objects.
     */
    Reflector.prototype.trackUsage = function () { this._usedKeys = new collection_1.Set(); };
    /**
     * Lists types for which reflection information was not requested since
     * {@link #trackUsage} was called. This list could later be audited as
     * potential dead code.
     */
    Reflector.prototype.listUnusedKeys = function () {
        var _this = this;
        if (this._usedKeys == null) {
            throw new exceptions_1.BaseException('Usage tracking is disabled');
        }
        var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);
        return allTypes.filter(function (key) { return !collection_1.SetWrapper.has(_this._usedKeys, key); });
    };
    Reflector.prototype.registerFunction = function (func, funcInfo) {
        this._injectableInfo.set(func, funcInfo);
    };
    Reflector.prototype.registerType = function (type, typeInfo) {
        this._injectableInfo.set(type, typeInfo);
    };
    Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };
    Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };
    Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };
    Reflector.prototype.factory = function (type) {
        if (this._containsReflectionInfo(type)) {
            var res = this._getReflectionInfo(type).factory;
            return lang_1.isPresent(res) ? res : null;
        }
        else {
            return this.reflectionCapabilities.factory(type);
        }
    };
    Reflector.prototype.parameters = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).parameters;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.parameters(typeOrFunc);
        }
    };
    Reflector.prototype.annotations = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).annotations;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.annotations(typeOrFunc);
        }
    };
    Reflector.prototype.propMetadata = function (typeOrFunc) {
        if (this._injectableInfo.has(typeOrFunc)) {
            var res = this._getReflectionInfo(typeOrFunc).propMetadata;
            return lang_1.isPresent(res) ? res : {};
        }
        else {
            return this.reflectionCapabilities.propMetadata(typeOrFunc);
        }
    };
    Reflector.prototype.interfaces = function (type) {
        if (this._injectableInfo.has(type)) {
            var res = this._getReflectionInfo(type).interfaces;
            return lang_1.isPresent(res) ? res : [];
        }
        else {
            return this.reflectionCapabilities.interfaces(type);
        }
    };
    Reflector.prototype.getter = function (name) {
        if (this._getters.has(name)) {
            return this._getters.get(name);
        }
        else {
            return this.reflectionCapabilities.getter(name);
        }
    };
    Reflector.prototype.setter = function (name) {
        if (this._setters.has(name)) {
            return this._setters.get(name);
        }
        else {
            return this.reflectionCapabilities.setter(name);
        }
    };
    Reflector.prototype.method = function (name) {
        if (this._methods.has(name)) {
            return this._methods.get(name);
        }
        else {
            return this.reflectionCapabilities.method(name);
        }
    };
    /** @internal */
    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
        if (lang_1.isPresent(this._usedKeys)) {
            this._usedKeys.add(typeOrFunc);
        }
        return this._injectableInfo.get(typeOrFunc);
    };
    /** @internal */
    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };
    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
    return Reflector;
}(reflector_reader_1.ReflectorReader));
exports.Reflector = Reflector;
function _mergeMaps(target, config) {
    collection_1.StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });
}

},{"../../src/facade/collection":171,"../../src/facade/exceptions":173,"../../src/facade/lang":174,"./reflector_reader":205}],205:[function(require,module,exports){
"use strict";
/**
* Provides read-only access to reflection data about symbols. Used internally by Angular
* to power dependency injection and compilation.
*/
var ReflectorReader = (function () {
    function ReflectorReader() {
    }
    return ReflectorReader;
}());
exports.ReflectorReader = ReflectorReader;

},{}],206:[function(require,module,exports){
"use strict";
// Public API for render
var api_1 = require('./render/api');
exports.RootRenderer = api_1.RootRenderer;
exports.Renderer = api_1.Renderer;
exports.RenderComponentType = api_1.RenderComponentType;

},{"./render/api":207}],207:[function(require,module,exports){
"use strict";
var exceptions_1 = require('../../src/facade/exceptions');
var RenderComponentType = (function () {
    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles) {
        this.id = id;
        this.templateUrl = templateUrl;
        this.slotCount = slotCount;
        this.encapsulation = encapsulation;
        this.styles = styles;
    }
    return RenderComponentType;
}());
exports.RenderComponentType = RenderComponentType;
var RenderDebugInfo = (function () {
    function RenderDebugInfo() {
    }
    Object.defineProperty(RenderDebugInfo.prototype, "injector", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "component", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "references", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "context", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderDebugInfo.prototype, "source", {
        get: function () { return exceptions_1.unimplemented(); },
        enumerable: true,
        configurable: true
    });
    return RenderDebugInfo;
}());
exports.RenderDebugInfo = RenderDebugInfo;
var Renderer = (function () {
    function Renderer() {
    }
    return Renderer;
}());
exports.Renderer = Renderer;
/**
 * Injectable service that provides a low-level interface for modifying the UI.
 *
 * Use this service to bypass Angular's templating and make custom UI changes that can't be
 * expressed declaratively. For example if you need to set a property or an attribute whose name is
 * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
 * respectively.
 *
 * If you are implementing a custom renderer, you must implement this interface.
 *
 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
 */
var RootRenderer = (function () {
    function RootRenderer() {
    }
    return RootRenderer;
}());
exports.RootRenderer = RootRenderer;

},{"../../src/facade/exceptions":173}],208:[function(require,module,exports){
"use strict";
/**
* A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
* like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
* handled.
*
* See DomSanitizationService for more details on security in Angular applications.
*/
(function (SecurityContext) {
    SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
    SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
    SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
    SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext[SecurityContext["URL"] = 4] = "URL";
    SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(exports.SecurityContext || (exports.SecurityContext = {}));
var SecurityContext = exports.SecurityContext;
/**
 * SanitizationService is used by the views to sanitize potentially dangerous values. This is a
 * private API, use code should only refer to DomSanitizationService.
 */
var SanitizationService = (function () {
    function SanitizationService() {
    }
    return SanitizationService;
}());
exports.SanitizationService = SanitizationService;

},{}],209:[function(require,module,exports){
"use strict";
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var ng_zone_1 = require('../zone/ng_zone');
var async_1 = require('../../src/facade/async');
var decorators_1 = require('../di/decorators');
var Testability = (function () {
    function Testability(_ngZone) {
        this._ngZone = _ngZone;
        /** @internal */
        this._pendingCount = 0;
        /** @internal */
        this._isZoneStable = true;
        /**
         * Whether any work was done since the last 'whenStable' callback. This is
         * useful to detect if this could have potentially destabilized another
         * component while it is stabilizing.
         * @internal
         */
        this._didWork = false;
        /** @internal */
        this._callbacks = [];
        this._watchAngularEvents();
    }
    /** @internal */
    Testability.prototype._watchAngularEvents = function () {
        var _this = this;
        async_1.ObservableWrapper.subscribe(this._ngZone.onUnstable, function (_) {
            _this._didWork = true;
            _this._isZoneStable = false;
        });
        this._ngZone.runOutsideAngular(function () {
            async_1.ObservableWrapper.subscribe(_this._ngZone.onStable, function (_) {
                ng_zone_1.NgZone.assertNotInAngularZone();
                lang_1.scheduleMicroTask(function () {
                    _this._isZoneStable = true;
                    _this._runCallbacksIfReady();
                });
            });
        });
    };
    Testability.prototype.increasePendingRequestCount = function () {
        this._pendingCount += 1;
        this._didWork = true;
        return this._pendingCount;
    };
    Testability.prototype.decreasePendingRequestCount = function () {
        this._pendingCount -= 1;
        if (this._pendingCount < 0) {
            throw new exceptions_1.BaseException('pending async requests below zero');
        }
        this._runCallbacksIfReady();
        return this._pendingCount;
    };
    Testability.prototype.isStable = function () {
        return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
    };
    /** @internal */
    Testability.prototype._runCallbacksIfReady = function () {
        var _this = this;
        if (this.isStable()) {
            // Schedules the call backs in a new frame so that it is always async.
            lang_1.scheduleMicroTask(function () {
                while (_this._callbacks.length !== 0) {
                    (_this._callbacks.pop())(_this._didWork);
                }
                _this._didWork = false;
            });
        }
        else {
            // Not Ready
            this._didWork = true;
        }
    };
    Testability.prototype.whenStable = function (callback) {
        this._callbacks.push(callback);
        this._runCallbacksIfReady();
    };
    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
    Testability.prototype.findBindings = function (using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
    };
    Testability.prototype.findProviders = function (using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
    };
    Testability.decorators = [
        { type: decorators_1.Injectable },
    ];
    Testability.ctorParameters = [
        { type: ng_zone_1.NgZone, },
    ];
    return Testability;
}());
exports.Testability = Testability;
var TestabilityRegistry = (function () {
    function TestabilityRegistry() {
        /** @internal */
        this._applications = new collection_1.Map();
        _testabilityGetter.addToWindow(this);
    }
    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
        this._applications.set(token, testability);
    };
    TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
    TestabilityRegistry.prototype.getAllTestabilities = function () { return collection_1.MapWrapper.values(this._applications); };
    TestabilityRegistry.prototype.getAllRootElements = function () { return collection_1.MapWrapper.keys(this._applications); };
    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
        if (findInAncestors === void 0) { findInAncestors = true; }
        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    };
    TestabilityRegistry.decorators = [
        { type: decorators_1.Injectable },
    ];
    TestabilityRegistry.ctorParameters = [];
    return TestabilityRegistry;
}());
exports.TestabilityRegistry = TestabilityRegistry;
/* @ts2dart_const */
var _NoopGetTestability = (function () {
    function _NoopGetTestability() {
    }
    _NoopGetTestability.prototype.addToWindow = function (registry) { };
    _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
        return null;
    };
    return _NoopGetTestability;
}());
/**
 * Set the {@link GetTestability} implementation used by the Angular testing framework.
 */
function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
}
exports.setTestabilityGetter = setTestabilityGetter;
var _testabilityGetter = new _NoopGetTestability();

},{"../../src/facade/async":169,"../../src/facade/collection":171,"../../src/facade/exceptions":173,"../../src/facade/lang":174,"../di/decorators":158,"../zone/ng_zone":213}],210:[function(require,module,exports){
"use strict";
// Public API for util
var decorators_1 = require('./util/decorators');
exports.Class = decorators_1.Class;

},{"./util/decorators":211}],211:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var _nextClassId = 0;
function extractAnnotation(annotation) {
    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
        // it is a decorator, extract annotation
        annotation = annotation.annotation;
    }
    return annotation;
}
function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
        fnOrArray === Number || fnOrArray === Array) {
        throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
    }
    if (lang_1.isFunction(fnOrArray)) {
        return fnOrArray;
    }
    else if (fnOrArray instanceof Array) {
        var annotations = fnOrArray;
        var fn = fnOrArray[fnOrArray.length - 1];
        if (!lang_1.isFunction(fn)) {
            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
        }
        var annoLength = annotations.length - 1;
        if (annoLength != fn.length) {
            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
        }
        var paramsAnnotations = [];
        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
            var paramAnnotations = [];
            paramsAnnotations.push(paramAnnotations);
            var annotation = annotations[i];
            if (annotation instanceof Array) {
                for (var j = 0; j < annotation.length; j++) {
                    paramAnnotations.push(extractAnnotation(annotation[j]));
                }
            }
            else if (lang_1.isFunction(annotation)) {
                paramAnnotations.push(extractAnnotation(annotation));
            }
            else {
                paramAnnotations.push(annotation);
            }
        }
        Reflect.defineMetadata('parameters', paramsAnnotations, fn);
        return fn;
    }
    else {
        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
    }
}
/**
 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
 *
 * ## Basic Example
 *
 * ```
 * var Greeter = ng.Class({
 *   constructor: function(name) {
 *     this.name = name;
 *   },
 *
 *   greet: function() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class Greeter {
 *   constructor(name) {
 *     this.name = name;
 *   }
 *
 *   greet() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * }
 * ```
 *
 * or equivalent to ES5:
 *
 * ```
 * var Greeter = function (name) {
 *   this.name = name;
 * }
 *
 * Greeter.prototype.greet = function () {
 *   alert('Hello ' + this.name + '!');
 * }
 * ```
 *
 * ### Example with parameter annotations
 *
 * ```
 * var MyService = ng.Class({
 *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
 *     ...
 *   }]
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class MyService {
 *   constructor(name: string, @Query() queryList: QueryList) {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Example with inheritance
 *
 * ```
 * var Shape = ng.Class({
 *   constructor: (color) {
 *     this.color = color;
 *   }
 * });
 *
 * var Square = ng.Class({
 *   extends: Shape,
 *   constructor: function(color, size) {
 *     Shape.call(this, color);
 *     this.size = size;
 *   }
 * });
 * ```
 */
function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
        if (lang_1.isFunction(clsDef.extends)) {
            constructor.prototype = proto =
                Object.create(clsDef.extends.prototype);
        }
        else {
            throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
        }
    }
    for (var key in clsDef) {
        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
            proto[key] = applyParams(clsDef[key], key);
        }
    }
    if (this && this.annotations instanceof Array) {
        Reflect.defineMetadata('annotations', this.annotations, constructor);
    }
    if (!constructor['name']) {
        constructor['overriddenName'] = "class" + _nextClassId++;
    }
    return constructor;
}
exports.Class = Class;
var Reflect = lang_1.global.Reflect;
// Throw statement at top-level is disallowed by closure compiler in ES6 input.
// Wrap in an IIFE as a work-around.
(function checkReflect() {
    if (!(Reflect && Reflect.getMetadata)) {
        throw 'reflect-metadata shim is required when using class decorators';
    }
})();
function makeDecorator(annotationCls, chainFn) {
    if (chainFn === void 0) { chainFn = null; }
    function DecoratorFactory(objOrType) {
        var annotationInstance = new annotationCls(objOrType);
        if (this instanceof annotationCls) {
            return annotationInstance;
        }
        else {
            var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
            chainAnnotation.push(annotationInstance);
            var TypeDecorator = function TypeDecorator(cls) {
                var annotations = Reflect.getOwnMetadata('annotations', cls);
                annotations = annotations || [];
                annotations.push(annotationInstance);
                Reflect.defineMetadata('annotations', annotations, cls);
                return cls;
            };
            TypeDecorator.annotations = chainAnnotation;
            TypeDecorator.Class = Class;
            if (chainFn)
                chainFn(TypeDecorator);
            return TypeDecorator;
        }
    }
    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
    DecoratorFactory.annotationCls = annotationCls;
    return DecoratorFactory;
}
exports.makeDecorator = makeDecorator;
function makeParamDecorator(annotationCls) {
    function ParamDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var annotationInstance = Object.create(annotationCls.prototype);
        annotationCls.apply(annotationInstance, args);
        if (this instanceof annotationCls) {
            return annotationInstance;
        }
        else {
            ParamDecorator.annotation = annotationInstance;
            return ParamDecorator;
        }
        function ParamDecorator(cls, unusedKey, index) {
            var parameters = Reflect.getMetadata('parameters', cls);
            parameters = parameters || [];
            // there might be gaps if some in between parameters do not have annotations.
            // we pad with nulls.
            while (parameters.length <= index) {
                parameters.push(null);
            }
            parameters[index] = parameters[index] || [];
            var annotationsForParam = parameters[index];
            annotationsForParam.push(annotationInstance);
            Reflect.defineMetadata('parameters', parameters, cls);
            return cls;
        }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    ParamDecoratorFactory.annotationCls = annotationCls;
    return ParamDecoratorFactory;
}
exports.makeParamDecorator = makeParamDecorator;
function makePropDecorator(annotationCls) {
    function PropDecoratorFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var decoratorInstance = Object.create(annotationCls.prototype);
        annotationCls.apply(decoratorInstance, args);
        if (this instanceof annotationCls) {
            return decoratorInstance;
        }
        else {
            return function PropDecorator(target, name) {
                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor);
                meta = meta || {};
                meta[name] = meta[name] || [];
                meta[name].unshift(decoratorInstance);
                Reflect.defineMetadata('propMetadata', meta, target.constructor);
            };
        }
    }
    PropDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    PropDecoratorFactory.annotationCls = annotationCls;
    return PropDecoratorFactory;
}
exports.makePropDecorator = makePropDecorator;

},{"../../src/facade/lang":174}],212:[function(require,module,exports){
"use strict";
// Public API for Zone
var ng_zone_1 = require('./zone/ng_zone');
exports.NgZone = ng_zone_1.NgZone;
exports.NgZoneError = ng_zone_1.NgZoneError;

},{"./zone/ng_zone":213}],213:[function(require,module,exports){
"use strict";
var async_1 = require('../../src/facade/async');
var ng_zone_impl_1 = require('./ng_zone_impl');
var exceptions_1 = require('../../src/facade/exceptions');
var ng_zone_impl_2 = require('./ng_zone_impl');
exports.NgZoneError = ng_zone_impl_2.NgZoneError;
/**
 * An injectable service for executing work inside or outside of the Angular zone.
 *
 * The most common use of this service is to optimize performance when starting a work consisting of
 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
 * can reenter the Angular zone via {@link #run}.
 *
 * <!-- TODO: add/fix links to:
 *   - docs explaining zones and the use of zones in Angular and change-detection
 *   - link to runOutsideAngular/run (throughout this file!)
 *   -->
 *
 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
 * ```
 * import {Component, View, NgZone} from '@angular/core';
 * import {NgIf} from '@angular/common';
 *
 * @Component({
 *   selector: 'ng-zone-demo'.
 *   template: `
 *     <h2>Demo: NgZone</h2>
 *
 *     <p>Progress: {{progress}}%</p>
 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
 *
 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
 *   `,
 *   directives: [NgIf]
 * })
 * export class NgZoneDemo {
 *   progress: number = 0;
 *   label: string;
 *
 *   constructor(private _ngZone: NgZone) {}
 *
 *   // Loop inside the Angular zone
 *   // so the UI DOES refresh after each setTimeout cycle
 *   processWithinAngularZone() {
 *     this.label = 'inside';
 *     this.progress = 0;
 *     this._increaseProgress(() => console.log('Inside Done!'));
 *   }
 *
 *   // Loop outside of the Angular zone
 *   // so the UI DOES NOT refresh after each setTimeout cycle
 *   processOutsideOfAngularZone() {
 *     this.label = 'outside';
 *     this.progress = 0;
 *     this._ngZone.runOutsideAngular(() => {
 *       this._increaseProgress(() => {
 *       // reenter the Angular zone and display done
 *       this._ngZone.run(() => {console.log('Outside Done!') });
 *     }}));
 *   }
 *
 *
 *   _increaseProgress(doneCallback: () => void) {
 *     this.progress += 1;
 *     console.log(`Current progress: ${this.progress}%`);
 *
 *     if (this.progress < 100) {
 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
 *     } else {
 *       doneCallback();
 *     }
 *   }
 * }
 * ```
 */
var NgZone = (function () {
    /**
     * @param {bool} enableLongStackTrace whether to enable long stack trace. They should only be
     *               enabled in development mode as they significantly impact perf.
     */
    function NgZone(_a) {
        var _this = this;
        var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
        this._hasPendingMicrotasks = false;
        this._hasPendingMacrotasks = false;
        /** @internal */
        this._isStable = true;
        /** @internal */
        this._nesting = 0;
        /** @internal */
        this._onUnstable = new async_1.EventEmitter(false);
        /** @internal */
        this._onMicrotaskEmpty = new async_1.EventEmitter(false);
        /** @internal */
        this._onStable = new async_1.EventEmitter(false);
        /** @internal */
        this._onErrorEvents = new async_1.EventEmitter(false);
        this._zoneImpl = new ng_zone_impl_1.NgZoneImpl({
            trace: enableLongStackTrace,
            onEnter: function () {
                // console.log('ZONE.enter', this._nesting, this._isStable);
                _this._nesting++;
                if (_this._isStable) {
                    _this._isStable = false;
                    _this._onUnstable.emit(null);
                }
            },
            onLeave: function () {
                _this._nesting--;
                // console.log('ZONE.leave', this._nesting, this._isStable);
                _this._checkStable();
            },
            setMicrotask: function (hasMicrotasks) {
                _this._hasPendingMicrotasks = hasMicrotasks;
                _this._checkStable();
            },
            setMacrotask: function (hasMacrotasks) { _this._hasPendingMacrotasks = hasMacrotasks; },
            onError: function (error) { return _this._onErrorEvents.emit(error); }
        });
    }
    NgZone.isInAngularZone = function () { return ng_zone_impl_1.NgZoneImpl.isInAngularZone(); };
    NgZone.assertInAngularZone = function () {
        if (!ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
            throw new exceptions_1.BaseException('Expected to be in Angular Zone, but it is not!');
        }
    };
    NgZone.assertNotInAngularZone = function () {
        if (ng_zone_impl_1.NgZoneImpl.isInAngularZone()) {
            throw new exceptions_1.BaseException('Expected to not be in Angular Zone, but it is!');
        }
    };
    NgZone.prototype._checkStable = function () {
        var _this = this;
        if (this._nesting == 0) {
            if (!this._hasPendingMicrotasks && !this._isStable) {
                try {
                    // console.log('ZONE.microtaskEmpty');
                    this._nesting++;
                    this._onMicrotaskEmpty.emit(null);
                }
                finally {
                    this._nesting--;
                    if (!this._hasPendingMicrotasks) {
                        try {
                            // console.log('ZONE.stable', this._nesting, this._isStable);
                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
                        }
                        finally {
                            this._isStable = true;
                        }
                    }
                }
            }
        }
    };
    ;
    Object.defineProperty(NgZone.prototype, "onUnstable", {
        /**
         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
         */
        get: function () { return this._onUnstable; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
        /**
         * Notifies when there is no more microtasks enqueue in the current VM Turn.
         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
         * For this reason this event can fire multiple times per VM Turn.
         */
        get: function () { return this._onMicrotaskEmpty; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onStable", {
        /**
         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
         * implies we are about to relinquish VM turn.
         * This event gets called just once.
         */
        get: function () { return this._onStable; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgZone.prototype, "onError", {
        /**
         * Notify that an error has been delivered.
         */
        get: function () { return this._onErrorEvents; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
        /**
         * Whether there are any outstanding microtasks.
         */
        get: function () { return this._hasPendingMicrotasks; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
        /**
         * Whether there are any outstanding microtasks.
         */
        get: function () { return this._hasPendingMacrotasks; },
        enumerable: true,
        configurable: true
    });
    /**
     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
     * the function.
     *
     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * within the Angular zone.
     *
     * If a synchronous error happens it will be rethrown and not reported via `onError`.
     */
    NgZone.prototype.run = function (fn) { return this._zoneImpl.runInner(fn); };
    /**
     * Same as #run, except that synchronous errors are caught and forwarded
     * via `onError` and not rethrown.
     */
    NgZone.prototype.runGuarded = function (fn) { return this._zoneImpl.runInnerGuarded(fn); };
    /**
     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
     * the function.
     *
     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * outside of the Angular zone.
     *
     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
     */
    NgZone.prototype.runOutsideAngular = function (fn) { return this._zoneImpl.runOuter(fn); };
    return NgZone;
}());
exports.NgZone = NgZone;

},{"../../src/facade/async":169,"../../src/facade/exceptions":173,"./ng_zone_impl":214}],214:[function(require,module,exports){
"use strict";
/**
* Stores error information; delivered via [NgZone.onError] stream.
*/
var NgZoneError = (function () {
    function NgZoneError(error, stackTrace) {
        this.error = error;
        this.stackTrace = stackTrace;
    }
    return NgZoneError;
}());
exports.NgZoneError = NgZoneError;
var NgZoneImpl = (function () {
    function NgZoneImpl(_a) {
        var _this = this;
        var trace = _a.trace, onEnter = _a.onEnter, onLeave = _a.onLeave, setMicrotask = _a.setMicrotask, setMacrotask = _a.setMacrotask, onError = _a.onError;
        this.onEnter = onEnter;
        this.onLeave = onLeave;
        this.setMicrotask = setMicrotask;
        this.setMacrotask = setMacrotask;
        this.onError = onError;
        if (Zone) {
            this.outer = this.inner = Zone.current;
            if (Zone['wtfZoneSpec']) {
                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
            }
            if (trace && Zone['longStackTraceZoneSpec']) {
                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
            }
            this.inner = this.inner.fork({
                name: 'angular',
                properties: { 'isAngularZone': true },
                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
                    try {
                        _this.onEnter();
                        return delegate.invokeTask(target, task, applyThis, applyArgs);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
                    try {
                        _this.onEnter();
                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onHasTask: function (delegate, current, target, hasTaskState) {
                    delegate.hasTask(target, hasTaskState);
                    if (current == target) {
                        // We are only interested in hasTask events which originate from our zone
                        // (A child hasTask event is not interesting to us)
                        if (hasTaskState.change == 'microTask') {
                            _this.setMicrotask(hasTaskState.microTask);
                        }
                        else if (hasTaskState.change == 'macroTask') {
                            _this.setMacrotask(hasTaskState.macroTask);
                        }
                    }
                },
                onHandleError: function (delegate, current, target, error) {
                    delegate.handleError(target, error);
                    _this.onError(new NgZoneError(error, error.stack));
                    return false;
                }
            });
        }
        else {
            throw new Error('Angular requires Zone.js polyfill.');
        }
    }
    NgZoneImpl.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
    NgZoneImpl.prototype.runInner = function (fn) { return this.inner.run(fn); };
    ;
    NgZoneImpl.prototype.runInnerGuarded = function (fn) { return this.inner.runGuarded(fn); };
    ;
    NgZoneImpl.prototype.runOuter = function (fn) { return this.outer.run(fn); };
    ;
    return NgZoneImpl;
}());
exports.NgZoneImpl = NgZoneImpl;

},{}],215:[function(require,module,exports){
"use strict";
/**
* @module
* @description
* The http module provides services to perform http requests. To get started, see the {@link Http}
* class.
*/
var core_1 = require('@angular/core');
var http_1 = require('./src/http');
var xhr_backend_1 = require('./src/backends/xhr_backend');
var jsonp_backend_1 = require('./src/backends/jsonp_backend');
var browser_xhr_1 = require('./src/backends/browser_xhr');
var browser_jsonp_1 = require('./src/backends/browser_jsonp');
var base_request_options_1 = require('./src/base_request_options');
var base_response_options_1 = require('./src/base_response_options');
var static_request_1 = require('./src/static_request');
exports.Request = static_request_1.Request;
var static_response_1 = require('./src/static_response');
exports.Response = static_response_1.Response;
var interfaces_1 = require('./src/interfaces');
exports.Connection = interfaces_1.Connection;
exports.ConnectionBackend = interfaces_1.ConnectionBackend;
var browser_xhr_2 = require('./src/backends/browser_xhr');
exports.BrowserXhr = browser_xhr_2.BrowserXhr;
var base_request_options_2 = require('./src/base_request_options');
exports.BaseRequestOptions = base_request_options_2.BaseRequestOptions;
exports.RequestOptions = base_request_options_2.RequestOptions;
var base_response_options_2 = require('./src/base_response_options');
exports.BaseResponseOptions = base_response_options_2.BaseResponseOptions;
exports.ResponseOptions = base_response_options_2.ResponseOptions;
var xhr_backend_2 = require('./src/backends/xhr_backend');
exports.XHRBackend = xhr_backend_2.XHRBackend;
exports.XHRConnection = xhr_backend_2.XHRConnection;
var jsonp_backend_2 = require('./src/backends/jsonp_backend');
exports.JSONPBackend = jsonp_backend_2.JSONPBackend;
exports.JSONPConnection = jsonp_backend_2.JSONPConnection;
var http_2 = require('./src/http');
exports.Http = http_2.Http;
exports.Jsonp = http_2.Jsonp;
var headers_1 = require('./src/headers');
exports.Headers = headers_1.Headers;
var enums_1 = require('./src/enums');
exports.ResponseType = enums_1.ResponseType;
exports.ReadyState = enums_1.ReadyState;
exports.RequestMethod = enums_1.RequestMethod;
var url_search_params_1 = require('./src/url_search_params');
exports.URLSearchParams = url_search_params_1.URLSearchParams;
/**
 * Provides a basic set of injectables to use the {@link Http} service in any application.
 *
 * The `HTTP_PROVIDERS` should be included either in a component's injector,
 * or in the root injector when bootstrapping an application.
 *
 * ### Example ([live demo](http://plnkr.co/edit/snj7Nv?p=preview))
 *
 * ```
 * import {Component} from '@angular/core';
 * import {bootstrap} from '@angular/platform-browser/browser';
 * import {NgFor} from '@angular/common';
 * import {HTTP_PROVIDERS, Http} from '@angular/http';
 *
 * @Component({
 *   selector: 'app',
 *   providers: [HTTP_PROVIDERS],
 *   template: `
 *     <div>
 *       <h1>People</h1>
 *       <ul>
 *         <li *ngFor="let person of people">
 *           {{person.name}}
 *         </li>
 *       </ul>
 *     </div>
 *   `,
 *   directives: [NgFor]
 * })
 * export class App {
 *   people: Object[];
 *   constructor(http:Http) {
 *     http.get('people.json').subscribe(res => {
 *       this.people = res.json();
 *     });
 *   }
 *   active:boolean = false;
 *   toggleActiveState() {
 *     this.active = !this.active;
 *   }
 * }
 *
 * bootstrap(App)
 *   .catch(err => console.error(err));
 * ```
 *
 * The primary public API included in `HTTP_PROVIDERS` is the {@link Http} class.
 * However, other providers required by `Http` are included,
 * which may be beneficial to override in certain cases.
 *
 * The providers included in `HTTP_PROVIDERS` include:
 *  * {@link Http}
 *  * {@link XHRBackend}
 *  * `BrowserXHR` - Private factory to create `XMLHttpRequest` instances
 *  * {@link RequestOptions} - Bound to {@link BaseRequestOptions} class
 *  * {@link ResponseOptions} - Bound to {@link BaseResponseOptions} class
 *
 * There may be cases where it makes sense to extend the base request options,
 * such as to add a search string to be appended to all URLs.
 * To accomplish this, a new provider for {@link RequestOptions} should
 * be added in the same injector as `HTTP_PROVIDERS`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/aCMEXi?p=preview))
 *
 * ```
 * import {provide} from '@angular/core';
 * import {bootstrap} from '@angular/platform-browser/browser';
 * import {HTTP_PROVIDERS, BaseRequestOptions, RequestOptions} from '@angular/http';
 *
 * class MyOptions extends BaseRequestOptions {
 *   search: string = 'coreTeam=true';
 * }
 *
 * bootstrap(App, [HTTP_PROVIDERS, provide(RequestOptions, {useClass: MyOptions})])
 *   .catch(err => console.error(err));
 * ```
 *
 * Likewise, to use a mock backend for unit tests, the {@link XHRBackend}
 * provider should be bound to {@link MockBackend}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/7LWALD?p=preview))
 *
 * ```
 * import {provide} from '@angular/core';
 * import {bootstrap} from '@angular/platform-browser/browser';
 * import {HTTP_PROVIDERS, Http, Response, XHRBackend} from '@angular/http';
 * import {MockBackend} from '@angular/http/testing';
 *
 * var people = [{name: 'Jeff'}, {name: 'Tobias'}];
 *
 * var injector = Injector.resolveAndCreate([
 *   HTTP_PROVIDERS,
 *   MockBackend,
 *   provide(XHRBackend, {useExisting: MockBackend})
 * ]);
 * var http = injector.get(Http);
 * var backend = injector.get(MockBackend);
 *
 * // Listen for any new requests
 * backend.connections.observer({
 *   next: connection => {
 *     var response = new Response({body: people});
 *     setTimeout(() => {
 *       // Send a response to the request
 *       connection.mockRespond(response);
 *     });
 *   }
 * });
 *
 * http.get('people.json').observer({
 *   next: res => {
 *     // Response came from mock backend
 *     console.log('first person', res.json()[0].name);
 *   }
 * });
 * ```
 */
exports.HTTP_PROVIDERS = [
    // TODO(pascal): use factory type annotations once supported in DI
    // issue: https://github.com/angular/angular/issues/3183
    core_1.provide(http_1.Http, {
        useFactory: function (xhrBackend, requestOptions) {
            return new http_1.Http(xhrBackend, requestOptions);
        },
        deps: [xhr_backend_1.XHRBackend, base_request_options_1.RequestOptions]
    }),
    browser_xhr_1.BrowserXhr,
    core_1.provide(base_request_options_1.RequestOptions, { useClass: base_request_options_1.BaseRequestOptions }),
    core_1.provide(base_response_options_1.ResponseOptions, { useClass: base_response_options_1.BaseResponseOptions }),
    xhr_backend_1.XHRBackend
];
/**
 * See {@link HTTP_PROVIDERS} instead.
 *
 * @deprecated
 */
exports.HTTP_BINDINGS = exports.HTTP_PROVIDERS;
/**
 * Provides a basic set of providers to use the {@link Jsonp} service in any application.
 *
 * The `JSONP_PROVIDERS` should be included either in a component's injector,
 * or in the root injector when bootstrapping an application.
 *
 * ### Example ([live demo](http://plnkr.co/edit/vmeN4F?p=preview))
 *
 * ```
 * import {Component} from '@angular/core';
 * import {NgFor} from '@angular/common';
 * import {JSONP_PROVIDERS, Jsonp} from '@angular/http';
 *
 * @Component({
 *   selector: 'app',
 *   providers: [JSONP_PROVIDERS],
 *   template: `
 *     <div>
 *       <h1>People</h1>
 *       <ul>
 *         <li *ngFor="let person of people">
 *           {{person.name}}
 *         </li>
 *       </ul>
 *     </div>
 *   `,
 *   directives: [NgFor]
 * })
 * export class App {
 *   people: Array<Object>;
 *   constructor(jsonp:Jsonp) {
 *     jsonp.request('people.json').subscribe(res => {
 *       this.people = res.json();
 *     })
 *   }
 * }
 * ```
 *
 * The primary public API included in `JSONP_PROVIDERS` is the {@link Jsonp} class.
 * However, other providers required by `Jsonp` are included,
 * which may be beneficial to override in certain cases.
 *
 * The providers included in `JSONP_PROVIDERS` include:
 *  * {@link Jsonp}
 *  * {@link JSONPBackend}
 *  * `BrowserJsonp` - Private factory
 *  * {@link RequestOptions} - Bound to {@link BaseRequestOptions} class
 *  * {@link ResponseOptions} - Bound to {@link BaseResponseOptions} class
 *
 * There may be cases where it makes sense to extend the base request options,
 * such as to add a search string to be appended to all URLs.
 * To accomplish this, a new provider for {@link RequestOptions} should
 * be added in the same injector as `JSONP_PROVIDERS`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/TFug7x?p=preview))
 *
 * ```
 * import {provide} from '@angular/core';
 * import {bootstrap} from '@angular/platform-browser/browser';
 * import {JSONP_PROVIDERS, BaseRequestOptions, RequestOptions} from '@angular/http';
 *
 * class MyOptions extends BaseRequestOptions {
 *   search: string = 'coreTeam=true';
 * }
 *
 * bootstrap(App, [JSONP_PROVIDERS, provide(RequestOptions, {useClass: MyOptions})])
 *   .catch(err => console.error(err));
 * ```
 *
 * Likewise, to use a mock backend for unit tests, the {@link JSONPBackend}
 * provider should be bound to {@link MockBackend}.
 *
 * ### Example ([live demo](http://plnkr.co/edit/HDqZWL?p=preview))
 *
 * ```
 * import {provide, Injector} from '@angular/core';
 * import {JSONP_PROVIDERS, Jsonp, Response, JSONPBackend} from '@angular/http';
 * import {MockBackend} from '@angular/http/testing';
 *
 * var people = [{name: 'Jeff'}, {name: 'Tobias'}];
 * var injector = Injector.resolveAndCreate([
 *   JSONP_PROVIDERS,
 *   MockBackend,
 *   provide(JSONPBackend, {useExisting: MockBackend})
 * ]);
 * var jsonp = injector.get(Jsonp);
 * var backend = injector.get(MockBackend);
 *
 * // Listen for any new requests
 * backend.connections.observer({
 *   next: connection => {
 *     var response = new Response({body: people});
 *     setTimeout(() => {
 *       // Send a response to the request
 *       connection.mockRespond(response);
 *     });
 *   }
 * });

 * jsonp.get('people.json').observer({
 *   next: res => {
 *     // Response came from mock backend
 *     console.log('first person', res.json()[0].name);
 *   }
 * });
 * ```
 */
exports.JSONP_PROVIDERS = [
    // TODO(pascal): use factory type annotations once supported in DI
    // issue: https://github.com/angular/angular/issues/3183
    core_1.provide(http_1.Jsonp, {
        useFactory: function (jsonpBackend, requestOptions) {
            return new http_1.Jsonp(jsonpBackend, requestOptions);
        },
        deps: [jsonp_backend_1.JSONPBackend, base_request_options_1.RequestOptions]
    }),
    browser_jsonp_1.BrowserJsonp,
    core_1.provide(base_request_options_1.RequestOptions, { useClass: base_request_options_1.BaseRequestOptions }),
    core_1.provide(base_response_options_1.ResponseOptions, { useClass: base_response_options_1.BaseResponseOptions }),
    core_1.provide(jsonp_backend_1.JSONPBackend, { useClass: jsonp_backend_1.JSONPBackend_ })
];
/**
 * See {@link JSONP_PROVIDERS} instead.
 *
 * @deprecated
 */
exports.JSON_BINDINGS = exports.JSONP_PROVIDERS;

},{"./src/backends/browser_jsonp":217,"./src/backends/browser_xhr":218,"./src/backends/jsonp_backend":219,"./src/backends/xhr_backend":220,"./src/base_request_options":221,"./src/base_response_options":222,"./src/enums":223,"./src/headers":229,"./src/http":230,"./src/interfaces":232,"./src/static_request":233,"./src/static_response":234,"./src/url_search_params":235,"@angular/core":140}],216:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./http'));

},{"./http":215}],217:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../src/facade/lang');
var _nextRequestId = 0;
exports.JSONP_HOME = '__ng_jsonp__';
var _jsonpConnections = null;
function _getJsonpConnections() {
    if (_jsonpConnections === null) {
        _jsonpConnections = lang_1.global[exports.JSONP_HOME] = {};
    }
    return _jsonpConnections;
}
var BrowserJsonp = (function () {
    function BrowserJsonp() {
    }
    // Construct a <script> element with the specified URL
    BrowserJsonp.prototype.build = function (url) {
        var node = document.createElement('script');
        node.src = url;
        return node;
    };
    BrowserJsonp.prototype.nextRequestID = function () { return "__req" + _nextRequestId++; };
    BrowserJsonp.prototype.requestCallback = function (id) { return exports.JSONP_HOME + "." + id + ".finished"; };
    BrowserJsonp.prototype.exposeConnection = function (id, connection) {
        var connections = _getJsonpConnections();
        connections[id] = connection;
    };
    BrowserJsonp.prototype.removeConnection = function (id) {
        var connections = _getJsonpConnections();
        connections[id] = null;
    };
    // Attach the <script> element to the DOM
    BrowserJsonp.prototype.send = function (node) { document.body.appendChild((node)); };
    // Remove <script> element from the DOM
    BrowserJsonp.prototype.cleanup = function (node) {
        if (node.parentNode) {
            node.parentNode.removeChild((node));
        }
    };
    BrowserJsonp.decorators = [
        { type: core_1.Injectable },
    ];
    return BrowserJsonp;
}());
exports.BrowserJsonp = BrowserJsonp;

},{"../../src/facade/lang":228,"@angular/core":140}],218:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var BrowserXhr = (function () {
    function BrowserXhr() {
    }
    BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };
    BrowserXhr.decorators = [
        { type: core_1.Injectable },
    ];
    BrowserXhr.ctorParameters = [];
    return BrowserXhr;
}());
exports.BrowserXhr = BrowserXhr;

},{"@angular/core":140}],219:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var interfaces_1 = require('../interfaces');
var enums_1 = require('../enums');
var static_response_1 = require('../static_response');
var base_response_options_1 = require('../base_response_options');
var core_1 = require('@angular/core');
var browser_jsonp_1 = require('./browser_jsonp');
var exceptions_1 = require('../../src/facade/exceptions');
var lang_1 = require('../../src/facade/lang');
var Observable_1 = require('rxjs/Observable');
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
/**
 * Abstract base class for an in-flight JSONP request.
 */
var JSONPConnection = (function () {
    function JSONPConnection() {
    }
    return JSONPConnection;
}());
exports.JSONPConnection = JSONPConnection;
var JSONPConnection_ = (function (_super) {
    __extends(JSONPConnection_, _super);
    function JSONPConnection_(req, _dom, baseResponseOptions) {
        var _this = this;
        _super.call(this);
        this._dom = _dom;
        this.baseResponseOptions = baseResponseOptions;
        this._finished = false;
        if (req.method !== enums_1.RequestMethod.Get) {
            throw exceptions_1.makeTypeError(JSONP_ERR_WRONG_METHOD);
        }
        this.request = req;
        this.response = new Observable_1.Observable(function (responseObserver) {
            _this.readyState = enums_1.ReadyState.Loading;
            var id = _this._id = _dom.nextRequestID();
            _dom.exposeConnection(id, _this);
            // Workaround Dart
            // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);
            var callback = _dom.requestCallback(_this._id);
            var url = req.url;
            if (url.indexOf('=JSONP_CALLBACK&') > -1) {
                url = lang_1.StringWrapper.replace(url, '=JSONP_CALLBACK&', "=" + callback + "&");
            }
            else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
                url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
            }
            var script = _this._script = _dom.build(url);
            var onLoad = function (event) {
                if (_this.readyState === enums_1.ReadyState.Cancelled)
                    return;
                _this.readyState = enums_1.ReadyState.Done;
                _dom.cleanup(script);
                if (!_this._finished) {
                    var responseOptions_1 = new base_response_options_1.ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: enums_1.ResponseType.Error, url: url });
                    if (lang_1.isPresent(baseResponseOptions)) {
                        responseOptions_1 = baseResponseOptions.merge(responseOptions_1);
                    }
                    responseObserver.error(new static_response_1.Response(responseOptions_1));
                    return;
                }
                var responseOptions = new base_response_options_1.ResponseOptions({ body: _this._responseData, url: url });
                if (lang_1.isPresent(_this.baseResponseOptions)) {
                    responseOptions = _this.baseResponseOptions.merge(responseOptions);
                }
                responseObserver.next(new static_response_1.Response(responseOptions));
                responseObserver.complete();
            };
            var onError = function (error) {
                if (_this.readyState === enums_1.ReadyState.Cancelled)
                    return;
                _this.readyState = enums_1.ReadyState.Done;
                _dom.cleanup(script);
                var responseOptions = new base_response_options_1.ResponseOptions({ body: error.message, type: enums_1.ResponseType.Error });
                if (lang_1.isPresent(baseResponseOptions)) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                responseObserver.error(new static_response_1.Response(responseOptions));
            };
            script.addEventListener('load', onLoad);
            script.addEventListener('error', onError);
            _dom.send(script);
            return function () {
                _this.readyState = enums_1.ReadyState.Cancelled;
                script.removeEventListener('load', onLoad);
                script.removeEventListener('error', onError);
                if (lang_1.isPresent(script)) {
                    _this._dom.cleanup(script);
                }
            };
        });
    }
    JSONPConnection_.prototype.finished = function (data) {
        // Don't leak connections
        this._finished = true;
        this._dom.removeConnection(this._id);
        if (this.readyState === enums_1.ReadyState.Cancelled)
            return;
        this._responseData = data;
    };
    return JSONPConnection_;
}(JSONPConnection));
exports.JSONPConnection_ = JSONPConnection_;
/**
 * A {@link ConnectionBackend} that uses the JSONP strategy of making requests.
 */
var JSONPBackend = (function (_super) {
    __extends(JSONPBackend, _super);
    function JSONPBackend() {
        _super.apply(this, arguments);
    }
    return JSONPBackend;
}(interfaces_1.ConnectionBackend));
exports.JSONPBackend = JSONPBackend;
var JSONPBackend_ = (function (_super) {
    __extends(JSONPBackend_, _super);
    function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
        _super.call(this);
        this._browserJSONP = _browserJSONP;
        this._baseResponseOptions = _baseResponseOptions;
    }
    JSONPBackend_.prototype.createConnection = function (request) {
        return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
    };
    JSONPBackend_.decorators = [
        { type: core_1.Injectable },
    ];
    JSONPBackend_.ctorParameters = [
        { type: browser_jsonp_1.BrowserJsonp, },
        { type: base_response_options_1.ResponseOptions, },
    ];
    return JSONPBackend_;
}(JSONPBackend));
exports.JSONPBackend_ = JSONPBackend_;

},{"../../src/facade/exceptions":227,"../../src/facade/lang":228,"../base_response_options":222,"../enums":223,"../interfaces":232,"../static_response":234,"./browser_jsonp":217,"@angular/core":140,"rxjs/Observable":290}],220:[function(require,module,exports){
"use strict";
var enums_1 = require('../enums');
var static_response_1 = require('../static_response');
var headers_1 = require('../headers');
var base_response_options_1 = require('../base_response_options');
var core_1 = require('@angular/core');
var browser_xhr_1 = require('./browser_xhr');
var lang_1 = require('../../src/facade/lang');
var Observable_1 = require('rxjs/Observable');
var http_utils_1 = require('../http_utils');
/**
* Creates connections using `XMLHttpRequest`. Given a fully-qualified
* request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
* request.
*
* This class would typically not be created or interacted with directly inside applications, though
* the {@link MockConnection} may be interacted with in tests.
*/
var XHRConnection = (function () {
    function XHRConnection(req, browserXHR, baseResponseOptions) {
        var _this = this;
        this.request = req;
        this.response = new Observable_1.Observable(function (responseObserver) {
            var _xhr = browserXHR.build();
            _xhr.open(enums_1.RequestMethod[req.method].toUpperCase(), req.url);
            // load event handler
            var onLoad = function () {
                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                // response/responseType properties were introduced in XHR Level2 spec (supported by
                // IE10)
                var body = lang_1.isPresent(_xhr.response) ? _xhr.response : _xhr.responseText;
                var headers = headers_1.Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
                var url = http_utils_1.getResponseURL(_xhr);
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status = _xhr.status === 1223 ? 204 : _xhr.status;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status === 0) {
                    status = body ? 200 : 0;
                }
                var responseOptions = new base_response_options_1.ResponseOptions({ body: body, status: status, headers: headers, url: url });
                if (lang_1.isPresent(baseResponseOptions)) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                var response = new static_response_1.Response(responseOptions);
                if (http_utils_1.isSuccess(status)) {
                    responseObserver.next(response);
                    // TODO(gdi2290): defer complete if array buffer until done
                    responseObserver.complete();
                    return;
                }
                responseObserver.error(response);
            };
            // error event handler
            var onError = function (err) {
                var responseOptions = new base_response_options_1.ResponseOptions({ body: err, type: enums_1.ResponseType.Error });
                if (lang_1.isPresent(baseResponseOptions)) {
                    responseOptions = baseResponseOptions.merge(responseOptions);
                }
                responseObserver.error(new static_response_1.Response(responseOptions));
            };
            if (lang_1.isPresent(req.headers)) {
                req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
            }
            _xhr.addEventListener('load', onLoad);
            _xhr.addEventListener('error', onError);
            _xhr.send(_this.request.text());
            return function () {
                _xhr.removeEventListener('load', onLoad);
                _xhr.removeEventListener('error', onError);
                _xhr.abort();
            };
        });
    }
    return XHRConnection;
}());
exports.XHRConnection = XHRConnection;
var XHRBackend = (function () {
    function XHRBackend(_browserXHR, _baseResponseOptions) {
        this._browserXHR = _browserXHR;
        this._baseResponseOptions = _baseResponseOptions;
    }
    XHRBackend.prototype.createConnection = function (request) {
        return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
    };
    XHRBackend.decorators = [
        { type: core_1.Injectable },
    ];
    XHRBackend.ctorParameters = [
        { type: browser_xhr_1.BrowserXhr, },
        { type: base_response_options_1.ResponseOptions, },
    ];
    return XHRBackend;
}());
exports.XHRBackend = XHRBackend;

},{"../../src/facade/lang":228,"../base_response_options":222,"../enums":223,"../headers":229,"../http_utils":231,"../static_response":234,"./browser_xhr":218,"@angular/core":140,"rxjs/Observable":290}],221:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../src/facade/lang');
var headers_1 = require('./headers');
var enums_1 = require('./enums');
var core_1 = require('@angular/core');
var url_search_params_1 = require('./url_search_params');
var http_utils_1 = require('./http_utils');
/**
 * Creates a request options object to be optionally provided when instantiating a
 * {@link Request}.
 *
 * This class is based on the `RequestInit` description in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#requestinit).
 *
 * All values are null by default. Typical defaults can be found in the {@link BaseRequestOptions}
 * class, which sub-classes `RequestOptions`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/7Wvi3lfLq41aQPKlxB4O?p=preview))
 *
 * ```typescript
 * import {RequestOptions, Request, RequestMethod} from '@angular/http';
 *
 * var options = new RequestOptions({
 *   method: RequestMethod.Post,
 *   url: 'https://google.com'
 * });
 * var req = new Request(options);
 * console.log('req.method:', RequestMethod[req.method]); // Post
 * console.log('options.url:', options.url); // https://google.com
 * ```
 */
var RequestOptions = (function () {
    function RequestOptions(_a) {
        var _b = _a === void 0 ? {} : _a, method = _b.method, headers = _b.headers, body = _b.body, url = _b.url, search = _b.search;
        this.method = lang_1.isPresent(method) ? http_utils_1.normalizeMethodName(method) : null;
        this.headers = lang_1.isPresent(headers) ? headers : null;
        this.body = lang_1.isPresent(body) ? body : null;
        this.url = lang_1.isPresent(url) ? url : null;
        this.search = lang_1.isPresent(search) ? (lang_1.isString(search) ? new url_search_params_1.URLSearchParams((search)) :
            (search)) :
            null;
    }
    /**
     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
     * existing values. This method will not change the values of the instance on which it is being
     * called.
     *
     * Note that `headers` and `search` will override existing values completely if present in
     * the `options` object. If these values should be merged, it should be done prior to calling
     * `merge` on the `RequestOptions` instance.
     *
     * ### Example ([live demo](http://plnkr.co/edit/6w8XA8YTkDRcPYpdB9dk?p=preview))
     *
     * ```typescript
     * import {RequestOptions, Request, RequestMethod} from '@angular/http';
     *
     * var options = new RequestOptions({
     *   method: RequestMethod.Post
     * });
     * var req = new Request(options.merge({
     *   url: 'https://google.com'
     * }));
     * console.log('req.method:', RequestMethod[req.method]); // Post
     * console.log('options.url:', options.url); // null
     * console.log('req.url:', req.url); // https://google.com
     * ```
     */
    RequestOptions.prototype.merge = function (options) {
        return new RequestOptions({
            method: lang_1.isPresent(options) && lang_1.isPresent(options.method) ? options.method : this.method,
            headers: lang_1.isPresent(options) && lang_1.isPresent(options.headers) ? options.headers : this.headers,
            body: lang_1.isPresent(options) && lang_1.isPresent(options.body) ? options.body : this.body,
            url: lang_1.isPresent(options) && lang_1.isPresent(options.url) ? options.url : this.url,
            search: lang_1.isPresent(options) && lang_1.isPresent(options.search) ?
                (lang_1.isString(options.search) ? new url_search_params_1.URLSearchParams((options.search)) :
                    (options.search).clone()) :
                this.search
        });
    };
    return RequestOptions;
}());
exports.RequestOptions = RequestOptions;
var BaseRequestOptions = (function (_super) {
    __extends(BaseRequestOptions, _super);
    function BaseRequestOptions() {
        _super.call(this, { method: enums_1.RequestMethod.Get, headers: new headers_1.Headers() });
    }
    BaseRequestOptions.decorators = [
        { type: core_1.Injectable },
    ];
    BaseRequestOptions.ctorParameters = [];
    return BaseRequestOptions;
}(RequestOptions));
exports.BaseRequestOptions = BaseRequestOptions;

},{"../src/facade/lang":228,"./enums":223,"./headers":229,"./http_utils":231,"./url_search_params":235,"@angular/core":140}],222:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../src/facade/lang');
var headers_1 = require('./headers');
var enums_1 = require('./enums');
/**
 * Creates a response options object to be optionally provided when instantiating a
 * {@link Response}.
 *
 * This class is based on the `ResponseInit` description in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#responseinit).
 *
 * All values are null by default. Typical defaults can be found in the
 * {@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.
 *
 * This class may be used in tests to build {@link Response Responses} for
 * mock responses (see {@link MockBackend}).
 *
 * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))
 *
 * ```typescript
 * import {ResponseOptions, Response} from '@angular/http';
 *
 * var options = new ResponseOptions({
 *   body: '{"name":"Jeff"}'
 * });
 * var res = new Response(options);
 *
 * console.log('res.json():', res.json()); // Object {name: "Jeff"}
 * ```
 */
var ResponseOptions = (function () {
    function ResponseOptions(_a) {
        var _b = _a === void 0 ? {} : _a, body = _b.body, status = _b.status, headers = _b.headers, statusText = _b.statusText, type = _b.type, url = _b.url;
        this.body = lang_1.isPresent(body) ? body : null;
        this.status = lang_1.isPresent(status) ? status : null;
        this.headers = lang_1.isPresent(headers) ? headers : null;
        this.statusText = lang_1.isPresent(statusText) ? statusText : null;
        this.type = lang_1.isPresent(type) ? type : null;
        this.url = lang_1.isPresent(url) ? url : null;
    }
    /**
     * Creates a copy of the `ResponseOptions` instance, using the optional input as values to
     * override
     * existing values. This method will not change the values of the instance on which it is being
     * called.
     *
     * This may be useful when sharing a base `ResponseOptions` object inside tests,
     * where certain properties may change from test to test.
     *
     * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))
     *
     * ```typescript
     * import {ResponseOptions, Response} from '@angular/http';
     *
     * var options = new ResponseOptions({
     *   body: {name: 'Jeff'}
     * });
     * var res = new Response(options.merge({
     *   url: 'https://google.com'
     * }));
     * console.log('options.url:', options.url); // null
     * console.log('res.json():', res.json()); // Object {name: "Jeff"}
     * console.log('res.url:', res.url); // https://google.com
     * ```
     */
    ResponseOptions.prototype.merge = function (options) {
        return new ResponseOptions({
            body: lang_1.isPresent(options) && lang_1.isPresent(options.body) ? options.body : this.body,
            status: lang_1.isPresent(options) && lang_1.isPresent(options.status) ? options.status : this.status,
            headers: lang_1.isPresent(options) && lang_1.isPresent(options.headers) ? options.headers : this.headers,
            statusText: lang_1.isPresent(options) && lang_1.isPresent(options.statusText) ? options.statusText :
                this.statusText,
            type: lang_1.isPresent(options) && lang_1.isPresent(options.type) ? options.type : this.type,
            url: lang_1.isPresent(options) && lang_1.isPresent(options.url) ? options.url : this.url,
        });
    };
    return ResponseOptions;
}());
exports.ResponseOptions = ResponseOptions;
var BaseResponseOptions = (function (_super) {
    __extends(BaseResponseOptions, _super);
    function BaseResponseOptions() {
        _super.call(this, { status: 200, statusText: 'Ok', type: enums_1.ResponseType.Default, headers: new headers_1.Headers() });
    }
    BaseResponseOptions.decorators = [
        { type: core_1.Injectable },
    ];
    BaseResponseOptions.ctorParameters = [];
    return BaseResponseOptions;
}(ResponseOptions));
exports.BaseResponseOptions = BaseResponseOptions;

},{"../src/facade/lang":228,"./enums":223,"./headers":229,"@angular/core":140}],223:[function(require,module,exports){
"use strict";
/**
* Supported http methods.
*/
(function (RequestMethod) {
    RequestMethod[RequestMethod["Get"] = 0] = "Get";
    RequestMethod[RequestMethod["Post"] = 1] = "Post";
    RequestMethod[RequestMethod["Put"] = 2] = "Put";
    RequestMethod[RequestMethod["Delete"] = 3] = "Delete";
    RequestMethod[RequestMethod["Options"] = 4] = "Options";
    RequestMethod[RequestMethod["Head"] = 5] = "Head";
    RequestMethod[RequestMethod["Patch"] = 6] = "Patch";
})(exports.RequestMethod || (exports.RequestMethod = {}));
var RequestMethod = exports.RequestMethod;
/**
 * All possible states in which a connection can be, based on
 * [States](http://www.w3.org/TR/XMLHttpRequest/#states) from the `XMLHttpRequest` spec, but with an
 * additional "CANCELLED" state.
 */
(function (ReadyState) {
    ReadyState[ReadyState["Unsent"] = 0] = "Unsent";
    ReadyState[ReadyState["Open"] = 1] = "Open";
    ReadyState[ReadyState["HeadersReceived"] = 2] = "HeadersReceived";
    ReadyState[ReadyState["Loading"] = 3] = "Loading";
    ReadyState[ReadyState["Done"] = 4] = "Done";
    ReadyState[ReadyState["Cancelled"] = 5] = "Cancelled";
})(exports.ReadyState || (exports.ReadyState = {}));
var ReadyState = exports.ReadyState;
/**
 * Acceptable response types to be associated with a {@link Response}, based on
 * [ResponseType](https://fetch.spec.whatwg.org/#responsetype) from the Fetch spec.
 */
(function (ResponseType) {
    ResponseType[ResponseType["Basic"] = 0] = "Basic";
    ResponseType[ResponseType["Cors"] = 1] = "Cors";
    ResponseType[ResponseType["Default"] = 2] = "Default";
    ResponseType[ResponseType["Error"] = 3] = "Error";
    ResponseType[ResponseType["Opaque"] = 4] = "Opaque";
})(exports.ResponseType || (exports.ResponseType = {}));
var ResponseType = exports.ResponseType;

},{}],224:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],225:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./lang":228,"dup":22}],226:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./base_wrapped_exception":224,"./collection":225,"./lang":228,"dup":23}],227:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./base_wrapped_exception":224,"./exception_handler":226,"dup":24}],228:[function(require,module,exports){
(function (global){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
exports.scheduleMicroTask = scheduleMicroTask;
exports.IS_DART = false;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    if (type['name']) {
        return type['name'];
    }
    return typeof type;
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var _devMode = true;
var _modeLocked = false;
function lockMode() {
    _modeLocked = true;
}
exports.lockMode = lockMode;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 */
function enableProdMode() {
    if (_modeLocked) {
        // Cannot use BaseException as that ends up importing from facade/lang.
        throw 'Cannot enable prod mode after platform setup.';
    }
    _devMode = false;
}
exports.enableProdMode = enableProdMode;
function assertionsEnabled() {
    return _devMode;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    // TODO: to be fixed properly via #2830, noop for now
};
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isBoolean(obj) {
    return typeof obj === "boolean";
}
exports.isBoolean = isBoolean;
function isNumber(obj) {
    return typeof obj === "number";
}
exports.isNumber = isNumber;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
var STRING_MAP_PROTO = Object.getPrototypeOf({});
function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
}
exports.isStrictStringMap = isStrictStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function noop() { }
exports.noop = noop;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    if (token.overriddenName) {
        return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
function resolveEnumToken(enumValue, val) {
    return enumValue[val];
}
exports.resolveEnumToken = resolveEnumToken;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.stripLeft = function (s, charVal) {
        if (s && s.length) {
            var pos = 0;
            for (var i = 0; i < s.length; i++) {
                if (s[i] != charVal)
                    break;
                pos++;
            }
            s = s.substring(pos);
        }
        return s;
    };
    StringWrapper.stripRight = function (s, charVal) {
        if (s && s.length) {
            var pos = s.length;
            for (var i = s.length - 1; i >= 0; i--) {
                if (s[i] != charVal)
                    break;
                pos--;
            }
            s = s.substring(0, pos);
        }
        return s;
    };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
}());
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
}());
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
}(Error));
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
}());
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    RegExpWrapper.replaceAll = function (regExp, input, replace) {
        var c = regExp.exec(input);
        var res = '';
        regExp.lastIndex = 0;
        var prev = 0;
        while (c) {
            res += input.substring(prev, c.index);
            res += replace(c);
            prev = c.index + c[0].length;
            regExp.lastIndex = prev;
            c = regExp.exec(input);
        }
        res += input.substring(prev);
        return res;
    };
    return RegExpWrapper;
}());
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
}());
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
}());
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
function warn(obj) {
    console.warn(obj);
}
exports.warn = warn;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
}());
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
}());
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;
function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
        fnArgNames.push(argName);
        fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
}
exports.evalExpression = evalExpression;
function isPrimitive(obj) {
    return !isJsObject(obj);
}
exports.isPrimitive = isPrimitive;
function hasConstructor(value, type) {
    return value.constructor === type;
}
exports.hasConstructor = hasConstructor;
function bitWiseOr(values) {
    return values.reduce(function (a, b) { return a | b; });
}
exports.bitWiseOr = bitWiseOr;
function bitWiseAnd(values) {
    return values.reduce(function (a, b) { return a & b; });
}
exports.bitWiseAnd = bitWiseAnd;
function escape(s) {
    return _global.encodeURI(s);
}
exports.escape = escape;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],229:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var collection_1 = require('../src/facade/collection');
/**
 * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
 * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).
 *
 * The only known difference between this `Headers` implementation and the spec is the
 * lack of an `entries` method.
 *
 * ### Example ([live demo](http://plnkr.co/edit/MTdwT6?p=preview))
 *
 * ```
 * import {Headers} from '@angular/http';
 *
 * var firstHeaders = new Headers();
 * firstHeaders.append('Content-Type', 'image/jpeg');
 * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'
 *
 * // Create headers from Plain Old JavaScript Object
 * var secondHeaders = new Headers({
 *   'X-My-Custom-Header': 'Angular'
 * });
 * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'
 *
 * var thirdHeaders = new Headers(secondHeaders);
 * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'
 * ```
 */
var Headers = (function () {
    function Headers(headers) {
        var _this = this;
        if (headers instanceof Headers) {
            this._headersMap = headers._headersMap;
            return;
        }
        this._headersMap = new collection_1.Map();
        if (lang_1.isBlank(headers)) {
            return;
        }
        // headers instanceof StringMap
        collection_1.StringMapWrapper.forEach(headers, function (v, k) {
            _this._headersMap.set(k, collection_1.isListLikeIterable(v) ? v : [v]);
        });
    }
    /**
     * Returns a new Headers instance from the given DOMString of Response Headers
     */
    Headers.fromResponseHeaderString = function (headersString) {
        return headersString.trim()
            .split('\n')
            .map(function (val) { return val.split(':'); })
            .map(function (_a) {
            var key = _a[0], parts = _a.slice(1);
            return ([key.trim(), parts.join(':').trim()]);
        })
            .reduce(function (headers, _a) {
            var key = _a[0], value = _a[1];
            return !headers.set(key, value) && headers;
        }, new Headers());
    };
    /**
     * Appends a header to existing list of header values for a given header name.
     */
    Headers.prototype.append = function (name, value) {
        var mapName = this._headersMap.get(name);
        var list = collection_1.isListLikeIterable(mapName) ? mapName : [];
        list.push(value);
        this._headersMap.set(name, list);
    };
    /**
     * Deletes all header values for the given name.
     */
    Headers.prototype.delete = function (name) { this._headersMap.delete(name); };
    Headers.prototype.forEach = function (fn) {
        this._headersMap.forEach(fn);
    };
    /**
     * Returns first header that matches given name.
     */
    Headers.prototype.get = function (header) { return collection_1.ListWrapper.first(this._headersMap.get(header)); };
    /**
     * Check for existence of header by given name.
     */
    Headers.prototype.has = function (header) { return this._headersMap.has(header); };
    /**
     * Provides names of set headers
     */
    Headers.prototype.keys = function () { return collection_1.MapWrapper.keys(this._headersMap); };
    /**
     * Sets or overrides header value for given name.
     */
    Headers.prototype.set = function (header, value) {
        var list = [];
        if (collection_1.isListLikeIterable(value)) {
            var pushValue = value.join(',');
            list.push(pushValue);
        }
        else {
            list.push(value);
        }
        this._headersMap.set(header, list);
    };
    /**
     * Returns values of all headers.
     */
    Headers.prototype.values = function () { return collection_1.MapWrapper.values(this._headersMap); };
    /**
     * Returns string of all headers.
     */
    Headers.prototype.toJSON = function () {
        var serializableHeaders = {};
        this._headersMap.forEach(function (values, name) {
            var list = [];
            collection_1.iterateListLike(values, function (val) { return list = collection_1.ListWrapper.concat(list, val.split(',')); });
            serializableHeaders[name] = list;
        });
        return serializableHeaders;
    };
    /**
     * Returns list of header values for a given name.
     */
    Headers.prototype.getAll = function (header) {
        var headers = this._headersMap.get(header);
        return collection_1.isListLikeIterable(headers) ? headers : [];
    };
    /**
     * This method is not implemented.
     */
    Headers.prototype.entries = function () { throw new exceptions_1.BaseException('"entries" method is not implemented on Headers class'); };
    return Headers;
}());
exports.Headers = Headers;

},{"../src/facade/collection":225,"../src/facade/exceptions":227,"../src/facade/lang":228}],230:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var core_1 = require('@angular/core');
var interfaces_1 = require('./interfaces');
var static_request_1 = require('./static_request');
var base_request_options_1 = require('./base_request_options');
var enums_1 = require('./enums');
function httpRequest(backend, request) {
    return backend.createConnection(request).response;
}
function mergeOptions(defaultOpts, providedOpts, method, url) {
    var newOptions = defaultOpts;
    if (lang_1.isPresent(providedOpts)) {
        // Hack so Dart can used named parameters
        return newOptions.merge(new base_request_options_1.RequestOptions({
            method: providedOpts.method || method,
            url: providedOpts.url || url,
            search: providedOpts.search,
            headers: providedOpts.headers,
            body: providedOpts.body
        }));
    }
    if (lang_1.isPresent(method)) {
        return newOptions.merge(new base_request_options_1.RequestOptions({ method: method, url: url }));
    }
    else {
        return newOptions.merge(new base_request_options_1.RequestOptions({ url: url }));
    }
}
var Http = (function () {
    function Http(_backend, _defaultOptions) {
        this._backend = _backend;
        this._defaultOptions = _defaultOptions;
    }
    /**
     * Performs any type of http request. First argument is required, and can either be a url or
     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
     * object can be provided as the 2nd argument. The options object will be merged with the values
     * of {@link BaseRequestOptions} before performing the request.
     */
    Http.prototype.request = function (url, options) {
        var responseObservable;
        if (lang_1.isString(url)) {
            responseObservable = httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Get, url)));
        }
        else if (url instanceof static_request_1.Request) {
            responseObservable = httpRequest(this._backend, url);
        }
        else {
            throw exceptions_1.makeTypeError('First argument must be a url string or Request instance.');
        }
        return responseObservable;
    };
    /**
     * Performs a request with `get` http method.
     */
    Http.prototype.get = function (url, options) {
        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Get, url)));
    };
    /**
     * Performs a request with `post` http method.
     */
    Http.prototype.post = function (url, body, options) {
        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions.merge(new base_request_options_1.RequestOptions({ body: body })), options, enums_1.RequestMethod.Post, url)));
    };
    /**
     * Performs a request with `put` http method.
     */
    Http.prototype.put = function (url, body, options) {
        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions.merge(new base_request_options_1.RequestOptions({ body: body })), options, enums_1.RequestMethod.Put, url)));
    };
    /**
     * Performs a request with `delete` http method.
     */
    Http.prototype.delete = function (url, options) {
        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Delete, url)));
    };
    /**
     * Performs a request with `patch` http method.
     */
    Http.prototype.patch = function (url, body, options) {
        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions.merge(new base_request_options_1.RequestOptions({ body: body })), options, enums_1.RequestMethod.Patch, url)));
    };
    /**
     * Performs a request with `head` http method.
     */
    Http.prototype.head = function (url, options) {
        return httpRequest(this._backend, new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Head, url)));
    };
    Http.decorators = [
        { type: core_1.Injectable },
    ];
    Http.ctorParameters = [
        { type: interfaces_1.ConnectionBackend, },
        { type: base_request_options_1.RequestOptions, },
    ];
    return Http;
}());
exports.Http = Http;
var Jsonp = (function (_super) {
    __extends(Jsonp, _super);
    function Jsonp(backend, defaultOptions) {
        _super.call(this, backend, defaultOptions);
    }
    /**
     * Performs any type of http request. First argument is required, and can either be a url or
     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
     * object can be provided as the 2nd argument. The options object will be merged with the values
     * of {@link BaseRequestOptions} before performing the request.
     */
    Jsonp.prototype.request = function (url, options) {
        var responseObservable;
        if (lang_1.isString(url)) {
            url =
                new static_request_1.Request(mergeOptions(this._defaultOptions, options, enums_1.RequestMethod.Get, url));
        }
        if (url instanceof static_request_1.Request) {
            if (url.method !== enums_1.RequestMethod.Get) {
                exceptions_1.makeTypeError('JSONP requests must use GET request method.');
            }
            responseObservable = httpRequest(this._backend, url);
        }
        else {
            throw exceptions_1.makeTypeError('First argument must be a url string or Request instance.');
        }
        return responseObservable;
    };
    Jsonp.decorators = [
        { type: core_1.Injectable },
    ];
    Jsonp.ctorParameters = [
        { type: interfaces_1.ConnectionBackend, },
        { type: base_request_options_1.RequestOptions, },
    ];
    return Jsonp;
}(Http));
exports.Jsonp = Jsonp;

},{"../src/facade/exceptions":227,"../src/facade/lang":228,"./base_request_options":221,"./enums":223,"./interfaces":232,"./static_request":233,"@angular/core":140}],231:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var enums_1 = require('./enums');
var exceptions_1 = require('../src/facade/exceptions');
function normalizeMethodName(method) {
    if (lang_1.isString(method)) {
        var originalMethod = method;
        method = method
            .replace(/(\w)(\w*)/g, function (g0, g1, g2) {
            return g1.toUpperCase() + g2.toLowerCase();
        });
        method = enums_1.RequestMethod[method];
        if (typeof method !== 'number')
            throw exceptions_1.makeTypeError("Invalid request method. The method \"" + originalMethod + "\" is not supported.");
    }
    return method;
}
exports.normalizeMethodName = normalizeMethodName;
exports.isSuccess = function (status) { return (status >= 200 && status < 300); };
function getResponseURL(xhr) {
    if ('responseURL' in xhr) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return;
}
exports.getResponseURL = getResponseURL;
var lang_2 = require('../src/facade/lang');
exports.isJsObject = lang_2.isJsObject;

},{"../src/facade/exceptions":227,"../src/facade/lang":228,"./enums":223}],232:[function(require,module,exports){
"use strict";
/**
 * Abstract class from which real backends are derived.
 *
 * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
 * {@link Request}.
 */
var ConnectionBackend = (function () {
    function ConnectionBackend() {
    }
    return ConnectionBackend;
}());
exports.ConnectionBackend = ConnectionBackend;
/**
 * Abstract class from which real connections are derived.
 */
var Connection = (function () {
    function Connection() {
    }
    return Connection;
}());
exports.Connection = Connection;

},{}],233:[function(require,module,exports){
"use strict";
var headers_1 = require('./headers');
var http_utils_1 = require('./http_utils');
var lang_1 = require('../src/facade/lang');
// TODO(jeffbcross): properly implement body accessors
/**
 * Creates `Request` instances from provided values.
 *
 * The Request's interface is inspired by the Request constructor defined in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#request-class),
 * but is considered a static value whose body can be accessed many times. There are other
 * differences in the implementation, but this is the most significant.
 *
 * `Request` instances are typically created by higher-level classes, like {@link Http} and
 * {@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
 * One such example is when creating services that wrap higher-level services, like {@link Http},
 * where it may be useful to generate a `Request` with arbitrary headers and search params.
 *
 * ```typescript
 * import {Injectable, Injector} from '@angular/core';
 * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '@angular/http';
 *
 * @Injectable()
 * class AutoAuthenticator {
 *   constructor(public http:Http) {}
 *   request(url:string) {
 *     return this.http.request(new Request({
 *       method: RequestMethod.Get,
 *       url: url,
 *       search: 'password=123'
 *     }));
 *   }
 * }
 *
 * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
 * var authenticator = injector.get(AutoAuthenticator);
 * authenticator.request('people.json').subscribe(res => {
 *   //URL should have included '?password=123'
 *   console.log('people', res.json());
 * });
 * ```
 */
var Request = (function () {
    function Request(requestOptions) {
        // TODO: assert that url is present
        var url = requestOptions.url;
        this.url = requestOptions.url;
        if (lang_1.isPresent(requestOptions.search)) {
            var search = requestOptions.search.toString();
            if (search.length > 0) {
                var prefix = '?';
                if (lang_1.StringWrapper.contains(this.url, '?')) {
                    prefix = (this.url[this.url.length - 1] == '&') ? '' : '&';
                }
                // TODO: just delete search-query-looking string in url?
                this.url = url + prefix + search;
            }
        }
        this._body = requestOptions.body;
        this.method = http_utils_1.normalizeMethodName(requestOptions.method);
        // TODO(jeffbcross): implement behavior
        // Defaults to 'omit', consistent with browser
        // TODO(jeffbcross): implement behavior
        this.headers = new headers_1.Headers(requestOptions.headers);
    }
    /**
     * Returns the request's body as string, assuming that body exists. If body is undefined, return
     * empty
     * string.
     */
    Request.prototype.text = function () { return lang_1.isPresent(this._body) ? this._body.toString() : ''; };
    return Request;
}());
exports.Request = Request;

},{"../src/facade/lang":228,"./headers":229,"./http_utils":231}],234:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var exceptions_1 = require('../src/facade/exceptions');
var http_utils_1 = require('./http_utils');
/**
 * Creates `Response` instances from provided values.
 *
 * Though this object isn't
 * usually instantiated by end-users, it is the primary object interacted with when it comes time to
 * add data to a view.
 *
 * ### Example
 *
 * ```
 * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
 * ```
 *
 * The Response's interface is inspired by the Response constructor defined in the [Fetch
 * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
 * can be accessed many times. There are other differences in the implementation, but this is the
 * most significant.
 */
var Response = (function () {
    function Response(responseOptions) {
        this._body = responseOptions.body;
        this.status = responseOptions.status;
        this.ok = (this.status >= 200 && this.status <= 299);
        this.statusText = responseOptions.statusText;
        this.headers = responseOptions.headers;
        this.type = responseOptions.type;
        this.url = responseOptions.url;
    }
    /**
     * Not yet implemented
     */
    // TODO: Blob return type
    Response.prototype.blob = function () { throw new exceptions_1.BaseException('"blob()" method not implemented on Response superclass'); };
    /**
     * Attempts to return body as parsed `JSON` object, or raises an exception.
     */
    Response.prototype.json = function () {
        var jsonResponse;
        if (http_utils_1.isJsObject(this._body)) {
            jsonResponse = this._body;
        }
        else if (lang_1.isString(this._body)) {
            jsonResponse = lang_1.Json.parse(this._body);
        }
        return jsonResponse;
    };
    /**
     * Returns the body as a string, presuming `toString()` can be called on the response body.
     */
    Response.prototype.text = function () { return this._body.toString(); };
    /**
     * Not yet implemented
     */
    // TODO: ArrayBuffer return type
    Response.prototype.arrayBuffer = function () {
        throw new exceptions_1.BaseException('"arrayBuffer()" method not implemented on Response superclass');
    };
    return Response;
}());
exports.Response = Response;

},{"../src/facade/exceptions":227,"../src/facade/lang":228,"./http_utils":231}],235:[function(require,module,exports){
"use strict";
var lang_1 = require('../src/facade/lang');
var collection_1 = require('../src/facade/collection');
function paramParser(rawParams) {
    if (rawParams === void 0) { rawParams = ''; }
    var map = new collection_1.Map();
    if (rawParams.length > 0) {
        var params = rawParams.split('&');
        params.forEach(function (param) {
            var split = param.split('=');
            var key = split[0];
            var val = split[1];
            var list = lang_1.isPresent(map.get(key)) ? map.get(key) : [];
            list.push(val);
            map.set(key, list);
        });
    }
    return map;
}
/**
 * Map-like representation of url search parameters, based on
 * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,
 * with several extensions for merging URLSearchParams objects:
 *   - setAll()
 *   - appendAll()
 *   - replaceAll()
 */
var URLSearchParams = (function () {
    function URLSearchParams(rawParams) {
        if (rawParams === void 0) { rawParams = ''; }
        this.rawParams = rawParams;
        this.paramsMap = paramParser(rawParams);
    }
    URLSearchParams.prototype.clone = function () {
        var clone = new URLSearchParams();
        clone.appendAll(this);
        return clone;
    };
    URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };
    URLSearchParams.prototype.get = function (param) {
        var storedParam = this.paramsMap.get(param);
        if (collection_1.isListLikeIterable(storedParam)) {
            return collection_1.ListWrapper.first(storedParam);
        }
        else {
            return null;
        }
    };
    URLSearchParams.prototype.getAll = function (param) {
        var mapParam = this.paramsMap.get(param);
        return lang_1.isPresent(mapParam) ? mapParam : [];
    };
    URLSearchParams.prototype.set = function (param, val) {
        var mapParam = this.paramsMap.get(param);
        var list = lang_1.isPresent(mapParam) ? mapParam : [];
        collection_1.ListWrapper.clear(list);
        list.push(val);
        this.paramsMap.set(param, list);
    };
    // A merge operation
    // For each name-values pair in `searchParams`, perform `set(name, values[0])`
    //
    // E.g: "a=[1,2,3], c=[8]" + "a=[4,5,6], b=[7]" = "a=[4], c=[8], b=[7]"
    //
    // TODO(@caitp): document this better
    URLSearchParams.prototype.setAll = function (searchParams) {
        var _this = this;
        searchParams.paramsMap.forEach(function (value, param) {
            var mapParam = _this.paramsMap.get(param);
            var list = lang_1.isPresent(mapParam) ? mapParam : [];
            collection_1.ListWrapper.clear(list);
            list.push(value[0]);
            _this.paramsMap.set(param, list);
        });
    };
    URLSearchParams.prototype.append = function (param, val) {
        var mapParam = this.paramsMap.get(param);
        var list = lang_1.isPresent(mapParam) ? mapParam : [];
        list.push(val);
        this.paramsMap.set(param, list);
    };
    // A merge operation
    // For each name-values pair in `searchParams`, perform `append(name, value)`
    // for each value in `values`.
    //
    // E.g: "a=[1,2], c=[8]" + "a=[3,4], b=[7]" = "a=[1,2,3,4], c=[8], b=[7]"
    //
    // TODO(@caitp): document this better
    URLSearchParams.prototype.appendAll = function (searchParams) {
        var _this = this;
        searchParams.paramsMap.forEach(function (value, param) {
            var mapParam = _this.paramsMap.get(param);
            var list = lang_1.isPresent(mapParam) ? mapParam : [];
            for (var i = 0; i < value.length; ++i) {
                list.push(value[i]);
            }
            _this.paramsMap.set(param, list);
        });
    };
    // A merge operation
    // For each name-values pair in `searchParams`, perform `delete(name)`,
    // followed by `set(name, values)`
    //
    // E.g: "a=[1,2,3], c=[8]" + "a=[4,5,6], b=[7]" = "a=[4,5,6], c=[8], b=[7]"
    //
    // TODO(@caitp): document this better
    URLSearchParams.prototype.replaceAll = function (searchParams) {
        var _this = this;
        searchParams.paramsMap.forEach(function (value, param) {
            var mapParam = _this.paramsMap.get(param);
            var list = lang_1.isPresent(mapParam) ? mapParam : [];
            collection_1.ListWrapper.clear(list);
            for (var i = 0; i < value.length; ++i) {
                list.push(value[i]);
            }
            _this.paramsMap.set(param, list);
        });
    };
    URLSearchParams.prototype.toString = function () {
        var paramsList = [];
        this.paramsMap.forEach(function (values, k) { values.forEach(function (v) { return paramsList.push(k + '=' + v); }); });
        return paramsList.join('&');
    };
    URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };
    return URLSearchParams;
}());
exports.URLSearchParams = URLSearchParams;

},{"../src/facade/collection":225,"../src/facade/lang":228}],236:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
exports.ReflectionCapabilities = core_1.__core_private__.ReflectionCapabilities;

},{"@angular/core":140}],237:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./platform_browser_dynamic'));

},{"./platform_browser_dynamic":238}],238:[function(require,module,exports){
"use strict";
var compiler_1 = require('@angular/compiler');
var xhr_cache_1 = require('./src/xhr/xhr_cache');
var lang_1 = require('./src/facade/lang');
var xhr_impl_1 = require('./src/xhr/xhr_impl');
var platform_browser_1 = require('@angular/platform-browser');
var core_1 = require('@angular/core');
var core_private_1 = require('./core_private');
exports.CACHED_TEMPLATE_PROVIDER = 
/*@ts2dart_const*/ [{ provide: compiler_1.XHR, useClass: xhr_cache_1.CachedXHR }];
/**
 * An array of providers that should be passed into `application()` when bootstrapping a component.
 */
exports.BROWSER_APP_DYNAMIC_PROVIDERS = 
/*@ts2dart_const*/ [
    platform_browser_1.BROWSER_APP_COMMON_PROVIDERS,
    compiler_1.COMPILER_PROVIDERS,
    { provide: compiler_1.XHR, useClass: xhr_impl_1.XHRImpl },
];
/**
 * Bootstrapping for Angular applications.
 *
 * You instantiate an Angular application by explicitly specifying a component to use
 * as the root component for your application via the `bootstrap()` method.
 *
 * ## Simple Example
 *
 * Assuming this `index.html`:
 *
 * ```html
 * <html>
 *   <!-- load Angular script tags here. -->
 *   <body>
 *     <my-app>loading...</my-app>
 *   </body>
 * </html>
 * ```
 *
 * An application is bootstrapped inside an existing browser DOM, typically `index.html`.
 * Unlike Angular 1, Angular 2 does not compile/process providers in `index.html`. This is
 * mainly for security reasons, as well as architectural changes in Angular 2. This means
 * that `index.html` can safely be processed using server-side technologies such as
 * providers. Bindings can thus use double-curly `{{ syntax }}` without collision from
 * Angular 2 component double-curly `{{ syntax }}`.
 *
 * We can use this script code:
 *
 * {@example core/ts/bootstrap/bootstrap.ts region='bootstrap'}
 *
 * When the app developer invokes `bootstrap()` with the root component `MyApp` as its
 * argument, Angular performs the following tasks:
 *
 *  1. It uses the component's `selector` property to locate the DOM element which needs
 *     to be upgraded into the angular component.
 *  2. It creates a new child injector (from the platform injector). Optionally, you can
 *     also override the injector configuration for an app by invoking `bootstrap` with the
 *     `componentInjectableBindings` argument.
 *  3. It creates a new `Zone` and connects it to the angular application's change detection
 *     domain instance.
 *  4. It creates an emulated or shadow DOM on the selected component's host element and loads the
 *     template into it.
 *  5. It instantiates the specified component.
 *  6. Finally, Angular performs change detection to apply the initial data providers for the
 *     application.
 *
 *
 * ## Bootstrapping Multiple Applications
 *
 * When working within a browser window, there are many singleton resources: cookies, title,
 * location, and others. Angular services that represent these resources must likewise be
 * shared across all Angular applications that occupy the same browser window. For this
 * reason, Angular creates exactly one global platform object which stores all shared
 * services, and each angular application injector has the platform injector as its parent.
 *
 * Each application has its own private injector as well. When there are multiple
 * applications on a page, Angular treats each application injector's services as private
 * to that application.
 *
 * ## API
 *
 * - `appComponentType`: The root component which should act as the application. This is
 *   a reference to a `Type` which is annotated with `@Component(...)`.
 * - `customProviders`: An additional set of providers that can be added to the
 *   app injector to override default injection behavior.
 *
 * Returns a `Promise` of {@link ComponentRef}.
 */
function bootstrap(appComponentType, customProviders) {
    core_1.reflector.reflectionCapabilities = new core_private_1.ReflectionCapabilities();
    var appInjector = core_1.ReflectiveInjector.resolveAndCreate([exports.BROWSER_APP_DYNAMIC_PROVIDERS, lang_1.isPresent(customProviders) ? customProviders : []], platform_browser_1.browserPlatform().injector);
    return core_1.coreLoadAndBootstrap(appInjector, appComponentType);
}
exports.bootstrap = bootstrap;

},{"./core_private":236,"./src/facade/lang":243,"./src/xhr/xhr_cache":245,"./src/xhr/xhr_impl":246,"@angular/compiler":73,"@angular/core":140,"@angular/platform-browser":248}],239:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],240:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./lang":243,"dup":22}],241:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./base_wrapped_exception":239,"./collection":240,"./lang":243,"dup":23}],242:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./base_wrapped_exception":239,"./exception_handler":241,"dup":24}],243:[function(require,module,exports){
(function (global){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
exports.scheduleMicroTask = scheduleMicroTask;
exports.IS_DART = false;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    if (type['name']) {
        return type['name'];
    }
    return typeof type;
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var _devMode = true;
var _modeLocked = false;
function lockMode() {
    _modeLocked = true;
}
exports.lockMode = lockMode;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 */
function enableProdMode() {
    if (_modeLocked) {
        // Cannot use BaseException as that ends up importing from facade/lang.
        throw 'Cannot enable prod mode after platform setup.';
    }
    _devMode = false;
}
exports.enableProdMode = enableProdMode;
function assertionsEnabled() {
    return _devMode;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    // TODO: to be fixed properly via #2830, noop for now
};
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isBoolean(obj) {
    return typeof obj === "boolean";
}
exports.isBoolean = isBoolean;
function isNumber(obj) {
    return typeof obj === "number";
}
exports.isNumber = isNumber;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
var STRING_MAP_PROTO = Object.getPrototypeOf({});
function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
}
exports.isStrictStringMap = isStrictStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function noop() { }
exports.noop = noop;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    if (token.overriddenName) {
        return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
function resolveEnumToken(enumValue, val) {
    return enumValue[val];
}
exports.resolveEnumToken = resolveEnumToken;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.stripLeft = function (s, charVal) {
        if (s && s.length) {
            var pos = 0;
            for (var i = 0; i < s.length; i++) {
                if (s[i] != charVal)
                    break;
                pos++;
            }
            s = s.substring(pos);
        }
        return s;
    };
    StringWrapper.stripRight = function (s, charVal) {
        if (s && s.length) {
            var pos = s.length;
            for (var i = s.length - 1; i >= 0; i--) {
                if (s[i] != charVal)
                    break;
                pos--;
            }
            s = s.substring(0, pos);
        }
        return s;
    };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
}());
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
}());
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
}(Error));
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
}());
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    RegExpWrapper.replaceAll = function (regExp, input, replace) {
        var c = regExp.exec(input);
        var res = '';
        regExp.lastIndex = 0;
        var prev = 0;
        while (c) {
            res += input.substring(prev, c.index);
            res += replace(c);
            prev = c.index + c[0].length;
            regExp.lastIndex = prev;
            c = regExp.exec(input);
        }
        res += input.substring(prev);
        return res;
    };
    return RegExpWrapper;
}());
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
}());
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
}());
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
function warn(obj) {
    console.warn(obj);
}
exports.warn = warn;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
}());
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
}());
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;
function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
        fnArgNames.push(argName);
        fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
}
exports.evalExpression = evalExpression;
function isPrimitive(obj) {
    return !isJsObject(obj);
}
exports.isPrimitive = isPrimitive;
function hasConstructor(value, type) {
    return value.constructor === type;
}
exports.hasConstructor = hasConstructor;
function bitWiseOr(values) {
    return values.reduce(function (a, b) { return a | b; });
}
exports.bitWiseOr = bitWiseOr;
function bitWiseAnd(values) {
    return values.reduce(function (a, b) { return a & b; });
}
exports.bitWiseAnd = bitWiseAnd;
function escape(s) {
    return _global.encodeURI(s);
}
exports.escape = escape;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],244:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],245:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var compiler_1 = require('@angular/compiler');
var exceptions_1 = require('../../src/facade/exceptions');
var lang_1 = require('../../src/facade/lang');
var promise_1 = require('../../src/facade/promise');
/**
 * An implementation of XHR that uses a template cache to avoid doing an actual
 * XHR.
 *
 * The template cache needs to be built and loaded into window.$templateCache
 * via a separate mechanism.
 */
var CachedXHR = (function (_super) {
    __extends(CachedXHR, _super);
    function CachedXHR() {
        _super.call(this);
        this._cache = lang_1.global.$templateCache;
        if (this._cache == null) {
            throw new exceptions_1.BaseException('CachedXHR: Template cache was not found in $templateCache.');
        }
    }
    CachedXHR.prototype.get = function (url) {
        if (this._cache.hasOwnProperty(url)) {
            return promise_1.PromiseWrapper.resolve(this._cache[url]);
        }
        else {
            return promise_1.PromiseWrapper.reject('CachedXHR: Did not find cached template for ' + url, null);
        }
    };
    return CachedXHR;
}(compiler_1.XHR));
exports.CachedXHR = CachedXHR;

},{"../../src/facade/exceptions":242,"../../src/facade/lang":243,"../../src/facade/promise":244,"@angular/compiler":73}],246:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var compiler_1 = require('@angular/compiler');
var promise_1 = require('../../src/facade/promise');
var lang_1 = require('../../src/facade/lang');
var XHRImpl = (function (_super) {
    __extends(XHRImpl, _super);
    function XHRImpl() {
        _super.apply(this, arguments);
    }
    XHRImpl.prototype.get = function (url) {
        var completer = promise_1.PromiseWrapper.completer();
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'text';
        xhr.onload = function () {
            // responseText is the old-school way of retrieving response (supported by IE8 & 9)
            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
            var response = lang_1.isPresent(xhr.response) ? xhr.response : xhr.responseText;
            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
            var status = xhr.status === 1223 ? 204 : xhr.status;
            // fix status code when it is 0 (0 status is undocumented).
            // Occurs when accessing file resources or on Android 4.1 stock browser
            // while retrieving files from application cache.
            if (status === 0) {
                status = response ? 200 : 0;
            }
            if (200 <= status && status <= 300) {
                completer.resolve(response);
            }
            else {
                completer.reject("Failed to load " + url, null);
            }
        };
        xhr.onerror = function () { completer.reject("Failed to load " + url, null); };
        xhr.send();
        return completer.promise;
    };
    return XHRImpl;
}(compiler_1.XHR));
exports.XHRImpl = XHRImpl;

},{"../../src/facade/lang":243,"../../src/facade/promise":244,"@angular/compiler":73}],247:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
exports.RenderDebugInfo = core_1.__core_private__.RenderDebugInfo;
exports.wtfInit = core_1.__core_private__.wtfInit;
exports.ReflectionCapabilities = core_1.__core_private__.ReflectionCapabilities;
exports.VIEW_ENCAPSULATION_VALUES = core_1.__core_private__.VIEW_ENCAPSULATION_VALUES;
exports.DebugDomRootRenderer = core_1.__core_private__.DebugDomRootRenderer;
exports.SecurityContext = core_1.__core_private__.SecurityContext;
exports.SanitizationService = core_1.__core_private__.SanitizationService;

},{"@angular/core":140}],248:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require('./src/platform_browser'));

},{"./src/platform_browser":282}],249:[function(require,module,exports){
"use strict";
var animation_builder = require('./src/animate/animation_builder');
var css_animation_builder = require('./src/animate/css_animation_builder');
var browser_details = require('./src/animate/browser_details');
var css_animation_options = require('./src/animate/css_animation_options');
var animation = require('./src/animate/animation');
var dom_adapter = require('./src/dom/dom_adapter');
var browser_adapter = require('./src/browser/browser_adapter');
var __platform_browser_private__;
(function (__platform_browser_private__) {
    __platform_browser_private__.DomAdapter = dom_adapter.DomAdapter;
    function getDOM() { return dom_adapter.getDOM(); }
    __platform_browser_private__.getDOM = getDOM;
    function setDOM(adapter) { return dom_adapter.setDOM(adapter); }
    __platform_browser_private__.setDOM = setDOM;
    __platform_browser_private__.setRootDomAdapter = dom_adapter.setRootDomAdapter;
    __platform_browser_private__.BrowserDomAdapter = browser_adapter.BrowserDomAdapter;
    __platform_browser_private__.AnimationBuilder = animation_builder.AnimationBuilder;
    __platform_browser_private__.CssAnimationBuilder = css_animation_builder.CssAnimationBuilder;
    __platform_browser_private__.CssAnimationOptions = css_animation_options.CssAnimationOptions;
    __platform_browser_private__.Animation = animation.Animation;
    __platform_browser_private__.BrowserDetails = browser_details.BrowserDetails;
})(__platform_browser_private__ = exports.__platform_browser_private__ || (exports.__platform_browser_private__ = {}));

},{"./src/animate/animation":250,"./src/animate/animation_builder":251,"./src/animate/browser_details":252,"./src/animate/css_animation_builder":253,"./src/animate/css_animation_options":254,"./src/browser/browser_adapter":255,"./src/dom/dom_adapter":265}],250:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var math_1 = require('../../src/facade/math');
var collection_1 = require('../../src/facade/collection');
var util_1 = require('../dom/util');
var dom_adapter_1 = require('../dom/dom_adapter');
var Animation = (function () {
    /**
     * Stores the start time and starts the animation
     * @param element
     * @param data
     * @param browserDetails
     */
    function Animation(element, data, browserDetails) {
        var _this = this;
        this.element = element;
        this.data = data;
        this.browserDetails = browserDetails;
        /** functions to be called upon completion */
        this.callbacks = [];
        /** functions for removing event listeners */
        this.eventClearFunctions = [];
        /** flag used to track whether or not the animation has finished */
        this.completed = false;
        this._stringPrefix = '';
        this.startTime = lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
        this._stringPrefix = dom_adapter_1.getDOM().getAnimationPrefix();
        this.setup();
        this.wait(function (timestamp) { return _this.start(); });
    }
    Object.defineProperty(Animation.prototype, "totalTime", {
        /** total amount of time that the animation should take including delay */
        get: function () {
            var delay = this.computedDelay != null ? this.computedDelay : 0;
            var duration = this.computedDuration != null ? this.computedDuration : 0;
            return delay + duration;
        },
        enumerable: true,
        configurable: true
    });
    Animation.prototype.wait = function (callback) {
        // Firefox requires 2 frames for some reason
        this.browserDetails.raf(callback, 2);
    };
    /**
     * Sets up the initial styles before the animation is started
     */
    Animation.prototype.setup = function () {
        if (this.data.fromStyles != null)
            this.applyStyles(this.data.fromStyles);
        if (this.data.duration != null)
            this.applyStyles({ 'transitionDuration': this.data.duration.toString() + 'ms' });
        if (this.data.delay != null)
            this.applyStyles({ 'transitionDelay': this.data.delay.toString() + 'ms' });
    };
    /**
     * After the initial setup has occurred, this method adds the animation styles
     */
    Animation.prototype.start = function () {
        this.addClasses(this.data.classesToAdd);
        this.addClasses(this.data.animationClasses);
        this.removeClasses(this.data.classesToRemove);
        if (this.data.toStyles != null)
            this.applyStyles(this.data.toStyles);
        var computedStyles = dom_adapter_1.getDOM().getComputedStyle(this.element);
        this.computedDelay =
            math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-delay')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-delay')));
        this.computedDuration = math_1.Math.max(this.parseDurationString(computedStyles.getPropertyValue(this._stringPrefix + 'transition-duration')), this.parseDurationString(this.element.style.getPropertyValue(this._stringPrefix + 'transition-duration')));
        this.addEvents();
    };
    /**
     * Applies the provided styles to the element
     * @param styles
     */
    Animation.prototype.applyStyles = function (styles) {
        var _this = this;
        collection_1.StringMapWrapper.forEach(styles, function (value, key) {
            var dashCaseKey = util_1.camelCaseToDashCase(key);
            if (lang_1.isPresent(dom_adapter_1.getDOM().getStyle(_this.element, dashCaseKey))) {
                dom_adapter_1.getDOM().setStyle(_this.element, dashCaseKey, value.toString());
            }
            else {
                dom_adapter_1.getDOM().setStyle(_this.element, _this._stringPrefix + dashCaseKey, value.toString());
            }
        });
    };
    /**
     * Adds the provided classes to the element
     * @param classes
     */
    Animation.prototype.addClasses = function (classes) {
        for (var i = 0, len = classes.length; i < len; i++)
            dom_adapter_1.getDOM().addClass(this.element, classes[i]);
    };
    /**
     * Removes the provided classes from the element
     * @param classes
     */
    Animation.prototype.removeClasses = function (classes) {
        for (var i = 0, len = classes.length; i < len; i++)
            dom_adapter_1.getDOM().removeClass(this.element, classes[i]);
    };
    /**
     * Adds events to track when animations have finished
     */
    Animation.prototype.addEvents = function () {
        var _this = this;
        if (this.totalTime > 0) {
            this.eventClearFunctions.push(dom_adapter_1.getDOM().onAndCancel(this.element, dom_adapter_1.getDOM().getTransitionEnd(), function (event) { return _this.handleAnimationEvent(event); }));
        }
        else {
            this.handleAnimationCompleted();
        }
    };
    Animation.prototype.handleAnimationEvent = function (event) {
        var elapsedTime = math_1.Math.round(event.elapsedTime * 1000);
        if (!this.browserDetails.elapsedTimeIncludesDelay)
            elapsedTime += this.computedDelay;
        event.stopPropagation();
        if (elapsedTime >= this.totalTime)
            this.handleAnimationCompleted();
    };
    /**
     * Runs all animation callbacks and removes temporary classes
     */
    Animation.prototype.handleAnimationCompleted = function () {
        this.removeClasses(this.data.animationClasses);
        this.callbacks.forEach(function (callback) { return callback(); });
        this.callbacks = [];
        this.eventClearFunctions.forEach(function (fn) { return fn(); });
        this.eventClearFunctions = [];
        this.completed = true;
    };
    /**
     * Adds animation callbacks to be called upon completion
     * @param callback
     * @returns {Animation}
     */
    Animation.prototype.onComplete = function (callback) {
        if (this.completed) {
            callback();
        }
        else {
            this.callbacks.push(callback);
        }
        return this;
    };
    /**
     * Converts the duration string to the number of milliseconds
     * @param duration
     * @returns {number}
     */
    Animation.prototype.parseDurationString = function (duration) {
        var maxValue = 0;
        // duration must have at least 2 characters to be valid. (number + type)
        if (duration == null || duration.length < 2) {
            return maxValue;
        }
        else if (duration.substring(duration.length - 2) == 'ms') {
            var value = lang_1.NumberWrapper.parseInt(this.stripLetters(duration), 10);
            if (value > maxValue)
                maxValue = value;
        }
        else if (duration.substring(duration.length - 1) == 's') {
            var ms = lang_1.NumberWrapper.parseFloat(this.stripLetters(duration)) * 1000;
            var value = math_1.Math.floor(ms);
            if (value > maxValue)
                maxValue = value;
        }
        return maxValue;
    };
    /**
     * Strips the letters from the duration string
     * @param str
     * @returns {string}
     */
    Animation.prototype.stripLetters = function (str) {
        return lang_1.StringWrapper.replaceAll(str, lang_1.RegExpWrapper.create('[^0-9]+$', ''), '');
    };
    return Animation;
}());
exports.Animation = Animation;

},{"../../src/facade/collection":277,"../../src/facade/lang":280,"../../src/facade/math":281,"../dom/dom_adapter":265,"../dom/util":274}],251:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var css_animation_builder_1 = require('./css_animation_builder');
var browser_details_1 = require('./browser_details');
var AnimationBuilder = (function () {
    /**
     * Used for DI
     * @param browserDetails
     */
    function AnimationBuilder(browserDetails) {
        this.browserDetails = browserDetails;
    }
    /**
     * Creates a new CSS Animation
     * @returns {CssAnimationBuilder}
     */
    AnimationBuilder.prototype.css = function () { return new css_animation_builder_1.CssAnimationBuilder(this.browserDetails); };
    AnimationBuilder.decorators = [
        { type: core_1.Injectable },
    ];
    AnimationBuilder.ctorParameters = [
        { type: browser_details_1.BrowserDetails, },
    ];
    return AnimationBuilder;
}());
exports.AnimationBuilder = AnimationBuilder;

},{"./browser_details":252,"./css_animation_builder":253,"@angular/core":140}],252:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var math_1 = require('../../src/facade/math');
var dom_adapter_1 = require('../dom/dom_adapter');
var BrowserDetails = (function () {
    function BrowserDetails() {
        this.elapsedTimeIncludesDelay = false;
        this.doesElapsedTimeIncludesDelay();
    }
    /**
     * Determines if `event.elapsedTime` includes transition delay in the current browser.  At this
     * time, Chrome and Opera seem to be the only browsers that include this.
     */
    BrowserDetails.prototype.doesElapsedTimeIncludesDelay = function () {
        var _this = this;
        var div = dom_adapter_1.getDOM().createElement('div');
        dom_adapter_1.getDOM().setAttribute(div, 'style', "position: absolute; top: -9999px; left: -9999px; width: 1px;\n      height: 1px; transition: all 1ms linear 1ms;");
        // Firefox requires that we wait for 2 frames for some reason
        this.raf(function (timestamp) {
            dom_adapter_1.getDOM().on(div, 'transitionend', function (event) {
                var elapsed = math_1.Math.round(event.elapsedTime * 1000);
                _this.elapsedTimeIncludesDelay = elapsed == 2;
                dom_adapter_1.getDOM().remove(div);
            });
            dom_adapter_1.getDOM().setStyle(div, 'width', '2px');
        }, 2);
    };
    BrowserDetails.prototype.raf = function (callback, frames) {
        if (frames === void 0) { frames = 1; }
        var queue = new RafQueue(callback, frames);
        return function () { return queue.cancel(); };
    };
    BrowserDetails.decorators = [
        { type: core_1.Injectable },
    ];
    BrowserDetails.ctorParameters = [];
    return BrowserDetails;
}());
exports.BrowserDetails = BrowserDetails;
var RafQueue = (function () {
    function RafQueue(callback, frames) {
        this.callback = callback;
        this.frames = frames;
        this._raf();
    }
    RafQueue.prototype._raf = function () {
        var _this = this;
        this.currentFrameId =
            dom_adapter_1.getDOM().requestAnimationFrame(function (timestamp) { return _this._nextFrame(timestamp); });
    };
    RafQueue.prototype._nextFrame = function (timestamp) {
        this.frames--;
        if (this.frames > 0) {
            this._raf();
        }
        else {
            this.callback(timestamp);
        }
    };
    RafQueue.prototype.cancel = function () {
        dom_adapter_1.getDOM().cancelAnimationFrame(this.currentFrameId);
        this.currentFrameId = null;
    };
    return RafQueue;
}());

},{"../../src/facade/math":281,"../dom/dom_adapter":265,"@angular/core":140}],253:[function(require,module,exports){
"use strict";
var css_animation_options_1 = require('./css_animation_options');
var animation_1 = require('./animation');
var CssAnimationBuilder = (function () {
    /**
     * Accepts public properties for CssAnimationBuilder
     */
    function CssAnimationBuilder(browserDetails) {
        this.browserDetails = browserDetails;
        /** @type {CssAnimationOptions} */
        this.data = new css_animation_options_1.CssAnimationOptions();
    }
    /**
     * Adds a temporary class that will be removed at the end of the animation
     * @param className
     */
    CssAnimationBuilder.prototype.addAnimationClass = function (className) {
        this.data.animationClasses.push(className);
        return this;
    };
    /**
     * Adds a class that will remain on the element after the animation has finished
     * @param className
     */
    CssAnimationBuilder.prototype.addClass = function (className) {
        this.data.classesToAdd.push(className);
        return this;
    };
    /**
     * Removes a class from the element
     * @param className
     */
    CssAnimationBuilder.prototype.removeClass = function (className) {
        this.data.classesToRemove.push(className);
        return this;
    };
    /**
     * Sets the animation duration (and overrides any defined through CSS)
     * @param duration
     */
    CssAnimationBuilder.prototype.setDuration = function (duration) {
        this.data.duration = duration;
        return this;
    };
    /**
     * Sets the animation delay (and overrides any defined through CSS)
     * @param delay
     */
    CssAnimationBuilder.prototype.setDelay = function (delay) {
        this.data.delay = delay;
        return this;
    };
    /**
     * Sets styles for both the initial state and the destination state
     * @param from
     * @param to
     */
    CssAnimationBuilder.prototype.setStyles = function (from, to) {
        return this.setFromStyles(from).setToStyles(to);
    };
    /**
     * Sets the initial styles for the animation
     * @param from
     */
    CssAnimationBuilder.prototype.setFromStyles = function (from) {
        this.data.fromStyles = from;
        return this;
    };
    /**
     * Sets the destination styles for the animation
     * @param to
     */
    CssAnimationBuilder.prototype.setToStyles = function (to) {
        this.data.toStyles = to;
        return this;
    };
    /**
     * Starts the animation and returns a promise
     * @param element
     */
    CssAnimationBuilder.prototype.start = function (element) {
        return new animation_1.Animation(element, this.data, this.browserDetails);
    };
    return CssAnimationBuilder;
}());
exports.CssAnimationBuilder = CssAnimationBuilder;

},{"./animation":250,"./css_animation_options":254}],254:[function(require,module,exports){
"use strict";
var CssAnimationOptions = (function () {
    function CssAnimationOptions() {
        /** classes to be added to the element */
        this.classesToAdd = [];
        /** classes to be removed from the element */
        this.classesToRemove = [];
        /** classes to be added for the duration of the animation */
        this.animationClasses = [];
    }
    return CssAnimationOptions;
}());
exports.CssAnimationOptions = CssAnimationOptions;

},{}],255:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var generic_browser_adapter_1 = require('./generic_browser_adapter');
var dom_adapter_1 = require('../dom/dom_adapter');
var _attrToPropMap = {
    'class': 'className',
    'innerHtml': 'innerHTML',
    'readonly': 'readOnly',
    'tabindex': 'tabIndex'
};
var DOM_KEY_LOCATION_NUMPAD = 3;
// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
var _keyMap = {
    // The following values are here for cross-browser compatibility and to match the W3C standard
    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
    '\b': 'Backspace',
    '\t': 'Tab',
    '\x7F': 'Delete',
    '\x1B': 'Escape',
    'Del': 'Delete',
    'Esc': 'Escape',
    'Left': 'ArrowLeft',
    'Right': 'ArrowRight',
    'Up': 'ArrowUp',
    'Down': 'ArrowDown',
    'Menu': 'ContextMenu',
    'Scroll': 'ScrollLock',
    'Win': 'OS'
};
// There is a bug in Chrome for numeric keypad keys:
// https://code.google.com/p/chromium/issues/detail?id=155654
// 1, 2, 3 ... are reported as A, B, C ...
var _chromeNumKeyPadMap = {
    'A': '1',
    'B': '2',
    'C': '3',
    'D': '4',
    'E': '5',
    'F': '6',
    'G': '7',
    'H': '8',
    'I': '9',
    'J': '*',
    'K': '+',
    'M': '-',
    'N': '.',
    'O': '/',
    '\x60': '0',
    '\x90': 'NumLock'
};
/**
 * A `DomAdapter` powered by full browser DOM APIs.
 */
/* tslint:disable:requireParameterType */
var BrowserDomAdapter = (function (_super) {
    __extends(BrowserDomAdapter, _super);
    function BrowserDomAdapter() {
        _super.apply(this, arguments);
    }
    BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error("parse not implemented"); };
    BrowserDomAdapter.makeCurrent = function () { dom_adapter_1.setRootDomAdapter(new BrowserDomAdapter()); };
    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
    BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) {
        el[methodName].apply(el, args);
    };
    // TODO(tbosch): move this into a separate environment class once we have it
    BrowserDomAdapter.prototype.logError = function (error) {
        if (window.console.error) {
            window.console.error(error);
        }
        else {
            window.console.log(error);
        }
    };
    BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };
    BrowserDomAdapter.prototype.logGroup = function (error) {
        if (window.console.group) {
            window.console.group(error);
            this.logError(error);
        }
        else {
            window.console.log(error);
        }
    };
    BrowserDomAdapter.prototype.logGroupEnd = function () {
        if (window.console.groupEnd) {
            window.console.groupEnd();
        }
    };
    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
        get: function () { return _attrToPropMap; },
        enumerable: true,
        configurable: true
    });
    BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };
    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
        el.addEventListener(evt, listener, false);
        // Needed to follow Dart's subscription semantic, until fix of
        // https://code.google.com/p/dart/issues/detail?id=17406
        return function () { el.removeEventListener(evt, listener, false); };
    };
    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
        var evt = document.createEvent('MouseEvent');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    BrowserDomAdapter.prototype.createEvent = function (eventType) {
        var evt = document.createEvent('Event');
        evt.initEvent(eventType, true, true);
        return evt;
    };
    BrowserDomAdapter.prototype.preventDefault = function (evt) {
        evt.preventDefault();
        evt.returnValue = false;
    };
    BrowserDomAdapter.prototype.isPrevented = function (evt) {
        return evt.defaultPrevented || lang_1.isPresent(evt.returnValue) && !evt.returnValue;
    };
    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
    BrowserDomAdapter.prototype.type = function (node) { return node.type; };
    BrowserDomAdapter.prototype.content = function (node) {
        if (this.hasProperty(node, "content")) {
            return node.content;
        }
        else {
            return node;
        }
    };
    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
    BrowserDomAdapter.prototype.childNodesAsList = function (el) {
        var childNodes = el.childNodes;
        var res = collection_1.ListWrapper.createFixedSize(childNodes.length);
        for (var i = 0; i < childNodes.length; i++) {
            res[i] = childNodes[i];
        }
        return res;
    };
    BrowserDomAdapter.prototype.clearNodes = function (el) {
        while (el.firstChild) {
            el.removeChild(el.firstChild);
        }
    };
    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
    BrowserDomAdapter.prototype.remove = function (node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        return node;
    };
    BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
    BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) { nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); }); };
    BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
    // TODO(vicb): removed Element type because it does not support StyleElement
    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
    BrowserDomAdapter.prototype.createTemplate = function (html) {
        var t = document.createElement('template');
        t.innerHTML = html;
        return t;
    };
    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createElement(tagName);
    };
    BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createElementNS(ns, tagName);
    };
    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
        if (doc === void 0) { doc = document; }
        return doc.createTextNode(text);
    };
    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
        if (doc === void 0) { doc = document; }
        var el = doc.createElement('SCRIPT');
        el.setAttribute(attrName, attrValue);
        return el;
    };
    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
        if (doc === void 0) { doc = document; }
        var style = doc.createElement('style');
        this.appendChild(style, this.createTextNode(css));
        return style;
    };
    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
    BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
        return element.getElementsByClassName(name);
    };
    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
        return element.getElementsByTagName(name);
    };
    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
    BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
    BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
    BrowserDomAdapter.prototype.hasClass = function (element, className) { return element.classList.contains(className); };
    BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
        element.style[styleName] = styleValue;
    };
    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) { element.style[stylename] = null; };
    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
    BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
        if (styleValue === void 0) { styleValue = null; }
        var value = this.getStyle(element, styleName) || '';
        return styleValue ? value == styleValue : value.length > 0;
    };
    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
    BrowserDomAdapter.prototype.attributeMap = function (element) {
        var res = new Map();
        var elAttrs = element.attributes;
        for (var i = 0; i < elAttrs.length; i++) {
            var attrib = elAttrs[i];
            res.set(attrib.name, attrib.value);
        }
        return res;
    };
    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) { return element.hasAttribute(attribute); };
    BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
        return element.hasAttributeNS(ns, attribute);
    };
    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) { return element.getAttribute(attribute); };
    BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
        return element.getAttributeNS(ns, name);
    };
    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
    BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
        element.setAttributeNS(ns, name, value);
    };
    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
    BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) { element.removeAttributeNS(ns, name); };
    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
    BrowserDomAdapter.prototype.createHtmlDocument = function () {
        return document.implementation.createHTMLDocument('fakeTitle');
    };
    BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
        try {
            return el.getBoundingClientRect();
        }
        catch (e) {
            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
        }
    };
    BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
    BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
        var matches = false;
        if (n instanceof HTMLElement) {
            if (n.matches) {
                matches = n.matches(selector);
            }
            else if (n.msMatchesSelector) {
                matches = n.msMatchesSelector(selector);
            }
            else if (n.webkitMatchesSelector) {
                matches = n.webkitMatchesSelector(selector);
            }
        }
        return matches;
    };
    BrowserDomAdapter.prototype.isTemplateElement = function (el) {
        return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
    };
    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
    BrowserDomAdapter.prototype.hasShadowRoot = function (node) { return node instanceof HTMLElement && lang_1.isPresent(node.shadowRoot); };
    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
    BrowserDomAdapter.prototype.importIntoDoc = function (node) {
        var toImport = node;
        if (this.isTemplateElement(node)) {
            toImport = this.content(node);
        }
        return document.importNode(toImport, true);
    };
    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
    BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
    BrowserDomAdapter.prototype.getEventKey = function (event) {
        var key = event.key;
        if (lang_1.isBlank(key)) {
            key = event.keyIdentifier;
            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
            // Safari
            // cf
            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
            if (lang_1.isBlank(key)) {
                return 'Unidentified';
            }
            if (key.startsWith('U+')) {
                key = String.fromCharCode(parseInt(key.substring(2), 16));
                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                    // There is a bug in Chrome for numeric keypad keys:
                    // https://code.google.com/p/chromium/issues/detail?id=155654
                    // 1, 2, 3 ... are reported as A, B, C ...
                    key = _chromeNumKeyPadMap[key];
                }
            }
        }
        if (_keyMap.hasOwnProperty(key)) {
            key = _keyMap[key];
        }
        return key;
    };
    BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
        if (target == "window") {
            return window;
        }
        else if (target == "document") {
            return document;
        }
        else if (target == "body") {
            return document.body;
        }
    };
    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
    BrowserDomAdapter.prototype.getBaseHref = function () {
        var href = getBaseElementHref();
        if (lang_1.isBlank(href)) {
            return null;
        }
        return relativePath(href);
    };
    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
    BrowserDomAdapter.prototype.setData = function (element, name, value) {
        this.setAttribute(element, 'data-' + name, value);
    };
    BrowserDomAdapter.prototype.getData = function (element, name) { return this.getAttribute(element, 'data-' + name); };
    BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
    // TODO(tbosch): move this into a separate environment class once we have it
    BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { lang_1.setValueOnPath(lang_1.global, path, value); };
    BrowserDomAdapter.prototype.requestAnimationFrame = function (callback) { return window.requestAnimationFrame(callback); };
    BrowserDomAdapter.prototype.cancelAnimationFrame = function (id) { window.cancelAnimationFrame(id); };
    BrowserDomAdapter.prototype.performanceNow = function () {
        // performance.now() is not available in all browsers, see
        // http://caniuse.com/#search=performance.now
        if (lang_1.isPresent(window.performance) && lang_1.isPresent(window.performance.now)) {
            return window.performance.now();
        }
        else {
            return lang_1.DateWrapper.toMillis(lang_1.DateWrapper.now());
        }
    };
    return BrowserDomAdapter;
}(generic_browser_adapter_1.GenericBrowserDomAdapter));
exports.BrowserDomAdapter = BrowserDomAdapter;
var baseElement = null;
function getBaseElementHref() {
    if (lang_1.isBlank(baseElement)) {
        baseElement = document.querySelector('base');
        if (lang_1.isBlank(baseElement)) {
            return null;
        }
    }
    return baseElement.getAttribute('href');
}
// based on urlUtils.js in AngularJS 1
var urlParsingNode = null;
function relativePath(url) {
    if (lang_1.isBlank(urlParsingNode)) {
        urlParsingNode = document.createElement("a");
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
        '/' + urlParsingNode.pathname;
}

},{"../../src/facade/collection":277,"../../src/facade/lang":280,"../dom/dom_adapter":265,"./generic_browser_adapter":256}],256:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var dom_adapter_1 = require('../dom/dom_adapter');
/**
 * Provides DOM operations in any browser environment.
 */
var GenericBrowserDomAdapter = (function (_super) {
    __extends(GenericBrowserDomAdapter, _super);
    function GenericBrowserDomAdapter() {
        var _this = this;
        _super.call(this);
        this._animationPrefix = null;
        this._transitionEnd = null;
        try {
            var element = this.createElement('div', this.defaultDoc());
            if (lang_1.isPresent(this.getStyle(element, 'animationName'))) {
                this._animationPrefix = '';
            }
            else {
                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
                for (var i = 0; i < domPrefixes.length; i++) {
                    if (lang_1.isPresent(this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {
                        this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
                        break;
                    }
                }
            }
            var transEndEventNames = {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd otransitionend',
                transition: 'transitionend'
            };
            collection_1.StringMapWrapper.forEach(transEndEventNames, function (value, key) {
                if (lang_1.isPresent(_this.getStyle(element, key))) {
                    _this._transitionEnd = value;
                }
            });
        }
        catch (e) {
            this._animationPrefix = null;
            this._transitionEnd = null;
        }
    }
    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
    };
    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
        return lang_1.isFunction(this.defaultDoc().body.createShadowRoot);
    };
    GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () {
        return lang_1.isPresent(this._animationPrefix) ? this._animationPrefix : "";
    };
    GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return lang_1.isPresent(this._transitionEnd) ? this._transitionEnd : ""; };
    GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
        return lang_1.isPresent(this._animationPrefix) && lang_1.isPresent(this._transitionEnd);
    };
    return GenericBrowserDomAdapter;
}(dom_adapter_1.DomAdapter));
exports.GenericBrowserDomAdapter = GenericBrowserDomAdapter;

},{"../../src/facade/collection":277,"../../src/facade/lang":280,"../dom/dom_adapter":265}],257:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var common_1 = require('@angular/common');
var dom_adapter_1 = require('../../dom/dom_adapter');
var BrowserPlatformLocation = (function (_super) {
    __extends(BrowserPlatformLocation, _super);
    function BrowserPlatformLocation() {
        _super.call(this);
        this._init();
    }
    // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it
    /** @internal */
    BrowserPlatformLocation.prototype._init = function () {
        this._location = dom_adapter_1.getDOM().getLocation();
        this._history = dom_adapter_1.getDOM().getHistory();
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
        /** @internal */
        get: function () { return this._location; },
        enumerable: true,
        configurable: true
    });
    BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return dom_adapter_1.getDOM().getBaseHref(); };
    BrowserPlatformLocation.prototype.onPopState = function (fn) {
        dom_adapter_1.getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
    };
    BrowserPlatformLocation.prototype.onHashChange = function (fn) {
        dom_adapter_1.getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
    };
    Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
        get: function () { return this._location.pathname; },
        set: function (newPath) { this._location.pathname = newPath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
        get: function () { return this._location.search; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
        get: function () { return this._location.hash; },
        enumerable: true,
        configurable: true
    });
    BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
        this._history.pushState(state, title, url);
    };
    BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
        this._history.replaceState(state, title, url);
    };
    BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
    BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
    BrowserPlatformLocation.decorators = [
        { type: core_1.Injectable },
    ];
    BrowserPlatformLocation.ctorParameters = [];
    return BrowserPlatformLocation;
}(common_1.PlatformLocation));
exports.BrowserPlatformLocation = BrowserPlatformLocation;

},{"../../dom/dom_adapter":265,"@angular/common":8,"@angular/core":140}],258:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var collection_1 = require('../../src/facade/collection');
var lang_1 = require('../../src/facade/lang');
var dom_adapter_1 = require('../dom/dom_adapter');
var PublicTestability = (function () {
    function PublicTestability(testability) {
        this._testability = testability;
    }
    PublicTestability.prototype.isStable = function () { return this._testability.isStable(); };
    PublicTestability.prototype.whenStable = function (callback) { this._testability.whenStable(callback); };
    PublicTestability.prototype.findBindings = function (using, provider, exactMatch) {
        return this.findProviders(using, provider, exactMatch);
    };
    PublicTestability.prototype.findProviders = function (using, provider, exactMatch) {
        return this._testability.findBindings(using, provider, exactMatch);
    };
    return PublicTestability;
}());
var BrowserGetTestability = (function () {
    function BrowserGetTestability() {
    }
    BrowserGetTestability.init = function () { core_1.setTestabilityGetter(new BrowserGetTestability()); };
    BrowserGetTestability.prototype.addToWindow = function (registry) {
        lang_1.global.getAngularTestability = function (elem, findInAncestors) {
            if (findInAncestors === void 0) { findInAncestors = true; }
            var testability = registry.findTestabilityInTree(elem, findInAncestors);
            if (testability == null) {
                throw new Error('Could not find testability for element.');
            }
            return new PublicTestability(testability);
        };
        lang_1.global.getAllAngularTestabilities = function () {
            var testabilities = registry.getAllTestabilities();
            return testabilities.map(function (testability) { return new PublicTestability(testability); });
        };
        lang_1.global.getAllAngularRootElements = function () { return registry.getAllRootElements(); };
        var whenAllStable = function (callback) {
            var testabilities = lang_1.global.getAllAngularTestabilities();
            var count = testabilities.length;
            var didWork = false;
            var decrement = function (didWork_) {
                didWork = didWork || didWork_;
                count--;
                if (count == 0) {
                    callback(didWork);
                }
            };
            testabilities.forEach(function (testability) { testability.whenStable(decrement); });
        };
        if (!lang_1.global.frameworkStabilizers) {
            lang_1.global.frameworkStabilizers = collection_1.ListWrapper.createGrowableSize(0);
        }
        lang_1.global.frameworkStabilizers.push(whenAllStable);
    };
    BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
        if (elem == null) {
            return null;
        }
        var t = registry.getTestability(elem);
        if (lang_1.isPresent(t)) {
            return t;
        }
        else if (!findInAncestors) {
            return null;
        }
        if (dom_adapter_1.getDOM().isShadowRoot(elem)) {
            return this.findTestabilityInTree(registry, dom_adapter_1.getDOM().getHost(elem), true);
        }
        return this.findTestabilityInTree(registry, dom_adapter_1.getDOM().parentElement(elem), true);
    };
    return BrowserGetTestability;
}());
exports.BrowserGetTestability = BrowserGetTestability;

},{"../../src/facade/collection":277,"../../src/facade/lang":280,"../dom/dom_adapter":265,"@angular/core":140}],259:[function(require,module,exports){
"use strict";
var dom_adapter_1 = require('../dom/dom_adapter');
/**
 * A service that can be used to get and set the title of a current HTML document.
 *
 * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
 * title value.
 */
var Title = (function () {
    function Title() {
    }
    /**
     * Get the title of the current HTML document.
     * @returns {string}
     */
    Title.prototype.getTitle = function () { return dom_adapter_1.getDOM().getTitle(); };
    /**
     * Set the title of the current HTML document.
     * @param newTitle
     */
    Title.prototype.setTitle = function (newTitle) { dom_adapter_1.getDOM().setTitle(newTitle); };
    return Title;
}());
exports.Title = Title;

},{"../dom/dom_adapter":265}],260:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var browser_1 = require('../../../src/facade/browser');
var dom_adapter_1 = require('../../dom/dom_adapter');
var ChangeDetectionPerfRecord = (function () {
    function ChangeDetectionPerfRecord(msPerTick, numTicks) {
        this.msPerTick = msPerTick;
        this.numTicks = numTicks;
    }
    return ChangeDetectionPerfRecord;
}());
exports.ChangeDetectionPerfRecord = ChangeDetectionPerfRecord;
/**
 * Entry point for all Angular debug tools. This object corresponds to the `ng`
 * global variable accessible in the dev console.
 */
var AngularTools = (function () {
    function AngularTools(ref) {
        this.profiler = new AngularProfiler(ref);
    }
    return AngularTools;
}());
exports.AngularTools = AngularTools;
/**
 * Entry point for all Angular profiling-related debug tools. This object
 * corresponds to the `ng.profiler` in the dev console.
 */
var AngularProfiler = (function () {
    function AngularProfiler(ref) {
        this.appRef = ref.injector.get(core_1.ApplicationRef);
    }
    /**
     * Exercises change detection in a loop and then prints the average amount of
     * time in milliseconds how long a single round of change detection takes for
     * the current state of the UI. It runs a minimum of 5 rounds for a minimum
     * of 500 milliseconds.
     *
     * Optionally, a user may pass a `config` parameter containing a map of
     * options. Supported options are:
     *
     * `record` (boolean) - causes the profiler to record a CPU profile while
     * it exercises the change detector. Example:
     *
     * ```
     * ng.profiler.timeChangeDetection({record: true})
     * ```
     */
    AngularProfiler.prototype.timeChangeDetection = function (config) {
        var record = lang_1.isPresent(config) && config['record'];
        var profileName = 'Change Detection';
        // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
        var isProfilerAvailable = lang_1.isPresent(browser_1.window.console.profile);
        if (record && isProfilerAvailable) {
            browser_1.window.console.profile(profileName);
        }
        var start = dom_adapter_1.getDOM().performanceNow();
        var numTicks = 0;
        while (numTicks < 5 || (dom_adapter_1.getDOM().performanceNow() - start) < 500) {
            this.appRef.tick();
            numTicks++;
        }
        var end = dom_adapter_1.getDOM().performanceNow();
        if (record && isProfilerAvailable) {
            // need to cast to <any> because type checker thinks there's no argument
            // while in fact there is:
            //
            // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
            browser_1.window.console.profileEnd(profileName);
        }
        var msPerTick = (end - start) / numTicks;
        browser_1.window.console.log("ran " + numTicks + " change detection cycles");
        browser_1.window.console.log(lang_1.NumberWrapper.toFixed(msPerTick, 2) + " ms per check");
        return new ChangeDetectionPerfRecord(msPerTick, numTicks);
    };
    return AngularProfiler;
}());
exports.AngularProfiler = AngularProfiler;

},{"../../../src/facade/browser":276,"../../../src/facade/lang":280,"../../dom/dom_adapter":265,"@angular/core":140}],261:[function(require,module,exports){
"use strict";
var lang_1 = require('../../../src/facade/lang');
var common_tools_1 = require('./common_tools');
var context = lang_1.global;
/**
 * Enabled Angular 2 debug tools that are accessible via your browser's
 * developer console.
 *
 * Usage:
 *
 * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
 * 1. Type `ng.` (usually the console will show auto-complete suggestion)
 * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
 *    then hit Enter.
 */
function enableDebugTools(ref) {
    context.ng = new common_tools_1.AngularTools(ref);
}
exports.enableDebugTools = enableDebugTools;
/**
 * Disables Angular 2 tools.
 */
function disableDebugTools() {
    delete context.ng;
}
exports.disableDebugTools = disableDebugTools;

},{"../../../src/facade/lang":280,"./common_tools":260}],262:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../core_private');
var common_1 = require('@angular/common');
var dom_sanitization_service_1 = require('./security/dom_sanitization_service');
var lang_1 = require('./facade/lang');
var browser_adapter_1 = require('./browser/browser_adapter');
var testability_1 = require('./browser/testability');
var dom_adapter_1 = require('./dom/dom_adapter');
var dom_tokens_1 = require('./dom/dom_tokens');
var event_manager_1 = require('./dom/events/event_manager');
var dom_renderer_1 = require('./dom/dom_renderer');
var shared_styles_host_1 = require('./dom/shared_styles_host');
var key_events_1 = require('./dom/events/key_events');
var ng_probe_1 = require('./dom/debug/ng_probe');
var dom_events_1 = require('./dom/events/dom_events');
var hammer_gestures_1 = require('./dom/events/hammer_gestures');
var shared_styles_host_2 = require('./dom/shared_styles_host');
var animation_builder_1 = require('./animate/animation_builder');
var browser_details_1 = require('./animate/browser_details');
var title_1 = require('./browser/title');
exports.Title = title_1.Title;
var browser_adapter_2 = require('./browser/browser_adapter');
exports.BrowserDomAdapter = browser_adapter_2.BrowserDomAdapter;
var tools_1 = require('./browser/tools/tools');
exports.enableDebugTools = tools_1.enableDebugTools;
exports.disableDebugTools = tools_1.disableDebugTools;
var by_1 = require('./dom/debug/by');
exports.By = by_1.By;
exports.BROWSER_PLATFORM_MARKER = 
/*@ts2dart_const*/ new core_1.OpaqueToken('BrowserPlatformMarker');
/**
 * A set of providers to initialize the Angular platform in a web browser.
 *
 * Used automatically by `bootstrap`, or can be passed to {@link platform}.
 */
exports.BROWSER_PROVIDERS = [
    /*@ts2dart_Provider*/ { provide: exports.BROWSER_PLATFORM_MARKER, useValue: true },
    core_1.PLATFORM_COMMON_PROVIDERS,
    /*@ts2dart_Provider*/ { provide: core_1.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
];
function _exceptionHandler() {
    // !IS_DART is required because we must rethrow exceptions in JS,
    // but must not rethrow exceptions in Dart
    return new core_1.ExceptionHandler(dom_adapter_1.getDOM(), !lang_1.IS_DART);
}
function _document() {
    return dom_adapter_1.getDOM().defaultDoc();
}
exports.BROWSER_SANITIZATION_PROVIDERS = [
    /* @ts2dart_Provider */ { provide: core_private_1.SanitizationService, useExisting: dom_sanitization_service_1.DomSanitizationService },
    /* @ts2dart_Provider */ { provide: dom_sanitization_service_1.DomSanitizationService, useClass: dom_sanitization_service_1.DomSanitizationServiceImpl },
];
/**
 * A set of providers to initialize an Angular application in a web browser.
 *
 * Used automatically by `bootstrap`, or can be passed to {@link PlatformRef.application}.
 */
exports.BROWSER_APP_COMMON_PROVIDERS = 
/*@ts2dart_const*/ [
    core_1.APPLICATION_COMMON_PROVIDERS,
    common_1.FORM_PROVIDERS,
    exports.BROWSER_SANITIZATION_PROVIDERS,
    /* @ts2dart_Provider */ { provide: core_1.PLATFORM_PIPES, useValue: common_1.COMMON_PIPES, multi: true },
    /* @ts2dart_Provider */ { provide: core_1.PLATFORM_DIRECTIVES, useValue: common_1.COMMON_DIRECTIVES, multi: true },
    /* @ts2dart_Provider */ { provide: core_1.ExceptionHandler, useFactory: _exceptionHandler, deps: [] },
    /* @ts2dart_Provider */ { provide: dom_tokens_1.DOCUMENT, useFactory: _document, deps: [] },
    /* @ts2dart_Provider */ { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: dom_events_1.DomEventsPlugin, multi: true },
    /* @ts2dart_Provider */ { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: key_events_1.KeyEventsPlugin, multi: true },
    /* @ts2dart_Provider */ { provide: event_manager_1.EVENT_MANAGER_PLUGINS, useClass: hammer_gestures_1.HammerGesturesPlugin, multi: true },
    /* @ts2dart_Provider */ { provide: hammer_gestures_1.HAMMER_GESTURE_CONFIG, useClass: hammer_gestures_1.HammerGestureConfig },
    /* @ts2dart_Provider */ { provide: dom_renderer_1.DomRootRenderer, useClass: dom_renderer_1.DomRootRenderer_ },
    /* @ts2dart_Provider */ { provide: core_1.RootRenderer, useExisting: dom_renderer_1.DomRootRenderer },
    /* @ts2dart_Provider */ { provide: shared_styles_host_1.SharedStylesHost, useExisting: shared_styles_host_2.DomSharedStylesHost },
    shared_styles_host_2.DomSharedStylesHost,
    core_1.Testability,
    browser_details_1.BrowserDetails,
    animation_builder_1.AnimationBuilder,
    event_manager_1.EventManager,
    ng_probe_1.ELEMENT_PROBE_PROVIDERS
];
var hammer_gestures_2 = require('../src/dom/events/hammer_gestures');
exports.HAMMER_GESTURE_CONFIG = hammer_gestures_2.HAMMER_GESTURE_CONFIG;
exports.HammerGestureConfig = hammer_gestures_2.HammerGestureConfig;
function initDomAdapter() {
    browser_adapter_1.BrowserDomAdapter.makeCurrent();
    core_private_1.wtfInit();
    testability_1.BrowserGetTestability.init();
}
exports.initDomAdapter = initDomAdapter;

},{"../core_private":247,"../src/dom/events/hammer_gestures":271,"./animate/animation_builder":251,"./animate/browser_details":252,"./browser/browser_adapter":255,"./browser/testability":258,"./browser/title":259,"./browser/tools/tools":261,"./dom/debug/by":263,"./dom/debug/ng_probe":264,"./dom/dom_adapter":265,"./dom/dom_renderer":266,"./dom/dom_tokens":267,"./dom/events/dom_events":268,"./dom/events/event_manager":269,"./dom/events/hammer_gestures":271,"./dom/events/key_events":272,"./dom/shared_styles_host":273,"./facade/lang":280,"./security/dom_sanitization_service":284,"@angular/common":8,"@angular/core":140}],263:[function(require,module,exports){
"use strict";
var lang_1 = require('../../../src/facade/lang');
var dom_adapter_1 = require('../../dom/dom_adapter');
/**
 * Predicates for use with {@link DebugElement}'s query functions.
 */
var By = (function () {
    function By() {
    }
    /**
     * Match all elements.
     *
     * ## Example
     *
     * {@example platform/dom/debug/ts/by/by.ts region='by_all'}
     */
    By.all = function () { return function (debugElement) { return true; }; };
    /**
     * Match elements by the given CSS selector.
     *
     * ## Example
     *
     * {@example platform/dom/debug/ts/by/by.ts region='by_css'}
     */
    By.css = function (selector) {
        return function (debugElement) {
            return lang_1.isPresent(debugElement.nativeElement) ?
                dom_adapter_1.getDOM().elementMatches(debugElement.nativeElement, selector) :
                false;
        };
    };
    /**
     * Match elements that have the given directive present.
     *
     * ## Example
     *
     * {@example platform/dom/debug/ts/by/by.ts region='by_directive'}
     */
    By.directive = function (type) {
        return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };
    };
    return By;
}());
exports.By = By;

},{"../../../src/facade/lang":280,"../../dom/dom_adapter":265}],264:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var core_private_1 = require('../../../core_private');
var lang_1 = require('../../facade/lang');
var dom_adapter_1 = require('../dom_adapter');
var dom_renderer_1 = require('../dom_renderer');
var CORE_TOKENS = { 'ApplicationRef': core_1.ApplicationRef, 'NgZone': core_1.NgZone };
var INSPECT_GLOBAL_NAME = 'ng.probe';
var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
/**
 * Returns a {@link DebugElement} for the given native DOM element, or
 * null if the given native element does not have an Angular view associated
 * with it.
 */
function inspectNativeElement(element) {
    return core_1.getDebugNode(element);
}
exports.inspectNativeElement = inspectNativeElement;
function _createConditionalRootRenderer(rootRenderer) {
    if (lang_1.assertionsEnabled()) {
        return _createRootRenderer(rootRenderer);
    }
    return rootRenderer;
}
function _createRootRenderer(rootRenderer) {
    dom_adapter_1.getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
    dom_adapter_1.getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, CORE_TOKENS);
    return new core_private_1.DebugDomRootRenderer(rootRenderer);
}
/**
 * Providers which support debugging Angular applications (e.g. via `ng.probe`).
 */
exports.ELEMENT_PROBE_PROVIDERS = [
    /*@ts2dart_Provider*/ {
        provide: core_1.RootRenderer,
        useFactory: _createConditionalRootRenderer,
        deps: [dom_renderer_1.DomRootRenderer]
    }
];
exports.ELEMENT_PROBE_PROVIDERS_PROD_MODE = [
    /*@ts2dart_Provider*/ {
        provide: core_1.RootRenderer,
        useFactory: _createRootRenderer,
        deps: [dom_renderer_1.DomRootRenderer]
    }
];

},{"../../../core_private":247,"../../facade/lang":280,"../dom_adapter":265,"../dom_renderer":266,"@angular/core":140}],265:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var _DOM = null;
function getDOM() {
    return _DOM;
}
exports.getDOM = getDOM;
function setDOM(adapter) {
    _DOM = adapter;
}
exports.setDOM = setDOM;
function setRootDomAdapter(adapter) {
    if (lang_1.isBlank(_DOM)) {
        _DOM = adapter;
    }
}
exports.setRootDomAdapter = setRootDomAdapter;
/* tslint:disable:requireParameterType */
/**
 * Provides DOM operations in an environment-agnostic way.
 */
var DomAdapter = (function () {
    function DomAdapter() {
        this.xhrType = null;
    }
    /** @deprecated */
    DomAdapter.prototype.getXHR = function () { return this.xhrType; };
    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
        /**
         * Maps attribute names to their corresponding property names for cases
         * where attribute name doesn't match property name.
         */
        get: function () { return this._attrToPropMap; },
        set: function (value) { this._attrToPropMap = value; },
        enumerable: true,
        configurable: true
    });
    ;
    ;
    return DomAdapter;
}());
exports.DomAdapter = DomAdapter;

},{"../../src/facade/lang":280}],266:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var animation_builder_1 = require('../animate/animation_builder');
var lang_1 = require('../../src/facade/lang');
var exceptions_1 = require('../../src/facade/exceptions');
var shared_styles_host_1 = require('./shared_styles_host');
var event_manager_1 = require('./events/event_manager');
var dom_tokens_1 = require('./dom_tokens');
var dom_adapter_1 = require('./dom_adapter');
var util_1 = require('./util');
var NAMESPACE_URIS = 
/*@ts2dart_const*/
{ 'xlink': 'http://www.w3.org/1999/xlink', 'svg': 'http://www.w3.org/2000/svg' };
var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/g;
var DomRootRenderer = (function () {
    function DomRootRenderer(document, eventManager, sharedStylesHost, animate) {
        this.document = document;
        this.eventManager = eventManager;
        this.sharedStylesHost = sharedStylesHost;
        this.animate = animate;
        this._registeredComponents = new Map();
    }
    DomRootRenderer.prototype.renderComponent = function (componentProto) {
        var renderer = this._registeredComponents.get(componentProto.id);
        if (lang_1.isBlank(renderer)) {
            renderer = new DomRenderer(this, componentProto);
            this._registeredComponents.set(componentProto.id, renderer);
        }
        return renderer;
    };
    return DomRootRenderer;
}());
exports.DomRootRenderer = DomRootRenderer;
var DomRootRenderer_ = (function (_super) {
    __extends(DomRootRenderer_, _super);
    function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animate) {
        _super.call(this, _document, _eventManager, sharedStylesHost, animate);
    }
    DomRootRenderer_.decorators = [
        { type: core_1.Injectable },
    ];
    DomRootRenderer_.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Inject, args: [dom_tokens_1.DOCUMENT,] },] },
        { type: event_manager_1.EventManager, },
        { type: shared_styles_host_1.DomSharedStylesHost, },
        { type: animation_builder_1.AnimationBuilder, },
    ];
    return DomRootRenderer_;
}(DomRootRenderer));
exports.DomRootRenderer_ = DomRootRenderer_;
var DomRenderer = (function () {
    function DomRenderer(_rootRenderer, componentProto) {
        this._rootRenderer = _rootRenderer;
        this.componentProto = componentProto;
        this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
        if (componentProto.encapsulation !== core_1.ViewEncapsulation.Native) {
            this._rootRenderer.sharedStylesHost.addStyles(this._styles);
        }
        if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Emulated) {
            this._contentAttr = _shimContentAttribute(componentProto.id);
            this._hostAttr = _shimHostAttribute(componentProto.id);
        }
        else {
            this._contentAttr = null;
            this._hostAttr = null;
        }
    }
    DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
        var el;
        if (lang_1.isString(selectorOrNode)) {
            el = dom_adapter_1.getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
            if (lang_1.isBlank(el)) {
                throw new exceptions_1.BaseException("The selector \"" + selectorOrNode + "\" did not match any elements");
            }
        }
        else {
            el = selectorOrNode;
        }
        dom_adapter_1.getDOM().clearNodes(el);
        return el;
    };
    DomRenderer.prototype.createElement = function (parent, name, debugInfo) {
        var nsAndName = splitNamespace(name);
        var el = lang_1.isPresent(nsAndName[0]) ?
            dom_adapter_1.getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :
            dom_adapter_1.getDOM().createElement(nsAndName[1]);
        if (lang_1.isPresent(this._contentAttr)) {
            dom_adapter_1.getDOM().setAttribute(el, this._contentAttr, '');
        }
        if (lang_1.isPresent(parent)) {
            dom_adapter_1.getDOM().appendChild(parent, el);
        }
        return el;
    };
    DomRenderer.prototype.createViewRoot = function (hostElement) {
        var nodesParent;
        if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Native) {
            nodesParent = dom_adapter_1.getDOM().createShadowRoot(hostElement);
            this._rootRenderer.sharedStylesHost.addHost(nodesParent);
            for (var i = 0; i < this._styles.length; i++) {
                dom_adapter_1.getDOM().appendChild(nodesParent, dom_adapter_1.getDOM().createStyleElement(this._styles[i]));
            }
        }
        else {
            if (lang_1.isPresent(this._hostAttr)) {
                dom_adapter_1.getDOM().setAttribute(hostElement, this._hostAttr, '');
            }
            nodesParent = hostElement;
        }
        return nodesParent;
    };
    DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
        var comment = dom_adapter_1.getDOM().createComment(TEMPLATE_COMMENT_TEXT);
        if (lang_1.isPresent(parentElement)) {
            dom_adapter_1.getDOM().appendChild(parentElement, comment);
        }
        return comment;
    };
    DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
        var node = dom_adapter_1.getDOM().createTextNode(value);
        if (lang_1.isPresent(parentElement)) {
            dom_adapter_1.getDOM().appendChild(parentElement, node);
        }
        return node;
    };
    DomRenderer.prototype.projectNodes = function (parentElement, nodes) {
        if (lang_1.isBlank(parentElement))
            return;
        appendNodes(parentElement, nodes);
    };
    DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
        moveNodesAfterSibling(node, viewRootNodes);
        for (var i = 0; i < viewRootNodes.length; i++)
            this.animateNodeEnter(viewRootNodes[i]);
    };
    DomRenderer.prototype.detachView = function (viewRootNodes) {
        for (var i = 0; i < viewRootNodes.length; i++) {
            var node = viewRootNodes[i];
            dom_adapter_1.getDOM().remove(node);
            this.animateNodeLeave(node);
        }
    };
    DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
        if (this.componentProto.encapsulation === core_1.ViewEncapsulation.Native && lang_1.isPresent(hostElement)) {
            this._rootRenderer.sharedStylesHost.removeHost(dom_adapter_1.getDOM().getShadowRoot(hostElement));
        }
    };
    DomRenderer.prototype.listen = function (renderElement, name, callback) {
        return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
    };
    DomRenderer.prototype.listenGlobal = function (target, name, callback) {
        return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
    };
    DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
        dom_adapter_1.getDOM().setProperty(renderElement, propertyName, propertyValue);
    };
    DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
        var attrNs;
        var nsAndName = splitNamespace(attributeName);
        if (lang_1.isPresent(nsAndName[0])) {
            attributeName = nsAndName[0] + ':' + nsAndName[1];
            attrNs = NAMESPACE_URIS[nsAndName[0]];
        }
        if (lang_1.isPresent(attributeValue)) {
            if (lang_1.isPresent(attrNs)) {
                dom_adapter_1.getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
            }
            else {
                dom_adapter_1.getDOM().setAttribute(renderElement, attributeName, attributeValue);
            }
        }
        else {
            if (lang_1.isPresent(attrNs)) {
                dom_adapter_1.getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
            }
            else {
                dom_adapter_1.getDOM().removeAttribute(renderElement, attributeName);
            }
        }
    };
    DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
        var dashCasedPropertyName = util_1.camelCaseToDashCase(propertyName);
        if (dom_adapter_1.getDOM().isCommentNode(renderElement)) {
            var existingBindings = lang_1.RegExpWrapper.firstMatch(TEMPLATE_BINDINGS_EXP, lang_1.StringWrapper.replaceAll(dom_adapter_1.getDOM().getText(renderElement), /\n/g, ''));
            var parsedBindings = lang_1.Json.parse(existingBindings[1]);
            parsedBindings[dashCasedPropertyName] = propertyValue;
            dom_adapter_1.getDOM().setText(renderElement, lang_1.StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}', lang_1.Json.stringify(parsedBindings)));
        }
        else {
            this.setElementAttribute(renderElement, propertyName, propertyValue);
        }
    };
    DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
        if (isAdd) {
            dom_adapter_1.getDOM().addClass(renderElement, className);
        }
        else {
            dom_adapter_1.getDOM().removeClass(renderElement, className);
        }
    };
    DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
        if (lang_1.isPresent(styleValue)) {
            dom_adapter_1.getDOM().setStyle(renderElement, styleName, lang_1.stringify(styleValue));
        }
        else {
            dom_adapter_1.getDOM().removeStyle(renderElement, styleName);
        }
    };
    DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
        dom_adapter_1.getDOM().invoke(renderElement, methodName, args);
    };
    DomRenderer.prototype.setText = function (renderNode, text) { dom_adapter_1.getDOM().setText(renderNode, text); };
    /**
     * Performs animations if necessary
     * @param node
     */
    DomRenderer.prototype.animateNodeEnter = function (node) {
        if (dom_adapter_1.getDOM().isElementNode(node) && dom_adapter_1.getDOM().hasClass(node, 'ng-animate')) {
            dom_adapter_1.getDOM().addClass(node, 'ng-enter');
            this._rootRenderer.animate.css()
                .addAnimationClass('ng-enter-active')
                .start(node)
                .onComplete(function () { dom_adapter_1.getDOM().removeClass(node, 'ng-enter'); });
        }
    };
    /**
     * If animations are necessary, performs animations then removes the element; otherwise, it just
     * removes the element.
     * @param node
     */
    DomRenderer.prototype.animateNodeLeave = function (node) {
        if (dom_adapter_1.getDOM().isElementNode(node) && dom_adapter_1.getDOM().hasClass(node, 'ng-animate')) {
            dom_adapter_1.getDOM().addClass(node, 'ng-leave');
            this._rootRenderer.animate.css()
                .addAnimationClass('ng-leave-active')
                .start(node)
                .onComplete(function () {
                dom_adapter_1.getDOM().removeClass(node, 'ng-leave');
                dom_adapter_1.getDOM().remove(node);
            });
        }
        else {
            dom_adapter_1.getDOM().remove(node);
        }
    };
    return DomRenderer;
}());
exports.DomRenderer = DomRenderer;
function moveNodesAfterSibling(sibling, nodes) {
    var parent = dom_adapter_1.getDOM().parentElement(sibling);
    if (nodes.length > 0 && lang_1.isPresent(parent)) {
        var nextSibling = dom_adapter_1.getDOM().nextSibling(sibling);
        if (lang_1.isPresent(nextSibling)) {
            for (var i = 0; i < nodes.length; i++) {
                dom_adapter_1.getDOM().insertBefore(nextSibling, nodes[i]);
            }
        }
        else {
            for (var i = 0; i < nodes.length; i++) {
                dom_adapter_1.getDOM().appendChild(parent, nodes[i]);
            }
        }
    }
}
function appendNodes(parent, nodes) {
    for (var i = 0; i < nodes.length; i++) {
        dom_adapter_1.getDOM().appendChild(parent, nodes[i]);
    }
}
function decoratePreventDefault(eventHandler) {
    return function (event) {
        var allowDefaultBehavior = eventHandler(event);
        if (allowDefaultBehavior === false) {
            // TODO(tbosch): move preventDefault into event plugins...
            dom_adapter_1.getDOM().preventDefault(event);
        }
    };
}
var COMPONENT_REGEX = /%COMP%/g;
exports.COMPONENT_VARIABLE = '%COMP%';
exports.HOST_ATTR = "_nghost-" + exports.COMPONENT_VARIABLE;
exports.CONTENT_ATTR = "_ngcontent-" + exports.COMPONENT_VARIABLE;
function _shimContentAttribute(componentShortId) {
    return lang_1.StringWrapper.replaceAll(exports.CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
}
function _shimHostAttribute(componentShortId) {
    return lang_1.StringWrapper.replaceAll(exports.HOST_ATTR, COMPONENT_REGEX, componentShortId);
}
function _flattenStyles(compId, styles, target) {
    for (var i = 0; i < styles.length; i++) {
        var style = styles[i];
        if (lang_1.isArray(style)) {
            _flattenStyles(compId, style, target);
        }
        else {
            style = lang_1.StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);
            target.push(style);
        }
    }
    return target;
}
var NS_PREFIX_RE = /^@([^:]+):(.+)/g;
function splitNamespace(name) {
    if (name[0] != '@') {
        return [null, name];
    }
    var match = lang_1.RegExpWrapper.firstMatch(NS_PREFIX_RE, name);
    return [match[1], match[2]];
}

},{"../../src/facade/exceptions":279,"../../src/facade/lang":280,"../animate/animation_builder":251,"./dom_adapter":265,"./dom_tokens":267,"./events/event_manager":269,"./shared_styles_host":273,"./util":274,"@angular/core":140}],267:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
/**
 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
 *
 * Note: Document might not be available in the Application Context when Application and Rendering
 * Contexts are not the same (e.g. when running the application into a Web Worker).
 */
exports.DOCUMENT = new core_1.OpaqueToken('DocumentToken');

},{"@angular/core":140}],268:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var dom_adapter_1 = require('../dom_adapter');
var event_manager_1 = require('./event_manager');
var DomEventsPlugin = (function (_super) {
    __extends(DomEventsPlugin, _super);
    function DomEventsPlugin() {
        _super.apply(this, arguments);
    }
    // This plugin should come last in the list of plugins, because it accepts all
    // events.
    DomEventsPlugin.prototype.supports = function (eventName) { return true; };
    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var zone = this.manager.getZone();
        var outsideHandler = function (event) { return zone.runGuarded(function () { return handler(event); }); };
        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.getDOM().onAndCancel(element, eventName, outsideHandler); });
    };
    DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
        var element = dom_adapter_1.getDOM().getGlobalEventTarget(target);
        var zone = this.manager.getZone();
        var outsideHandler = function (event) { return zone.runGuarded(function () { return handler(event); }); };
        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.getDOM().onAndCancel(element, eventName, outsideHandler); });
    };
    DomEventsPlugin.decorators = [
        { type: core_1.Injectable },
    ];
    return DomEventsPlugin;
}(event_manager_1.EventManagerPlugin));
exports.DomEventsPlugin = DomEventsPlugin;

},{"../dom_adapter":265,"./event_manager":269,"@angular/core":140}],269:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var exceptions_1 = require('../../../src/facade/exceptions');
var collection_1 = require('../../../src/facade/collection');
exports.EVENT_MANAGER_PLUGINS = 
/*@ts2dart_const*/ new core_1.OpaqueToken("EventManagerPlugins");
var EventManager = (function () {
    function EventManager(plugins, _zone) {
        var _this = this;
        this._zone = _zone;
        plugins.forEach(function (p) { return p.manager = _this; });
        this._plugins = collection_1.ListWrapper.reversed(plugins);
    }
    EventManager.prototype.addEventListener = function (element, eventName, handler) {
        var plugin = this._findPluginFor(eventName);
        return plugin.addEventListener(element, eventName, handler);
    };
    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
        var plugin = this._findPluginFor(eventName);
        return plugin.addGlobalEventListener(target, eventName, handler);
    };
    EventManager.prototype.getZone = function () { return this._zone; };
    /** @internal */
    EventManager.prototype._findPluginFor = function (eventName) {
        var plugins = this._plugins;
        for (var i = 0; i < plugins.length; i++) {
            var plugin = plugins[i];
            if (plugin.supports(eventName)) {
                return plugin;
            }
        }
        throw new exceptions_1.BaseException("No event manager plugin found for event " + eventName);
    };
    EventManager.decorators = [
        { type: core_1.Injectable },
    ];
    EventManager.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Inject, args: [exports.EVENT_MANAGER_PLUGINS,] },] },
        { type: core_1.NgZone, },
    ];
    return EventManager;
}());
exports.EventManager = EventManager;
var EventManagerPlugin = (function () {
    function EventManagerPlugin() {
    }
    // That is equivalent to having supporting $event.target
    EventManagerPlugin.prototype.supports = function (eventName) { return false; };
    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
        throw "not implemented";
    };
    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
        throw "not implemented";
    };
    return EventManagerPlugin;
}());
exports.EventManagerPlugin = EventManagerPlugin;

},{"../../../src/facade/collection":277,"../../../src/facade/exceptions":279,"@angular/core":140}],270:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var event_manager_1 = require('./event_manager');
var collection_1 = require('../../../src/facade/collection');
var _eventNames = {
    // pan
    'pan': true,
    'panstart': true,
    'panmove': true,
    'panend': true,
    'pancancel': true,
    'panleft': true,
    'panright': true,
    'panup': true,
    'pandown': true,
    // pinch
    'pinch': true,
    'pinchstart': true,
    'pinchmove': true,
    'pinchend': true,
    'pinchcancel': true,
    'pinchin': true,
    'pinchout': true,
    // press
    'press': true,
    'pressup': true,
    // rotate
    'rotate': true,
    'rotatestart': true,
    'rotatemove': true,
    'rotateend': true,
    'rotatecancel': true,
    // swipe
    'swipe': true,
    'swipeleft': true,
    'swiperight': true,
    'swipeup': true,
    'swipedown': true,
    // tap
    'tap': true,
};
var HammerGesturesPluginCommon = (function (_super) {
    __extends(HammerGesturesPluginCommon, _super);
    function HammerGesturesPluginCommon() {
        _super.call(this);
    }
    HammerGesturesPluginCommon.prototype.supports = function (eventName) {
        eventName = eventName.toLowerCase();
        return collection_1.StringMapWrapper.contains(_eventNames, eventName);
    };
    return HammerGesturesPluginCommon;
}(event_manager_1.EventManagerPlugin));
exports.HammerGesturesPluginCommon = HammerGesturesPluginCommon;

},{"../../../src/facade/collection":277,"./event_manager":269}],271:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var exceptions_1 = require('../../../src/facade/exceptions');
var hammer_common_1 = require('./hammer_common');
exports.HAMMER_GESTURE_CONFIG = 
/*@ts2dart_const*/ new core_1.OpaqueToken("HammerGestureConfig");
var HammerGestureConfig = (function () {
    function HammerGestureConfig() {
        this.events = [];
        this.overrides = {};
    }
    HammerGestureConfig.prototype.buildHammer = function (element) {
        var mc = new Hammer(element);
        mc.get('pinch').set({ enable: true });
        mc.get('rotate').set({ enable: true });
        for (var eventName in this.overrides) {
            mc.get(eventName).set(this.overrides[eventName]);
        }
        return mc;
    };
    HammerGestureConfig.decorators = [
        { type: core_1.Injectable },
    ];
    return HammerGestureConfig;
}());
exports.HammerGestureConfig = HammerGestureConfig;
var HammerGesturesPlugin = (function (_super) {
    __extends(HammerGesturesPlugin, _super);
    function HammerGesturesPlugin(_config) {
        _super.call(this);
        this._config = _config;
    }
    HammerGesturesPlugin.prototype.supports = function (eventName) {
        if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))
            return false;
        if (!lang_1.isPresent(window['Hammer'])) {
            throw new exceptions_1.BaseException("Hammer.js is not loaded, can not bind " + eventName + " event");
        }
        return true;
    };
    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var _this = this;
        var zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        return zone.runOutsideAngular(function () {
            // Creating the manager bind events, must be done outside of angular
            var mc = _this._config.buildHammer(element);
            var callback = function (eventObj) { zone.runGuarded(function () { handler(eventObj); }); };
            mc.on(eventName, callback);
            return function () { mc.off(eventName, callback); };
        });
    };
    HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
    HammerGesturesPlugin.decorators = [
        { type: core_1.Injectable },
    ];
    HammerGesturesPlugin.ctorParameters = [
        { type: HammerGestureConfig, decorators: [{ type: core_1.Inject, args: [exports.HAMMER_GESTURE_CONFIG,] },] },
    ];
    return HammerGesturesPlugin;
}(hammer_common_1.HammerGesturesPluginCommon));
exports.HammerGesturesPlugin = HammerGesturesPlugin;

},{"../../../src/facade/exceptions":279,"../../../src/facade/lang":280,"./hammer_common":270,"@angular/core":140}],272:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var lang_1 = require('../../../src/facade/lang');
var collection_1 = require('../../../src/facade/collection');
var dom_adapter_1 = require('../dom_adapter');
var event_manager_1 = require('./event_manager');
var modifierKeys = ['alt', 'control', 'meta', 'shift'];
var modifierKeyGetters = {
    'alt': function (event) { return event.altKey; },
    'control': function (event) { return event.ctrlKey; },
    'meta': function (event) { return event.metaKey; },
    'shift': function (event) { return event.shiftKey; }
};
var KeyEventsPlugin = (function (_super) {
    __extends(KeyEventsPlugin, _super);
    function KeyEventsPlugin() {
        _super.call(this);
    }
    KeyEventsPlugin.prototype.supports = function (eventName) {
        return lang_1.isPresent(KeyEventsPlugin.parseEventName(eventName));
    };
    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
        var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
        var outsideHandler = KeyEventsPlugin.eventCallback(element, collection_1.StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
        return this.manager.getZone().runOutsideAngular(function () {
            return dom_adapter_1.getDOM().onAndCancel(element, collection_1.StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
        });
    };
    KeyEventsPlugin.parseEventName = function (eventName) {
        var parts = eventName.toLowerCase().split('.');
        var domEventName = parts.shift();
        if ((parts.length === 0) ||
            !(lang_1.StringWrapper.equals(domEventName, 'keydown') ||
                lang_1.StringWrapper.equals(domEventName, 'keyup'))) {
            return null;
        }
        var key = KeyEventsPlugin._normalizeKey(parts.pop());
        var fullKey = '';
        modifierKeys.forEach(function (modifierName) {
            if (collection_1.ListWrapper.contains(parts, modifierName)) {
                collection_1.ListWrapper.remove(parts, modifierName);
                fullKey += modifierName + '.';
            }
        });
        fullKey += key;
        if (parts.length != 0 || key.length === 0) {
            // returning null instead of throwing to let another plugin process the event
            return null;
        }
        var result = collection_1.StringMapWrapper.create();
        collection_1.StringMapWrapper.set(result, 'domEventName', domEventName);
        collection_1.StringMapWrapper.set(result, 'fullKey', fullKey);
        return result;
    };
    KeyEventsPlugin.getEventFullKey = function (event) {
        var fullKey = '';
        var key = dom_adapter_1.getDOM().getEventKey(event);
        key = key.toLowerCase();
        if (lang_1.StringWrapper.equals(key, ' ')) {
            key = 'space'; // for readability
        }
        else if (lang_1.StringWrapper.equals(key, '.')) {
            key = 'dot'; // because '.' is used as a separator in event names
        }
        modifierKeys.forEach(function (modifierName) {
            if (modifierName != key) {
                var modifierGetter = collection_1.StringMapWrapper.get(modifierKeyGetters, modifierName);
                if (modifierGetter(event)) {
                    fullKey += modifierName + '.';
                }
            }
        });
        fullKey += key;
        return fullKey;
    };
    KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
        return function (event) {
            if (lang_1.StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
                zone.runGuarded(function () { return handler(event); });
            }
        };
    };
    /** @internal */
    KeyEventsPlugin._normalizeKey = function (keyName) {
        // TODO: switch to a StringMap if the mapping grows too much
        switch (keyName) {
            case 'esc':
                return 'escape';
            default:
                return keyName;
        }
    };
    KeyEventsPlugin.decorators = [
        { type: core_1.Injectable },
    ];
    KeyEventsPlugin.ctorParameters = [];
    return KeyEventsPlugin;
}(event_manager_1.EventManagerPlugin));
exports.KeyEventsPlugin = KeyEventsPlugin;

},{"../../../src/facade/collection":277,"../../../src/facade/lang":280,"../dom_adapter":265,"./event_manager":269,"@angular/core":140}],273:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var core_1 = require('@angular/core');
var collection_1 = require('../../src/facade/collection');
var dom_adapter_1 = require('./dom_adapter');
var dom_tokens_1 = require('./dom_tokens');
var SharedStylesHost = (function () {
    function SharedStylesHost() {
        /** @internal */
        this._styles = [];
        /** @internal */
        this._stylesSet = new Set();
    }
    SharedStylesHost.prototype.addStyles = function (styles) {
        var _this = this;
        var additions = [];
        styles.forEach(function (style) {
            if (!collection_1.SetWrapper.has(_this._stylesSet, style)) {
                _this._stylesSet.add(style);
                _this._styles.push(style);
                additions.push(style);
            }
        });
        this.onStylesAdded(additions);
    };
    SharedStylesHost.prototype.onStylesAdded = function (additions) { };
    SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
    SharedStylesHost.decorators = [
        { type: core_1.Injectable },
    ];
    SharedStylesHost.ctorParameters = [];
    return SharedStylesHost;
}());
exports.SharedStylesHost = SharedStylesHost;
var DomSharedStylesHost = (function (_super) {
    __extends(DomSharedStylesHost, _super);
    function DomSharedStylesHost(doc) {
        _super.call(this);
        this._hostNodes = new Set();
        this._hostNodes.add(doc.head);
    }
    /** @internal */
    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
        for (var i = 0; i < styles.length; i++) {
            var style = styles[i];
            dom_adapter_1.getDOM().appendChild(host, dom_adapter_1.getDOM().createStyleElement(style));
        }
    };
    DomSharedStylesHost.prototype.addHost = function (hostNode) {
        this._addStylesToHost(this._styles, hostNode);
        this._hostNodes.add(hostNode);
    };
    DomSharedStylesHost.prototype.removeHost = function (hostNode) { collection_1.SetWrapper.delete(this._hostNodes, hostNode); };
    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
        var _this = this;
        this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
    };
    DomSharedStylesHost.decorators = [
        { type: core_1.Injectable },
    ];
    DomSharedStylesHost.ctorParameters = [
        { type: undefined, decorators: [{ type: core_1.Inject, args: [dom_tokens_1.DOCUMENT,] },] },
    ];
    return DomSharedStylesHost;
}(SharedStylesHost));
exports.DomSharedStylesHost = DomSharedStylesHost;

},{"../../src/facade/collection":277,"./dom_adapter":265,"./dom_tokens":267,"@angular/core":140}],274:[function(require,module,exports){
"use strict";
var lang_1 = require('../../src/facade/lang');
var CAMEL_CASE_REGEXP = /([A-Z])/g;
var DASH_CASE_REGEXP = /-([a-z])/g;
function camelCaseToDashCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
}
exports.camelCaseToDashCase = camelCaseToDashCase;
function dashCaseToCamelCase(input) {
    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
}
exports.dashCaseToCamelCase = dashCaseToCamelCase;

},{"../../src/facade/lang":280}],275:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],276:[function(require,module,exports){
"use strict";
/**
* JS version of browser APIs. This library can only run in the browser.
*/
var win = typeof window !== 'undefined' && window || {};
exports.window = win;
exports.document = win.document;
exports.location = win.location;
exports.gc = win['gc'] ? function () { return win['gc'](); } : function () { return null; };
exports.performance = win['performance'] ? win['performance'] : null;
exports.Event = win['Event'];
exports.MouseEvent = win['MouseEvent'];
exports.KeyboardEvent = win['KeyboardEvent'];
exports.EventTarget = win['EventTarget'];
exports.History = win['History'];
exports.Location = win['Location'];
exports.EventListener = win['EventListener'];

},{}],277:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./lang":280,"dup":22}],278:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./base_wrapped_exception":275,"./collection":277,"./lang":280,"dup":23}],279:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./base_wrapped_exception":275,"./exception_handler":278,"dup":24}],280:[function(require,module,exports){
(function (global){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var globalScope;
if (typeof window === 'undefined') {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
        globalScope = self;
    }
    else {
        globalScope = global;
    }
}
else {
    globalScope = window;
}
function scheduleMicroTask(fn) {
    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
}
exports.scheduleMicroTask = scheduleMicroTask;
exports.IS_DART = false;
// Need to declare a new variable for global here since TypeScript
// exports the original value of the symbol.
var _global = globalScope;
exports.global = _global;
exports.Type = Function;
function getTypeNameForDebugging(type) {
    if (type['name']) {
        return type['name'];
    }
    return typeof type;
}
exports.getTypeNameForDebugging = getTypeNameForDebugging;
exports.Math = _global.Math;
exports.Date = _global.Date;
var _devMode = true;
var _modeLocked = false;
function lockMode() {
    _modeLocked = true;
}
exports.lockMode = lockMode;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 */
function enableProdMode() {
    if (_modeLocked) {
        // Cannot use BaseException as that ends up importing from facade/lang.
        throw 'Cannot enable prod mode after platform setup.';
    }
    _devMode = false;
}
exports.enableProdMode = enableProdMode;
function assertionsEnabled() {
    return _devMode;
}
exports.assertionsEnabled = assertionsEnabled;
// TODO: remove calls to assert in production environment
// Note: Can't just export this and import in in other files
// as `assert` is a reserved keyword in Dart
_global.assert = function assert(condition) {
    // TODO: to be fixed properly via #2830, noop for now
};
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
exports.isPresent = isPresent;
function isBlank(obj) {
    return obj === undefined || obj === null;
}
exports.isBlank = isBlank;
function isBoolean(obj) {
    return typeof obj === "boolean";
}
exports.isBoolean = isBoolean;
function isNumber(obj) {
    return typeof obj === "number";
}
exports.isNumber = isNumber;
function isString(obj) {
    return typeof obj === "string";
}
exports.isString = isString;
function isFunction(obj) {
    return typeof obj === "function";
}
exports.isFunction = isFunction;
function isType(obj) {
    return isFunction(obj);
}
exports.isType = isType;
function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
}
exports.isStringMap = isStringMap;
var STRING_MAP_PROTO = Object.getPrototypeOf({});
function isStrictStringMap(obj) {
    return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
}
exports.isStrictStringMap = isStrictStringMap;
function isPromise(obj) {
    return obj instanceof _global.Promise;
}
exports.isPromise = isPromise;
function isArray(obj) {
    return Array.isArray(obj);
}
exports.isArray = isArray;
function isDate(obj) {
    return obj instanceof exports.Date && !isNaN(obj.valueOf());
}
exports.isDate = isDate;
function noop() { }
exports.noop = noop;
function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (token === undefined || token === null) {
        return '' + token;
    }
    if (token.name) {
        return token.name;
    }
    if (token.overriddenName) {
        return token.overriddenName;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
}
exports.stringify = stringify;
// serialize / deserialize enum exist only for consistency with dart API
// enums in typescript don't need to be serialized
function serializeEnum(val) {
    return val;
}
exports.serializeEnum = serializeEnum;
function deserializeEnum(val, values) {
    return val;
}
exports.deserializeEnum = deserializeEnum;
function resolveEnumToken(enumValue, val) {
    return enumValue[val];
}
exports.resolveEnumToken = resolveEnumToken;
var StringWrapper = (function () {
    function StringWrapper() {
    }
    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
    StringWrapper.equals = function (s, s2) { return s === s2; };
    StringWrapper.stripLeft = function (s, charVal) {
        if (s && s.length) {
            var pos = 0;
            for (var i = 0; i < s.length; i++) {
                if (s[i] != charVal)
                    break;
                pos++;
            }
            s = s.substring(pos);
        }
        return s;
    };
    StringWrapper.stripRight = function (s, charVal) {
        if (s && s.length) {
            var pos = s.length;
            for (var i = s.length - 1; i >= 0; i--) {
                if (s[i] != charVal)
                    break;
                pos--;
            }
            s = s.substring(0, pos);
        }
        return s;
    };
    StringWrapper.replace = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.replaceAll = function (s, from, replace) {
        return s.replace(from, replace);
    };
    StringWrapper.slice = function (s, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = null; }
        return s.slice(from, to === null ? undefined : to);
    };
    StringWrapper.replaceAllMapped = function (s, from, cb) {
        return s.replace(from, function () {
            var matches = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                matches[_i - 0] = arguments[_i];
            }
            // Remove offset & string from the result array
            matches.splice(-2, 2);
            // The callback receives match, p1, ..., pn
            return cb(matches);
        });
    };
    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
    StringWrapper.compare = function (a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return StringWrapper;
}());
exports.StringWrapper = StringWrapper;
var StringJoiner = (function () {
    function StringJoiner(parts) {
        if (parts === void 0) { parts = []; }
        this.parts = parts;
    }
    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
    return StringJoiner;
}());
exports.StringJoiner = StringJoiner;
var NumberParseError = (function (_super) {
    __extends(NumberParseError, _super);
    function NumberParseError(message) {
        _super.call(this);
        this.message = message;
    }
    NumberParseError.prototype.toString = function () { return this.message; };
    return NumberParseError;
}(Error));
exports.NumberParseError = NumberParseError;
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
    NumberWrapper.equal = function (a, b) { return a === b; };
    NumberWrapper.parseIntAutoRadix = function (text) {
        var result = parseInt(text);
        if (isNaN(result)) {
            throw new NumberParseError("Invalid integer literal when parsing " + text);
        }
        return result;
    };
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
            radix);
    };
    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
    Object.defineProperty(NumberWrapper, "NaN", {
        get: function () { return NaN; },
        enumerable: true,
        configurable: true
    });
    NumberWrapper.isNaN = function (value) { return isNaN(value); };
    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
    return NumberWrapper;
}());
exports.NumberWrapper = NumberWrapper;
exports.RegExp = _global.RegExp;
var RegExpWrapper = (function () {
    function RegExpWrapper() {
    }
    RegExpWrapper.create = function (regExpStr, flags) {
        if (flags === void 0) { flags = ''; }
        flags = flags.replace(/g/g, '');
        return new _global.RegExp(regExpStr, flags + 'g');
    };
    RegExpWrapper.firstMatch = function (regExp, input) {
        // Reset multimatch regex state
        regExp.lastIndex = 0;
        return regExp.exec(input);
    };
    RegExpWrapper.test = function (regExp, input) {
        regExp.lastIndex = 0;
        return regExp.test(input);
    };
    RegExpWrapper.matcher = function (regExp, input) {
        // Reset regex state for the case
        // someone did not loop over all matches
        // last time.
        regExp.lastIndex = 0;
        return { re: regExp, input: input };
    };
    RegExpWrapper.replaceAll = function (regExp, input, replace) {
        var c = regExp.exec(input);
        var res = '';
        regExp.lastIndex = 0;
        var prev = 0;
        while (c) {
            res += input.substring(prev, c.index);
            res += replace(c);
            prev = c.index + c[0].length;
            regExp.lastIndex = prev;
            c = regExp.exec(input);
        }
        res += input.substring(prev);
        return res;
    };
    return RegExpWrapper;
}());
exports.RegExpWrapper = RegExpWrapper;
var RegExpMatcherWrapper = (function () {
    function RegExpMatcherWrapper() {
    }
    RegExpMatcherWrapper.next = function (matcher) {
        return matcher.re.exec(matcher.input);
    };
    return RegExpMatcherWrapper;
}());
exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
var FunctionWrapper = (function () {
    function FunctionWrapper() {
    }
    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
    return FunctionWrapper;
}());
exports.FunctionWrapper = FunctionWrapper;
// JS has NaN !== NaN
function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
}
exports.looseIdentical = looseIdentical;
// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
function getMapKey(value) {
    return value;
}
exports.getMapKey = getMapKey;
function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
}
exports.normalizeBlank = normalizeBlank;
function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
}
exports.normalizeBool = normalizeBool;
function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
}
exports.isJsObject = isJsObject;
function print(obj) {
    console.log(obj);
}
exports.print = print;
function warn(obj) {
    console.warn(obj);
}
exports.warn = warn;
// Can't be all uppercase as our transpiler would think it is a special directive...
var Json = (function () {
    function Json() {
    }
    Json.parse = function (s) { return _global.JSON.parse(s); };
    Json.stringify = function (data) {
        // Dart doesn't take 3 arguments
        return _global.JSON.stringify(data, null, 2);
    };
    return Json;
}());
exports.Json = Json;
var DateWrapper = (function () {
    function DateWrapper() {
    }
    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
        if (month === void 0) { month = 1; }
        if (day === void 0) { day = 1; }
        if (hour === void 0) { hour = 0; }
        if (minutes === void 0) { minutes = 0; }
        if (seconds === void 0) { seconds = 0; }
        if (milliseconds === void 0) { milliseconds = 0; }
        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
    };
    DateWrapper.fromISOString = function (str) { return new exports.Date(str); };
    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
    DateWrapper.toMillis = function (date) { return date.getTime(); };
    DateWrapper.now = function () { return new exports.Date(); };
    DateWrapper.toJson = function (date) { return date.toJSON(); };
    return DateWrapper;
}());
exports.DateWrapper = DateWrapper;
function setValueOnPath(global, path, value) {
    var parts = path.split('.');
    var obj = global;
    while (parts.length > 1) {
        var name = parts.shift();
        if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
            obj = obj[name];
        }
        else {
            obj = obj[name] = {};
        }
    }
    if (obj === undefined || obj === null) {
        obj = {};
    }
    obj[parts.shift()] = value;
}
exports.setValueOnPath = setValueOnPath;
var _symbolIterator = null;
function getSymbolIterator() {
    if (isBlank(_symbolIterator)) {
        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
            _symbolIterator = Symbol.iterator;
        }
        else {
            // es6-shim specific logic
            var keys = Object.getOwnPropertyNames(Map.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                if (key !== 'entries' && key !== 'size' &&
                    Map.prototype[key] === Map.prototype['entries']) {
                    _symbolIterator = key;
                }
            }
        }
    }
    return _symbolIterator;
}
exports.getSymbolIterator = getSymbolIterator;
function evalExpression(sourceUrl, expr, declarations, vars) {
    var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
    var fnArgNames = [];
    var fnArgValues = [];
    for (var argName in vars) {
        fnArgNames.push(argName);
        fnArgValues.push(vars[argName]);
    }
    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
}
exports.evalExpression = evalExpression;
function isPrimitive(obj) {
    return !isJsObject(obj);
}
exports.isPrimitive = isPrimitive;
function hasConstructor(value, type) {
    return value.constructor === type;
}
exports.hasConstructor = hasConstructor;
function bitWiseOr(values) {
    return values.reduce(function (a, b) { return a | b; });
}
exports.bitWiseOr = bitWiseOr;
function bitWiseAnd(values) {
    return values.reduce(function (a, b) { return a & b; });
}
exports.bitWiseAnd = bitWiseAnd;
function escape(s) {
    return _global.encodeURI(s);
}
exports.escape = escape;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],281:[function(require,module,exports){
"use strict";
var lang_1 = require('./lang');
exports.Math = lang_1.global.Math;
exports.NaN = typeof exports.NaN;

},{"./lang":280}],282:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var core_1 = require('@angular/core');
var lang_1 = require('./facade/lang');
var browser_common_1 = require('./browser_common');
var dom_events_1 = require('./dom/events/dom_events');
exports.DomEventsPlugin = dom_events_1.DomEventsPlugin;
var event_manager_1 = require('./dom/events/event_manager');
exports.EventManager = event_manager_1.EventManager;
exports.EVENT_MANAGER_PLUGINS = event_manager_1.EVENT_MANAGER_PLUGINS;
var ng_probe_1 = require('./dom/debug/ng_probe');
exports.ELEMENT_PROBE_PROVIDERS = ng_probe_1.ELEMENT_PROBE_PROVIDERS;
var browser_common_2 = require('./browser_common');
exports.BROWSER_APP_COMMON_PROVIDERS = browser_common_2.BROWSER_APP_COMMON_PROVIDERS;
exports.BROWSER_SANITIZATION_PROVIDERS = browser_common_2.BROWSER_SANITIZATION_PROVIDERS;
exports.BROWSER_PROVIDERS = browser_common_2.BROWSER_PROVIDERS;
exports.By = browser_common_2.By;
exports.Title = browser_common_2.Title;
exports.enableDebugTools = browser_common_2.enableDebugTools;
exports.disableDebugTools = browser_common_2.disableDebugTools;
exports.HAMMER_GESTURE_CONFIG = browser_common_2.HAMMER_GESTURE_CONFIG;
exports.HammerGestureConfig = browser_common_2.HammerGestureConfig;
__export(require('../private_export'));
var dom_tokens_1 = require('./dom/dom_tokens');
exports.DOCUMENT = dom_tokens_1.DOCUMENT;
var dom_sanitization_service_1 = require('./security/dom_sanitization_service');
exports.DomSanitizationService = dom_sanitization_service_1.DomSanitizationService;
exports.SecurityContext = dom_sanitization_service_1.SecurityContext;
var platform_browser_static_1 = require('./platform_browser_static');
exports.bootstrapStatic = platform_browser_static_1.bootstrapStatic;
exports.browserStaticPlatform = platform_browser_static_1.browserStaticPlatform;
exports.BROWSER_APP_STATIC_PROVIDERS = platform_browser_static_1.BROWSER_APP_STATIC_PROVIDERS;
exports.BrowserPlatformLocation = platform_browser_static_1.BrowserPlatformLocation;
function browserPlatform() {
    if (lang_1.isBlank(core_1.getPlatform())) {
        core_1.createPlatform(core_1.ReflectiveInjector.resolveAndCreate(browser_common_1.BROWSER_PROVIDERS));
    }
    return core_1.assertPlatform(browser_common_1.BROWSER_PLATFORM_MARKER);
}
exports.browserPlatform = browserPlatform;

},{"../private_export":249,"./browser_common":262,"./dom/debug/ng_probe":264,"./dom/dom_tokens":267,"./dom/events/dom_events":268,"./dom/events/event_manager":269,"./facade/lang":280,"./platform_browser_static":283,"./security/dom_sanitization_service":284,"@angular/core":140}],283:[function(require,module,exports){
"use strict";
var core_1 = require('@angular/core');
var lang_1 = require('./facade/lang');
var browser_common_1 = require('./browser_common');
var ng_probe_1 = require('./dom/debug/ng_probe');
exports.ELEMENT_PROBE_PROVIDERS = ng_probe_1.ELEMENT_PROBE_PROVIDERS;
var browser_platform_location_1 = require('./browser/location/browser_platform_location');
exports.BrowserPlatformLocation = browser_platform_location_1.BrowserPlatformLocation;
var browser_common_2 = require('./browser_common');
exports.BROWSER_PROVIDERS = browser_common_2.BROWSER_PROVIDERS;
exports.By = browser_common_2.By;
exports.Title = browser_common_2.Title;
exports.enableDebugTools = browser_common_2.enableDebugTools;
exports.disableDebugTools = browser_common_2.disableDebugTools;
/**
 * An array of providers that should be passed into `application()` when bootstrapping a component
 * when all templates
 * have been precompiled offline.
 */
exports.BROWSER_APP_STATIC_PROVIDERS = 
/*@ts2dart_const*/ browser_common_1.BROWSER_APP_COMMON_PROVIDERS;
function browserStaticPlatform() {
    if (lang_1.isBlank(core_1.getPlatform())) {
        core_1.createPlatform(core_1.ReflectiveInjector.resolveAndCreate(browser_common_1.BROWSER_PROVIDERS));
    }
    return core_1.assertPlatform(browser_common_1.BROWSER_PLATFORM_MARKER);
}
exports.browserStaticPlatform = browserStaticPlatform;
/**
 * See {@link bootstrap} for more information.
 */
function bootstrapStatic(appComponentType, customProviders, initReflector) {
    if (lang_1.isPresent(initReflector)) {
        initReflector();
    }
    var appProviders = lang_1.isPresent(customProviders) ? [exports.BROWSER_APP_STATIC_PROVIDERS, customProviders] :
        exports.BROWSER_APP_STATIC_PROVIDERS;
    var appInjector = core_1.ReflectiveInjector.resolveAndCreate(appProviders, browserStaticPlatform().injector);
    return core_1.coreLoadAndBootstrap(appInjector, appComponentType);
}
exports.bootstrapStatic = bootstrapStatic;

},{"./browser/location/browser_platform_location":257,"./browser_common":262,"./dom/debug/ng_probe":264,"./facade/lang":280,"@angular/core":140}],284:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var url_sanitizer_1 = require('./url_sanitizer');
var style_sanitizer_1 = require('./style_sanitizer');
var core_private_1 = require('../../core_private');
exports.SecurityContext = core_private_1.SecurityContext;
var core_1 = require('@angular/core');
/**
 * DomSanitizationService helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
 * values to be safe to use in the different DOM contexts.
 *
 * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
 * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
 * the website.
 *
 * In specific situations, it might be necessary to disable sanitization, for example if the
 * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
 * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
 * methods, and then binding to that value from the template.
 *
 * These situations should be very rare, and extraordinary care must be taken to avoid creating a
 * Cross Site Scripting (XSS) security bug!
 *
 * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
 * close as possible to the source of the value, to make it easy to verify no security bug is
 * created by its use.
 *
 * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
 * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
 * code. The sanitizer leaves safe values intact.
 */
var DomSanitizationService = (function () {
    function DomSanitizationService() {
    }
    return DomSanitizationService;
}());
exports.DomSanitizationService = DomSanitizationService;
var DomSanitizationServiceImpl = (function (_super) {
    __extends(DomSanitizationServiceImpl, _super);
    function DomSanitizationServiceImpl() {
        _super.apply(this, arguments);
    }
    DomSanitizationServiceImpl.prototype.sanitize = function (ctx, value) {
        if (value == null)
            return null;
        switch (ctx) {
            case core_private_1.SecurityContext.NONE:
                return value;
            case core_private_1.SecurityContext.HTML:
                if (value instanceof SafeHtmlImpl)
                    return value.changingThisBreaksApplicationSecurity;
                this.checkNotSafeValue(value, 'HTML');
                return this.sanitizeHtml(String(value));
            case core_private_1.SecurityContext.STYLE:
                if (value instanceof SafeStyleImpl)
                    return value.changingThisBreaksApplicationSecurity;
                this.checkNotSafeValue(value, 'Style');
                return style_sanitizer_1.sanitizeStyle(value);
            case core_private_1.SecurityContext.SCRIPT:
                if (value instanceof SafeScriptImpl)
                    return value.changingThisBreaksApplicationSecurity;
                this.checkNotSafeValue(value, 'Script');
                throw new Error('unsafe value used in a script context');
            case core_private_1.SecurityContext.URL:
                if (value instanceof SafeUrlImpl)
                    return value.changingThisBreaksApplicationSecurity;
                this.checkNotSafeValue(value, 'URL');
                return url_sanitizer_1.sanitizeUrl(String(value));
            case core_private_1.SecurityContext.RESOURCE_URL:
                if (value instanceof SafeResourceUrlImpl) {
                    return value.changingThisBreaksApplicationSecurity;
                }
                this.checkNotSafeValue(value, 'ResourceURL');
                throw new Error('unsafe value used in a resource URL context');
            default:
                throw new Error("Unexpected SecurityContext " + ctx);
        }
    };
    DomSanitizationServiceImpl.prototype.checkNotSafeValue = function (value, expectedType) {
        if (value instanceof SafeValueImpl) {
            throw new Error('Required a safe ' + expectedType + ', got a ' + value.getTypeName());
        }
    };
    DomSanitizationServiceImpl.prototype.sanitizeHtml = function (value) {
        // TODO(martinprobst): implement.
        return value;
    };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
    DomSanitizationServiceImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
        return new SafeResourceUrlImpl(value);
    };
    DomSanitizationServiceImpl.decorators = [
        { type: core_1.Injectable },
    ];
    return DomSanitizationServiceImpl;
}(DomSanitizationService));
exports.DomSanitizationServiceImpl = DomSanitizationServiceImpl;
var SafeValueImpl = (function () {
    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
        // empty
    }
    return SafeValueImpl;
}());
var SafeHtmlImpl = (function (_super) {
    __extends(SafeHtmlImpl, _super);
    function SafeHtmlImpl() {
        _super.apply(this, arguments);
    }
    SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
    return SafeHtmlImpl;
}(SafeValueImpl));
var SafeStyleImpl = (function (_super) {
    __extends(SafeStyleImpl, _super);
    function SafeStyleImpl() {
        _super.apply(this, arguments);
    }
    SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
    return SafeStyleImpl;
}(SafeValueImpl));
var SafeScriptImpl = (function (_super) {
    __extends(SafeScriptImpl, _super);
    function SafeScriptImpl() {
        _super.apply(this, arguments);
    }
    SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
    return SafeScriptImpl;
}(SafeValueImpl));
var SafeUrlImpl = (function (_super) {
    __extends(SafeUrlImpl, _super);
    function SafeUrlImpl() {
        _super.apply(this, arguments);
    }
    SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
    return SafeUrlImpl;
}(SafeValueImpl));
var SafeResourceUrlImpl = (function (_super) {
    __extends(SafeResourceUrlImpl, _super);
    function SafeResourceUrlImpl() {
        _super.apply(this, arguments);
    }
    SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
    return SafeResourceUrlImpl;
}(SafeValueImpl));

},{"../../core_private":247,"./style_sanitizer":285,"./url_sanitizer":286,"@angular/core":140}],285:[function(require,module,exports){
"use strict";
/**
* Regular expression for safe style values.
*
* Quotes (" and ') are allowed, but a check must be done elsewhere to ensure
* they're balanced.
*
* ',' allows multiple values to be assigned to the same property
* (e.g. background-attachment or font-family) and hence could allow
* multiple values to get injected, but that should pose no risk of XSS.
*
* The rgb() and rgba() expression checks only for XSS safety, not for CSS
* validity.
*
* This regular expression was taken from the Closure sanitization library.
*/
var SAFE_STYLE_VALUE = /^([-,."'%_!# a-zA-Z0-9]+|(?:rgb|hsl)a?\([0-9.%, ]+\))$/;
/**
 * Checks that quotes (" and ') are properly balanced inside a string. Assumes
 * that neither escape (\) nor any other character that could result in
 * breaking out of a string parsing context are allowed;
 * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
 *
 * This code was taken from the Closure sanitization library.
 */
function hasBalancedQuotes(value) {
    var outsideSingle = true;
    var outsideDouble = true;
    for (var i = 0; i < value.length; i++) {
        var c = value.charAt(i);
        if (c === '\'' && outsideDouble) {
            outsideSingle = !outsideSingle;
        }
        else if (c === '"' && outsideSingle) {
            outsideDouble = !outsideDouble;
        }
    }
    return outsideSingle && outsideDouble;
}
function sanitizeStyle(value) {
    if (String(value).match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value))
        return value;
    return 'unsafe';
}
exports.sanitizeStyle = sanitizeStyle;

},{}],286:[function(require,module,exports){
"use strict";
/**
* A pattern that recognizes a commonly useful subset of URLs that are safe.
*
* This regular expression matches a subset of URLs that will not cause script
* execution if used in URL context within a HTML document. Specifically, this
* regular expression matches if (comment from here on and regex copied from
* Soy's EscapingConventions):
* (1) Either a protocol in a whitelist (http, https, mailto or ftp).
* (2) or no protocol.  A protocol must be followed by a colon. The below
*     allows that by allowing colons only after one of the characters [/?#].
*     A colon after a hash (#) must be in the fragment.
*     Otherwise, a colon after a (?) must be in a query.
*     Otherwise, a colon after a single solidus (/) must be in a path.
*     Otherwise, a colon after a double solidus (//) must be in the authority
*     (before port).
*
* The pattern disallows &, used in HTML entity declarations before
* one of the characters in [/?#]. This disallows HTML entities used in the
* protocol name, which should never happen, e.g. "h&#116;tp" for "http".
* It also disallows HTML entities in the first path part of a relative path,
* e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
* that. More importantly, it disallows masking of a colon,
* e.g. "javascript&#58;...".
*
* This regular expression was taken from the Closure sanitization library.
*/
var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
function sanitizeUrl(url) {
    if (String(url).match(SAFE_URL_PATTERN))
        return url;
    return 'unsafe:' + url;
}
exports.sanitizeUrl = sanitizeUrl;

},{}],287:[function(require,module,exports){
(function(name, definition) {

/****************
 *  A tolerant, minimal icalendar parser
 *  (http://tools.ietf.org/html/rfc5545)
 *
 *  <peterbraden@peterbraden.co.uk>
 * **************/

  if (typeof module !== 'undefined') {
    module.exports = definition();
  } else if (typeof define === 'function' && typeof define.amd === 'object'){
    define(definition);
  } else {
    this[name] = definition();
  }

}('ical', function(){

   // Unescape Text re RFC 4.3.11
  var text = function(t){
    t = t || "";
    return (t
      .replace(/\\\,/g, ',')
      .replace(/\\\;/g, ';')
      .replace(/\\[nN]/g, '\n')
      .replace(/\\\\/g, '\\')
    )
  }

  var parseParams = function(p){
    var out = {}
    for (var i = 0; i<p.length; i++){
      if (p[i].indexOf('=') > -1){
        var segs = p[i].split('=');
        
        out[segs[0]] = parseValue(segs.slice(1).join('='));
        
      }
    }
    return out || sp
  }

  var parseValue = function(val){
    if ('TRUE' === val)
      return true;
    
    if ('FALSE' === val)
      return false;

    var number = Number(val);
    if (!isNaN(number))
      return number;

    return val;
  }

  var storeParam = function(name){
    return function(val, params, curr){
      var data;
      if (params && params.length && !(params.length==1 && params[0]==='CHARSET=utf-8')){
        data = {params:parseParams(params), val:text(val)}
      }
      else
        data = text(val)

      var current = curr[name];
      if (Array.isArray(current)){
        current.push(data);
        return curr;
      }

      if (current != null){
        curr[name] = [current, data];
        return curr;
      }

      curr[name] = data;
      return curr
    }
  }

  var addTZ = function(dt, name, params){
    var p = parseParams(params);

    if (params && p){
      dt[name].tz = p.TZID
    }

    return dt
  }


  var dateParam = function(name){
    return function(val, params, curr){

      // Store as string - worst case scenario
      storeParam(name)(val, undefined, curr)

      if (params && params[0] === "VALUE=DATE") {
        // Just Date

        var comps = /^(\d{4})(\d{2})(\d{2})$/.exec(val);
        if (comps !== null) {
          // No TZ info - assume same timezone as this computer
          curr[name] = new Date(
            comps[1],
            parseInt(comps[2], 10)-1,
            comps[3]
          );

          return addTZ(curr, name, params);
        }
      }


      //typical RFC date-time format
      var comps = /^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(Z)?$/.exec(val);
      if (comps !== null) {
        if (comps[7] == 'Z'){ // GMT
          curr[name] = new Date(Date.UTC(
            parseInt(comps[1], 10),
            parseInt(comps[2], 10)-1,
            parseInt(comps[3], 10),
            parseInt(comps[4], 10),
            parseInt(comps[5], 10),
            parseInt(comps[6], 10 )
          ));
          // TODO add tz
        } else {
          curr[name] = new Date(
            parseInt(comps[1], 10),
            parseInt(comps[2], 10)-1,
            parseInt(comps[3], 10),
            parseInt(comps[4], 10),
            parseInt(comps[5], 10),
            parseInt(comps[6], 10)
          );
        }
      }

      return addTZ(curr, name, params)
    }
  }


  var geoParam = function(name){
    return function(val, params, curr){
      storeParam(val, params, curr)
      var parts = val.split(';');
      curr[name] = {lat:Number(parts[0]), lon:Number(parts[1])};
      return curr
    }
  }

  var categoriesParam = function (name) {
    var separatorPattern = /\s*,\s*/g;
    return function (val, params, curr) {
      storeParam(val, params, curr)
      curr[name] = val ? val.split(separatorPattern) : []
      return curr
    }
  }

  var addFBType = function(fb, params){
    var p = parseParams(params);

    if (params && p){
      fb.type = p.FBTYPE || "BUSY"
    }

    return fb;
  }

  var freebusyParam = function (name) {
    return function(val, params, curr){
      var fb = addFBType({}, params);
      curr[name] = curr[name] || []
      curr[name].push(fb);

      storeParam(val, params, fb);

      var parts = val.split('/');

      ['start', 'end'].forEach(function (name, index) {
        dateParam(name)(parts[index], params, fb);
      });

      return curr;
    }
  }

  return {


    objectHandlers : {
      'BEGIN' : function(component, params, curr, stack){
          stack.push(curr)

          return {type:component, params:params}
        }

      , 'END' : function(component, params, curr, stack){
        // prevents the need to search the root of the tree for the VCALENDAR object
        if (component === "VCALENDAR") {
            //scan all high level object in curr and drop all strings
            var key,
                obj;
            
            for (key in curr) {
                if(curr.hasOwnProperty(key)) {
                   obj = curr[key];
                   if (typeof obj === 'string') {
                       delete curr[key];
                   }
                }
            }
            
            return curr
        }
        
        var par = stack.pop()

        if (curr.uid)
          par[curr.uid] = curr
        else
          par[Math.random()*100000] = curr  // Randomly assign ID : TODO - use true GUID

        return par
      }

      , 'SUMMARY' : storeParam('summary')
      , 'DESCRIPTION' : storeParam('description')
      , 'URL' : storeParam('url')
      , 'UID' : storeParam('uid')
      , 'LOCATION' : storeParam('location')
      , 'DTSTART' : dateParam('start')
      , 'DTEND' : dateParam('end')
      ,' CLASS' : storeParam('class')
      , 'TRANSP' : storeParam('transparency')
      , 'GEO' : geoParam('geo')
      , 'PERCENT-COMPLETE': storeParam('completion')
      , 'COMPLETED': dateParam('completed')
      , 'CATEGORIES': categoriesParam('categories')
      , 'FREEBUSY': freebusyParam('freebusy')
    },


    handleObject : function(name, val, params, ctx, stack, line){
      var self = this

      if(self.objectHandlers[name])
        return self.objectHandlers[name](val, params, ctx, stack, line)

      //handling custom properties
      if(name.match(/X\-[\w\-]+/) && stack.length > 0) {
          //trimming the leading and perform storeParam
          name = name.substring(2);
          return (storeParam(name))(val, params, ctx, stack, line);
      }
      
      return storeParam(name.toLowerCase())(val, params, ctx);
    },


    parseICS : function(str){
      var self = this
      var lines = str.split(/\r?\n/)
      var ctx = {}
      var stack = []

      for (var i = 0, ii = lines.length, l = lines[0]; i<ii; i++, l=lines[i]){
        //Unfold : RFC#3.1
        while (lines[i+1] && /[ \t]/.test(lines[i+1][0])) {
          l += lines[i+1].slice(1)
          i += 1
        }

        var kv = l.split(":")

        if (kv.length < 2){
          // Invalid line - must have k&v
          continue;
        }

        // Although the spec says that vals with colons should be quote wrapped
        // in practise nobody does, so we assume further colons are part of the
        // val
        var value = kv.slice(1).join(":")
          , kp = kv[0].split(";")
          , name = kp[0]
          , params = kp.slice(1)

        ctx = self.handleObject(name, value, params, ctx, stack, l) || {}
      }

       // type and params are added to the list of items, get rid of them.
       delete ctx.type
       delete ctx.params

       return ctx
    }

  }
}))

},{}],288:[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],289:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');
var objectAssign = require('object-assign');

function encode(value, opts) {
	if (opts.encode) {
		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str) {
	// Create an object with no prototype
	// https://github.com/sindresorhus/query-string/issues/47
	var ret = Object.create(null);

	if (typeof str !== 'string') {
		return ret;
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return ret;
	}

	str.split('&').forEach(function (param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		key = decodeURIComponent(key);

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		if (ret[key] === undefined) {
			ret[key] = val;
		} else if (Array.isArray(ret[key])) {
			ret[key].push(val);
		} else {
			ret[key] = [ret[key], val];
		}
	});

	return ret;
};

exports.stringify = function (obj, opts) {
	var defaults = {
		encode: true,
		strict: true
	};

	opts = objectAssign(defaults, opts);

	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return key;
		}

		if (Array.isArray(val)) {
			var result = [];

			val.slice().forEach(function (val2) {
				if (val2 === undefined) {
					return;
				}

				if (val2 === null) {
					result.push(encode(key, opts));
				} else {
					result.push(encode(key, opts) + '=' + encode(val2, opts));
				}
			});

			return result.join('&');
		}

		return encode(key, opts) + '=' + encode(val, opts);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

},{"object-assign":288,"strict-uri-encode":308}],290:[function(require,module,exports){
"use strict";
var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var $$observable = require('symbol-observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     * @method subscribe
     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this);
        }
        else {
            sink.add(this._subscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` imple will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;

},{"./util/root":305,"./util/toSubscriber":306,"symbol-observable":309}],291:[function(require,module,exports){
"use strict";
exports.empty = {
    isUnsubscribed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};

},{}],292:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.isUnsubscribed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.isUnsubscribed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.isUnsubscribed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.isUnsubscribed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.isUnsubscribed = true;
        this.observers = null;
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.isUnsubscribed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"./Observable":290,"./SubjectSubscription":293,"./Subscriber":294,"./Subscription":295,"./symbol/rxSubscriber":298,"./util/ObjectUnsubscribedError":299}],293:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.isUnsubscribed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.isUnsubscribed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":295}],294:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.isUnsubscribed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
        _super.call(this);
        this._parent = _parent;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parent = this._parent;
            if (!_parent.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parent, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._error) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parent.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parent.syncErrorValue = err;
                _parent.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._complete) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._complete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parent = this._parent;
        this._context = null;
        this._parent = null;
        _parent.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

},{"./Observer":291,"./Subscription":295,"./symbol/rxSubscriber":298,"./util/isFunction":303}],295:[function(require,module,exports){
"use strict";
var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.isUnsubscribed = false;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this._subscriptions = null;
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                (errors = errors || []).push(errorObject_1.errorObject.e);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(err.errors);
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `isUnsubscribed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
            return;
        }
        var sub = teardown;
        switch (typeof teardown) {
            case 'function':
                sub = new Subscription(teardown);
            case 'object':
                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
                    break;
                }
                else if (this.isUnsubscribed) {
                    sub.unsubscribe();
                }
                else {
                    (this._subscriptions || (this._subscriptions = [])).push(sub);
                }
                break;
            default:
                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        return sub;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        // HACK: This might be redundant because of the logic in `add()`
        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.isUnsubscribed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;

},{"./util/UnsubscriptionError":300,"./util/errorObject":301,"./util/isArray":302,"./util/isFunction":303,"./util/isObject":304,"./util/tryCatch":307}],296:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var PromiseObservable = (function (_super) {
    __extends(PromiseObservable, _super);
    function PromiseObservable(promise, scheduler) {
        if (scheduler === void 0) { scheduler = null; }
        _super.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
    }
    /**
     * Converts a Promise to an Observable.
     *
     * <span class="informal">Returns an Observable that just emits the Promise's
     * resolved value, then completes.</span>
     *
     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
     * Observable. If the Promise resolves with a value, the output Observable
     * emits that resolved value as a `next`, and then completes. If the Promise
     * is rejected, then the output Observable emits the corresponding Error.
     *
     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link bindCallback}
     * @see {@link from}
     *
     * @param {Promise<T>} promise The promise to be converted.
     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling
     * the delivery of the resolved value (or the rejection).
     * @return {Observable<T>} An Observable which wraps the Promise.
     * @static true
     * @name fromPromise
     * @owner Observable
     */
    PromiseObservable.create = function (promise, scheduler) {
        if (scheduler === void 0) { scheduler = null; }
        return new PromiseObservable(promise, scheduler);
    };
    PromiseObservable.prototype._subscribe = function (subscriber) {
        var _this = this;
        var promise = this.promise;
        var scheduler = this.scheduler;
        if (scheduler == null) {
            if (this._isScalar) {
                if (!subscriber.isUnsubscribed) {
                    subscriber.next(this.value);
                    subscriber.complete();
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.isUnsubscribed) {
                        subscriber.next(value);
                        subscriber.complete();
                    }
                }, function (err) {
                    if (!subscriber.isUnsubscribed) {
                        subscriber.error(err);
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
        else {
            if (this._isScalar) {
                if (!subscriber.isUnsubscribed) {
                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
                }
            }
            else {
                promise.then(function (value) {
                    _this.value = value;
                    _this._isScalar = true;
                    if (!subscriber.isUnsubscribed) {
                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }
                }, function (err) {
                    if (!subscriber.isUnsubscribed) {
                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }
                })
                    .then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    root_1.root.setTimeout(function () { throw err; });
                });
            }
        }
    };
    return PromiseObservable;
}(Observable_1.Observable));
exports.PromiseObservable = PromiseObservable;
function dispatchNext(arg) {
    var value = arg.value, subscriber = arg.subscriber;
    if (!subscriber.isUnsubscribed) {
        subscriber.next(value);
        subscriber.complete();
    }
}
function dispatchError(arg) {
    var err = arg.err, subscriber = arg.subscriber;
    if (!subscriber.isUnsubscribed) {
        subscriber.error(err);
    }
}

},{"../Observable":290,"../util/root":305}],297:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
/**
 * @param PromiseCtor
 * @return {Promise<T>}
 * @method toPromise
 * @owner Observable
 */
function toPromise(PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
            PromiseCtor = root_1.root.Rx.config.Promise;
        }
        else if (root_1.root.Promise) {
            PromiseCtor = root_1.root.Promise;
        }
    }
    if (!PromiseCtor) {
        throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function (resolve, reject) {
        var value;
        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
    });
}
exports.toPromise = toPromise;

},{"../util/root":305}],298:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';

},{"../util/root":305}],299:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        _super.call(this, 'object unsubscribed');
        this.name = 'ObjectUnsubscribedError';
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

},{}],300:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        this.name = 'UnsubscriptionError';
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n') : '';
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;

},{}],301:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };

},{}],302:[function(require,module,exports){
"use strict";
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

},{}],303:[function(require,module,exports){
"use strict";
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],304:[function(require,module,exports){
"use strict";
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],305:[function(require,module,exports){
(function (global){
"use strict";
var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
};
exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
/* tslint:disable:no-unused-variable */
var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
var freeGlobal = objectTypes[typeof global] && global;
if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = freeGlobal;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],306:[function(require,module,exports){
"use strict";
var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber();
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Subscriber":294,"../symbol/rxSubscriber":298}],307:[function(require,module,exports){
"use strict";
var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;

},{"./errorObject":301}],308:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};

},{}],309:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

module.exports = require('./ponyfill')(global || window || this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill":310}],310:[function(require,module,exports){
'use strict';

module.exports = function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvc2NyaXB0L2FwcC5qcyIsInNyYy9zY3JpcHQvY29tcG9uZW50L2FwcC5qcyIsInNyYy9zY3JpcHQvY29tcG9uZW50L2xpc3QuanMiLCJzcmMvc2NyaXB0L2NvbXBvbmVudC9zZXJ2aWNlLmpzIiwic3JjL3NjcmlwdC9jb21wb25lbnQvc2hhcmUuanMiLCJzcmMvc2NyaXB0L3BpcGUvc2VhcmNoLmpzIiwic3JjL3NjcmlwdC9waXBlL3RpbWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvY29tbW9uX2RpcmVjdGl2ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9kaXJlY3RpdmVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZGlyZWN0aXZlcy9jb3JlX2RpcmVjdGl2ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9kaXJlY3RpdmVzL25nX2NsYXNzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZGlyZWN0aXZlcy9uZ19mb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9kaXJlY3RpdmVzL25nX2lmLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZGlyZWN0aXZlcy9uZ19wbHVyYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9kaXJlY3RpdmVzL25nX3N0eWxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZGlyZWN0aXZlcy9uZ19zd2l0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9kaXJlY3RpdmVzL25nX3RlbXBsYXRlX291dGxldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2RpcmVjdGl2ZXMvb2JzZXJ2YWJsZV9saXN0X2RpZmYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mYWNhZGUvYXN5bmMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mYWNhZGUvYmFzZV93cmFwcGVkX2V4Y2VwdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZmFjYWRlL2V4Y2VwdGlvbl9oYW5kbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mYWNhZGUvaW50bC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2ZhY2FkZS9sYW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZmFjYWRlL3Byb21pc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL2Fic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZm9ybXMvZGlyZWN0aXZlcy9jaGVja2JveF92YWx1ZV9hY2Nlc3Nvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMvY29udHJvbF9jb250YWluZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL2RlZmF1bHRfdmFsdWVfYWNjZXNzb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2wuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2xfZ3JvdXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL25nX2NvbnRyb2xfbmFtZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9zdGF0dXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL25nX2Zvcm0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL25nX2Zvcm1fY29udHJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfZm9ybV9tb2RlbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfbW9kZWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL25vcm1hbGl6ZV92YWxpZGF0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL251bWJlcl92YWx1ZV9hY2Nlc3Nvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMvcmFkaW9fY29udHJvbF92YWx1ZV9hY2Nlc3Nvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMvc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9mb3Jtcy9kaXJlY3RpdmVzL3NoYXJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL2Zvcm1fYnVpbGRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2Zvcm1zL21vZGVsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvZm9ybXMvdmFsaWRhdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2xvY2F0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvbG9jYXRpb24vaGFzaF9sb2NhdGlvbl9zdHJhdGVneS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL2xvY2F0aW9uL2xvY2F0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvbG9jYXRpb24vbG9jYXRpb25fc3RyYXRlZ3kuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9sb2NhdGlvbi9wYXRoX2xvY2F0aW9uX3N0cmF0ZWd5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvbG9jYXRpb24vcGxhdGZvcm1fbG9jYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9waXBlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL3BpcGVzL2FzeW5jX3BpcGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9waXBlcy9jb21tb25fcGlwZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9waXBlcy9kYXRlX3BpcGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9waXBlcy9pMThuX3BsdXJhbF9waXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvcGlwZXMvaTE4bl9zZWxlY3RfcGlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL3BpcGVzL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9waXBlcy9qc29uX3BpcGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL3NyYy9waXBlcy9sb3dlcmNhc2VfcGlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL3BpcGVzL251bWJlcl9waXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvcGlwZXMvcmVwbGFjZV9waXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbW1vbi9zcmMvcGlwZXMvc2xpY2VfcGlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vc3JjL3BpcGVzL3VwcGVyY2FzZV9waXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL2NvbXBpbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL2NvcmVfcHJpdmF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9wcml2YXRlX2V4cG9ydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvYXNzZXJ0aW9ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvY29tcGlsZV9tZXRhZGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvY29tcGlsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL2NvbmZpZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL2RpcmVjdGl2ZV9ub3JtYWxpemVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9kaXJlY3RpdmVfcmVzb2x2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL2V4cHJlc3Npb25fcGFyc2VyL2FzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvZXhwcmVzc2lvbl9wYXJzZXIvbGV4ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL2V4cHJlc3Npb25fcGFyc2VyL3BhcnNlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvZmFjYWRlL2xhbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL2h0bWxfYXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9odG1sX2xleGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9odG1sX3BhcnNlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvaHRtbF90YWdzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9pZGVudGlmaWVycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvbWV0YWRhdGFfcmVzb2x2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL29mZmxpbmVfY29tcGlsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL291dHB1dC9hYnN0cmFjdF9lbWl0dGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9vdXRwdXQvYWJzdHJhY3RfanNfZW1pdHRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvb3V0cHV0L2RhcnRfZW1pdHRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvb3V0cHV0L2ludGVycHJldGl2ZV92aWV3LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9vdXRwdXQvb3V0cHV0X2FzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvb3V0cHV0L291dHB1dF9pbnRlcnByZXRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvb3V0cHV0L291dHB1dF9qaXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL291dHB1dC9wYXRoX3V0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL291dHB1dC90c19lbWl0dGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9wYXJzZV91dGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9waXBlX3Jlc29sdmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9wcm92aWRlcl9wYXJzZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3J1bnRpbWVfY29tcGlsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3NjaGVtYS9kb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3NjaGVtYS9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvc2VsZWN0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3NoYWRvd19jc3MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3N0eWxlX2NvbXBpbGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy9zdHlsZV91cmxfcmVzb2x2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3RlbXBsYXRlX2FzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvdGVtcGxhdGVfcGFyc2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy90ZW1wbGF0ZV9wcmVwYXJzZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3VybF9yZXNvbHZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvdmlld19jb21waWxlci9jb21waWxlX2JpbmRpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3ZpZXdfY29tcGlsZXIvY29tcGlsZV9lbGVtZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy92aWV3X2NvbXBpbGVyL2NvbXBpbGVfbWV0aG9kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy92aWV3X2NvbXBpbGVyL2NvbXBpbGVfcGlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvdmlld19jb21waWxlci9jb21waWxlX3F1ZXJ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy92aWV3X2NvbXBpbGVyL2NvbXBpbGVfdmlldy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9zcmMvdmlld19jb21waWxlci9jb25zdGFudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3ZpZXdfY29tcGlsZXIvZXZlbnRfYmluZGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy92aWV3X2NvbXBpbGVyL2V4cHJlc3Npb25fY29udmVydGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy92aWV3X2NvbXBpbGVyL2xpZmVjeWNsZV9iaW5kZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3ZpZXdfY29tcGlsZXIvcHJvcGVydHlfYmluZGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy92aWV3X2NvbXBpbGVyL3V0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3ZpZXdfY29tcGlsZXIvdmlld19iaW5kZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3ZpZXdfY29tcGlsZXIvdmlld19idWlsZGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL3NyYy92aWV3X2NvbXBpbGVyL3ZpZXdfY29tcGlsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3ZpZXdfcmVzb2x2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvc3JjL3hoci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvcHJpdmF0ZV9leHBvcnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvYXBwbGljYXRpb25fY29tbW9uX3Byb3ZpZGVycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9hcHBsaWNhdGlvbl9yZWYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvYXBwbGljYXRpb25fdG9rZW5zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2NoYW5nZV9kZXRlY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl91dGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdG9yX3JlZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9jaGFuZ2VfZGV0ZWN0aW9uL2RpZmZlcnMvZGVmYXVsdF9pdGVyYWJsZV9kaWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvY2hhbmdlX2RldGVjdGlvbi9kaWZmZXJzL2RlZmF1bHRfa2V5dmFsdWVfZGlmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2NoYW5nZV9kZXRlY3Rpb24vZGlmZmVycy9pdGVyYWJsZV9kaWZmZXJzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2NoYW5nZV9kZXRlY3Rpb24vZGlmZmVycy9rZXl2YWx1ZV9kaWZmZXJzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2NvbnNvbGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvZGVidWcvZGVidWdfbm9kZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9kZWJ1Zy9kZWJ1Z19yZW5kZXJlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9kaS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9kaS9kZWNvcmF0b3JzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2RpL2ZvcndhcmRfcmVmLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2RpL2luamVjdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2RpL21ldGFkYXRhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2RpL29wYXF1ZV90b2tlbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9kaS9wcm92aWRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9kaS9wcm92aWRlcl91dGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2RpL3JlZmxlY3RpdmVfZXhjZXB0aW9ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9kaS9yZWZsZWN0aXZlX2luamVjdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2RpL3JlZmxlY3RpdmVfa2V5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2RpL3JlZmxlY3RpdmVfcHJvdmlkZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvZmFjYWRlL2xhbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvbGlua2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2xpbmtlci9jb21wb25lbnRfZmFjdG9yeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9saW5rZXIvY29tcG9uZW50X3Jlc29sdmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2xpbmtlci9kZWJ1Z19jb250ZXh0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2xpbmtlci9keW5hbWljX2NvbXBvbmVudF9sb2FkZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvbGlua2VyL2VsZW1lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvbGlua2VyL2VsZW1lbnRfaW5qZWN0b3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvbGlua2VyL2VsZW1lbnRfcmVmLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2xpbmtlci9leGNlcHRpb25zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2xpbmtlci9xdWVyeV9saXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL2xpbmtlci90ZW1wbGF0ZV9yZWYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvbGlua2VyL3ZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9saW5rZXIvdmlld19yZWYuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvbGlua2VyL3ZpZXdfdHlwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9saW5rZXIvdmlld191dGlscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9tZXRhZGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9tZXRhZGF0YS9kaS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9tZXRhZGF0YS9kaXJlY3RpdmVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9tZXRhZGF0YS92aWV3LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL3BsYXRmb3JtX2NvbW1vbl9wcm92aWRlcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvcGxhdGZvcm1fZGlyZWN0aXZlc19hbmRfcGlwZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvcHJvZmlsZS9wcm9maWxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL3Byb2ZpbGUvd3RmX2ltcGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvcHJvZmlsZS93dGZfaW5pdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9yZWZsZWN0aW9uL3JlZmxlY3Rpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvcmVmbGVjdGlvbi9yZWZsZWN0aW9uX2NhcGFiaWxpdGllcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9yZWZsZWN0aW9uL3JlZmxlY3Rvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy9yZWZsZWN0aW9uL3JlZmxlY3Rvcl9yZWFkZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvcmVuZGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvcmUvc3JjL3JlbmRlci9hcGkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvc2VjdXJpdHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvdGVzdGFiaWxpdHkvdGVzdGFiaWxpdHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy91dGlsL2RlY29yYXRvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvem9uZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL3NyYy96b25lL25nX3pvbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9zcmMvem9uZS9uZ196b25lX2ltcGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvaHR0cC9odHRwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvaHR0cC9zcmMvYmFja2VuZHMvYnJvd3Nlcl9qc29ucC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL3NyYy9iYWNrZW5kcy9icm93c2VyX3hoci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL3NyYy9iYWNrZW5kcy9qc29ucF9iYWNrZW5kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvc3JjL2JhY2tlbmRzL3hocl9iYWNrZW5kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvc3JjL2Jhc2VfcmVxdWVzdF9vcHRpb25zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvc3JjL2Jhc2VfcmVzcG9uc2Vfb3B0aW9ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL3NyYy9lbnVtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL3NyYy9mYWNhZGUvbGFuZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL3NyYy9oZWFkZXJzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvc3JjL2h0dHAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvaHR0cC9zcmMvaHR0cF91dGlscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL3NyYy9pbnRlcmZhY2VzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvc3JjL3N0YXRpY19yZXF1ZXN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2h0dHAvc3JjL3N0YXRpY19yZXNwb25zZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9odHRwL3NyYy91cmxfc2VhcmNoX3BhcmFtcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvY29yZV9wcml2YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvcGxhdGZvcm1fYnJvd3Nlcl9keW5hbWljLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9zcmMvZmFjYWRlL2xhbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL3NyYy94aHIveGhyX2NhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9zcmMveGhyL3hocl9pbXBsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvY29yZV9wcml2YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9wcml2YXRlX2V4cG9ydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9hbmltYXRlL2FuaW1hdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9hbmltYXRlL2FuaW1hdGlvbl9idWlsZGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2FuaW1hdGUvYnJvd3Nlcl9kZXRhaWxzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2FuaW1hdGUvY3NzX2FuaW1hdGlvbl9idWlsZGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2FuaW1hdGUvY3NzX2FuaW1hdGlvbl9vcHRpb25zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2Jyb3dzZXIvYnJvd3Nlcl9hZGFwdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2Jyb3dzZXIvZ2VuZXJpY19icm93c2VyX2FkYXB0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvYnJvd3Nlci9sb2NhdGlvbi9icm93c2VyX3BsYXRmb3JtX2xvY2F0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2Jyb3dzZXIvdGVzdGFiaWxpdHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvYnJvd3Nlci90aXRsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9icm93c2VyL3Rvb2xzL2NvbW1vbl90b29scy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9icm93c2VyL3Rvb2xzL3Rvb2xzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2Jyb3dzZXJfY29tbW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2RvbS9kZWJ1Zy9ieS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9kb20vZGVidWcvbmdfcHJvYmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZG9tL2RvbV9hZGFwdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2RvbS9kb21fcmVuZGVyZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZG9tL2RvbV90b2tlbnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZG9tL2V2ZW50cy9kb21fZXZlbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2RvbS9ldmVudHMvZXZlbnRfbWFuYWdlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9kb20vZXZlbnRzL2hhbW1lcl9jb21tb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZG9tL2V2ZW50cy9oYW1tZXJfZ2VzdHVyZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZG9tL2V2ZW50cy9rZXlfZXZlbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL2RvbS9zaGFyZWRfc3R5bGVzX2hvc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZG9tL3V0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZmFjYWRlL2Jyb3dzZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZmFjYWRlL2xhbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvZmFjYWRlL21hdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvcGxhdGZvcm1fYnJvd3Nlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9wbGF0Zm9ybV9icm93c2VyX3N0YXRpYy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL3NyYy9zZWN1cml0eS9kb21fc2FuaXRpemF0aW9uX3NlcnZpY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9zcmMvc2VjdXJpdHkvc3R5bGVfc2FuaXRpemVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvc3JjL3NlY3VyaXR5L3VybF9zYW5pdGl6ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvaWNhbC9pY2FsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL09ic2VydmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpYmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvU3Vic2NyaXB0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Qcm9taXNlT2JzZXJ2YWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3RvUHJvbWlzZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9yeFN1YnNjcmliZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9lcnJvck9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNGdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3Jvb3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3RvU3Vic2NyaWJlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdHJ5Q2F0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7YUNBQSxtQ0FDQSx5RUFDQSx1Q0FDQSxtQ0FDQSxvQ0FFQSwyQkFDQSwrQ0FBZSxzQkFFZCxtQ0FBb0IsQ0FBQyxpQ0FBRCxDQUFwQixDQUZjLENBR2QsMkNBQTBCLENBQUUscUNBQUYsQ0FBMUIsQ0FIYyxDQUFmOzs7Mm1CQ1BBLHVDQUNBLG1DQUNBLG1DQUNBLDRCQUNBLDhCQUNBLHlDLHFKQVNhLEcsU0FBQSxHLE9BUFosb0JBQVUsQ0FDVixTQUFVLE1BREEsQ0FFVixVQUFXLHNCQUZELENBR1YsV0FBWSw0REFIRixDQUlWLFlBQWEsT0FBTyxHQUFQLENBQVcsS0FBWCxDQUFtQixXQUp0QixDQUtWLE1BQVEsc0JBTEUsQ0FBVixDLHdCQWdCQSxhQUFhLElBQWIsQ0FBeUIsZ0NBUnpCLEtBUXlCLENBUmpCLEVBUWlCLE1BUHpCLFNBT3lCLENBUGIsQ0FDWCxLQUFPLEVBREksQ0FFWCxNQUFRLElBRkcsQ0FHWCxPQUFTLEVBSEUsQ0FJWCxLQUFPLEtBSkksQ0FPYSxDQUN4QixJQUFJLE1BQVEsdUJBQU0sT0FBTyxRQUFQLENBQWdCLE1BQXRCLENBQVosQ0FDQSxJQUFLLElBQUksQ0FBVCxJQUFjLEtBQWQsQ0FBcUIsQ0FDcEIsR0FBRyx3QkFBd0IsSUFBeEIsQ0FBNkIsQ0FBN0IsQ0FBSCxDQUFvQyxDQUNuQyxLQUFLLFNBQUwsQ0FBZSxNQUFmLENBQXdCLE1BQU0sQ0FBTixDQUF4QixDQUNBLENBQ0QsQ0FFRCxLQUFLLElBQUwsQ0FBWSxJQUFaLENBQ0EsS0FBSyxJQUFMLENBQVUsZUFBVixDQUEwQixHQUExQixDQUFnQyxPQUFPLEdBQVAsQ0FBVyxRQUEzQyxDQUNBLEMsMkRBRVMsZ0JBQ1QsR0FBRyxLQUFLLFNBQUwsQ0FBZSxJQUFsQixDQUF1QixDQUN0QixLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQXVCLElBQXZCLENBQ0EsS0FBSyxJQUFMLENBQ0UsSUFERixDQUNPLE9BQU8sR0FBUCxDQUFXLFFBRGxCLENBQzRCLEtBQUssU0FBTCxDQUFlLEtBQUssU0FBcEIsQ0FENUIsRUFFRSxTQUZGLENBRVksYUFBTyxDQUNqQixJQUFJLEdBQUssSUFBSSxJQUFKLEVBQVQsQ0FDQSxHQUFHLEdBQUcsS0FBTixDQUFZLENBQ1gsTUFBSyxTQUFMLENBQWUsS0FBZixDQUF1QixHQUFHLEtBQTFCLENBQ0EsQ0FGRCxLQUVPLENBQ04sTUFBSyxTQUFMLENBQWUsSUFBZixDQUFzQixFQUF0QixDQUNBLE1BQUssU0FBTCxDQUFlLElBQWYsQ0FBc0IsSUFBdEIsQ0FDQSxDQUNELENBVkYsRUFXQSxDQUVELEMscUZBckNXLEc7OzttcEJDZGIsdUNBQ0EsbUNBQ0Esa0NBQ0EsOEJBQ0Esc0NBQ0Esa0M7SUFVYSxJLFNBQUEsSSxPQVBaLG9CQUFVLENBQ1YsU0FBVSxNQURBLENBRVYsVUFBVyxnQkFGRCxDQUdWLFdBQVksc0NBSEYsQ0FJVixZQUFhLE9BQU8sR0FBUCxDQUFXLEtBQVgsQ0FBbUIsYUFKdEIsQ0FLVixNQUFRLGdEQUxFLENBQVYsQyxPQVFDLGlCLGlDQUVELGNBQVksQ0FBWixDQUFzQiwyRUFDckIsS0FBSyxJQUFMLENBQVksQ0FBWixDQUNBLEMsNERBRVMsQ0FDVCxLQUFLLElBQUwsQ0FBVSxNQUFWLEdBQ0EsQyw2SkFSUSxLLHFGQURHLEk7Ozs2bUJDZmIsbUNBQ0Esa0NBQ0EsbUMscUpBR2EsSyxTQUFBLEssT0FEWixzQix3QkFHQSxlQUFhLElBQWIsQ0FBeUIsa0NBRHpCLE1BQ3lCLENBRGhCLEVBQ2dCLENBQ3hCLEtBQUssSUFBTCxDQUFZLElBQVosQ0FDQSxLQUFLLElBQUwsQ0FBVSxlQUFWLENBQTBCLEdBQTFCLENBQWdDLE9BQU8sR0FBUCxDQUFXLEdBQTNDLENBQ0EsQyx5REFFaUIsZ0JBQ2pCLE9BQU8sS0FBSyxJQUFMLENBQVUsR0FBVixHQUFnQixTQUFoQixDQUEwQixxQkFBTyxNQUFLLE1BQUwsQ0FBYyxJQUFJLElBQUosR0FBVyxLQUFoQyxFQUExQixDQUFQLENBQ0EsQyxnREFFVyxLLENBQU8sQ0FDbEIsUUFBUSxLQUFSLENBQWMsbUJBQWQsQ0FBbUMsS0FBbkMsRUFDQSxPQUFPLFFBQVEsTUFBUixDQUFlLE1BQU0sT0FBTixFQUFpQixLQUFoQyxDQUFQLENBQ0EsQyx1RkFkVyxLOzs7d3NCQ0xiLHVDQUNBLG1DQUNBLG1DOzs7T0FhYSxLLFNBQUEsSyxPQVBaLG9CQUFVLENBQ1YsU0FBVSxPQURBLENBRVYsY0FBZSxzQkFGTCxDQUdWLFlBQWEsT0FBTyxHQUFQLENBQVcsS0FBWCxDQUFtQixZQUh0QixDQUlWLFdBQVkseUJBSkYsQ0FLVixNQUFRLHNCQUxFLENBQVYsQyxPQTRGQyxpQixPQUNBLGlCLE9BQ0EsaUIsMk9BRUQsTSxDQUFTLEUsTUFDVCxHLENBQU8sT0FBTyxHQUFQLENBQVcsSyxNQUNsQixJLENBQU8sRSxNQUNQLEssQ0FBUSxDLDhEQUVzQixNLENBQTRCLEssQ0FBMEIsSSxDQUFNLENBQ3pGLEtBQUssSUFBTCxDQUFZLE1BQVEsT0FBcEIsQ0FDQSxLQUFLLE1BQUwsQ0FBYyxNQUFNLEtBQUssRUFBWCxDQUFkLENBQ0EsS0FBSyxPQUFMLENBQWUsS0FBSyxPQUFMLENBQWEsS0FBYixDQUFvQixNQUFwQixDQUFmLENBQ0EsQyxtQ0FFSyxDQUNMLElBQUksS0FBTyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLEtBQUssR0FBdkIsQ0FBNEIsVUFBVSxLQUFLLElBQWYsQ0FBNUIsQ0FBa0QsS0FBSyxHQUF2RCxDQUFYLENBQ0EsSUFBSSxLQUFPLE9BQU8sSUFBUCxDQUFZLElBQVosQ0FBa0IsS0FBSyxJQUF2QixDQUE2QixLQUFLLE9BQWxDLENBQVgsQ0FDQSxHQUFJLE9BQU8sS0FBWCxDQUFrQixLQUFLLEtBQUwsR0FDbEIsQyx5Q0FFa0QsS0FBMUMsS0FBMEMsK0NBQTFCLEdBQTBCLGtCQUFyQixNQUFxQiwrQ0FBSixHQUFJLGNBQ2xELElBQUksUUFBVSxrQ0FBZCxDQUNBLFNBQVcsV0FBYSxNQUF4QixDQUNBLFNBQVcsVUFBWSxLQUF2QixDQUNBLFNBQVcsU0FBWSxPQUFPLE1BQVAsQ0FBZ0IsQ0FBakIsQ0FBeUIsT0FBUyxDQUE3QyxDQUFYLENBQ0EsU0FBVyxVQUFhLE9BQU8sS0FBUCxDQUFlLENBQWhCLENBQXVCLE1BQVEsQ0FBM0MsQ0FBWCxDQUNBLE9BQU8sT0FBUCxDQUNBLEMsNkJBL0dNLFEsQ0FBVyxDQUNqQixLQUFPLFVBRFUsQ0FFakIsS0FGaUIsZ0JBRVYsTUFGVSxDQUVGLENBQ2QsT0FBTyx3Q0FBMEMsTUFBakQsQ0FDQSxDQUpnQixDQUtqQixLQUxpQixnQkFLVixNQUxVLENBS0YsQ0FDZCxPQUFPLHlEQUEwRCxNQUFqRSxDQUNBLENBUGdCLENBUWpCLEdBUmlCLGNBUVosSUFSWSxDQVFOLENBQ1YsT0FBTyxLQUFLLE1BQVosQ0FDQSxDQVZnQixDLFNBWVgsTyxDQUFVLENBQ2hCLEtBQU8sU0FEUyxDQUVoQixLQUZnQixnQkFFVCxNQUZTLENBRUQsSUFGQyxDQUVLLEdBRkwsQ0FFVSxDQUN6QixPQUFPLGlDQUFtQyxJQUFuQyxDQUEwQyxPQUExQyxDQUFvRCxNQUFwRCxDQUE2RCxPQUE3RCxDQUF1RSxHQUE5RSxDQUNBLENBSmUsQ0FLaEIsS0FMZ0IsZ0JBS1QsTUFMUyxDQUtELENBQ2QsT0FBTyw0RUFBNkUsTUFBcEYsQ0FDQSxDQVBlLENBUWhCLEdBUmdCLGNBUVgsSUFSVyxDQVFMLENBQ1YsT0FBTyxLQUFLLEtBQVosQ0FDQSxDQVZlLEMsU0FZVixNLENBQVMsQ0FDZixLQUFPLGFBRFEsQ0FFZixLQUZlLGdCQUVULE1BRlMsQ0FFRCxDQUNiLE9BQU8scUNBQXNDLE1BQTdDLENBQ0EsQ0FKYyxDLFNBTVQsTSxDQUFTLENBQ2YsS0FBTyxRQURRLENBRWYsS0FGZSxnQkFFVCxNQUZTLENBRUQsQ0FDYixPQUFPLGtGQUFvRixNQUEzRixDQUNBLENBSmMsQyxTQU1ULE0sQ0FBUyxDQUNmLEtBQU8sY0FEUSxDQUVmLEtBRmUsZ0JBRVIsTUFGUSxDQUVBLENBQ2QsT0FBTyxxQ0FBdUMsTUFBOUMsQ0FDQSxDQUpjLEMsU0FNVCxRLENBQVcsQ0FDakIsS0FBTyxVQURVLENBRWpCLEtBRmlCLGdCQUVWLE1BRlUsQ0FFRixDQUNkLE9BQU8sdURBQXlELE1BQWhFLENBQ0EsQ0FKZ0IsQ0FLakIsS0FMaUIsZ0JBS1YsTUFMVSxDQUtGLENBQ2QsT0FBTywwRkFBMkYsTUFBbEcsQ0FDQSxDQVBnQixDQVFqQixHQVJpQixjQVFaLElBUlksQ0FRTixDQUNWLE9BQU8sS0FBSyxLQUFaLENBQ0EsQ0FWZ0IsQyxTQVlYLFMsQ0FBWSxDQUNsQixLQUFPLGFBRFcsQ0FFbEIsS0FGa0IsZ0JBRVgsTUFGVyxDQUVILElBRkcsQ0FFRyxHQUZILENBRVEsQ0FDekIsT0FBTywrQ0FBaUQsTUFBakQsQ0FBMEQsZUFBMUQsQ0FBNEUsSUFBNUUsQ0FBbUYsU0FBbkYsQ0FBK0YsR0FBdEcsQ0FDQSxDQUppQixDQUtsQixLQUxrQixnQkFLWCxNQUxXLENBS0gsQ0FDZCxPQUFPLDJFQUE0RSxNQUFuRixDQUNBLENBUGlCLENBUWxCLEdBUmtCLGNBUWIsSUFSYSxDQVFQLENBQ1YsT0FBTyxLQUFLLEtBQVosQ0FDQSxDQVZpQixDLFNBWVosSSxDQUFPLENBQ2IsS0FBTyxNQURNLENBRWIsS0FGYSxnQkFFUCxNQUZPLENBRUMsQ0FDYixPQUFPLG9FQUFzRSxNQUE3RSxDQUNBLENBSlksQyxTQU1QLEssQ0FBUSxDQUNkLEtBQU8sWUFETyxDQUVkLEtBRmMsZ0JBRVAsTUFGTyxDQUVDLElBRkQsQ0FFTyxDQUNwQixPQUFPLG1CQUFxQixJQUFyQixDQUE0QixRQUE1QixDQUF1QyxNQUE5QyxDQUNBLENBSmEsQyxTQU9SLE0sQ0FBUyxDQUFFLEdBQUYsQ0FBTyxHQUFQLENBQVksR0FBWixDLFNBQ1QsSyxDQUFRLEksU0FDUixHLENBQU0sRyw4SUFFSixFLDRJQUNBLEcsNklBQ0EsSTs7O3EwQkN0R1YsbUM7Ozs7OztPQWVhLE0sU0FBQSxNLE9BTFosZUFBSyxDQUNMLEtBQU0sUUFERCxDQUVMLEtBQU0sS0FGRCxDQUFMLEMsT0FJQSxzQixvSkFNVSxLLENBQU8sSSxDQUFNLENBRXRCLElBQUksU0FBVyxTQUFYLFFBQVcsTUFBUSxDQUN0QixJQUFJLE1BQVEsS0FBWixDQUVBLEdBQUcsUUFBTyxJQUFQLG1DQUFPLElBQVAsS0FBZ0IsUUFBbkIsQ0FBNkIsQ0FDNUIsSUFBSyxJQUFJLENBQVQsSUFBYyxJQUFkLENBQW9CLENBQ25CLEdBQUcsTUFBUSxTQUFTLEtBQUssQ0FBTCxDQUFULENBQVgsQ0FBOEIsQ0FDN0IsTUFDQSxDQUNELENBQ0QsQ0FORCxLQU1PLENBQ04sR0FBRyxPQUFPLElBQVAsR0FBZ0IsUUFBbkIsQ0FBNEIsQ0FDM0IsTUFBUSxPQUFTLElBQWpCLENBQ0EsQ0FGRCxLQUVPLENBQ04sTUFBUSxLQUFLLFFBQUwsR0FBZ0IsS0FBaEIsQ0FBdUIsSUFBSSxNQUFKLENBQVcsSUFBWCxDQUFpQixHQUFqQixDQUF2QixDQUFSLENBQ0EsQ0FDRCxDQUVELE9BQU8sS0FBUCxDQUNBLENBbEJELENBb0JBLE9BQU8sTUFBTSxNQUFOLENBQWEsUUFBYixFQUF1QixJQUF2QixDQUE0QixPQUFPLElBQW5DLENBQVAsQ0FDQSxDLG9DQTNCWSxDLENBQUcsQyxDQUFFLENBQ2pCLE9BQU8sS0FBSyxJQUFMLENBQVUsT0FBTyxFQUFFLEtBQVQsRUFBZ0IsSUFBaEIsQ0FBcUIsT0FBTyxFQUFFLEtBQVQsQ0FBckIsQ0FBVixDQUFQLENBQ0EsQzs7O2tuQkNsQkYsbUM7Ozs7OztPQWVhLEksU0FBQSxJLE9BTFosZUFBSyxDQUNMLEtBQU0sTUFERCxDQUVMLEtBQU0sS0FGRCxDQUFMLEMsT0FJQSxzQiw4SUFFVSxJLENBQU0sSSxDQUFNLENBQ3JCLE9BQU8sT0FBTyxJQUFQLEVBQWEsTUFBYixDQUFvQixJQUFwQixDQUFQLENBQ0EsQzs7O0FDbEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNucUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2w5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCB7cHJvdmlkZSwgZW5hYmxlUHJvZE1vZGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtib290c3RyYXB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG5pbXBvcnQge0xvY2F0aW9uU3RyYXRlZ3ksIEhhc2hMb2NhdGlvblN0cmF0ZWd5fSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtIVFRQX1BST1ZJREVSUywgSHR0cCwgQmFzZVJlcXVlc3RPcHRpb25zLCBYSFJCYWNrZW5kfSBmcm9tICdAYW5ndWxhci9odHRwJztcbmltcG9ydCB7YXBwfSBmcm9tICcuL2NvbXBvbmVudC9hcHAnO1xuXG5lbmFibGVQcm9kTW9kZSgpO1xuYm9vdHN0cmFwKGFwcCwgW1xuXHRIVFRQX1BST1ZJREVSUyxcblx0cHJvdmlkZShYSFJCYWNrZW5kLCB7dXNlQ2xhc3M6IEJhc2VSZXF1ZXN0T3B0aW9uc30pLFxuXHRwcm92aWRlKExvY2F0aW9uU3RyYXRlZ3ksIHsgdXNlQ2xhc3M6IEhhc2hMb2NhdGlvblN0cmF0ZWd5IH0pXG5dKTtcbiIsImltcG9ydCB7Q09SRV9ESVJFQ1RJVkVTLCBGT1JNX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU30gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SFRUUF9QUk9WSURFUlMsIEh0dHB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuaW1wb3J0IHtsaXN0fSBmcm9tICcuL2xpc3QnO1xuaW1wb3J0IHtzaGFyZX0gZnJvbSAnLi9zaGFyZSc7XG5pbXBvcnQge3BhcnNlfSBmcm9tICdxdWVyeS1zdHJpbmcnO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdib2R5Jyxcblx0cHJvdmlkZXJzOiBbSFRUUF9QUk9WSURFUlNdLFxuXHRkaXJlY3RpdmVzOiBbIENPUkVfRElSRUNUSVZFUywgRk9STV9ESVJFQ1RJVkVTLCBsaXN0XSxcblx0dGVtcGxhdGVVcmw6IHdpbmRvdy5lbnYuU0hBUkUgKyAnaG9tZS5odG1sJyxcblx0cGlwZXMgOiBbIENPTU1PTl9QSVBFUyBdXG59KVxuZXhwb3J0IGNsYXNzIGFwcCB7XG5cdHF1ZXJ5ID0ge307XG5cdHN1c2NyaWJlciA9IHtcblx0XHRtYWlsIDogJycsXG5cdFx0ZXJyb3IgOiBudWxsLFxuXHRcdHNlYXJjaCA6ICcnLFxuXHRcdHNlbmQgOiBmYWxzZVxuXHR9XG5cblx0Y29uc3RydWN0b3IoIGh0dHA6IEh0dHApIHtcblx0XHRsZXQgcXVlcnkgPSBwYXJzZSh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcblx0XHRmb3IgKGxldCBpIGluIHF1ZXJ5KSB7XG5cdFx0XHRpZigvYmFuZHxjaXR5fHR5cGV8cGxhY2UvaS50ZXN0KGkpICl7XG5cdFx0XHRcdHRoaXMuc3VzY3JpYmVyLnNlYXJjaCA9IHF1ZXJ5W2ldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuaHR0cCA9IGh0dHA7XG5cdFx0dGhpcy5odHRwLl9kZWZhdWx0T3B0aW9ucy51cmwgPSB3aW5kb3cuZW52LlNVU0NSSUJFO1xuXHR9XG5cblx0c3VzY3JpYmUoKXtcblx0XHRpZih0aGlzLnN1c2NyaWJlci5tYWlsKXtcblx0XHRcdHRoaXMuc3VzY3JpYmVyLmVycm9yID0gbnVsbFxuXHRcdFx0dGhpcy5odHRwXG5cdFx0XHRcdC5wb3N0KHdpbmRvdy5lbnYuU1VTQ1JJQkUsIEpTT04uc3RyaW5naWZ5KHRoaXMuc3VzY3JpYmVyKSApXG5cdFx0XHRcdC5zdWJzY3JpYmUocmVzID0+IHtcblx0XHRcdFx0XHRsZXQgcnQgPSByZXMuanNvbigpO1xuXHRcdFx0XHRcdGlmKHJ0LmVycm9yKXtcblx0XHRcdFx0XHRcdHRoaXMuc3VzY3JpYmVyLmVycm9yID0gcnQuZXJyb3I7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuc3VzY3JpYmVyLm1haWwgPSAnJztcblx0XHRcdFx0XHRcdHRoaXMuc3VzY3JpYmVyLnNlbmQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XHRcblx0XHR9XG5cdFx0XG5cdH1cbn1cbiIsImltcG9ydCB7Q09SRV9ESVJFQ1RJVkVTLCBGT1JNX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU30gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7bGl2ZXN9IGZyb20gJy4vc2VydmljZSc7XG5pbXBvcnQge3NoYXJlfSBmcm9tICcuL3NoYXJlJztcbmltcG9ydCB7c2VhcmNofSBmcm9tICcuLi9waXBlL3NlYXJjaCc7XG5pbXBvcnQge3RpbWV9IGZyb20gJy4uL3BpcGUvdGltZSc7XG5cbi8vIDIwMjY1IDM1MzczXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdsaXN0Jyxcblx0cHJvdmlkZXJzOiBbIGxpdmVzIF0sXG5cdGRpcmVjdGl2ZXM6IFtzaGFyZSwgQ09SRV9ESVJFQ1RJVkVTXSxcblx0dGVtcGxhdGVVcmw6IHdpbmRvdy5lbnYuU0hBUkUgKyAnLi9saXN0Lmh0bWwnLFxuXHRwaXBlcyA6IFsgc2VhcmNoLCB0aW1lLCBDT01NT05fUElQRVMgXVxufSlcbmV4cG9ydCBjbGFzcyBsaXN0IHtcblx0QElucHV0KCkgcXVlcnk7XG5cblx0Y29uc3RydWN0b3IobDogbGl2ZXMpIHtcblx0XHR0aGlzLmxpdmUgPSBsO1xuXHR9XG5cblx0bmdPbkluaXQoKXtcblx0XHR0aGlzLmxpdmUuZ2V0QWxsKCk7XG5cdH1cbn0iLCJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpY2FsfSBmcm9tICdpY2FsL2ljYWwuanMnXG5pbXBvcnQge0h0dHB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgbGl2ZXMge1xuXHRldmVudHMgPSBbXTtcblx0Y29uc3RydWN0b3IoIGh0dHA6IEh0dHApIHtcblx0XHR0aGlzLmh0dHAgPSBodHRwO1xuXHRcdHRoaXMuaHR0cC5fZGVmYXVsdE9wdGlvbnMudXJsID0gd2luZG93LmVudi5DQUw7XG5cdH1cblxuXHRnZXRBbGwoKTogUHJvbWlzZSB7XG5cdFx0cmV0dXJuIHRoaXMuaHR0cC5nZXQoKS5zdWJzY3JpYmUocmVzID0+IHRoaXMuZXZlbnRzID0gcmVzLmpzb24oKS5ldmVudCk7XG5cdH1cblxuXHRoYW5kbGVFcnJvcihlcnJvcikge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkJywgZXJyb3IpO1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvci5tZXNzYWdlIHx8IGVycm9yKTtcblx0fVxufSIsImltcG9ydCB7Q09SRV9ESVJFQ1RJVkVTLCBDT01NT05fUElQRVN9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0NvbXBvbmVudCwgIElucHV0LCBBdHRyaWJ1dGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtIVFRQX1BST1ZJREVSUywgSHR0cH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG5cbi8qKlxuICogIFwiVW5leHBlY3RlZCBkaXJlY3RpdmUgdmFsdWUgJ3VuZGVmaW5lZCcgb24gdGhlIFZpZXcgb2YgY29tcG9uZW50ICdhcHAnXCJcbiAqIDxzaGFyZSBpcz0ndHdpdHRlcicgdGV4dD0nU2hhcmUgdGhpcyB0ZXh0JyB2aWE9J0BhbGVqb25leHQnIHx8IG9wdGlvbmFsIC0+IHdpZHRoPTMwMCBoZWlnaHQ9NjAwIG5hbWU9J2hlbGxvJyAvPlxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdzaGFyZScsXG5cdHZpZXdQcm92aWRlcnM6IFtIVFRQX1BST1ZJREVSU10sXG5cdHRlbXBsYXRlVXJsOiB3aW5kb3cuZW52LlNIQVJFICsgJ3NoYXJlLmh0bWwnLFxuXHRkaXJlY3RpdmVzOiBbIENPUkVfRElSRUNUSVZFUyBdLFxuXHRwaXBlcyA6IFsgQ09NTU9OX1BJUEVTIF1cbn0pXG5leHBvcnQgY2xhc3Mgc2hhcmUge1xuXG5cdHN0YXRpYyBmYWNlYm9vayA9IHtcblx0XHRpY29uIDogJ2ZhY2Vib29rJyxcblx0XHRzaGFyZSAoYWJzVXJsKSB7XG5cdFx0XHRyZXR1cm4gJ2h0dHA6Ly93d3cuZmFjZWJvb2suY29tL3NoYXJlci5waHA/dT0nICsgYWJzVXJsO1xuXHRcdH0sXG5cdFx0Y291bnQgKGFic1VybCkge1xuXHRcdFx0cmV0dXJuICdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8/Y2FsbGJhY2s9SlNPTl9DQUxMQkFDSyZpZD0nKyBhYnNVcmw7XG5cdFx0fSxcblx0XHRnZXQgKGRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhLnNoYXJlcztcblx0XHR9XG5cdH07XG5cdHN0YXRpYyB0d2l0dGVyID0ge1xuXHRcdGljb24gOiAndHdpdHRlcicsXG5cdFx0c2hhcmUgKGFic1VybCwgdGV4dCwgdmlhKSB7XG5cdFx0XHRyZXR1cm4gJ2h0dHA6Ly90d2l0dGVyLmNvbS9zaGFyZT90ZXh0PScgKyB0ZXh0ICsgJyZ1cmw9JyArIGFic1VybCArICcmdmlhPScgKyB2aWE7XG5cdFx0fSxcblx0XHRjb3VudCAoYWJzVXJsKSB7XG5cdFx0XHRyZXR1cm4gJ2h0dHBzOi8vY2RuLmFwaS50d2l0dGVyLmNvbS8xL3VybHMvY291bnQuanNvbj9jYWxsYmFjaz1KU09OX0NBTExCQUNLJnVybD0nKyBhYnNVcmw7XG5cdFx0fSxcblx0XHRnZXQgKGRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhLmNvdW50O1xuXHRcdH1cblx0fTtcblx0c3RhdGljIGdvb2dsZSA9IHtcblx0XHRpY29uIDogJ2dvb2dsZS1wbHVzJyxcblx0XHRzaGFyZShhYnNVcmwpIHtcblx0XHRcdHJldHVybiAnaHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20vc2hhcmU/dXJsPScrIGFic1VybDtcblx0XHR9XG5cdH07XG5cdHN0YXRpYyB0dW1ibHIgPSB7XG5cdFx0aWNvbiA6ICd0dW1ibHInLFxuXHRcdHNoYXJlKGFic1VybCkge1xuXHRcdFx0cmV0dXJuICdodHRwczovL3d3dy50dW1ibHIuY29tL3dpZGdldHMvc2hhcmUvdG9vbD9zaGFyZVNvdXJjZT1sZWdhY3kmY2Fub25pY2FsVXJsPSZ1cmw9JyArIGFic1VybDtcblx0XHR9XG5cdH07XG5cdHN0YXRpYyByZWRkaXQgPSB7XG5cdFx0aWNvbiA6ICdyZWRkaXQtYWxpZW4nLFxuXHRcdHNoYXJlIChhYnNVcmwpIHtcblx0XHRcdHJldHVybiAnaHR0cHM6Ly93d3cucmVkZGl0LmNvbS9zdWJtaXQ/dXJsPScgKyBhYnNVcmw7XG5cdFx0fVxuXHR9O1xuXHRzdGF0aWMgbGlua2VkaW4gPSB7XG5cdFx0aWNvbiA6ICdsaW5rZWRpbicsXG5cdFx0c2hhcmUgKGFic1VybCkge1xuXHRcdFx0cmV0dXJuICdodHRwczovL3d3dy5saW5rZWRpbi5jb20vc2hhcmVBcnRpY2xlP21pbmk9dHJ1ZSZ1cmw9JyArIGFic1VybDtcblx0XHR9LFxuXHRcdGNvdW50IChhYnNVcmwpIHtcblx0XHRcdHJldHVybiAnaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2NvdW50c2Vydi9jb3VudC9zaGFyZT9jYWxsYmFjaz1KU09OX0NBTExCQUNLJmZvcm1hdD1qc29ucCZ1cmw9JysgYWJzVXJsO1xuXHRcdH0sXG5cdFx0Z2V0IChkYXRhKSB7XG5cdFx0XHRyZXR1cm4gZGF0YS5jb3VudDtcblx0XHR9XG5cdH07XG5cdHN0YXRpYyBwaW50ZXJlc3QgPSB7XG5cdFx0aWNvbiA6ICdwaW50ZXJlc3QtcCcsXG5cdFx0c2hhcmUgKGFic1VybCwgdGV4dCwgdmlhKSB7XG5cdFx0XHRyZXR1cm4gJ2h0dHA6Ly9waW50ZXJlc3QuY29tL3Bpbi9jcmVhdGUvYnV0dG9uLz91cmw9JyArIGFic1VybCArICcmZGVzY3JpcHRpb249JyArIHRleHQgKyAnJm1lZGlhPScgKyB2aWEgO1xuXHRcdH0sXG5cdFx0Y291bnQgKGFic1VybCkge1xuXHRcdFx0cmV0dXJuICdodHRwczovL2FwaS5waW50ZXJlc3QuY29tL3YxL3VybHMvY291bnQuanNvbj9jYWxsYmFjaz1KU09OX0NBTExCQUNLJnVybD0nKyBhYnNVcmw7XG5cdFx0fSxcblx0XHRnZXQgKGRhdGEpIHtcblx0XHRcdHJldHVybiBkYXRhLmNvdW50O1xuXHRcdH1cblx0fTtcblx0c3RhdGljIHhpbmcgPSB7XG5cdFx0aWNvbiA6ICd4aW5nJyxcblx0XHRzaGFyZShhYnNVcmwpIHtcblx0XHRcdHJldHVybiAnaHR0cHM6Ly93d3cueGluZy1zaGFyZS5jb20vYXBwL3VzZXI/b3A9c2hhcmU7c2NfcD14aW5nLXNoYXJlO3VybD0nICsgYWJzVXJsO1xuXHRcdH1cblx0fTtcblx0c3RhdGljIGVtYWlsID0ge1xuXHRcdGljb24gOiAnZW52ZWxvcGUtbycsXG5cdFx0c2hhcmUgKGFic1VybCwgdGV4dCkge1xuXHRcdFx0cmV0dXJuICdtYWlsdG86P3N1YmplY3Q9JyArIHRleHQgKyAnJmJvZHk9JyArIGFic1VybDtcblx0XHR9XG5cdH07XG5cblx0c3RhdGljIENIQU5HRSA9IFsgJ2snLCAnTScsICdCJyBdO1xuXHRzdGF0aWMgTVVMVEkgPSAxMDAwO1xuXHRzdGF0aWMgREVDID0gMTAwO1xuXHRcblx0QElucHV0KCkgaXM7XG5cdEBJbnB1dCgpIHZpYTtcblx0QElucHV0KCkgdGV4dDtcblxuXHRzeXN0ZW0gPSB7fTtcblx0dXJsID0gIHdpbmRvdy5lbnYuU0hBUkU7XG5cdG1vcmUgPSAnJztcblx0Y291bnQgPSAwO1xuXG5cdG5nT25Jbml0KEBBdHRyaWJ1dGUoJ2hlaWdodCcpIGhlaWdodCwgQEF0dHJpYnV0ZSgnd2lkdGgnKSB3aWR0aCwgQEF0dHJpYnV0ZSgnbmFtZScpIG5hbWUgKXtcblx0XHR0aGlzLm5hbWUgPSBuYW1lIHx8ICdTaGFyZSc7XG5cdFx0dGhpcy5zeXN0ZW0gPSBzaGFyZVt0aGlzLmlzXTtcblx0XHR0aGlzLnNldHRpbmcgPSB0aGlzLndpbmRvd3Mod2lkdGgsIGhlaWdodCk7XG5cdH1cblxuXHRwb3N0KCl7XG5cdFx0dmFyIGhyZWYgPSB0aGlzLnN5c3RlbS5zaGFyZSh0aGlzLnVybCwgZW5jb2RlVVJJKHRoaXMudGV4dCksIHRoaXMudmlhKTtcblx0XHR2YXIgbmV3dyA9IHdpbmRvdy5vcGVuKGhyZWYsIHRoaXMubmFtZSwgdGhpcy5zZXR0aW5nKTtcblx0XHRpZiAod2luZG93LmZvY3VzKSBuZXd3LmZvY3VzKCk7XG5cdH1cblxuXHR3aW5kb3dzICh3aWR0aDogTnVtYmVyID0gNjAwLCBoZWlnaHQ6IE51bWJlciA9IDMwMCl7XG5cdFx0bGV0IHNldHRpbmcgPSAnbG9jYXRpb249MSxzdGF0dXM9MSxzY3JvbGxiYXJzPTEnO1xuXHRcdHNldHRpbmcgKz0gJyxoZWlnaHQ9JyArIGhlaWdodDtcblx0XHRzZXR0aW5nICs9ICcsd2lkdGg9JyArIHdpZHRoO1xuXHRcdHNldHRpbmcgKz0gJyx0b3A9JyArICgoc2NyZWVuLmhlaWdodCAvIDIpIC0gICggaGVpZ2h0IC8gMiApKTtcblx0XHRzZXR0aW5nICs9ICcsbGVmdD0nICsgKChzY3JlZW4ud2lkdGggLyAyKSAtICggd2lkdGggLyAyICkpO1xuXHRcdHJldHVybiBzZXR0aW5nXG5cdH1cblxufVxuIiwiaW1wb3J0IHtQaXBlLCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKlxuICogIDxpbnB1dCBbKG1vZGVsKV09XCJxdWVyeVwiIHR5cGU9XCJ0ZXh0XCIgLz5cbiAqICA8dWw+XG4gKiBcdFx0PGxpICpuZ0Zvcj1cImxldCBoZXJvIG9mIGhlcm9lcyB8IHNlYXJjaDpxdWVyeVwiID57e2hlcm8ubmFtZX19PC9saT5cbiAqICA8L3VsPlxuICovXG5cbkBQaXBlKHtcblx0bmFtZTogJ3NlYXJjaCcsXG5cdHB1cmU6IGZhbHNlXG59KVxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIHNlYXJjaCB7XG5cdHN0YXRpYyB0aW1lIChhLCBiKXtcblx0XHRyZXR1cm4gTWF0aC5zaWduKG1vbWVudChhLnN0YXJ0KS5kaWZmKG1vbWVudChiLnN0YXJ0KSkpO1xuXHR9XG5cblx0dHJhbnNmb3JtKGl0ZW1zLCBhcmdzKSB7XG5cdFx0XG5cdFx0dmFyIGlzU2VhcmNoID0gZGF0YSA9PiB7XG5cdFx0XHR2YXIgaXNBbGwgPSBmYWxzZTtcblxuXHRcdFx0aWYodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICl7XG5cdFx0XHRcdGZvciAodmFyIHogaW4gZGF0YSkge1xuXHRcdFx0XHRcdGlmKGlzQWxsID0gaXNTZWFyY2goZGF0YVt6XSkgKXtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodHlwZW9mIGFyZ3MgPT09ICdudW1iZXInKXtcblx0XHRcdFx0XHRpc0FsbCA9IGRhdGEgPT09IGFyZ3M7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aXNBbGwgPSBkYXRhLnRvU3RyaW5nKCkubWF0Y2goIG5ldyBSZWdFeHAoYXJncywgJ2knKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IFxuXG5cdFx0XHRyZXR1cm4gaXNBbGw7XG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gaXRlbXMuZmlsdGVyKGlzU2VhcmNoKS5zb3J0KHNlYXJjaC50aW1lKTtcblx0fVxufVxuIiwiaW1wb3J0IHtQaXBlLCBQaXBlVHJhbnNmb3JtLCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKlxuICogIDxpbnB1dCBbKG1vZGVsKV09XCJxdWVyeVwiIHR5cGU9XCJ0ZXh0XCIgLz5cbiAqICA8dWw+XG4gKiBcdFx0PGxpICpuZ0Zvcj1cImxldCBoZXJvIG9mIGhlcm9lcyB8IHNlYXJjaDpxdWVyeVwiID57e2hlcm8ubmFtZX19PC9saT5cbiAqICA8L3VsPlxuICovXG5cbkBQaXBlKHtcblx0bmFtZTogJ3RpbWUnLFxuXHRwdXJlOiBmYWxzZVxufSlcbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyB0aW1lIHtcblx0dHJhbnNmb3JtKGRhdGUsIGFyZ3MpIHtcblx0XHRyZXR1cm5cdG1vbWVudChkYXRlKS5mb3JtYXQoYXJncyk7XG5cdH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL3BpcGVzJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvZGlyZWN0aXZlcycpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2Zvcm1zJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvY29tbW9uX2RpcmVjdGl2ZXMnKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9sb2NhdGlvbicpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGZvcm1zXzEgPSByZXF1aXJlKCcuL2Zvcm1zJyk7XG52YXIgZGlyZWN0aXZlc18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzJyk7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBBbmd1bGFyIGNvcmUgZGlyZWN0aXZlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBpbiBlYWNoIGFuZCBldmVyeSBBbmd1bGFyXG4gKiBhcHBsaWNhdGlvbi4gVGhpcyBpbmNsdWRlcyBjb3JlIGRpcmVjdGl2ZXMgKGUuZy4sIE5nSWYgYW5kIE5nRm9yKSwgYW5kIGZvcm1zIGRpcmVjdGl2ZXMgKGUuZy4sXG4gKiBOZ01vZGVsKS5cbiAqXG4gKiBUaGlzIGNvbGxlY3Rpb24gY2FuIGJlIHVzZWQgdG8gcXVpY2tseSBlbnVtZXJhdGUgYWxsIHRoZSBidWlsdC1pbiBkaXJlY3RpdmVzIGluIHRoZSBgZGlyZWN0aXZlc2BcbiAqIHByb3BlcnR5IG9mIHRoZSBgQENvbXBvbmVudGAgZGVjb3JhdG9yLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogSW5zdGVhZCBvZiB3cml0aW5nOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7TmdDbGFzcywgTmdJZiwgTmdGb3IsIE5nU3dpdGNoLCBOZ1N3aXRjaFdoZW4sIE5nU3dpdGNoRGVmYXVsdCwgTmdNb2RlbCwgTmdGb3JtfSBmcm9tXG4gKiAnQGFuZ3VsYXIvY29tbW9uJztcbiAqIGltcG9ydCB7T3RoZXJEaXJlY3RpdmV9IGZyb20gJy4vbXlEaXJlY3RpdmVzJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1jb21wb25lbnQnLFxuICogICB0ZW1wbGF0ZVVybDogJ215Q29tcG9uZW50Lmh0bWwnLFxuICogICBkaXJlY3RpdmVzOiBbTmdDbGFzcywgTmdJZiwgTmdGb3IsIE5nU3dpdGNoLCBOZ1N3aXRjaFdoZW4sIE5nU3dpdGNoRGVmYXVsdCwgTmdNb2RlbCwgTmdGb3JtLFxuICogT3RoZXJEaXJlY3RpdmVdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgLi4uXG4gKiB9XG4gKiBgYGBcbiAqIG9uZSBjb3VsZCBpbXBvcnQgYWxsIHRoZSBjb21tb24gZGlyZWN0aXZlcyBhdCBvbmNlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7Q09NTU9OX0RJUkVDVElWRVN9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gKiBpbXBvcnQge090aGVyRGlyZWN0aXZlfSBmcm9tICcuL215RGlyZWN0aXZlcyc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGVVcmw6ICdteUNvbXBvbmVudC5odG1sJyxcbiAqICAgZGlyZWN0aXZlczogW0NPTU1PTl9ESVJFQ1RJVkVTLCBPdGhlckRpcmVjdGl2ZV1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICogICAuLi5cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnRzLkNPTU1PTl9ESVJFQ1RJVkVTID0gW2RpcmVjdGl2ZXNfMS5DT1JFX0RJUkVDVElWRVMsIGZvcm1zXzEuRk9STV9ESVJFQ1RJVkVTXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbl9kaXJlY3RpdmVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbi8qKlxuKiBAbW9kdWxlXG4qIEBkZXNjcmlwdGlvblxuKiBDb21tb24gZGlyZWN0aXZlcyBzaGlwcGVkIHdpdGggQW5ndWxhci5cbiovXG52YXIgbmdfY2xhc3NfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jbGFzcycpO1xuZXhwb3J0cy5OZ0NsYXNzID0gbmdfY2xhc3NfMS5OZ0NsYXNzO1xudmFyIG5nX2Zvcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2ZvcicpO1xuZXhwb3J0cy5OZ0ZvciA9IG5nX2Zvcl8xLk5nRm9yO1xudmFyIG5nX2lmXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfaWYnKTtcbmV4cG9ydHMuTmdJZiA9IG5nX2lmXzEuTmdJZjtcbnZhciBuZ190ZW1wbGF0ZV9vdXRsZXRfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ190ZW1wbGF0ZV9vdXRsZXQnKTtcbmV4cG9ydHMuTmdUZW1wbGF0ZU91dGxldCA9IG5nX3RlbXBsYXRlX291dGxldF8xLk5nVGVtcGxhdGVPdXRsZXQ7XG52YXIgbmdfc3R5bGVfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19zdHlsZScpO1xuZXhwb3J0cy5OZ1N0eWxlID0gbmdfc3R5bGVfMS5OZ1N0eWxlO1xudmFyIG5nX3N3aXRjaF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX3N3aXRjaCcpO1xuZXhwb3J0cy5OZ1N3aXRjaCA9IG5nX3N3aXRjaF8xLk5nU3dpdGNoO1xuZXhwb3J0cy5OZ1N3aXRjaFdoZW4gPSBuZ19zd2l0Y2hfMS5OZ1N3aXRjaFdoZW47XG5leHBvcnRzLk5nU3dpdGNoRGVmYXVsdCA9IG5nX3N3aXRjaF8xLk5nU3dpdGNoRGVmYXVsdDtcbnZhciBuZ19wbHVyYWxfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19wbHVyYWwnKTtcbmV4cG9ydHMuTmdQbHVyYWwgPSBuZ19wbHVyYWxfMS5OZ1BsdXJhbDtcbmV4cG9ydHMuTmdQbHVyYWxDYXNlID0gbmdfcGx1cmFsXzEuTmdQbHVyYWxDYXNlO1xuZXhwb3J0cy5OZ0xvY2FsaXphdGlvbiA9IG5nX3BsdXJhbF8xLk5nTG9jYWxpemF0aW9uO1xuX19leHBvcnQocmVxdWlyZSgnLi9kaXJlY3RpdmVzL29ic2VydmFibGVfbGlzdF9kaWZmJykpO1xudmFyIGNvcmVfZGlyZWN0aXZlc18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2NvcmVfZGlyZWN0aXZlcycpO1xuZXhwb3J0cy5DT1JFX0RJUkVDVElWRVMgPSBjb3JlX2RpcmVjdGl2ZXNfMS5DT1JFX0RJUkVDVElWRVM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG5nX2NsYXNzXzEgPSByZXF1aXJlKCcuL25nX2NsYXNzJyk7XG52YXIgbmdfZm9yXzEgPSByZXF1aXJlKCcuL25nX2ZvcicpO1xudmFyIG5nX2lmXzEgPSByZXF1aXJlKCcuL25nX2lmJyk7XG52YXIgbmdfdGVtcGxhdGVfb3V0bGV0XzEgPSByZXF1aXJlKCcuL25nX3RlbXBsYXRlX291dGxldCcpO1xudmFyIG5nX3N0eWxlXzEgPSByZXF1aXJlKCcuL25nX3N0eWxlJyk7XG52YXIgbmdfc3dpdGNoXzEgPSByZXF1aXJlKCcuL25nX3N3aXRjaCcpO1xudmFyIG5nX3BsdXJhbF8xID0gcmVxdWlyZSgnLi9uZ19wbHVyYWwnKTtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIEFuZ3VsYXIgY29yZSBkaXJlY3RpdmVzIHRoYXQgYXJlIGxpa2VseSB0byBiZSB1c2VkIGluIGVhY2ggYW5kIGV2ZXJ5IEFuZ3VsYXJcbiAqIGFwcGxpY2F0aW9uLlxuICpcbiAqIFRoaXMgY29sbGVjdGlvbiBjYW4gYmUgdXNlZCB0byBxdWlja2x5IGVudW1lcmF0ZSBhbGwgdGhlIGJ1aWx0LWluIGRpcmVjdGl2ZXMgaW4gdGhlIGBkaXJlY3RpdmVzYFxuICogcHJvcGVydHkgb2YgdGhlIGBAQ29tcG9uZW50YCBhbm5vdGF0aW9uLlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC95YWtHd3BDZFVrZzBxZnpYNW04Zz9wPXByZXZpZXcpKVxuICpcbiAqIEluc3RlYWQgb2Ygd3JpdGluZzpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge05nQ2xhc3MsIE5nSWYsIE5nRm9yLCBOZ1N3aXRjaCwgTmdTd2l0Y2hXaGVuLCBOZ1N3aXRjaERlZmF1bHR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gKiBpbXBvcnQge090aGVyRGlyZWN0aXZlfSBmcm9tICcuL215RGlyZWN0aXZlcyc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGVVcmw6ICdteUNvbXBvbmVudC5odG1sJyxcbiAqICAgZGlyZWN0aXZlczogW05nQ2xhc3MsIE5nSWYsIE5nRm9yLCBOZ1N3aXRjaCwgTmdTd2l0Y2hXaGVuLCBOZ1N3aXRjaERlZmF1bHQsIE90aGVyRGlyZWN0aXZlXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCB7XG4gKiAgIC4uLlxuICogfVxuICogYGBgXG4gKiBvbmUgY291bGQgaW1wb3J0IGFsbCB0aGUgY29yZSBkaXJlY3RpdmVzIGF0IG9uY2U6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtDT1JFX0RJUkVDVElWRVN9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gKiBpbXBvcnQge090aGVyRGlyZWN0aXZlfSBmcm9tICcuL215RGlyZWN0aXZlcyc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcbiAqICAgdGVtcGxhdGVVcmw6ICdteUNvbXBvbmVudC5odG1sJyxcbiAqICAgZGlyZWN0aXZlczogW0NPUkVfRElSRUNUSVZFUywgT3RoZXJEaXJlY3RpdmVdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgLi4uXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5DT1JFX0RJUkVDVElWRVMgPSBbXG4gICAgbmdfY2xhc3NfMS5OZ0NsYXNzLFxuICAgIG5nX2Zvcl8xLk5nRm9yLFxuICAgIG5nX2lmXzEuTmdJZixcbiAgICBuZ190ZW1wbGF0ZV9vdXRsZXRfMS5OZ1RlbXBsYXRlT3V0bGV0LFxuICAgIG5nX3N0eWxlXzEuTmdTdHlsZSxcbiAgICBuZ19zd2l0Y2hfMS5OZ1N3aXRjaCxcbiAgICBuZ19zd2l0Y2hfMS5OZ1N3aXRjaFdoZW4sXG4gICAgbmdfc3dpdGNoXzEuTmdTd2l0Y2hEZWZhdWx0LFxuICAgIG5nX3BsdXJhbF8xLk5nUGx1cmFsLFxuICAgIG5nX3BsdXJhbF8xLk5nUGx1cmFsQ2FzZVxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmVfZGlyZWN0aXZlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgTmdDbGFzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdDbGFzcyhfaXRlcmFibGVEaWZmZXJzLCBfa2V5VmFsdWVEaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVycyA9IF9pdGVyYWJsZURpZmZlcnM7XG4gICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVycyA9IF9rZXlWYWx1ZURpZmZlcnM7XG4gICAgICAgIHRoaXMuX25nRWwgPSBfbmdFbDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gW107XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NsYXNzLnByb3RvdHlwZSwgXCJpbml0aWFsQ2xhc3Nlc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IGxhbmdfMS5pc1ByZXNlbnQodikgJiYgbGFuZ18xLmlzU3RyaW5nKHYpID8gdi5zcGxpdCgnICcpIDogW107XG4gICAgICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2xhc3Nlcyh0aGlzLl9yYXdDbGFzcywgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDbGFzcy5wcm90b3R5cGUsIFwicmF3Q2xhc3NcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xhc3Nlcyh0aGlzLl9yYXdDbGFzcyk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzU3RyaW5nKHYpKSB7XG4gICAgICAgICAgICAgICAgdiA9IHYuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Jhd0NsYXNzID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXIgPSB0aGlzLl9pdGVyYWJsZURpZmZlcnMuZmluZCh2KS5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlciA9IHRoaXMuX2tleVZhbHVlRGlmZmVycy5maW5kKHYpLmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5nQ2xhc3MucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5faXRlcmFibGVEaWZmZXIpKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVyLmRpZmYodGhpcy5fcmF3Q2xhc3MpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2hhbmdlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUl0ZXJhYmxlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9rZXlWYWx1ZURpZmZlcikpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fa2V5VmFsdWVEaWZmZXIuZGlmZih0aGlzLl9yYXdDbGFzcyk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY2xlYW51cENsYXNzZXModGhpcy5fcmF3Q2xhc3MpOyB9O1xuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9jbGVhbnVwQ2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCkge1xuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXMocmF3Q2xhc3NWYWwsIHRydWUpO1xuICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKGZhbHNlKTtcbiAgICB9O1xuICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUtleVZhbHVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlJdGVyYWJsZUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIHRydWUpOyB9KTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIGZhbHNlKTsgfSk7XG4gICAgfTtcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlJbml0aWFsQ2xhc3NlcyA9IGZ1bmN0aW9uIChpc0NsZWFudXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCAhaXNDbGVhbnVwKTsgfSk7XG4gICAgfTtcbiAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlDbGFzc2VzID0gZnVuY3Rpb24gKHJhd0NsYXNzVmFsLCBpc0NsZWFudXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmF3Q2xhc3NWYWwpKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQXJyYXkocmF3Q2xhc3NWYWwpKSB7XG4gICAgICAgICAgICAgICAgcmF3Q2xhc3NWYWwuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCAhaXNDbGVhbnVwKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYXdDbGFzc1ZhbCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJhd0NsYXNzVmFsLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKGNsYXNzTmFtZSwgIWlzQ2xlYW51cCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChyYXdDbGFzc1ZhbCwgZnVuY3Rpb24gKGV4cFZhbCwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGV4cFZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lLCAhaXNDbGVhbnVwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTmdDbGFzcy5wcm90b3R5cGUuX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZW5hYmxlZCkge1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUudHJpbSgpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fbmdFbC5uYXRpdmVFbGVtZW50LCBjbGFzc2VzW2ldLCBlbmFibGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fbmdFbC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOZ0NsYXNzLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdDbGFzc10nLCBpbnB1dHM6IFsncmF3Q2xhc3M6IG5nQ2xhc3MnLCAnaW5pdGlhbENsYXNzZXM6IGNsYXNzJ10gfSxdIH0sXG4gICAgXTtcbiAgICBOZ0NsYXNzLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JdGVyYWJsZURpZmZlcnMsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLktleVZhbHVlRGlmZmVycywgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUmVuZGVyZXIsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gTmdDbGFzcztcbn0oKSk7XG5leHBvcnRzLk5nQ2xhc3MgPSBOZ0NsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfY2xhc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIE5nRm9yUm93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ0ZvclJvdygkaW1wbGljaXQsIGluZGV4LCBjb3VudCkge1xuICAgICAgICB0aGlzLiRpbXBsaWNpdCA9ICRpbXBsaWNpdDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPT09IDA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwibGFzdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCA9PT0gdGhpcy5jb3VudCAtIDE7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwiZXZlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwib2RkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5ldmVuOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTmdGb3JSb3c7XG59KCkpO1xuZXhwb3J0cy5OZ0ZvclJvdyA9IE5nRm9yUm93O1xudmFyIE5nRm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ0Zvcihfdmlld0NvbnRhaW5lciwgX3RlbXBsYXRlUmVmLCBfaXRlcmFibGVEaWZmZXJzLCBfY2RyKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVSZWYgPSBfdGVtcGxhdGVSZWY7XG4gICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVycyA9IF9pdGVyYWJsZURpZmZlcnM7XG4gICAgICAgIHRoaXMuX2NkciA9IF9jZHI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvci5wcm90b3R5cGUsIFwibmdGb3JPZlwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uZ0Zvck9mID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGhpcy5fZGlmZmVyKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5fY2RyLCB0aGlzLl9uZ0ZvclRyYWNrQnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCAnXCIgKyB2YWx1ZSArIFwiJyBvZiB0eXBlICdcIiArIGxhbmdfMS5nZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh2YWx1ZSkgKyBcIicuIE5nRm9yIG9ubHkgc3VwcG9ydHMgYmluZGluZyB0byBJdGVyYWJsZXMgc3VjaCBhcyBBcnJheXMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yLnByb3RvdHlwZSwgXCJuZ0ZvclRlbXBsYXRlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUmVmID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvci5wcm90b3R5cGUsIFwibmdGb3JUcmFja0J5XCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fbmdGb3JUcmFja0J5ID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5nRm9yLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RpZmZlcikpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5fbmdGb3JPZik7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjaGFuZ2VzKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nRm9yLnByb3RvdHlwZS5fYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVE9ETyhyYWRvKTogY2hlY2sgaWYgY2hhbmdlIGRldGVjdGlvbiBjYW4gcHJvZHVjZSBhIGNoYW5nZSByZWNvcmQgdGhhdCBpc1xuICAgICAgICAvLyBlYXNpZXIgdG8gY29uc3VtZSB0aGFuIGN1cnJlbnQuXG4gICAgICAgIHZhciByZWNvcmRWaWV3VHVwbGVzID0gW107XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZW1vdmVkUmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkVmlld1R1cGxlcy5wdXNoKG5ldyBSZWNvcmRWaWV3VHVwbGUocmVtb3ZlZFJlY29yZCwgbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoTW92ZWRJdGVtKGZ1bmN0aW9uIChtb3ZlZFJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZFZpZXdUdXBsZXMucHVzaChuZXcgUmVjb3JkVmlld1R1cGxlKG1vdmVkUmVjb3JkLCBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW5zZXJ0VHVwbGVzID0gdGhpcy5fYnVsa1JlbW92ZShyZWNvcmRWaWV3VHVwbGVzKTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChhZGRlZFJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydFR1cGxlcy5wdXNoKG5ldyBSZWNvcmRWaWV3VHVwbGUoYWRkZWRSZWNvcmQsIG51bGwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2J1bGtJbnNlcnQoaW5zZXJ0VHVwbGVzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRUdXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3BlclZpZXdDaGFuZ2UoaW5zZXJ0VHVwbGVzW2ldLnZpZXcsIGluc2VydFR1cGxlc1tpXS5yZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5fdmlld0NvbnRhaW5lci5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lci5nZXQoaSk7XG4gICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuaW5kZXggPSBpO1xuICAgICAgICAgICAgdmlld1JlZi5jb250ZXh0LmNvdW50ID0gaWxlbjtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hJZGVudGl0eUNoYW5nZShmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdmlld1JlZiA9IF90aGlzLl92aWV3Q29udGFpbmVyLmdldChyZWNvcmQuY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC4kaW1wbGljaXQgPSByZWNvcmQuaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOZ0Zvci5wcm90b3R5cGUuX3BlclZpZXdDaGFuZ2UgPSBmdW5jdGlvbiAodmlldywgcmVjb3JkKSB7XG4gICAgICAgIHZpZXcuY29udGV4dC4kaW1wbGljaXQgPSByZWNvcmQuaXRlbTtcbiAgICB9O1xuICAgIE5nRm9yLnByb3RvdHlwZS5fYnVsa1JlbW92ZSA9IGZ1bmN0aW9uICh0dXBsZXMpIHtcbiAgICAgICAgdHVwbGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnJlY29yZC5wcmV2aW91c0luZGV4IC0gYi5yZWNvcmQucHJldmlvdXNJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtb3ZlZFR1cGxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gdHVwbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgdHVwbGUgPSB0dXBsZXNbaV07XG4gICAgICAgICAgICAvLyBzZXBhcmF0ZSBtb3ZlZCB2aWV3cyBmcm9tIHJlbW92ZWQgdmlld3MuXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0dXBsZS5yZWNvcmQuY3VycmVudEluZGV4KSkge1xuICAgICAgICAgICAgICAgIHR1cGxlLnZpZXcgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmRldGFjaCh0dXBsZS5yZWNvcmQucHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgbW92ZWRUdXBsZXMucHVzaCh0dXBsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLnJlbW92ZSh0dXBsZS5yZWNvcmQucHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVkVHVwbGVzO1xuICAgIH07XG4gICAgTmdGb3IucHJvdG90eXBlLl9idWxrSW5zZXJ0ID0gZnVuY3Rpb24gKHR1cGxlcykge1xuICAgICAgICB0dXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5yZWNvcmQuY3VycmVudEluZGV4IC0gYi5yZWNvcmQuY3VycmVudEluZGV4OyB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0dXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0dXBsZSA9IHR1cGxlc1tpXTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR1cGxlLnZpZXcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5pbnNlcnQodHVwbGUudmlldywgdHVwbGUucmVjb3JkLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0dXBsZS52aWV3ID0gdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYsIG5ldyBOZ0ZvclJvdyhudWxsLCBudWxsLCBudWxsKSwgdHVwbGUucmVjb3JkLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR1cGxlcztcbiAgICB9O1xuICAgIE5nRm9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdGb3JdW25nRm9yT2ZdJywgaW5wdXRzOiBbJ25nRm9yVHJhY2tCeScsICduZ0Zvck9mJywgJ25nRm9yVGVtcGxhdGUnXSB9LF0gfSxcbiAgICBdO1xuICAgIE5nRm9yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSXRlcmFibGVEaWZmZXJzLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5DaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICBdO1xuICAgIHJldHVybiBOZ0Zvcjtcbn0oKSk7XG5leHBvcnRzLk5nRm9yID0gTmdGb3I7XG52YXIgUmVjb3JkVmlld1R1cGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWNvcmRWaWV3VHVwbGUocmVjb3JkLCB2aWV3KSB7XG4gICAgICAgIHRoaXMucmVjb3JkID0gcmVjb3JkO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIH1cbiAgICByZXR1cm4gUmVjb3JkVmlld1R1cGxlO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2Zvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgTmdJZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdJZihfdmlld0NvbnRhaW5lciwgX3RlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVSZWYgPSBfdGVtcGxhdGVSZWY7XG4gICAgICAgIHRoaXMuX3ByZXZDb25kaXRpb24gPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdJZi5wcm90b3R5cGUsIFwibmdJZlwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0NvbmRpdGlvbiAvKiBib29sZWFuICovKSB7XG4gICAgICAgICAgICBpZiAobmV3Q29uZGl0aW9uICYmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9wcmV2Q29uZGl0aW9uKSB8fCAhdGhpcy5fcHJldkNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2Q29uZGl0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghbmV3Q29uZGl0aW9uICYmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9wcmV2Q29uZGl0aW9uKSB8fCB0aGlzLl9wcmV2Q29uZGl0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZDb25kaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5nSWYuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ0lmXScsIGlucHV0czogWyduZ0lmJ10gfSxdIH0sXG4gICAgXTtcbiAgICBOZ0lmLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5UZW1wbGF0ZVJlZiwgfSxcbiAgICBdO1xuICAgIHJldHVybiBOZ0lmO1xufSgpKTtcbmV4cG9ydHMuTmdJZiA9IE5nSWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19pZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbmdfc3dpdGNoXzEgPSByZXF1aXJlKCcuL25nX3N3aXRjaCcpO1xudmFyIF9DQVRFR09SWV9ERUZBVUxUID0gJ290aGVyJztcbnZhciBOZ0xvY2FsaXphdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdMb2NhbGl6YXRpb24oKSB7XG4gICAgfVxuICAgIHJldHVybiBOZ0xvY2FsaXphdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5nTG9jYWxpemF0aW9uID0gTmdMb2NhbGl6YXRpb247XG52YXIgTmdQbHVyYWxDYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ1BsdXJhbENhc2UodmFsdWUsIHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBuZ19zd2l0Y2hfMS5Td2l0Y2hWaWV3KHZpZXdDb250YWluZXIsIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgTmdQbHVyYWxDYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdQbHVyYWxDYXNlXScgfSxdIH0sXG4gICAgXTtcbiAgICBOZ1BsdXJhbENhc2UuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuQXR0cmlidXRlLCBhcmdzOiBbJ25nUGx1cmFsQ2FzZScsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuVGVtcGxhdGVSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gTmdQbHVyYWxDYXNlO1xufSgpKTtcbmV4cG9ydHMuTmdQbHVyYWxDYXNlID0gTmdQbHVyYWxDYXNlO1xudmFyIE5nUGx1cmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ1BsdXJhbChfbG9jYWxpemF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsaXphdGlvbiA9IF9sb2NhbGl6YXRpb247XG4gICAgICAgIHRoaXMuX2Nhc2VWaWV3cyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdQbHVyYWwucHJvdG90eXBlLCBcIm5nUGx1cmFsXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5nUGx1cmFsLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2FzZXMuZm9yRWFjaChmdW5jdGlvbiAocGx1cmFsQ2FzZSkge1xuICAgICAgICAgICAgX3RoaXMuX2Nhc2VWaWV3cy5zZXQoX3RoaXMuX2Zvcm1hdFZhbHVlKHBsdXJhbENhc2UpLCBwbHVyYWxDYXNlLl92aWV3KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX3VwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVmlld3MoKTtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jYXNlVmlld3MuZ2V0KHRoaXMuX3N3aXRjaFZhbHVlKTtcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNQcmVzZW50KHZpZXcpKVxuICAgICAgICAgICAgdmlldyA9IHRoaXMuX2dldENhdGVnb3J5Vmlldyh0aGlzLl9zd2l0Y2hWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlVmlldyh2aWV3KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX2NsZWFyVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2FjdGl2ZVZpZXcpKVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlldy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgTmdQbHVyYWwucHJvdG90eXBlLl9hY3RpdmF0ZVZpZXcgPSBmdW5jdGlvbiAodmlldykge1xuICAgICAgICBpZiAoIWxhbmdfMS5pc1ByZXNlbnQodmlldykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLl9hY3RpdmVWaWV3LmNyZWF0ZSgpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE5nUGx1cmFsLnByb3RvdHlwZS5fZ2V0Q2F0ZWdvcnlWaWV3ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYXRlZ29yeSA9IHRoaXMuX2xvY2FsaXphdGlvbi5nZXRQbHVyYWxDYXRlZ29yeSh2YWx1ZSk7XG4gICAgICAgIHZhciBjYXRlZ29yeVZpZXcgPSB0aGlzLl9jYXNlVmlld3MuZ2V0KGNhdGVnb3J5KTtcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQoY2F0ZWdvcnlWaWV3KSA/IGNhdGVnb3J5VmlldyA6IHRoaXMuX2Nhc2VWaWV3cy5nZXQoX0NBVEVHT1JZX0RFRkFVTFQpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE5nUGx1cmFsLnByb3RvdHlwZS5faXNWYWx1ZVZpZXcgPSBmdW5jdGlvbiAocGx1cmFsQ2FzZSkgeyByZXR1cm4gcGx1cmFsQ2FzZS52YWx1ZVswXSA9PT0gXCI9XCI7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE5nUGx1cmFsLnByb3RvdHlwZS5fZm9ybWF0VmFsdWUgPSBmdW5jdGlvbiAocGx1cmFsQ2FzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWx1ZVZpZXcocGx1cmFsQ2FzZSkgPyB0aGlzLl9zdHJpcFZhbHVlKHBsdXJhbENhc2UudmFsdWUpIDogcGx1cmFsQ2FzZS52YWx1ZTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX3N0cmlwVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxKSwgMTApOyB9O1xuICAgIE5nUGx1cmFsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdQbHVyYWxdJyB9LF0gfSxcbiAgICBdO1xuICAgIE5nUGx1cmFsLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IE5nTG9jYWxpemF0aW9uLCB9LFxuICAgIF07XG4gICAgTmdQbHVyYWwucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdjYXNlcyc6IFt7IHR5cGU6IGNvcmVfMS5Db250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOZ1BsdXJhbENhc2UsXSB9LF0sXG4gICAgICAgICduZ1BsdXJhbCc6IFt7IHR5cGU6IGNvcmVfMS5JbnB1dCB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gTmdQbHVyYWw7XG59KCkpO1xuZXhwb3J0cy5OZ1BsdXJhbCA9IE5nUGx1cmFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfcGx1cmFsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBOZ1N0eWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ1N0eWxlKF9kaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2RpZmZlcnMgPSBfZGlmZmVycztcbiAgICAgICAgdGhpcy5fbmdFbCA9IF9uZ0VsO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU3R5bGUucHJvdG90eXBlLCBcInJhd1N0eWxlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fcmF3U3R5bGUgPSB2O1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHRoaXMuX2RpZmZlcikgJiYgbGFuZ18xLmlzUHJlc2VudCh2KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh0aGlzLl9yYXdTdHlsZSkuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOZ1N0eWxlLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RpZmZlcikpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5fcmF3U3R5bGUpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2hhbmdlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nU3R5bGUucHJvdG90eXBlLl9hcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hDaGFuZ2VkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgX3RoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIG51bGwpOyB9KTtcbiAgICB9O1xuICAgIE5nU3R5bGUucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX25nRWwubmF0aXZlRWxlbWVudCwgbmFtZSwgdmFsKTtcbiAgICB9O1xuICAgIE5nU3R5bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N0eWxlXScsIGlucHV0czogWydyYXdTdHlsZTogbmdTdHlsZSddIH0sXSB9LFxuICAgIF07XG4gICAgTmdTdHlsZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuS2V5VmFsdWVEaWZmZXJzLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5SZW5kZXJlciwgfSxcbiAgICBdO1xuICAgIHJldHVybiBOZ1N0eWxlO1xufSgpKTtcbmV4cG9ydHMuTmdTdHlsZSA9IE5nU3R5bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19zdHlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgX1dIRU5fREVGQVVMVCA9IG5ldyBPYmplY3QoKTtcbnZhciBTd2l0Y2hWaWV3ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hWaWV3KF92aWV3Q29udGFpbmVyUmVmLCBfdGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZVJlZiA9IF90ZW1wbGF0ZVJlZjtcbiAgICB9XG4gICAgU3dpdGNoVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZik7IH07XG4gICAgU3dpdGNoVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jbGVhcigpOyB9O1xuICAgIHJldHVybiBTd2l0Y2hWaWV3O1xufSgpKTtcbmV4cG9ydHMuU3dpdGNoVmlldyA9IFN3aXRjaFZpZXc7XG52YXIgTmdTd2l0Y2ggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nU3dpdGNoKCkge1xuICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbHVlVmlld3MgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cyA9IFtdO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2gucHJvdG90eXBlLCBcIm5nU3dpdGNoXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IHRoZSBjdXJyZW50bHkgYWN0aXZlIFZpZXdDb250YWluZXJzXG4gICAgICAgICAgICB0aGlzLl9lbXB0eUFsbEFjdGl2ZVZpZXdzKCk7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIFZpZXdDb250YWluZXJzIG1hdGNoaW5nIHRoZSB2YWx1ZSAod2l0aCBhIGZhbGxiYWNrIHRvIGRlZmF1bHQpXG4gICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmlld3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlld3MgPSBsYW5nXzEubm9ybWFsaXplQmxhbmsodGhpcy5fdmFsdWVWaWV3cy5nZXQoX1dIRU5fREVGQVVMVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVWaWV3cyh2aWV3cyk7XG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2hWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9vbldoZW5WYWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkV2hlbiwgbmV3V2hlbiwgdmlldykge1xuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyVmlldyhvbGRXaGVuLCB2aWV3KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJWaWV3KG5ld1doZW4sIHZpZXcpO1xuICAgICAgICBpZiAob2xkV2hlbiA9PT0gdGhpcy5fc3dpdGNoVmFsdWUpIHtcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9hY3RpdmVWaWV3cywgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3V2hlbiA9PT0gdGhpcy5fc3dpdGNoVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtcHR5QWxsQWN0aXZlVmlld3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcuY3JlYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN3aXRjaCB0byBkZWZhdWx0IHdoZW4gdGhlcmUgaXMgbm8gbW9yZSBhY3RpdmUgVmlld0NvbnRhaW5lcnNcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVZpZXdzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy5fdXNlRGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZVZpZXdzKHRoaXMuX3ZhbHVlVmlld3MuZ2V0KF9XSEVOX0RFRkFVTFQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fZW1wdHlBbGxBY3RpdmVWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUNvbnRhaW5lcnMgPSB0aGlzLl9hY3RpdmVWaWV3cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVDb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhY3RpdmVDb250YWluZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cyA9IFtdO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fYWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh2aWV3cykge1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBhc3NlcnQodGhpcy5fYWN0aXZlVmlld3MubGVuZ3RoID09PSAwKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmlld3MpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmlld3NbaV0uY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cyA9IHZpZXdzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgTmdTd2l0Y2gucHJvdG90eXBlLl9yZWdpc3RlclZpZXcgPSBmdW5jdGlvbiAodmFsdWUsIHZpZXcpIHtcbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5fdmFsdWVWaWV3cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmlld3MpKSB7XG4gICAgICAgICAgICB2aWV3cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVWaWV3cy5zZXQodmFsdWUsIHZpZXdzKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3cy5wdXNoKHZpZXcpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fZGVyZWdpc3RlclZpZXcgPSBmdW5jdGlvbiAodmFsdWUsIHZpZXcpIHtcbiAgICAgICAgLy8gYF9XSEVOX0RFRkFVTFRgIGlzIHVzZWQgYSBtYXJrZXIgZm9yIG5vbi1yZWdpc3RlcmVkIHdoZW5zXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gX1dIRU5fREVGQVVMVClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5fdmFsdWVWaWV3cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodmlld3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlVmlld3MuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUodmlld3MsIHZpZXcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOZ1N3aXRjaC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nU3dpdGNoXScsIGlucHV0czogWyduZ1N3aXRjaCddIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIE5nU3dpdGNoO1xufSgpKTtcbmV4cG9ydHMuTmdTd2l0Y2ggPSBOZ1N3aXRjaDtcbnZhciBOZ1N3aXRjaFdoZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nU3dpdGNoV2hlbih2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgbmdTd2l0Y2gpIHtcbiAgICAgICAgLy8gYF9XSEVOX0RFRkFVTFRgIGlzIHVzZWQgYXMgYSBtYXJrZXIgZm9yIGEgbm90IHlldCBpbml0aWFsaXplZCB2YWx1ZVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX1dIRU5fREVGQVVMVDtcbiAgICAgICAgdGhpcy5fc3dpdGNoID0gbmdTd2l0Y2g7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1N3aXRjaFdoZW4ucHJvdG90eXBlLCBcIm5nU3dpdGNoV2hlblwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2guX29uV2hlblZhbHVlQ2hhbmdlZCh0aGlzLl92YWx1ZSwgdmFsdWUsIHRoaXMuX3ZpZXcpO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTmdTd2l0Y2hXaGVuLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hXaGVuXScsIGlucHV0czogWyduZ1N3aXRjaFdoZW4nXSB9LF0gfSxcbiAgICBdO1xuICAgIE5nU3dpdGNoV2hlbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuVGVtcGxhdGVSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogTmdTd2l0Y2gsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5Ib3N0IH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIE5nU3dpdGNoV2hlbjtcbn0oKSk7XG5leHBvcnRzLk5nU3dpdGNoV2hlbiA9IE5nU3dpdGNoV2hlbjtcbnZhciBOZ1N3aXRjaERlZmF1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nU3dpdGNoRGVmYXVsdCh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgc3N3aXRjaCkge1xuICAgICAgICBzc3dpdGNoLl9yZWdpc3RlclZpZXcoX1dIRU5fREVGQVVMVCwgbmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYpKTtcbiAgICB9XG4gICAgTmdTd2l0Y2hEZWZhdWx0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hEZWZhdWx0XScgfSxdIH0sXG4gICAgXTtcbiAgICBOZ1N3aXRjaERlZmF1bHQuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICB7IHR5cGU6IE5nU3dpdGNoLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuSG9zdCB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBOZ1N3aXRjaERlZmF1bHQ7XG59KCkpO1xuZXhwb3J0cy5OZ1N3aXRjaERlZmF1bHQgPSBOZ1N3aXRjaERlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19zd2l0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIE5nVGVtcGxhdGVPdXRsZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nVGVtcGxhdGVPdXRsZXQoX3ZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdUZW1wbGF0ZU91dGxldC5wcm90b3R5cGUsIFwibmdUZW1wbGF0ZU91dGxldFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9pbnNlcnRlZFZpZXdSZWYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5yZW1vdmUodGhpcy5fdmlld0NvbnRhaW5lclJlZi5pbmRleE9mKHRoaXMuX2luc2VydGVkVmlld1JlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGVtcGxhdGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0ZWRWaWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOZ1RlbXBsYXRlT3V0bGV0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdUZW1wbGF0ZU91dGxldF0nIH0sXSB9LFxuICAgIF07XG4gICAgTmdUZW1wbGF0ZU91dGxldC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICBdO1xuICAgIE5nVGVtcGxhdGVPdXRsZXQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICduZ1RlbXBsYXRlT3V0bGV0JzogW3sgdHlwZTogY29yZV8xLklucHV0IH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBOZ1RlbXBsYXRlT3V0bGV0O1xufSgpKTtcbmV4cG9ydHMuTmdUZW1wbGF0ZU91dGxldCA9IE5nVGVtcGxhdGVPdXRsZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ190ZW1wbGF0ZV9vdXRsZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlX2xpc3RfZGlmZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4vbGFuZycpO1xudmFyIHByb21pc2VfMSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xuZXhwb3J0cy5Qcm9taXNlV3JhcHBlciA9IHByb21pc2VfMS5Qcm9taXNlV3JhcHBlcjtcbmV4cG9ydHMuUHJvbWlzZUNvbXBsZXRlciA9IHByb21pc2VfMS5Qcm9taXNlQ29tcGxldGVyO1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJ3J4anMvU3ViamVjdCcpO1xudmFyIFByb21pc2VPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL29ic2VydmFibGUvUHJvbWlzZU9ic2VydmFibGUnKTtcbnZhciB0b1Byb21pc2VfMSA9IHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG5leHBvcnRzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZTtcbnZhciBTdWJqZWN0XzIgPSByZXF1aXJlKCdyeGpzL1N1YmplY3QnKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3RfMi5TdWJqZWN0O1xudmFyIFRpbWVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZXJXcmFwcGVyKCkge1xuICAgIH1cbiAgICBUaW1lcldyYXBwZXIuc2V0VGltZW91dCA9IGZ1bmN0aW9uIChmbiwgbWlsbGlzKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuZ2xvYmFsLnNldFRpbWVvdXQoZm4sIG1pbGxpcyk7XG4gICAgfTtcbiAgICBUaW1lcldyYXBwZXIuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKGlkKSB7IGxhbmdfMS5nbG9iYWwuY2xlYXJUaW1lb3V0KGlkKTsgfTtcbiAgICBUaW1lcldyYXBwZXIuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoZm4sIG1pbGxpcykge1xuICAgICAgICByZXR1cm4gbGFuZ18xLmdsb2JhbC5zZXRJbnRlcnZhbChmbiwgbWlsbGlzKTtcbiAgICB9O1xuICAgIFRpbWVyV3JhcHBlci5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKGlkKSB7IGxhbmdfMS5nbG9iYWwuY2xlYXJJbnRlcnZhbChpZCk7IH07XG4gICAgcmV0dXJuIFRpbWVyV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlRpbWVyV3JhcHBlciA9IFRpbWVyV3JhcHBlcjtcbnZhciBPYnNlcnZhYmxlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZVdyYXBwZXIoKSB7XG4gICAgfVxuICAgIC8vIFRPRE8odnNhdmtpbik6IHdoZW4gd2UgdXNlIHJ4bmV4dCwgdHJ5IGluZmVycmluZyB0aGUgZ2VuZXJpYyB0eXBlIGZyb20gdGhlIGZpcnN0IGFyZ1xuICAgIE9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChlbWl0dGVyLCBvbk5leHQsIG9uRXJyb3IsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgaWYgKG9uQ29tcGxldGUgPT09IHZvaWQgMCkgeyBvbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyB9OyB9XG4gICAgICAgIG9uRXJyb3IgPSAodHlwZW9mIG9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiYgb25FcnJvciB8fCBsYW5nXzEubm9vcDtcbiAgICAgICAgb25Db21wbGV0ZSA9ICh0eXBlb2Ygb25Db21wbGV0ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiBvbkNvbXBsZXRlIHx8IGxhbmdfMS5ub29wO1xuICAgICAgICByZXR1cm4gZW1pdHRlci5zdWJzY3JpYmUoeyBuZXh0OiBvbk5leHQsIGVycm9yOiBvbkVycm9yLCBjb21wbGV0ZTogb25Db21wbGV0ZSB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVXcmFwcGVyLmlzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuICEhb2JzLnN1YnNjcmliZTsgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYG9ic2AgaGFzIGFueSBzdWJzY3JpYmVycyBsaXN0ZW5pbmcgdG8gZXZlbnRzLlxuICAgICAqL1xuICAgIE9ic2VydmFibGVXcmFwcGVyLmhhc1N1YnNjcmliZXJzID0gZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzLm9ic2VydmVycy5sZW5ndGggPiAwOyB9O1xuICAgIE9ic2VydmFibGVXcmFwcGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gdXNlIGNhbGxFbWl0KCkgaW5zdGVhZFxuICAgICAqL1xuICAgIE9ic2VydmFibGVXcmFwcGVyLmNhbGxOZXh0ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHZhbHVlKSB7IGVtaXR0ZXIubmV4dCh2YWx1ZSk7IH07XG4gICAgT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbEVtaXQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdmFsdWUpIHsgZW1pdHRlci5lbWl0KHZhbHVlKTsgfTtcbiAgICBPYnNlcnZhYmxlV3JhcHBlci5jYWxsRXJyb3IgPSBmdW5jdGlvbiAoZW1pdHRlciwgZXJyb3IpIHsgZW1pdHRlci5lcnJvcihlcnJvcik7IH07XG4gICAgT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbENvbXBsZXRlID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHsgZW1pdHRlci5jb21wbGV0ZSgpOyB9O1xuICAgIE9ic2VydmFibGVXcmFwcGVyLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2VPYnNlcnZhYmxlXzEuUHJvbWlzZU9ic2VydmFibGUuY3JlYXRlKHByb21pc2UpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVdyYXBwZXIudG9Qcm9taXNlID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdG9Qcm9taXNlXzEudG9Qcm9taXNlLmNhbGwob2JqKTsgfTtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZVdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlV3JhcHBlciA9IE9ic2VydmFibGVXcmFwcGVyO1xuLyoqXG4gKiBVc2UgYnkgZGlyZWN0aXZlcyBhbmQgY29tcG9uZW50cyB0byBlbWl0IGN1c3RvbSBFdmVudHMuXG4gKlxuICogIyMjIEV4YW1wbGVzXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBgWmlwcHlgIGFsdGVybmF0aXZlbHkgZW1pdHMgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyB3aGVuIGl0c1xuICogdGl0bGUgZ2V0cyBjbGlja2VkOlxuICpcbiAqIGBgYFxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnemlwcHknLFxuICogICB0ZW1wbGF0ZTogYFxuICogICA8ZGl2IGNsYXNzPVwiemlwcHlcIj5cbiAqICAgICA8ZGl2IChjbGljayk9XCJ0b2dnbGUoKVwiPlRvZ2dsZTwvZGl2PlxuICogICAgIDxkaXYgW2hpZGRlbl09XCIhdmlzaWJsZVwiPlxuICogICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICogICAgIDwvZGl2PlxuICogIDwvZGl2PmB9KVxuICogZXhwb3J0IGNsYXNzIFppcHB5IHtcbiAqICAgdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gKiAgIEBPdXRwdXQoKSBvcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAqICAgQE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAqXG4gKiAgIHRvZ2dsZSgpIHtcbiAqICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICogICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAqICAgICAgIHRoaXMub3Blbi5lbWl0KG51bGwpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICB0aGlzLmNsb3NlLmVtaXQobnVsbCk7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBVc2UgUnguT2JzZXJ2YWJsZSBidXQgcHJvdmlkZXMgYW4gYWRhcHRlciB0byBtYWtlIGl0IHdvcmsgYXMgc3BlY2lmaWVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vamh1c2Fpbi9vYnNlcnZhYmxlLXNwZWNcbiAqXG4gKiBPbmNlIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjIGlzIGF2YWlsYWJsZSwgc3dpdGNoIHRvIGl0LlxuICovXG52YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgW0V2ZW50RW1pdHRlcl0sIHdoaWNoIGRlcGVuZGluZyBvbiBbaXNBc3luY10sXG4gICAgICogZGVsaXZlcnMgZXZlbnRzIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGlzQXN5bmMpIHtcbiAgICAgICAgaWYgKGlzQXN5bmMgPT09IHZvaWQgMCkgeyBpc0FzeW5jID0gdHJ1ZTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNBc3luYyA9IGlzQXN5bmM7XG4gICAgfVxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7IH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSB1c2UgLmVtaXQodmFsdWUpIGluc3RlYWRcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHsgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpOyB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGdlbmVyYXRvck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZXJGbjtcbiAgICAgICAgdmFyIGVycm9yRm4gPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICB2YXIgY29tcGxldGVGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQgJiYgdHlwZW9mIGdlbmVyYXRvck9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JGbiA9IHRoaXMuX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikgeyBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID0gdGhpcy5faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0KHZhbHVlKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JGbiA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoZXJyKTsgfSk7IH0gOiBmdW5jdGlvbiAoZXJyKSB7IGVycm9yKGVycik7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSgpOyB9KTsgfSA6IGZ1bmN0aW9uICgpIHsgY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBzY2hlZHVsZXJGbiwgZXJyb3JGbiwgY29tcGxldGVGbik7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufShTdWJqZWN0XzEuU3ViamVjdCkpO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4qIEEgYmFzZSBjbGFzcyBmb3IgdGhlIFdyYXBwZWRFeGNlcHRpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeVxuKiBhIFdyYXBwZWRFeGNlcHRpb24gZnJvbSBFeGNlcHRpb25IYW5kbGVyIHdpdGhvdXQgYWRkaW5nIGNpcmN1bGFyXG4qIGRlcGVuZGVuY3kuXG4qL1xudmFyIEJhc2VXcmFwcGVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzZVdyYXBwZWRFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZVdyYXBwZWRFeGNlcHRpb24obWVzc2FnZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGVyTWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwid3JhcHBlclN0YWNrXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsRXhjZXB0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsU3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEJhc2VXcmFwcGVkRXhjZXB0aW9uO1xufShFcnJvcikpO1xuZXhwb3J0cy5CYXNlV3JhcHBlZEV4Y2VwdGlvbiA9IEJhc2VXcmFwcGVkRXhjZXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZV93cmFwcGVkX2V4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuL2xhbmcnKTtcbmV4cG9ydHMuTWFwID0gbGFuZ18xLmdsb2JhbC5NYXA7XG5leHBvcnRzLlNldCA9IGxhbmdfMS5nbG9iYWwuU2V0O1xuLy8gU2FmYXJpIGFuZCBJbnRlcm5ldCBFeHBsb3JlciBkbyBub3Qgc3VwcG9ydCB0aGUgaXRlcmFibGUgcGFyYW1ldGVyIHRvIHRoZVxuLy8gTWFwIGNvbnN0cnVjdG9yLiAgV2Ugd29yayBhcm91bmQgdGhhdCBieSBtYW51YWxseSBhZGRpbmcgdGhlIGl0ZW1zLlxudmFyIGNyZWF0ZU1hcEZyb21QYWlycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5ldyBleHBvcnRzLk1hcChbWzEsIDJdXSkuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1hcEZyb21QYWlycyhwYWlycykgeyByZXR1cm4gbmV3IGV4cG9ydHMuTWFwKHBhaXJzKTsgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwQW5kUG9wdWxhdGVGcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBleHBvcnRzLk1hcCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH07XG59KSgpO1xudmFyIGNyZWF0ZU1hcEZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChuZXcgZXhwb3J0cy5NYXAobmV3IGV4cG9ydHMuTWFwKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwRnJvbU1hcChtKSB7IHJldHVybiBuZXcgZXhwb3J0cy5NYXAobSk7IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1hcEFuZFBvcHVsYXRlRnJvbU1hcChtKSB7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgZXhwb3J0cy5NYXAoKTtcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IG1hcC5zZXQoaywgdik7IH0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH07XG59KSgpO1xudmFyIF9jbGVhclZhbHVlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKChuZXcgZXhwb3J0cy5NYXAoKSkua2V5cygpLm5leHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jbGVhclZhbHVlcyhtKSB7XG4gICAgICAgICAgICB2YXIga2V5SXRlcmF0b3IgPSBtLmtleXMoKTtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgd2hpbGUgKCEoKGsgPSBrZXlJdGVyYXRvci5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICAgICAgbS5zZXQoay52YWx1ZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NsZWFyVmFsdWVzV2l0aEZvcmVFYWNoKG0pIHtcbiAgICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyBtLnNldChrLCBudWxsKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcbi8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbi8vIFRPRE8obWxhdmFsKTogcmVtb3ZlIHRoZSB3b3JrIGFyb3VuZCBvbmNlIHdlIGhhdmUgYSB3b3JraW5nIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbnZhciBfYXJyYXlGcm9tTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoKG5ldyBleHBvcnRzLk1hcCgpKS52YWx1ZXMoKS5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZXMgPyBBcnJheS5mcm9tKG0udmFsdWVzKCkpIDogQXJyYXkuZnJvbShtLmtleXMoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXBXaXRoRm9yZWFjaChtLCBnZXRWYWx1ZXMpIHtcbiAgICAgICAgdmFyIHJlcyA9IExpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShtLnNpemUpLCBpID0gMDtcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBnZXRWYWx1ZXMgPyB2IDogaztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn0pKCk7XG52YXIgTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwV3JhcHBlcigpIHtcbiAgICB9XG4gICAgTWFwV3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBjcmVhdGVNYXBGcm9tTWFwKG0pOyB9O1xuICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVN0cmluZ01hcCA9IGZ1bmN0aW9uIChzdHJpbmdNYXApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBleHBvcnRzLk1hcCgpO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0cmluZ01hcCkge1xuICAgICAgICAgICAgcmVzdWx0LnNldChwcm9wLCBzdHJpbmdNYXBbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXBXcmFwcGVyLnRvU3RyaW5nTWFwID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdmFyIHIgPSB7fTtcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiByW2tdID0gdjsgfSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgTWFwV3JhcHBlci5jcmVhdGVGcm9tUGFpcnMgPSBmdW5jdGlvbiAocGFpcnMpIHsgcmV0dXJuIGNyZWF0ZU1hcEZyb21QYWlycyhwYWlycyk7IH07XG4gICAgTWFwV3JhcHBlci5jbGVhclZhbHVlcyA9IGZ1bmN0aW9uIChtKSB7IF9jbGVhclZhbHVlcyhtKTsgfTtcbiAgICBNYXBXcmFwcGVyLml0ZXJhYmxlID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG07IH07XG4gICAgTWFwV3JhcHBlci5rZXlzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgZmFsc2UpOyB9O1xuICAgIE1hcFdyYXBwZXIudmFsdWVzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgdHJ1ZSk7IH07XG4gICAgcmV0dXJuIE1hcFdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5NYXBXcmFwcGVyID0gTWFwV3JhcHBlcjtcbi8qKlxuICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXG4gKi9cbnZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xuICAgIH1cbiAgICBTdHJpbmdNYXBXcmFwcGVyLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm90ZTogV2UgYXJlIG5vdCB1c2luZyBPYmplY3QuY3JlYXRlKG51bGwpIGhlcmUgZHVlIHRvXG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIVxuICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9uZzItb2JqZWN0LWNyZWF0ZS1udWxsXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9O1xuICAgIFN0cmluZ01hcFdyYXBwZXIuY29udGFpbnMgPSBmdW5jdGlvbiAobWFwLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIH07XG4gICAgU3RyaW5nTWFwV3JhcHBlci5nZXQgPSBmdW5jdGlvbiAobWFwLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpID8gbWFwW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdHJpbmdNYXBXcmFwcGVyLnNldCA9IGZ1bmN0aW9uIChtYXAsIGtleSwgdmFsdWUpIHsgbWFwW2tleV0gPSB2YWx1ZTsgfTtcbiAgICBTdHJpbmdNYXBXcmFwcGVyLmtleXMgPSBmdW5jdGlvbiAobWFwKSB7IHJldHVybiBPYmplY3Qua2V5cyhtYXApOyB9O1xuICAgIFN0cmluZ01hcFdyYXBwZXIudmFsdWVzID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobWFwKS5yZWR1Y2UoZnVuY3Rpb24gKHIsIGEpIHtcbiAgICAgICAgICAgIHIucHVzaChtYXBbYV0pO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIFN0cmluZ01hcFdyYXBwZXIuaXNFbXB0eSA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBtYXApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0cmluZ01hcFdyYXBwZXIuZGVsZXRlID0gZnVuY3Rpb24gKG1hcCwga2V5KSB7IGRlbGV0ZSBtYXBba2V5XTsgfTtcbiAgICBTdHJpbmdNYXBXcmFwcGVyLmZvckVhY2ggPSBmdW5jdGlvbiAobWFwLCBjYWxsYmFjaykge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1hcCkge1xuICAgICAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG1hcFtwcm9wXSwgcHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmluZ01hcFdyYXBwZXIubWVyZ2UgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgIHZhciBtID0ge307XG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gbTEpIHtcbiAgICAgICAgICAgIGlmIChtMS5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgIG1bYXR0cl0gPSBtMVthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIG0yKSB7XG4gICAgICAgICAgICBpZiAobTIuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICBtW2F0dHJdID0gbTJbYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcbiAgICBTdHJpbmdNYXBXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgIGlmIChrMS5sZW5ndGggIT0gazIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5ID0gazFbaV07XG4gICAgICAgICAgICBpZiAobTFba2V5XSAhPT0gbTJba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdNYXBXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nTWFwV3JhcHBlciA9IFN0cmluZ01hcFdyYXBwZXI7XG52YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgIH1cbiAgICAvLyBKUyBoYXMgbm8gd2F5IHRvIGV4cHJlc3MgYSBzdGF0aWNhbGx5IGZpeGVkIHNpemUgbGlzdCwgYnV0IGRhcnQgZG9lcyBzbyB3ZVxuICAgIC8vIGtlZXAgYm90aCBtZXRob2RzLlxuICAgIExpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBuZXcgQXJyYXkoc2l6ZSk7IH07XG4gICAgTGlzdFdyYXBwZXIuY3JlYXRlR3Jvd2FibGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcbiAgICBMaXN0V3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCk7IH07XG4gICAgTGlzdFdyYXBwZXIuZm9yRWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uIChhcnJheSwgZm4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaXN0V3JhcHBlci5maXJzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICBpZiAoIWFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICB9O1xuICAgIExpc3RXcmFwcGVyLmxhc3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBMaXN0V3JhcHBlci5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCB2YWx1ZSwgc3RhcnRJbmRleCkge1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlLCBzdGFydEluZGV4KTtcbiAgICB9O1xuICAgIExpc3RXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7IHJldHVybiBsaXN0LmluZGV4T2YoZWwpICE9PSAtMTsgfTtcbiAgICBMaXN0V3JhcHBlci5yZXZlcnNlZCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgYSA9IExpc3RXcmFwcGVyLmNsb25lKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGEucmV2ZXJzZSgpO1xuICAgIH07XG4gICAgTGlzdFdyYXBwZXIuY29uY2F0ID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9O1xuICAgIExpc3RXcmFwcGVyLmluc2VydCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCwgdmFsdWUpIHsgbGlzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTsgfTtcbiAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICB2YXIgcmVzID0gbGlzdFtpbmRleF07XG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaXN0V3JhcHBlci5yZW1vdmUgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExpc3RXcmFwcGVyLmNsZWFyID0gZnVuY3Rpb24gKGxpc3QpIHsgbGlzdC5sZW5ndGggPSAwOyB9O1xuICAgIExpc3RXcmFwcGVyLmlzRW1wdHkgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5sZW5ndGggPT0gMDsgfTtcbiAgICBMaXN0V3JhcHBlci5maWxsID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gbnVsbDsgfVxuICAgICAgICBsaXN0LmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQgPT09IG51bGwgPyBsaXN0Lmxlbmd0aCA6IGVuZCk7XG4gICAgfTtcbiAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgTGlzdFdyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAobCwgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIGwuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgfTtcbiAgICBMaXN0V3JhcHBlci5zcGxpY2UgPSBmdW5jdGlvbiAobCwgZnJvbSwgbGVuZ3RoKSB7IHJldHVybiBsLnNwbGljZShmcm9tLCBsZW5ndGgpOyB9O1xuICAgIExpc3RXcmFwcGVyLnNvcnQgPSBmdW5jdGlvbiAobCwgY29tcGFyZUZuKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBhcmVGbikpIHtcbiAgICAgICAgICAgIGwuc29ydChjb21wYXJlRm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbC5zb3J0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpc3RXcmFwcGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudG9TdHJpbmcoKTsgfTtcbiAgICBMaXN0V3JhcHBlci50b0pTT04gPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkobCk7IH07XG4gICAgTGlzdFdyYXBwZXIubWF4aW11bSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZVZhbHVlID0gcHJlZGljYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgIH07XG4gICAgTGlzdFdyYXBwZXIuZmxhdHRlbiA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICAgICAgX2ZsYXR0ZW5BcnJheShsaXN0LCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgTGlzdFdyYXBwZXIuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHNvdXJjZVtpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLkxpc3RXcmFwcGVyID0gTGlzdFdyYXBwZXI7XG5mdW5jdGlvbiBfZmxhdHRlbkFycmF5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc291cmNlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBzb3VyY2VbaV07XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBfZmxhdHRlbkFycmF5KGl0ZW0sIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gaXNMaXN0TGlrZUl0ZXJhYmxlKG9iaikge1xuICAgIGlmICghbGFuZ18xLmlzSnNPYmplY3Qob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBsYW5nXzEuaXNBcnJheShvYmopIHx8XG4gICAgICAgICghKG9iaiBpbnN0YW5jZW9mIGV4cG9ydHMuTWFwKSAmJlxuICAgICAgICAgICAgbGFuZ18xLmdldFN5bWJvbEl0ZXJhdG9yKCkgaW4gb2JqKTsgLy8gSlMgSXRlcmFibGUgaGF2ZSBhIFN5bWJvbC5pdGVyYXRvciBwcm9wXG59XG5leHBvcnRzLmlzTGlzdExpa2VJdGVyYWJsZSA9IGlzTGlzdExpa2VJdGVyYWJsZTtcbmZ1bmN0aW9uIGFyZUl0ZXJhYmxlc0VxdWFsKGEsIGIsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaXRlcmF0b3IxID0gYVtsYW5nXzEuZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICB2YXIgaXRlcmF0b3IyID0gYltsYW5nXzEuZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgaXRlbTEgPSBpdGVyYXRvcjEubmV4dCgpO1xuICAgICAgICB2YXIgaXRlbTIgPSBpdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlbTEuZG9uZSAmJiBpdGVtMi5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChpdGVtMS5kb25lIHx8IGl0ZW0yLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY29tcGFyYXRvcihpdGVtMS52YWx1ZSwgaXRlbTIudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuYXJlSXRlcmFibGVzRXF1YWwgPSBhcmVJdGVyYWJsZXNFcXVhbDtcbmZ1bmN0aW9uIGl0ZXJhdGVMaXN0TGlrZShvYmosIGZuKSB7XG4gICAgaWYgKGxhbmdfMS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZuKG9ialtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IG9ialtsYW5nXzEuZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHdoaWxlICghKChpdGVtID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSkge1xuICAgICAgICAgICAgZm4oaXRlbS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLml0ZXJhdGVMaXN0TGlrZSA9IGl0ZXJhdGVMaXN0TGlrZTtcbi8vIFNhZmFyaSBhbmQgSW50ZXJuZXQgRXhwbG9yZXIgZG8gbm90IHN1cHBvcnQgdGhlIGl0ZXJhYmxlIHBhcmFtZXRlciB0byB0aGVcbi8vIFNldCBjb25zdHJ1Y3Rvci4gIFdlIHdvcmsgYXJvdW5kIHRoYXQgYnkgbWFudWFsbHkgYWRkaW5nIHRoZSBpdGVtcy5cbnZhciBjcmVhdGVTZXRGcm9tTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgZXhwb3J0cy5TZXQoWzEsIDIsIDNdKTtcbiAgICBpZiAodGVzdC5zaXplID09PSAzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVTZXRGcm9tTGlzdChsc3QpIHsgcmV0dXJuIG5ldyBleHBvcnRzLlNldChsc3QpOyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNldEFuZFBvcHVsYXRlRnJvbUxpc3QobHN0KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IGV4cG9ydHMuU2V0KGxzdCk7XG4gICAgICAgICAgICBpZiAocmVzLnNpemUgIT09IGxzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMuYWRkKGxzdFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xudmFyIFNldFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldFdyYXBwZXIoKSB7XG4gICAgfVxuICAgIFNldFdyYXBwZXIuY3JlYXRlRnJvbUxpc3QgPSBmdW5jdGlvbiAobHN0KSB7IHJldHVybiBjcmVhdGVTZXRGcm9tTGlzdChsc3QpOyB9O1xuICAgIFNldFdyYXBwZXIuaGFzID0gZnVuY3Rpb24gKHMsIGtleSkgeyByZXR1cm4gcy5oYXMoa2V5KTsgfTtcbiAgICBTZXRXcmFwcGVyLmRlbGV0ZSA9IGZ1bmN0aW9uIChtLCBrKSB7IG0uZGVsZXRlKGspOyB9O1xuICAgIHJldHVybiBTZXRXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuU2V0V3JhcHBlciA9IFNldFdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsZWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4vbGFuZycpO1xudmFyIGJhc2Vfd3JhcHBlZF9leGNlcHRpb25fMSA9IHJlcXVpcmUoJy4vYmFzZV93cmFwcGVkX2V4Y2VwdGlvbicpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xudmFyIF9BcnJheUxvZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0FycmF5TG9nZ2VyKCkge1xuICAgICAgICB0aGlzLnJlcyA9IFtdO1xuICAgIH1cbiAgICBfQXJyYXlMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChzKSB7IHRoaXMucmVzLnB1c2gocyk7IH07XG4gICAgX0FycmF5TG9nZ2VyLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChzKSB7IHRoaXMucmVzLnB1c2gocyk7IH07XG4gICAgX0FycmF5TG9nZ2VyLnByb3RvdHlwZS5sb2dHcm91cCA9IGZ1bmN0aW9uIChzKSB7IHRoaXMucmVzLnB1c2gocyk7IH07XG4gICAgX0FycmF5TG9nZ2VyLnByb3RvdHlwZS5sb2dHcm91cEVuZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICA7XG4gICAgcmV0dXJuIF9BcnJheUxvZ2dlcjtcbn0oKSk7XG4vKipcbiAqIFByb3ZpZGVzIGEgaG9vayBmb3IgY2VudHJhbGl6ZWQgZXhjZXB0aW9uIGhhbmRsaW5nLlxuICpcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBFeGNlcHRpb25IYW5kbGVyYCBwcmludHMgZXJyb3IgbWVzc2FnZXMgdG8gdGhlIGBDb25zb2xlYC4gVG9cbiAqIGludGVyY2VwdCBlcnJvciBoYW5kbGluZyxcbiAqIHdyaXRlIGEgY3VzdG9tIGV4Y2VwdGlvbiBoYW5kbGVyIHRoYXQgcmVwbGFjZXMgdGhpcyBkZWZhdWx0IGFzIGFwcHJvcHJpYXRlIGZvciB5b3VyIGFwcC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqXG4gKiBjbGFzcyBNeUV4Y2VwdGlvbkhhbmRsZXIgaW1wbGVtZW50cyBFeGNlcHRpb25IYW5kbGVyIHtcbiAqICAgY2FsbChlcnJvciwgc3RhY2tUcmFjZSA9IG51bGwsIHJlYXNvbiA9IG51bGwpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZXhjZXB0aW9uXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBib290c3RyYXAoTXlBcHAsIFtwcm92aWRlKEV4Y2VwdGlvbkhhbmRsZXIsIHt1c2VDbGFzczogTXlFeGNlcHRpb25IYW5kbGVyfSldKVxuICpcbiAqIGBgYFxuICovXG52YXIgRXhjZXB0aW9uSGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhjZXB0aW9uSGFuZGxlcihfbG9nZ2VyLCBfcmV0aHJvd0V4Y2VwdGlvbikge1xuICAgICAgICBpZiAoX3JldGhyb3dFeGNlcHRpb24gPT09IHZvaWQgMCkgeyBfcmV0aHJvd0V4Y2VwdGlvbiA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gX2xvZ2dlcjtcbiAgICAgICAgdGhpcy5fcmV0aHJvd0V4Y2VwdGlvbiA9IF9yZXRocm93RXhjZXB0aW9uO1xuICAgIH1cbiAgICBFeGNlcHRpb25IYW5kbGVyLmV4Y2VwdGlvblRvU3RyaW5nID0gZnVuY3Rpb24gKGV4Y2VwdGlvbiwgc3RhY2tUcmFjZSwgcmVhc29uKSB7XG4gICAgICAgIGlmIChzdGFja1RyYWNlID09PSB2b2lkIDApIHsgc3RhY2tUcmFjZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7IHJlYXNvbiA9IG51bGw7IH1cbiAgICAgICAgdmFyIGwgPSBuZXcgX0FycmF5TG9nZ2VyKCk7XG4gICAgICAgIHZhciBlID0gbmV3IEV4Y2VwdGlvbkhhbmRsZXIobCwgZmFsc2UpO1xuICAgICAgICBlLmNhbGwoZXhjZXB0aW9uLCBzdGFja1RyYWNlLCByZWFzb24pO1xuICAgICAgICByZXR1cm4gbC5yZXMuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoZXhjZXB0aW9uLCBzdGFja1RyYWNlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHN0YWNrVHJhY2UgPT09IHZvaWQgMCkgeyBzdGFja1RyYWNlID0gbnVsbDsgfVxuICAgICAgICBpZiAocmVhc29uID09PSB2b2lkIDApIHsgcmVhc29uID0gbnVsbDsgfVxuICAgICAgICB2YXIgb3JpZ2luYWxFeGNlcHRpb24gPSB0aGlzLl9maW5kT3JpZ2luYWxFeGNlcHRpb24oZXhjZXB0aW9uKTtcbiAgICAgICAgdmFyIG9yaWdpbmFsU3RhY2sgPSB0aGlzLl9maW5kT3JpZ2luYWxTdGFjayhleGNlcHRpb24pO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2ZpbmRDb250ZXh0KGV4Y2VwdGlvbik7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5sb2dHcm91cChcIkVYQ0VQVElPTjogXCIgKyB0aGlzLl9leHRyYWN0TWVzc2FnZShleGNlcHRpb24pKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3RhY2tUcmFjZSkgJiYgbGFuZ18xLmlzQmxhbmsob3JpZ2luYWxTdGFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihcIlNUQUNLVFJBQ0U6XCIpO1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKHRoaXMuX2xvbmdTdGFja1RyYWNlKHN0YWNrVHJhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChyZWFzb24pKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IoXCJSRUFTT046IFwiICsgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcmlnaW5hbEV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihcIk9SSUdJTkFMIEVYQ0VQVElPTjogXCIgKyB0aGlzLl9leHRyYWN0TWVzc2FnZShvcmlnaW5hbEV4Y2VwdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9yaWdpbmFsU3RhY2spKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nRXJyb3IoXCJPUklHSU5BTCBTVEFDS1RSQUNFOlwiKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcih0aGlzLl9sb25nU3RhY2tUcmFjZShvcmlnaW5hbFN0YWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2dFcnJvcihcIkVSUk9SIENPTlRFWFQ6XCIpO1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZ0Vycm9yKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZ2dlci5sb2dHcm91cEVuZCgpO1xuICAgICAgICAvLyBXZSByZXRocm93IGV4Y2VwdGlvbnMsIHNvIG9wZXJhdGlvbnMgbGlrZSAnYm9vdHN0cmFwJyB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvclxuICAgICAgICAvLyB3aGVuIGFuIGV4Y2VwdGlvbiBoYXBwZW5zLiBJZiB3ZSBkbyBub3QgcmV0aHJvdywgYm9vdHN0cmFwIHdpbGwgYWx3YXlzIHN1Y2NlZWQuXG4gICAgICAgIGlmICh0aGlzLl9yZXRocm93RXhjZXB0aW9uKVxuICAgICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLl9leHRyYWN0TWVzc2FnZSA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIGJhc2Vfd3JhcHBlZF9leGNlcHRpb25fMS5CYXNlV3JhcHBlZEV4Y2VwdGlvbiA/IGV4Y2VwdGlvbi53cmFwcGVyTWVzc2FnZSA6XG4gICAgICAgICAgICBleGNlcHRpb24udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fbG9uZ1N0YWNrVHJhY2UgPSBmdW5jdGlvbiAoc3RhY2tUcmFjZSkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLmlzTGlzdExpa2VJdGVyYWJsZShzdGFja1RyYWNlKSA/IHN0YWNrVHJhY2Uuam9pbihcIlxcblxcbi0tLS0tYXN5bmMgZ2FwLS0tLS1cXG5cIikgOlxuICAgICAgICAgICAgc3RhY2tUcmFjZS50b1N0cmluZygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEV4Y2VwdGlvbkhhbmRsZXIucHJvdG90eXBlLl9maW5kQ29udGV4dCA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghKGV4Y2VwdGlvbiBpbnN0YW5jZW9mIGJhc2Vfd3JhcHBlZF9leGNlcHRpb25fMS5CYXNlV3JhcHBlZEV4Y2VwdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChleGNlcHRpb24uY29udGV4dCkgPyBleGNlcHRpb24uY29udGV4dCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluZENvbnRleHQoZXhjZXB0aW9uLm9yaWdpbmFsRXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZXhjZXB0aW9uLmNvbnRleHQgY2FuIHRocm93IGFuIGV4Y2VwdGlvbi4gaWYgaXQgaGFwcGVucywgd2UgaWdub3JlIHRoZSBjb250ZXh0LlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsRXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBpZiAoIShleGNlcHRpb24gaW5zdGFuY2VvZiBiYXNlX3dyYXBwZWRfZXhjZXB0aW9uXzEuQmFzZVdyYXBwZWRFeGNlcHRpb24pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBlID0gZXhjZXB0aW9uLm9yaWdpbmFsRXhjZXB0aW9uO1xuICAgICAgICB3aGlsZSAoZSBpbnN0YW5jZW9mIGJhc2Vfd3JhcHBlZF9leGNlcHRpb25fMS5CYXNlV3JhcHBlZEV4Y2VwdGlvbiAmJiBsYW5nXzEuaXNQcmVzZW50KGUub3JpZ2luYWxFeGNlcHRpb24pKSB7XG4gICAgICAgICAgICBlID0gZS5vcmlnaW5hbEV4Y2VwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBFeGNlcHRpb25IYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsU3RhY2sgPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICghKGV4Y2VwdGlvbiBpbnN0YW5jZW9mIGJhc2Vfd3JhcHBlZF9leGNlcHRpb25fMS5CYXNlV3JhcHBlZEV4Y2VwdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGUgPSBleGNlcHRpb247XG4gICAgICAgIHZhciBzdGFjayA9IGV4Y2VwdGlvbi5vcmlnaW5hbFN0YWNrO1xuICAgICAgICB3aGlsZSAoZSBpbnN0YW5jZW9mIGJhc2Vfd3JhcHBlZF9leGNlcHRpb25fMS5CYXNlV3JhcHBlZEV4Y2VwdGlvbiAmJiBsYW5nXzEuaXNQcmVzZW50KGUub3JpZ2luYWxFeGNlcHRpb24pKSB7XG4gICAgICAgICAgICBlID0gZS5vcmlnaW5hbEV4Y2VwdGlvbjtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgYmFzZV93cmFwcGVkX2V4Y2VwdGlvbl8xLkJhc2VXcmFwcGVkRXhjZXB0aW9uICYmIGxhbmdfMS5pc1ByZXNlbnQoZS5vcmlnaW5hbEV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICBzdGFjayA9IGUub3JpZ2luYWxTdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gRXhjZXB0aW9uSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLkV4Y2VwdGlvbkhhbmRsZXIgPSBFeGNlcHRpb25IYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9uX2hhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBiYXNlX3dyYXBwZWRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2Jhc2Vfd3JhcHBlZF9leGNlcHRpb24nKTtcbnZhciBleGNlcHRpb25faGFuZGxlcl8xID0gcmVxdWlyZSgnLi9leGNlcHRpb25faGFuZGxlcicpO1xudmFyIGV4Y2VwdGlvbl9oYW5kbGVyXzIgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbl9oYW5kbGVyJyk7XG5leHBvcnRzLkV4Y2VwdGlvbkhhbmRsZXIgPSBleGNlcHRpb25faGFuZGxlcl8yLkV4Y2VwdGlvbkhhbmRsZXI7XG52YXIgQmFzZUV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IFwiLS1cIjsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IobWVzc2FnZSkpLnN0YWNrO1xuICAgIH1cbiAgICBCYXNlRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcbiAgICByZXR1cm4gQmFzZUV4Y2VwdGlvbjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQmFzZUV4Y2VwdGlvbiA9IEJhc2VFeGNlcHRpb247XG4vKipcbiAqIFdyYXBzIGFuIGV4Y2VwdGlvbiBhbmQgcHJvdmlkZXMgYWRkaXRpb25hbCBjb250ZXh0IG9yIGluZm9ybWF0aW9uLlxuICovXG52YXIgV3JhcHBlZEV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdyYXBwZWRFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JhcHBlZEV4Y2VwdGlvbihfd3JhcHBlck1lc3NhZ2UsIF9vcmlnaW5hbEV4Y2VwdGlvbiwgX29yaWdpbmFsU3RhY2ssIF9jb250ZXh0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF93cmFwcGVyTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJNZXNzYWdlID0gX3dyYXBwZXJNZXNzYWdlO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEV4Y2VwdGlvbiA9IF9vcmlnaW5hbEV4Y2VwdGlvbjtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxTdGFjayA9IF9vcmlnaW5hbFN0YWNrO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gX2NvbnRleHQ7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGFjayA9IChuZXcgRXJyb3IoX3dyYXBwZXJNZXNzYWdlKSkuc3RhY2s7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGVyTWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fd3JhcHBlck1lc3NhZ2U7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGVyU3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3dyYXBwZXJTdGFjazsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsRXhjZXB0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vcmlnaW5hbEV4Y2VwdGlvbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFeGNlcHRpb24ucHJvdG90eXBlLCBcIm9yaWdpbmFsU3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29yaWdpbmFsU3RhY2s7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250ZXh0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEV4Y2VwdGlvbi5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uX2hhbmRsZXJfMS5FeGNlcHRpb25IYW5kbGVyLmV4Y2VwdGlvblRvU3RyaW5nKHRoaXMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXcmFwcGVkRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcbiAgICByZXR1cm4gV3JhcHBlZEV4Y2VwdGlvbjtcbn0oYmFzZV93cmFwcGVkX2V4Y2VwdGlvbl8xLkJhc2VXcmFwcGVkRXhjZXB0aW9uKSk7XG5leHBvcnRzLldyYXBwZWRFeGNlcHRpb24gPSBXcmFwcGVkRXhjZXB0aW9uO1xuZnVuY3Rpb24gbWFrZVR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG59XG5leHBvcnRzLm1ha2VUeXBlRXJyb3IgPSBtYWtlVHlwZUVycm9yO1xuZnVuY3Rpb24gdW5pbXBsZW1lbnRlZCgpIHtcbiAgICB0aHJvdyBuZXcgQmFzZUV4Y2VwdGlvbigndW5pbXBsZW1lbnRlZCcpO1xufVxuZXhwb3J0cy51bmltcGxlbWVudGVkID0gdW5pbXBsZW1lbnRlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2VwdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4oZnVuY3Rpb24gKE51bWJlckZvcm1hdFN0eWxlKSB7XG4gICAgTnVtYmVyRm9ybWF0U3R5bGVbTnVtYmVyRm9ybWF0U3R5bGVbXCJEZWNpbWFsXCJdID0gMF0gPSBcIkRlY2ltYWxcIjtcbiAgICBOdW1iZXJGb3JtYXRTdHlsZVtOdW1iZXJGb3JtYXRTdHlsZVtcIlBlcmNlbnRcIl0gPSAxXSA9IFwiUGVyY2VudFwiO1xuICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiQ3VycmVuY3lcIl0gPSAyXSA9IFwiQ3VycmVuY3lcIjtcbn0pKGV4cG9ydHMuTnVtYmVyRm9ybWF0U3R5bGUgfHwgKGV4cG9ydHMuTnVtYmVyRm9ybWF0U3R5bGUgPSB7fSkpO1xudmFyIE51bWJlckZvcm1hdFN0eWxlID0gZXhwb3J0cy5OdW1iZXJGb3JtYXRTdHlsZTtcbnZhciBOdW1iZXJGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bWJlckZvcm1hdHRlcigpIHtcbiAgICB9XG4gICAgTnVtYmVyRm9ybWF0dGVyLmZvcm1hdCA9IGZ1bmN0aW9uIChudW0sIGxvY2FsZSwgc3R5bGUsIF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLm1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIF9kID0gX2IubWluaW11bUZyYWN0aW9uRGlnaXRzLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCBfZSA9IF9iLm1heGltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzID0gX2UgPT09IHZvaWQgMCA/IDMgOiBfZSwgY3VycmVuY3kgPSBfYi5jdXJyZW5jeSwgX2YgPSBfYi5jdXJyZW5jeUFzU3ltYm9sLCBjdXJyZW5jeUFzU3ltYm9sID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2Y7XG4gICAgICAgIHZhciBpbnRsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiBtaW5pbXVtSW50ZWdlckRpZ2l0cyxcbiAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbWluaW11bUZyYWN0aW9uRGlnaXRzLFxuICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcbiAgICAgICAgfTtcbiAgICAgICAgaW50bE9wdGlvbnMuc3R5bGUgPSBOdW1iZXJGb3JtYXRTdHlsZVtzdHlsZV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0eWxlID09IE51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5KSB7XG4gICAgICAgICAgICBpbnRsT3B0aW9ucy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgICAgICAgICAgaW50bE9wdGlvbnMuY3VycmVuY3lEaXNwbGF5ID0gY3VycmVuY3lBc1N5bWJvbCA/ICdzeW1ib2wnIDogJ2NvZGUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBpbnRsT3B0aW9ucykuZm9ybWF0KG51bSk7XG4gICAgfTtcbiAgICByZXR1cm4gTnVtYmVyRm9ybWF0dGVyO1xufSgpKTtcbmV4cG9ydHMuTnVtYmVyRm9ybWF0dGVyID0gTnVtYmVyRm9ybWF0dGVyO1xuZnVuY3Rpb24gZGlnaXRDb25kaXRpb24obGVuKSB7XG4gICAgcmV0dXJuIGxlbiA9PSAyID8gJzItZGlnaXQnIDogJ251bWVyaWMnO1xufVxuZnVuY3Rpb24gbmFtZUNvbmRpdGlvbihsZW4pIHtcbiAgICByZXR1cm4gbGVuIDwgNCA/ICdzaG9ydCcgOiAnbG9uZyc7XG59XG5mdW5jdGlvbiBleHRyYWN0Q29tcG9uZW50cyhwYXR0ZXJuKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIHZhciBpID0gMCwgajtcbiAgICB3aGlsZSAoaSA8IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgIGogPSBpO1xuICAgICAgICB3aGlsZSAoaiA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm5bal0gPT0gcGF0dGVybltpXSlcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgdmFyIGxlbiA9IGogLSBpO1xuICAgICAgICBzd2l0Y2ggKHBhdHRlcm5baV0pIHtcbiAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgIHJldC5lcmEgPSBuYW1lQ29uZGl0aW9uKGxlbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICByZXQueWVhciA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICBpZiAobGVuID49IDMpXG4gICAgICAgICAgICAgICAgICAgIHJldC5tb250aCA9IG5hbWVDb25kaXRpb24obGVuKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldC5tb250aCA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICByZXQuZGF5ID0gZGlnaXRDb25kaXRpb24obGVuKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldC53ZWVrZGF5ID0gbmFtZUNvbmRpdGlvbihsZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgcmV0LmhvdXIgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgcmV0LmhvdXIgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xuICAgICAgICAgICAgICAgIHJldC5ob3VyMTIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgcmV0LmhvdXIgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xuICAgICAgICAgICAgICAgIHJldC5ob3VyMTIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldC5taW51dGUgPSBkaWdpdENvbmRpdGlvbihsZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgcmV0LnNlY29uZCA9IGRpZ2l0Q29uZGl0aW9uKGxlbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICByZXQudGltZVpvbmVOYW1lID0gJ2xvbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgcmV0LnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG52YXIgZGF0ZUZvcm1hdHRlckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIERhdGVGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGVGb3JtYXR0ZXIoKSB7XG4gICAgfVxuICAgIERhdGVGb3JtYXR0ZXIuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgcGF0dGVybikge1xuICAgICAgICB2YXIga2V5ID0gbG9jYWxlICsgcGF0dGVybjtcbiAgICAgICAgaWYgKGRhdGVGb3JtYXR0ZXJDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXR0ZXJDYWNoZS5nZXQoa2V5KS5mb3JtYXQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgZXh0cmFjdENvbXBvbmVudHMocGF0dGVybikpO1xuICAgICAgICBkYXRlRm9ybWF0dGVyQ2FjaGUuc2V0KGtleSwgZm9ybWF0dGVyKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoZGF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZUZvcm1hdHRlcjtcbn0oKSk7XG5leHBvcnRzLkRhdGVGb3JtYXR0ZXIgPSBEYXRlRm9ybWF0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50bC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGdsb2JhbFNjb3BlO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XG4gICAgfVxufVxuZWxzZSB7XG4gICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG59XG5mdW5jdGlvbiBzY2hlZHVsZU1pY3JvVGFzayhmbikge1xuICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XG59XG5leHBvcnRzLnNjaGVkdWxlTWljcm9UYXNrID0gc2NoZWR1bGVNaWNyb1Rhc2s7XG5leHBvcnRzLklTX0RBUlQgPSBmYWxzZTtcbi8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbnZhciBfZ2xvYmFsID0gZ2xvYmFsU2NvcGU7XG5leHBvcnRzLmdsb2JhbCA9IF9nbG9iYWw7XG5leHBvcnRzLlR5cGUgPSBGdW5jdGlvbjtcbmZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGUpIHtcbiAgICBpZiAodHlwZVsnbmFtZSddKSB7XG4gICAgICAgIHJldHVybiB0eXBlWyduYW1lJ107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdHlwZTtcbn1cbmV4cG9ydHMuZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcgPSBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZztcbmV4cG9ydHMuTWF0aCA9IF9nbG9iYWwuTWF0aDtcbmV4cG9ydHMuRGF0ZSA9IF9nbG9iYWwuRGF0ZTtcbnZhciBfZGV2TW9kZSA9IHRydWU7XG52YXIgX21vZGVMb2NrZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGxvY2tNb2RlKCkge1xuICAgIF9tb2RlTG9ja2VkID0gdHJ1ZTtcbn1cbmV4cG9ydHMubG9ja01vZGUgPSBsb2NrTW9kZTtcbi8qKlxuICogRGlzYWJsZSBBbmd1bGFyJ3MgZGV2ZWxvcG1lbnQgbW9kZSwgd2hpY2ggdHVybnMgb2ZmIGFzc2VydGlvbnMgYW5kIG90aGVyXG4gKiBjaGVja3Mgd2l0aGluIHRoZSBmcmFtZXdvcmsuXG4gKlxuICogT25lIGltcG9ydGFudCBhc3NlcnRpb24gdGhpcyBkaXNhYmxlcyB2ZXJpZmllcyB0aGF0IGEgY2hhbmdlIGRldGVjdGlvbiBwYXNzXG4gKiBkb2VzIG5vdCByZXN1bHQgaW4gYWRkaXRpb25hbCBjaGFuZ2VzIHRvIGFueSBiaW5kaW5ncyAoYWxzbyBrbm93biBhc1xuICogdW5pZGlyZWN0aW9uYWwgZGF0YSBmbG93KS5cbiAqL1xuZnVuY3Rpb24gZW5hYmxlUHJvZE1vZGUoKSB7XG4gICAgaWYgKF9tb2RlTG9ja2VkKSB7XG4gICAgICAgIC8vIENhbm5vdCB1c2UgQmFzZUV4Y2VwdGlvbiBhcyB0aGF0IGVuZHMgdXAgaW1wb3J0aW5nIGZyb20gZmFjYWRlL2xhbmcuXG4gICAgICAgIHRocm93ICdDYW5ub3QgZW5hYmxlIHByb2QgbW9kZSBhZnRlciBwbGF0Zm9ybSBzZXR1cC4nO1xuICAgIH1cbiAgICBfZGV2TW9kZSA9IGZhbHNlO1xufVxuZXhwb3J0cy5lbmFibGVQcm9kTW9kZSA9IGVuYWJsZVByb2RNb2RlO1xuZnVuY3Rpb24gYXNzZXJ0aW9uc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIF9kZXZNb2RlO1xufVxuZXhwb3J0cy5hc3NlcnRpb25zRW5hYmxlZCA9IGFzc2VydGlvbnNFbmFibGVkO1xuLy8gVE9ETzogcmVtb3ZlIGNhbGxzIHRvIGFzc2VydCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4vLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbi8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG5fZ2xvYmFsLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xufTtcbmZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG5mdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XG59XG5leHBvcnRzLmlzQmxhbmsgPSBpc0JsYW5rO1xuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImJvb2xlYW5cIjtcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCI7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5mdW5jdGlvbiBpc1R5cGUob2JqKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqKTtcbn1cbmV4cG9ydHMuaXNUeXBlID0gaXNUeXBlO1xuZnVuY3Rpb24gaXNTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNTdHJpbmdNYXAgPSBpc1N0cmluZ01hcDtcbnZhciBTVFJJTkdfTUFQX1BST1RPID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbmZ1bmN0aW9uIGlzU3RyaWN0U3RyaW5nTWFwKG9iaikge1xuICAgIHJldHVybiBpc1N0cmluZ01hcChvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xufVxuZXhwb3J0cy5pc1N0cmljdFN0cmluZ01hcCA9IGlzU3RyaWN0U3RyaW5nTWFwO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBfZ2xvYmFsLlByb21pc2U7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIGV4cG9ydHMuRGF0ZSAmJiAhaXNOYU4ob2JqLnZhbHVlT2YoKSk7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5mdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgIH1cbiAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICB9XG4gICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKFwiXFxuXCIpO1xuICAgIHJldHVybiAobmV3TGluZUluZGV4ID09PSAtMSkgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbi8vIHNlcmlhbGl6ZSAvIGRlc2VyaWFsaXplIGVudW0gZXhpc3Qgb25seSBmb3IgY29uc2lzdGVuY3kgd2l0aCBkYXJ0IEFQSVxuLy8gZW51bXMgaW4gdHlwZXNjcmlwdCBkb24ndCBuZWVkIHRvIGJlIHNlcmlhbGl6ZWRcbmZ1bmN0aW9uIHNlcmlhbGl6ZUVudW0odmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmV4cG9ydHMuc2VyaWFsaXplRW51bSA9IHNlcmlhbGl6ZUVudW07XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVudW0odmFsLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZUVudW0gPSBkZXNlcmlhbGl6ZUVudW07XG5mdW5jdGlvbiByZXNvbHZlRW51bVRva2VuKGVudW1WYWx1ZSwgdmFsKSB7XG4gICAgcmV0dXJuIGVudW1WYWx1ZVt2YWxdO1xufVxuZXhwb3J0cy5yZXNvbHZlRW51bVRva2VuID0gcmVzb2x2ZUVudW1Ub2tlbjtcbnZhciBTdHJpbmdXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdXcmFwcGVyKCkge1xuICAgIH1cbiAgICBTdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdCA9IGZ1bmN0aW9uIChzLCBpbmRleCkgeyByZXR1cm4gcy5jaGFyQ29kZUF0KGluZGV4KTsgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnNwbGl0ID0gZnVuY3Rpb24gKHMsIHJlZ0V4cCkgeyByZXR1cm4gcy5zcGxpdChyZWdFeHApOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKHMsIHMyKSB7IHJldHVybiBzID09PSBzMjsgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnN0cmlwTGVmdCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnN0cmlwUmlnaHQgPSBmdW5jdGlvbiAocywgY2hhclZhbCkge1xuICAgICAgICBpZiAocyAmJiBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPSBjaGFyVmFsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzLCBmcm9tLCByZXBsYWNlKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgcmVwbGFjZSk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnNsaWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBzLnNsaWNlKGZyb20sIHRvID09PSBudWxsID8gdW5kZWZpbmVkIDogdG8pO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkID0gZnVuY3Rpb24gKHMsIGZyb20sIGNiKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzZXQgJiBzdHJpbmcgZnJvbSB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICBtYXRjaGVzLnNwbGljZSgtMiwgMik7XG4gICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbWF0Y2gsIHAxLCAuLi4sIHBuXG4gICAgICAgICAgICByZXR1cm4gY2IobWF0Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChzLCBzdWJzdHIpIHsgcmV0dXJuIHMuaW5kZXhPZihzdWJzdHIpICE9IC0xOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5nV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ1dyYXBwZXIgPSBTdHJpbmdXcmFwcGVyO1xudmFyIFN0cmluZ0pvaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nSm9pbmVyKHBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7IHBhcnRzID0gW107IH1cbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIH1cbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwYXJ0KSB7IHRoaXMucGFydHMucHVzaChwYXJ0KTsgfTtcbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJ0cy5qb2luKFwiXCIpOyB9O1xuICAgIHJldHVybiBTdHJpbmdKb2luZXI7XG59KCkpO1xuZXhwb3J0cy5TdHJpbmdKb2luZXIgPSBTdHJpbmdKb2luZXI7XG52YXIgTnVtYmVyUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlclBhcnNlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVtYmVyUGFyc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBOdW1iZXJQYXJzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcbiAgICByZXR1cm4gTnVtYmVyUGFyc2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuTnVtYmVyUGFyc2VFcnJvciA9IE51bWJlclBhcnNlRXJyb3I7XG52YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVyV3JhcHBlcigpIHtcbiAgICB9XG4gICAgTnVtYmVyV3JhcHBlci50b0ZpeGVkID0gZnVuY3Rpb24gKG4sIGZyYWN0aW9uRGlnaXRzKSB7IHJldHVybiBuLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpOyB9O1xuICAgIE51bWJlcldyYXBwZXIuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcbiAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE51bWJlclBhcnNlRXJyb3IoXCJJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgXCIgKyB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUludCA9IGZ1bmN0aW9uICh0ZXh0LCByYWRpeCkge1xuICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05XSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYWRpeCA9PSAxNikge1xuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE51bWJlclBhcnNlRXJyb3IoXCJJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgXCIgKyB0ZXh0ICsgXCIgaW4gYmFzZSBcIiArXG4gICAgICAgICAgICByYWRpeCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBOYU4gaXMgYSB2YWxpZCBsaXRlcmFsIGJ1dCBpcyByZXR1cm5lZCBieSBwYXJzZUZsb2F0IHRvIGluZGljYXRlIGFuIGVycm9yLlxuICAgIE51bWJlcldyYXBwZXIucGFyc2VGbG9hdCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBwYXJzZUZsb2F0KHRleHQpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBcIk5hTlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmFOOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOdW1iZXJXcmFwcGVyLmlzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc05hTih2YWx1ZSk7IH07XG4gICAgTnVtYmVyV3JhcHBlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpOyB9O1xuICAgIHJldHVybiBOdW1iZXJXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuTnVtYmVyV3JhcHBlciA9IE51bWJlcldyYXBwZXI7XG5leHBvcnRzLlJlZ0V4cCA9IF9nbG9iYWwuUmVnRXhwO1xudmFyIFJlZ0V4cFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZ0V4cFdyYXBwZXIoKSB7XG4gICAgfVxuICAgIFJlZ0V4cFdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHJlZ0V4cFN0ciwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAnJzsgfVxuICAgICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoL2cvZywgJycpO1xuICAgICAgICByZXR1cm4gbmV3IF9nbG9iYWwuUmVnRXhwKHJlZ0V4cFN0ciwgZmxhZ3MgKyAnZycpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgLy8gUmVzZXQgbXVsdGltYXRjaCByZWdleCBzdGF0ZVxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICB9O1xuICAgIFJlZ0V4cFdyYXBwZXIudGVzdCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0KSB7XG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcmVnRXhwLnRlc3QoaW5wdXQpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci5tYXRjaGVyID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgLy8gUmVzZXQgcmVnZXggc3RhdGUgZm9yIHRoZSBjYXNlXG4gICAgICAgIC8vIHNvbWVvbmUgZGlkIG5vdCBsb29wIG92ZXIgYWxsIG1hdGNoZXNcbiAgICAgICAgLy8gbGFzdCB0aW1lLlxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHsgcmU6IHJlZ0V4cCwgaW5wdXQ6IGlucHV0IH07XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgYyA9IHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICAgICAgdmFyIHJlcyA9ICcnO1xuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIHByZXYgPSAwO1xuICAgICAgICB3aGlsZSAoYykge1xuICAgICAgICAgICAgcmVzICs9IGlucHV0LnN1YnN0cmluZyhwcmV2LCBjLmluZGV4KTtcbiAgICAgICAgICAgIHJlcyArPSByZXBsYWNlKGMpO1xuICAgICAgICAgICAgcHJldiA9IGMuaW5kZXggKyBjWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSBwcmV2O1xuICAgICAgICAgICAgYyA9IHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gaW5wdXQuc3Vic3RyaW5nKHByZXYpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ0V4cFdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5SZWdFeHBXcmFwcGVyID0gUmVnRXhwV3JhcHBlcjtcbnZhciBSZWdFeHBNYXRjaGVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnRXhwTWF0Y2hlcldyYXBwZXIoKSB7XG4gICAgfVxuICAgIFJlZ0V4cE1hdGNoZXJXcmFwcGVyLm5leHQgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5yZS5leGVjKG1hdGNoZXIuaW5wdXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ0V4cE1hdGNoZXJXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuUmVnRXhwTWF0Y2hlcldyYXBwZXIgPSBSZWdFeHBNYXRjaGVyV3JhcHBlcjtcbnZhciBGdW5jdGlvbldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uV3JhcHBlcigpIHtcbiAgICB9XG4gICAgRnVuY3Rpb25XcmFwcGVyLmFwcGx5ID0gZnVuY3Rpb24gKGZuLCBwb3NBcmdzKSB7IHJldHVybiBmbi5hcHBseShudWxsLCBwb3NBcmdzKTsgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25XcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRnVuY3Rpb25XcmFwcGVyID0gRnVuY3Rpb25XcmFwcGVyO1xuLy8gSlMgaGFzIE5hTiAhPT0gTmFOXG5mdW5jdGlvbiBsb29zZUlkZW50aWNhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XG59XG5leHBvcnRzLmxvb3NlSWRlbnRpY2FsID0gbG9vc2VJZGVudGljYWw7XG4vLyBKUyBjb25zaWRlcnMgTmFOIGlzIHRoZSBzYW1lIGFzIE5hTiBmb3IgbWFwIEtleSAod2hpbGUgTmFOICE9PSBOYU4gb3RoZXJ3aXNlKVxuLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcFxuZnVuY3Rpb24gZ2V0TWFwS2V5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5nZXRNYXBLZXkgPSBnZXRNYXBLZXk7XG5mdW5jdGlvbiBub3JtYWxpemVCbGFuayhvYmopIHtcbiAgICByZXR1cm4gaXNCbGFuayhvYmopID8gbnVsbCA6IG9iajtcbn1cbmV4cG9ydHMubm9ybWFsaXplQmxhbmsgPSBub3JtYWxpemVCbGFuaztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJvb2wob2JqKSB7XG4gICAgcmV0dXJuIGlzQmxhbmsob2JqKSA/IGZhbHNlIDogb2JqO1xufVxuZXhwb3J0cy5ub3JtYWxpemVCb29sID0gbm9ybWFsaXplQm9vbDtcbmZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvID09PSBcIm9iamVjdFwiKTtcbn1cbmV4cG9ydHMuaXNKc09iamVjdCA9IGlzSnNPYmplY3Q7XG5mdW5jdGlvbiBwcmludChvYmopIHtcbiAgICBjb25zb2xlLmxvZyhvYmopO1xufVxuZXhwb3J0cy5wcmludCA9IHByaW50O1xuZnVuY3Rpb24gd2FybihvYmopIHtcbiAgICBjb25zb2xlLndhcm4ob2JqKTtcbn1cbmV4cG9ydHMud2FybiA9IHdhcm47XG4vLyBDYW4ndCBiZSBhbGwgdXBwZXJjYXNlIGFzIG91ciB0cmFuc3BpbGVyIHdvdWxkIHRoaW5rIGl0IGlzIGEgc3BlY2lhbCBkaXJlY3RpdmUuLi5cbnZhciBKc29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKc29uKCkge1xuICAgIH1cbiAgICBKc29uLnBhcnNlID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF9nbG9iYWwuSlNPTi5wYXJzZShzKTsgfTtcbiAgICBKc29uLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIERhcnQgZG9lc24ndCB0YWtlIDMgYXJndW1lbnRzXG4gICAgICAgIHJldHVybiBfZ2xvYmFsLkpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb247XG59KCkpO1xuZXhwb3J0cy5Kc29uID0gSnNvbjtcbnZhciBEYXRlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVdyYXBwZXIoKSB7XG4gICAgfVxuICAgIERhdGVXcmFwcGVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgaWYgKG1vbnRoID09PSB2b2lkIDApIHsgbW9udGggPSAxOyB9XG4gICAgICAgIGlmIChkYXkgPT09IHZvaWQgMCkgeyBkYXkgPSAxOyB9XG4gICAgICAgIGlmIChob3VyID09PSB2b2lkIDApIHsgaG91ciA9IDA7IH1cbiAgICAgICAgaWYgKG1pbnV0ZXMgPT09IHZvaWQgMCkgeyBtaW51dGVzID0gMDsgfVxuICAgICAgICBpZiAoc2Vjb25kcyA9PT0gdm9pZCAwKSB7IHNlY29uZHMgPSAwOyB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMgPT09IHZvaWQgMCkgeyBtaWxsaXNlY29uZHMgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpO1xuICAgIH07XG4gICAgRGF0ZVdyYXBwZXIuZnJvbUlTT1N0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoc3RyKTsgfTtcbiAgICBEYXRlV3JhcHBlci5mcm9tTWlsbGlzID0gZnVuY3Rpb24gKG1zKSB7IHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKG1zKTsgfTtcbiAgICBEYXRlV3JhcHBlci50b01pbGxpcyA9IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfTtcbiAgICBEYXRlV3JhcHBlci5ub3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKCk7IH07XG4gICAgRGF0ZVdyYXBwZXIudG9Kc29uID0gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUudG9KU09OKCk7IH07XG4gICAgcmV0dXJuIERhdGVXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRGF0ZVdyYXBwZXIgPSBEYXRlV3JhcHBlcjtcbmZ1bmN0aW9uIHNldFZhbHVlT25QYXRoKGdsb2JhbCwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIG9iaiA9IGdsb2JhbDtcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNQcmVzZW50KG9ialtuYW1lXSkpIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgfVxuICAgIG9ialtwYXJ0cy5zaGlmdCgpXSA9IHZhbHVlO1xufVxuZXhwb3J0cy5zZXRWYWx1ZU9uUGF0aCA9IHNldFZhbHVlT25QYXRoO1xudmFyIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XG5mdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICBpZiAoaXNCbGFuayhfc3ltYm9sSXRlcmF0b3IpKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZ2xvYmFsU2NvcGUuU3ltYm9sKSAmJiBpc1ByZXNlbnQoU3ltYm9sLml0ZXJhdG9yKSkge1xuICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXM2LXNoaW0gc3BlY2lmaWMgbG9naWNcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtrZXldID09PSBNYXAucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3N5bWJvbEl0ZXJhdG9yO1xufVxuZXhwb3J0cy5nZXRTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbEl0ZXJhdG9yO1xuZnVuY3Rpb24gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsLCBleHByLCBkZWNsYXJhdGlvbnMsIHZhcnMpIHtcbiAgICB2YXIgZm5Cb2R5ID0gZGVjbGFyYXRpb25zICsgXCJcXG5yZXR1cm4gXCIgKyBleHByICsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgc291cmNlVXJsO1xuICAgIHZhciBmbkFyZ05hbWVzID0gW107XG4gICAgdmFyIGZuQXJnVmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgYXJnTmFtZSBpbiB2YXJzKSB7XG4gICAgICAgIGZuQXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgW3ZvaWQgMF0uY29uY2F0KGZuQXJnTmFtZXMuY29uY2F0KGZuQm9keSkpKSkoKS5hcHBseSh2b2lkIDAsIGZuQXJnVmFsdWVzKTtcbn1cbmV4cG9ydHMuZXZhbEV4cHJlc3Npb24gPSBldmFsRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZnVuY3Rpb24gaGFzQ29uc3RydWN0b3IodmFsdWUsIHR5cGUpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IHR5cGU7XG59XG5leHBvcnRzLmhhc0NvbnN0cnVjdG9yID0gaGFzQ29uc3RydWN0b3I7XG5mdW5jdGlvbiBiaXRXaXNlT3IodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgfCBiOyB9KTtcbn1cbmV4cG9ydHMuYml0V2lzZU9yID0gYml0V2lzZU9yO1xuZnVuY3Rpb24gYml0V2lzZUFuZCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAmIGI7IH0pO1xufVxuZXhwb3J0cy5iaXRXaXNlQW5kID0gYml0V2lzZUFuZDtcbmZ1bmN0aW9uIGVzY2FwZShzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWwuZW5jb2RlVVJJKHMpO1xufVxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFByb21pc2VDb21wbGV0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb21pc2VDb21wbGV0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIF90aGlzLnJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlQ29tcGxldGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvbWlzZUNvbXBsZXRlciA9IFByb21pc2VDb21wbGV0ZXI7XG52YXIgUHJvbWlzZVdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb21pc2VXcmFwcGVyKCkge1xuICAgIH1cbiAgICBQcm9taXNlV3JhcHBlci5yZXNvbHZlID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iaik7IH07XG4gICAgUHJvbWlzZVdyYXBwZXIucmVqZWN0ID0gZnVuY3Rpb24gKG9iaiwgXykgeyByZXR1cm4gUHJvbWlzZS5yZWplY3Qob2JqKTsgfTtcbiAgICAvLyBOb3RlOiBXZSBjYW4ndCByZW5hbWUgdGhpcyBtZXRob2QgaW50byBgY2F0Y2hgLCBhcyB0aGlzIGlzIG5vdCBhIHZhbGlkXG4gICAgLy8gbWV0aG9kIG5hbWUgaW4gRGFydC5cbiAgICBQcm9taXNlV3JhcHBlci5jYXRjaEVycm9yID0gZnVuY3Rpb24gKHByb21pc2UsIG9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuY2F0Y2gob25FcnJvcik7XG4gICAgfTtcbiAgICBQcm9taXNlV3JhcHBlci5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfTtcbiAgICBQcm9taXNlV3JhcHBlci50aGVuID0gZnVuY3Rpb24gKHByb21pc2UsIHN1Y2Nlc3MsIHJlamVjdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHN1Y2Nlc3MsIHJlamVjdGlvbik7XG4gICAgfTtcbiAgICBQcm9taXNlV3JhcHBlci53cmFwID0gZnVuY3Rpb24gKGNvbXB1dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzKGNvbXB1dGF0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWooZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJvbWlzZVdyYXBwZXIuc2NoZWR1bGVNaWNyb3Rhc2sgPSBmdW5jdGlvbiAoY29tcHV0YXRpb24pIHtcbiAgICAgICAgUHJvbWlzZVdyYXBwZXIudGhlbihQcm9taXNlV3JhcHBlci5yZXNvbHZlKG51bGwpLCBjb21wdXRhdGlvbiwgZnVuY3Rpb24gKF8pIHsgfSk7XG4gICAgfTtcbiAgICBQcm9taXNlV3JhcHBlci5pc1Byb21pc2UgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogaW5zdGFuY2VvZiBQcm9taXNlOyB9O1xuICAgIFByb21pc2VXcmFwcGVyLmNvbXBsZXRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBQcm9taXNlQ29tcGxldGVyKCk7IH07XG4gICAgcmV0dXJuIFByb21pc2VXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvbWlzZVdyYXBwZXIgPSBQcm9taXNlV3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiogQG1vZHVsZVxuKiBAZGVzY3JpcHRpb25cbiogVGhpcyBtb2R1bGUgaXMgdXNlZCBmb3IgaGFuZGxpbmcgdXNlciBpbnB1dCwgYnkgZGVmaW5pbmcgYW5kIGJ1aWxkaW5nIGEge0BsaW5rIENvbnRyb2xHcm91cH0gdGhhdFxuKiBjb25zaXN0cyBvZlxuKiB7QGxpbmsgQ29udHJvbH0gb2JqZWN0cywgYW5kIG1hcHBpbmcgdGhlbSBvbnRvIHRoZSBET00uIHtAbGluayBDb250cm9sfSBvYmplY3RzIGNhbiB0aGVuIGJlIHVzZWRcbiogdG8gcmVhZCBpbmZvcm1hdGlvblxuKiBmcm9tIHRoZSBmb3JtIERPTSBlbGVtZW50cy5cbipcbiogRm9ybXMgcHJvdmlkZXJzIGFyZSBub3QgaW5jbHVkZWQgaW4gZGVmYXVsdCBwcm92aWRlcnM7IHlvdSBtdXN0IGltcG9ydCB0aGVzZSBwcm92aWRlcnNcbiogZXhwbGljaXRseS5cbiovXG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoJy4vZm9ybXMvbW9kZWwnKTtcbmV4cG9ydHMuQWJzdHJhY3RDb250cm9sID0gbW9kZWxfMS5BYnN0cmFjdENvbnRyb2w7XG5leHBvcnRzLkNvbnRyb2wgPSBtb2RlbF8xLkNvbnRyb2w7XG5leHBvcnRzLkNvbnRyb2xHcm91cCA9IG1vZGVsXzEuQ29udHJvbEdyb3VwO1xuZXhwb3J0cy5Db250cm9sQXJyYXkgPSBtb2RlbF8xLkNvbnRyb2xBcnJheTtcbnZhciBhYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZV8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL2Fic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlJyk7XG5leHBvcnRzLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IGFic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlXzEuQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlO1xudmFyIGNvbnRyb2xfY29udGFpbmVyXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvY29udHJvbF9jb250YWluZXInKTtcbmV4cG9ydHMuQ29udHJvbENvbnRhaW5lciA9IGNvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lcjtcbnZhciBuZ19jb250cm9sX25hbWVfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX25hbWUnKTtcbmV4cG9ydHMuTmdDb250cm9sTmFtZSA9IG5nX2NvbnRyb2xfbmFtZV8xLk5nQ29udHJvbE5hbWU7XG52YXIgbmdfZm9ybV9jb250cm9sXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfZm9ybV9jb250cm9sJyk7XG5leHBvcnRzLk5nRm9ybUNvbnRyb2wgPSBuZ19mb3JtX2NvbnRyb2xfMS5OZ0Zvcm1Db250cm9sO1xudmFyIG5nX21vZGVsXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfbW9kZWwnKTtcbmV4cG9ydHMuTmdNb2RlbCA9IG5nX21vZGVsXzEuTmdNb2RlbDtcbnZhciBuZ19jb250cm9sXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvbmdfY29udHJvbCcpO1xuZXhwb3J0cy5OZ0NvbnRyb2wgPSBuZ19jb250cm9sXzEuTmdDb250cm9sO1xudmFyIG5nX2NvbnRyb2xfZ3JvdXBfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX2dyb3VwJyk7XG5leHBvcnRzLk5nQ29udHJvbEdyb3VwID0gbmdfY29udHJvbF9ncm91cF8xLk5nQ29udHJvbEdyb3VwO1xudmFyIG5nX2Zvcm1fbW9kZWxfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtX21vZGVsJyk7XG5leHBvcnRzLk5nRm9ybU1vZGVsID0gbmdfZm9ybV9tb2RlbF8xLk5nRm9ybU1vZGVsO1xudmFyIG5nX2Zvcm1fMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19mb3JtJyk7XG5leHBvcnRzLk5nRm9ybSA9IG5nX2Zvcm1fMS5OZ0Zvcm07XG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcbmV4cG9ydHMuTkdfVkFMVUVfQUNDRVNTT1IgPSBjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1I7XG52YXIgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL2RlZmF1bHRfdmFsdWVfYWNjZXNzb3InKTtcbmV4cG9ydHMuRGVmYXVsdFZhbHVlQWNjZXNzb3IgPSBkZWZhdWx0X3ZhbHVlX2FjY2Vzc29yXzEuRGVmYXVsdFZhbHVlQWNjZXNzb3I7XG52YXIgbmdfY29udHJvbF9zdGF0dXNfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9uZ19jb250cm9sX3N0YXR1cycpO1xuZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXMgPSBuZ19jb250cm9sX3N0YXR1c18xLk5nQ29udHJvbFN0YXR1cztcbnZhciBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9mb3Jtcy9kaXJlY3RpdmVzL2NoZWNrYm94X3ZhbHVlX2FjY2Vzc29yJyk7XG5leHBvcnRzLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8xLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xuZXhwb3J0cy5OZ1NlbGVjdE9wdGlvbiA9IHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTmdTZWxlY3RPcHRpb247XG5leHBvcnRzLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcbnZhciBkaXJlY3RpdmVzXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMnKTtcbmV4cG9ydHMuRk9STV9ESVJFQ1RJVkVTID0gZGlyZWN0aXZlc18xLkZPUk1fRElSRUNUSVZFUztcbmV4cG9ydHMuUmFkaW9CdXR0b25TdGF0ZSA9IGRpcmVjdGl2ZXNfMS5SYWRpb0J1dHRvblN0YXRlO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoJy4vZm9ybXMvdmFsaWRhdG9ycycpO1xuZXhwb3J0cy5OR19WQUxJREFUT1JTID0gdmFsaWRhdG9yc18xLk5HX1ZBTElEQVRPUlM7XG5leHBvcnRzLk5HX0FTWU5DX1ZBTElEQVRPUlMgPSB2YWxpZGF0b3JzXzEuTkdfQVNZTkNfVkFMSURBVE9SUztcbmV4cG9ydHMuVmFsaWRhdG9ycyA9IHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzO1xudmFyIHZhbGlkYXRvcnNfMiA9IHJlcXVpcmUoJy4vZm9ybXMvZGlyZWN0aXZlcy92YWxpZGF0b3JzJyk7XG5leHBvcnRzLlJlcXVpcmVkVmFsaWRhdG9yID0gdmFsaWRhdG9yc18yLlJlcXVpcmVkVmFsaWRhdG9yO1xuZXhwb3J0cy5NaW5MZW5ndGhWYWxpZGF0b3IgPSB2YWxpZGF0b3JzXzIuTWluTGVuZ3RoVmFsaWRhdG9yO1xuZXhwb3J0cy5NYXhMZW5ndGhWYWxpZGF0b3IgPSB2YWxpZGF0b3JzXzIuTWF4TGVuZ3RoVmFsaWRhdG9yO1xuZXhwb3J0cy5QYXR0ZXJuVmFsaWRhdG9yID0gdmFsaWRhdG9yc18yLlBhdHRlcm5WYWxpZGF0b3I7XG52YXIgZm9ybV9idWlsZGVyXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2Zvcm1fYnVpbGRlcicpO1xuZXhwb3J0cy5Gb3JtQnVpbGRlciA9IGZvcm1fYnVpbGRlcl8xLkZvcm1CdWlsZGVyO1xudmFyIGZvcm1fYnVpbGRlcl8yID0gcmVxdWlyZSgnLi9mb3Jtcy9mb3JtX2J1aWxkZXInKTtcbnZhciByYWRpb19jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2Zvcm1zL2RpcmVjdGl2ZXMvcmFkaW9fY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xuLyoqXG4gKiBTaG9ydGhhbmQgc2V0IG9mIHByb3ZpZGVycyB1c2VkIGZvciBidWlsZGluZyBBbmd1bGFyIGZvcm1zLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogYm9vdHN0cmFwKE15QXBwLCBbRk9STV9QUk9WSURFUlNdKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLkZPUk1fUFJPVklERVJTID0gW2Zvcm1fYnVpbGRlcl8yLkZvcm1CdWlsZGVyLCByYWRpb19jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuUmFkaW9Db250cm9sUmVnaXN0cnldO1xuLyoqXG4gKiBTZWUge0BsaW5rIEZPUk1fUFJPVklERVJTfSBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuRk9STV9CSU5ESU5HUyA9IGV4cG9ydHMuRk9STV9QUk9WSURFUlM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3Jtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBuZ19jb250cm9sX25hbWVfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jb250cm9sX25hbWUnKTtcbnZhciBuZ19mb3JtX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19mb3JtX2NvbnRyb2wnKTtcbnZhciBuZ19tb2RlbF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX21vZGVsJyk7XG52YXIgbmdfY29udHJvbF9ncm91cF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NvbnRyb2xfZ3JvdXAnKTtcbnZhciBuZ19mb3JtX21vZGVsXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfZm9ybV9tb2RlbCcpO1xudmFyIG5nX2Zvcm1fMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19mb3JtJyk7XG52YXIgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2RlZmF1bHRfdmFsdWVfYWNjZXNzb3InKTtcbnZhciBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2NoZWNrYm94X3ZhbHVlX2FjY2Vzc29yJyk7XG52YXIgbnVtYmVyX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbnVtYmVyX3ZhbHVlX2FjY2Vzc29yJyk7XG52YXIgcmFkaW9fY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL3JhZGlvX2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcbnZhciBuZ19jb250cm9sX3N0YXR1c18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NvbnRyb2xfc3RhdHVzJyk7XG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xudmFyIHZhbGlkYXRvcnNfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy92YWxpZGF0b3JzJyk7XG52YXIgbmdfY29udHJvbF9uYW1lXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9uYW1lJyk7XG5leHBvcnRzLk5nQ29udHJvbE5hbWUgPSBuZ19jb250cm9sX25hbWVfMi5OZ0NvbnRyb2xOYW1lO1xudmFyIG5nX2Zvcm1fY29udHJvbF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm1fY29udHJvbCcpO1xuZXhwb3J0cy5OZ0Zvcm1Db250cm9sID0gbmdfZm9ybV9jb250cm9sXzIuTmdGb3JtQ29udHJvbDtcbnZhciBuZ19tb2RlbF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX21vZGVsJyk7XG5leHBvcnRzLk5nTW9kZWwgPSBuZ19tb2RlbF8yLk5nTW9kZWw7XG52YXIgbmdfY29udHJvbF9ncm91cF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2NvbnRyb2xfZ3JvdXAnKTtcbmV4cG9ydHMuTmdDb250cm9sR3JvdXAgPSBuZ19jb250cm9sX2dyb3VwXzIuTmdDb250cm9sR3JvdXA7XG52YXIgbmdfZm9ybV9tb2RlbF8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm1fbW9kZWwnKTtcbmV4cG9ydHMuTmdGb3JtTW9kZWwgPSBuZ19mb3JtX21vZGVsXzIuTmdGb3JtTW9kZWw7XG52YXIgbmdfZm9ybV8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL25nX2Zvcm0nKTtcbmV4cG9ydHMuTmdGb3JtID0gbmdfZm9ybV8yLk5nRm9ybTtcbnZhciBkZWZhdWx0X3ZhbHVlX2FjY2Vzc29yXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZGVmYXVsdF92YWx1ZV9hY2Nlc3NvcicpO1xuZXhwb3J0cy5EZWZhdWx0VmFsdWVBY2Nlc3NvciA9IGRlZmF1bHRfdmFsdWVfYWNjZXNzb3JfMi5EZWZhdWx0VmFsdWVBY2Nlc3NvcjtcbnZhciBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2NoZWNrYm94X3ZhbHVlX2FjY2Vzc29yJyk7XG5leHBvcnRzLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBjaGVja2JveF92YWx1ZV9hY2Nlc3Nvcl8yLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG52YXIgcmFkaW9fY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8yID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL3JhZGlvX2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcbmV4cG9ydHMuUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IHJhZGlvX2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMi5SYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuZXhwb3J0cy5SYWRpb0J1dHRvblN0YXRlID0gcmFkaW9fY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8yLlJhZGlvQnV0dG9uU3RhdGU7XG52YXIgbnVtYmVyX3ZhbHVlX2FjY2Vzc29yXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbnVtYmVyX3ZhbHVlX2FjY2Vzc29yJyk7XG5leHBvcnRzLk51bWJlclZhbHVlQWNjZXNzb3IgPSBudW1iZXJfdmFsdWVfYWNjZXNzb3JfMi5OdW1iZXJWYWx1ZUFjY2Vzc29yO1xudmFyIG5nX2NvbnRyb2xfc3RhdHVzXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvbmdfY29udHJvbF9zdGF0dXMnKTtcbmV4cG9ydHMuTmdDb250cm9sU3RhdHVzID0gbmdfY29udHJvbF9zdGF0dXNfMi5OZ0NvbnRyb2xTdGF0dXM7XG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMiA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xuZXhwb3J0cy5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzIuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XG5leHBvcnRzLk5nU2VsZWN0T3B0aW9uID0gc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMi5OZ1NlbGVjdE9wdGlvbjtcbnZhciB2YWxpZGF0b3JzXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycycpO1xuZXhwb3J0cy5SZXF1aXJlZFZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMi5SZXF1aXJlZFZhbGlkYXRvcjtcbmV4cG9ydHMuTWluTGVuZ3RoVmFsaWRhdG9yID0gdmFsaWRhdG9yc18yLk1pbkxlbmd0aFZhbGlkYXRvcjtcbmV4cG9ydHMuTWF4TGVuZ3RoVmFsaWRhdG9yID0gdmFsaWRhdG9yc18yLk1heExlbmd0aFZhbGlkYXRvcjtcbmV4cG9ydHMuUGF0dGVyblZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMi5QYXR0ZXJuVmFsaWRhdG9yO1xudmFyIG5nX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9uZ19jb250cm9sJyk7XG5leHBvcnRzLk5nQ29udHJvbCA9IG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2w7XG4vKipcbiAqXG4gKiBBIGxpc3Qgb2YgYWxsIHRoZSBmb3JtIGRpcmVjdGl2ZXMgdXNlZCBhcyBwYXJ0IG9mIGEgYEBDb21wb25lbnRgIGFubm90YXRpb24uXG4gKlxuICogIFRoaXMgaXMgYSBzaG9ydGhhbmQgZm9yIGltcG9ydGluZyB0aGVtIGVhY2ggaW5kaXZpZHVhbGx5LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgZGlyZWN0aXZlczogW0ZPUk1fRElSRUNUSVZFU11cbiAqIH0pXG4gKiBjbGFzcyBNeUFwcCB7fVxuICogYGBgXG4gKi9cbmV4cG9ydHMuRk9STV9ESVJFQ1RJVkVTID0gW1xuICAgIG5nX2NvbnRyb2xfbmFtZV8xLk5nQ29udHJvbE5hbWUsXG4gICAgbmdfY29udHJvbF9ncm91cF8xLk5nQ29udHJvbEdyb3VwLFxuICAgIG5nX2Zvcm1fY29udHJvbF8xLk5nRm9ybUNvbnRyb2wsXG4gICAgbmdfbW9kZWxfMS5OZ01vZGVsLFxuICAgIG5nX2Zvcm1fbW9kZWxfMS5OZ0Zvcm1Nb2RlbCxcbiAgICBuZ19mb3JtXzEuTmdGb3JtLFxuICAgIHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTmdTZWxlY3RPcHRpb24sXG4gICAgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xLkRlZmF1bHRWYWx1ZUFjY2Vzc29yLFxuICAgIG51bWJlcl92YWx1ZV9hY2Nlc3Nvcl8xLk51bWJlclZhbHVlQWNjZXNzb3IsXG4gICAgY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMS5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIHNlbGVjdF9jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgcmFkaW9fY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLlJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgbmdfY29udHJvbF9zdGF0dXNfMS5OZ0NvbnRyb2xTdGF0dXMsXG4gICAgdmFsaWRhdG9yc18xLlJlcXVpcmVkVmFsaWRhdG9yLFxuICAgIHZhbGlkYXRvcnNfMS5NaW5MZW5ndGhWYWxpZGF0b3IsXG4gICAgdmFsaWRhdG9yc18xLk1heExlbmd0aFZhbGlkYXRvcixcbiAgICB2YWxpZGF0b3JzXzEuUGF0dGVyblZhbGlkYXRvclxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnRyb2wgZGlyZWN0aXZlcy5cbiAqXG4gKiBPbmx5IHVzZWQgaW50ZXJuYWxseSBpbiB0aGUgZm9ybXMgbW9kdWxlLlxuICovXG52YXIgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudmFsdWUgOiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnZhbGlkIDogbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLmVycm9ycyA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wucHJpc3RpbmUgOiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLmRpcnR5IDogbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG91Y2hlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnRvdWNoZWQgOiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC51bnRvdWNoZWQgOiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlO1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlID0gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xuZXhwb3J0cy5DSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25DaGFuZ2UgPSBmbjsgfTtcbiAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW25nQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bbmdGb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LmNoZWNrZWQpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZXhwb3J0cy5DSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlJlbmRlcmVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG59KCkpO1xuZXhwb3J0cy5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmVfMSA9IHJlcXVpcmUoJy4vYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmUnKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBjb250YWlucyBtdWx0aXBsZSB7QGxpbmsgTmdDb250cm9sfXMuXG4gKlxuICogT25seSB1c2VkIGJ5IHRoZSBmb3JtcyBtb2R1bGUuXG4gKi9cbnZhciBDb250cm9sQ29udGFpbmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udHJvbENvbnRhaW5lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250cm9sQ29udGFpbmVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmb3JtIHRvIHdoaWNoIHRoaXMgY29udGFpbmVyIGJlbG9uZ3MuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQ29udGFpbmVyLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgcGF0aCB0byB0aGlzIGNvbnRhaW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnRyb2xDb250YWluZXI7XG59KGFic3RyYWN0X2NvbnRyb2xfZGlyZWN0aXZlXzEuQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKSk7XG5leHBvcnRzLkNvbnRyb2xDb250YWluZXIgPSBDb250cm9sQ29udGFpbmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbF9jb250YWluZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xuLyoqXG4gKiBVc2VkIHRvIHByb3ZpZGUgYSB7QGxpbmsgQ29udHJvbFZhbHVlQWNjZXNzb3J9IGZvciBmb3JtIGNvbnRyb2xzLlxuICpcbiAqIFNlZSB7QGxpbmsgRGVmYXVsdFZhbHVlQWNjZXNzb3J9IGZvciBob3cgdG8gaW1wbGVtZW50IG9uZS5cbiAqL1xuZXhwb3J0cy5OR19WQUxVRV9BQ0NFU1NPUiA9IFxuLypAdHMyZGFydF9jb25zdCovIG5ldyBjb3JlXzEuT3BhcXVlVG9rZW4oXCJOZ1ZhbHVlQWNjZXNzb3JcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sX3ZhbHVlX2FjY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcbmV4cG9ydHMuREVGQVVMVF9WQUxVRV9BQ0NFU1NPUiA9IFxuLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8ge1xuICAgIHByb3ZpZGU6IGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVmYXVsdFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIERlZmF1bHRWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0VmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IGxhbmdfMS5pc0JsYW5rKHZhbHVlKSA/ICcnIDogdmFsdWU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgfTtcbiAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XG4gICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW25nQ29udHJvbF0sdGV4dGFyZWFbbmdDb250cm9sXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtuZ0Zvcm1Db250cm9sXSx0ZXh0YXJlYVtuZ0Zvcm1Db250cm9sXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtuZ01vZGVsXSx0ZXh0YXJlYVtuZ01vZGVsXSxbbmdEZWZhdWx0Q29udHJvbF0nLFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB2c2F2a2luIHJlcGxhY2UgdGhlIGFib3ZlIHNlbGVjdG9yIHdpdGggdGhlIG9uZSBiZWxvdyBpdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMwMTEgaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0b3I6ICdbbmdDb250cm9sXSxbbmdNb2RlbF0sW25nRm9ybUNvbnRyb2xdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzOiBbZXhwb3J0cy5ERUZBVUxUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlJlbmRlcmVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xufSgpKTtcbmV4cG9ydHMuRGVmYXVsdFZhbHVlQWNjZXNzb3IgPSBEZWZhdWx0VmFsdWVBY2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRfdmFsdWVfYWNjZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBhYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZV8xID0gcmVxdWlyZSgnLi9hYnN0cmFjdF9jb250cm9sX2RpcmVjdGl2ZScpO1xuLyoqXG4gKiBBIGJhc2UgY2xhc3MgdGhhdCBhbGwgY29udHJvbCBkaXJlY3RpdmUgZXh0ZW5kLlxuICogSXQgYmluZHMgYSB7QGxpbmsgQ29udHJvbH0gb2JqZWN0IHRvIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogVXNlZCBpbnRlcm5hbGx5IGJ5IEFuZ3VsYXIgZm9ybXMuXG4gKi9cbnZhciBOZ0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZ0NvbnRyb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmdDb250cm9sKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE5nQ29udHJvbDtcbn0oYWJzdHJhY3RfY29udHJvbF9kaXJlY3RpdmVfMS5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUpKTtcbmV4cG9ydHMuTmdDb250cm9sID0gTmdDb250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfY29udHJvbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb250cm9sX2NvbnRhaW5lcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX2NvbnRhaW5lcicpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XG5leHBvcnRzLmNvbnRyb2xHcm91cFByb3ZpZGVyID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8ge1xuICAgIHByb3ZpZGU6IGNvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lcixcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdDb250cm9sR3JvdXA7IH0pXG59O1xudmFyIE5nQ29udHJvbEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmdDb250cm9sR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmdDb250cm9sR3JvdXAocGFyZW50LCBfdmFsaWRhdG9ycywgX2FzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IF92YWxpZGF0b3JzO1xuICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBfYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIE5nQ29udHJvbEdyb3VwLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2xHcm91cCh0aGlzKTsgfTtcbiAgICBOZ0NvbnRyb2xHcm91cC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sR3JvdXAodGhpcyk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbEdyb3VwLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUge0BsaW5rIENvbnRyb2xHcm91cH0gYmFja2luZyB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRDb250cm9sR3JvdXAodGhpcyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xHcm91cC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHBhdGggdG8gdGhpcyBjb250cm9sIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRfMS5jb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xHcm91cC5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHtAbGluayBGb3JtfSB0byB3aGljaCB0aGlzIGdyb3VwIGJlbG9uZ3MuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sR3JvdXAucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzEuY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xHcm91cC5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZF8xLmNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fYXN5bmNWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTmdDb250cm9sR3JvdXAuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ0NvbnRyb2xHcm91cF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLmNvbnRyb2xHcm91cFByb3ZpZGVyXSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbJ25hbWU6IG5nQ29udHJvbEdyb3VwJ10sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTmdDb250cm9sR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuSG9zdCB9LCB7IHR5cGU6IGNvcmVfMS5Ta2lwU2VsZiB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5PcHRpb25hbCB9LCB7IHR5cGU6IGNvcmVfMS5TZWxmIH0sIHsgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW3ZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuU2VsZiB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFt2YWxpZGF0b3JzXzEuTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIE5nQ29udHJvbEdyb3VwO1xufShjb250cm9sX2NvbnRhaW5lcl8xLkNvbnRyb2xDb250YWluZXIpKTtcbmV4cG9ydHMuTmdDb250cm9sR3JvdXAgPSBOZ0NvbnRyb2xHcm91cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2NvbnRyb2xfZ3JvdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvYXN5bmMnKTtcbnZhciBjb250cm9sX2NvbnRhaW5lcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX2NvbnRhaW5lcicpO1xudmFyIG5nX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vbmdfY29udHJvbCcpO1xudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XG5leHBvcnRzLmNvbnRyb2xOYW1lQmluZGluZyA9IFxuLypAdHMyZGFydF9jb25zdCovIC8qIEB0czJkYXJ0X1Byb3ZpZGVyICovIHtcbiAgICBwcm92aWRlOiBuZ19jb250cm9sXzEuTmdDb250cm9sLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0NvbnRyb2xOYW1lOyB9KVxufTtcbnZhciBOZ0NvbnRyb2xOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmdDb250cm9sTmFtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZ0NvbnRyb2xOYW1lKF9wYXJlbnQsIF92YWxpZGF0b3JzLCBfYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IF92YWxpZGF0b3JzO1xuICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBfYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNoYXJlZF8xLnNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgIH1cbiAgICBOZ0NvbnRyb2xOYW1lLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZWRfMS5pc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS51cGRhdGVNb2RlbCh0aGlzLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTmdDb250cm9sTmFtZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpOyB9O1xuICAgIE5nQ29udHJvbE5hbWUucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgIGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuY2FsbEVtaXQodGhpcy51cGRhdGUsIG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRfMS5jb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbE5hbWUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzEuY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzEuY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sTmFtZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldENvbnRyb2wodGhpcyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5nQ29udHJvbE5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ0NvbnRyb2xdJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3M6IFtleHBvcnRzLmNvbnRyb2xOYW1lQmluZGluZ10sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWyduYW1lOiBuZ0NvbnRyb2wnLCAnbW9kZWw6IG5nTW9kZWwnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWyd1cGRhdGU6IG5nTW9kZWxDaGFuZ2UnXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ0Zvcm0nXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBOZ0NvbnRyb2xOYW1lLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGNvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLkhvc3QgfSwgeyB0eXBlOiBjb3JlXzEuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuU2VsZiB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFt2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLk9wdGlvbmFsIH0sIHsgdHlwZTogY29yZV8xLlNlbGYgfSwgeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbdmFsaWRhdG9yc18xLk5HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5PcHRpb25hbCB9LCB7IHR5cGU6IGNvcmVfMS5TZWxmIH0sIHsgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5OR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIE5nQ29udHJvbE5hbWU7XG59KG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wpKTtcbmV4cG9ydHMuTmdDb250cm9sTmFtZSA9IE5nQ29udHJvbE5hbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19jb250cm9sX25hbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIG5nX2NvbnRyb2xfMSA9IHJlcXVpcmUoJy4vbmdfY29udHJvbCcpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIE5nQ29udHJvbFN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzKGNkKSB7XG4gICAgICAgIHRoaXMuX2NkID0gY2Q7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NVbnRvdWNoZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC51bnRvdWNoZWQgOiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1RvdWNoZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC50b3VjaGVkIDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NQcmlzdGluZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnByaXN0aW5lIDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NEaXJ0eVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLmRpcnR5IDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NWYWxpZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnZhbGlkIDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NJbnZhbGlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/ICF0aGlzLl9jZC5jb250cm9sLnZhbGlkIDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5nQ29udHJvbFN0YXR1cy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nQ29udHJvbF0sW25nTW9kZWxdLFtuZ0Zvcm1Db250cm9sXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctdW50b3VjaGVkXSc6ICduZ0NsYXNzVW50b3VjaGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctdG91Y2hlZF0nOiAnbmdDbGFzc1RvdWNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnbmdDbGFzc1ByaXN0aW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubmctZGlydHldJzogJ25nQ2xhc3NEaXJ0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXZhbGlkXSc6ICduZ0NsYXNzVmFsaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICduZ0NsYXNzSW52YWxpZCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTmdDb250cm9sU3RhdHVzLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5TZWxmIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1cztcbn0oKSk7XG5leHBvcnRzLk5nQ29udHJvbFN0YXR1cyA9IE5nQ29udHJvbFN0YXR1cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX2NvbnRyb2xfc3RhdHVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29udHJvbF9jb250YWluZXJfMSA9IHJlcXVpcmUoJy4vY29udHJvbF9jb250YWluZXInKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZSgnLi4vbW9kZWwnKTtcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xuZXhwb3J0cy5mb3JtRGlyZWN0aXZlUHJvdmlkZXIgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyB7IHByb3ZpZGU6IGNvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lciwgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nRm9ybTsgfSkgfTtcbnZhciBOZ0Zvcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZ0Zvcm0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmdGb3JtKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmZvcm0gPSBuZXcgbW9kZWxfMS5Db250cm9sR3JvdXAoe30sIG51bGwsIHNoYXJlZF8xLmNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpLCBzaGFyZWRfMS5jb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycykpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJjb250cm9sc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtLmNvbnRyb2xzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIHZhciBjdHJsID0gbmV3IG1vZGVsXzEuQ29udHJvbCgpO1xuICAgICAgICAgICAgc2hhcmVkXzEuc2V0VXBDb250cm9sKGN0cmwsIGRpcik7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ29udHJvbChkaXIubmFtZSwgY3RybCk7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Q29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5maW5kKGRpci5wYXRoKTsgfTtcbiAgICBOZ0Zvcm0ucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5nRm9ybS5wcm90b3R5cGUuYWRkQ29udHJvbEdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3luY18xLlByb21pc2VXcmFwcGVyLnNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgbW9kZWxfMS5Db250cm9sR3JvdXAoe30pO1xuICAgICAgICAgICAgc2hhcmVkXzEuc2V0VXBDb250cm9sR3JvdXAoZ3JvdXAsIGRpcik7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ29udHJvbChkaXIubmFtZSwgZ3JvdXApO1xuICAgICAgICAgICAgZ3JvdXAudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTmdGb3JtLnByb3RvdHlwZS5yZW1vdmVDb250cm9sR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Q29udHJvbEdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xuICAgIH07XG4gICAgTmdGb3JtLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChkaXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSBfdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTmdGb3JtLnByb3RvdHlwZS5vblN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsRW1pdCh0aGlzLm5nU3VibWl0LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIE5nRm9ybS5wcm90b3R5cGUuX2ZpbmRDb250YWluZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkocGF0aCkgPyB0aGlzLmZvcm0gOiB0aGlzLmZvcm0uZmluZChwYXRoKTtcbiAgICB9O1xuICAgIE5nRm9ybS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybTpub3QoW25nTm9Gb3JtXSk6bm90KFtuZ0Zvcm1Nb2RlbF0pLG5nRm9ybSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzOiBbZXhwb3J0cy5mb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnKHN1Ym1pdCknOiAnb25TdWJtaXQoKScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbmdTdWJtaXQnXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ0Zvcm0nXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBOZ0Zvcm0uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuU2VsZiB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFt2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLk9wdGlvbmFsIH0sIHsgdHlwZTogY29yZV8xLlNlbGYgfSwgeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbdmFsaWRhdG9yc18xLk5HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBOZ0Zvcm07XG59KGNvbnRyb2xfY29udGFpbmVyXzEuQ29udHJvbENvbnRhaW5lcikpO1xuZXhwb3J0cy5OZ0Zvcm0gPSBOZ0Zvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19mb3JtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgbmdfY29udHJvbF8xID0gcmVxdWlyZSgnLi9uZ19jb250cm9sJyk7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbmV4cG9ydHMuZm9ybUNvbnRyb2xCaW5kaW5nID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8ge1xuICAgIHByb3ZpZGU6IG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nRm9ybUNvbnRyb2w7IH0pXG59O1xudmFyIE5nRm9ybUNvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZ0Zvcm1Db250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5nRm9ybUNvbnRyb2woX3ZhbGlkYXRvcnMsIF9hc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gX3ZhbGlkYXRvcnM7XG4gICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IF9hc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNoYXJlZF8xLnNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgIH1cbiAgICBOZ0Zvcm1Db250cm9sLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NvbnRyb2xDaGFuZ2VkKGNoYW5nZXMpKSB7XG4gICAgICAgICAgICBzaGFyZWRfMS5zZXRVcENvbnRyb2wodGhpcy5mb3JtLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcmVkXzEuaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0udXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm1Db250cm9sLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybUNvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzEuY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm1Db250cm9sLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzEuY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtQ29udHJvbC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOZ0Zvcm1Db250cm9sLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmNhbGxFbWl0KHRoaXMudXBkYXRlLCBuZXdWYWx1ZSk7XG4gICAgfTtcbiAgICBOZ0Zvcm1Db250cm9sLnByb3RvdHlwZS5faXNDb250cm9sQ2hhbmdlZCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhjaGFuZ2VzLCBcImZvcm1cIik7XG4gICAgfTtcbiAgICBOZ0Zvcm1Db250cm9sLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmdGb3JtQ29udHJvbF0nLFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogW2V4cG9ydHMuZm9ybUNvbnRyb2xCaW5kaW5nXSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2Zvcm06IG5nRm9ybUNvbnRyb2wnLCAnbW9kZWw6IG5nTW9kZWwnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWyd1cGRhdGU6IG5nTW9kZWxDaGFuZ2UnXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ0Zvcm0nXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICBOZ0Zvcm1Db250cm9sLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLk9wdGlvbmFsIH0sIHsgdHlwZTogY29yZV8xLlNlbGYgfSwgeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbdmFsaWRhdG9yc18xLk5HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5PcHRpb25hbCB9LCB7IHR5cGU6IGNvcmVfMS5TZWxmIH0sIHsgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW3ZhbGlkYXRvcnNfMS5OR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuU2VsZiB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFtjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1IsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBOZ0Zvcm1Db250cm9sO1xufShuZ19jb250cm9sXzEuTmdDb250cm9sKSk7XG5leHBvcnRzLk5nRm9ybUNvbnRyb2wgPSBOZ0Zvcm1Db250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmdfZm9ybV9jb250cm9sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgY29udHJvbF9jb250YWluZXJfMSA9IHJlcXVpcmUoJy4vY29udHJvbF9jb250YWluZXInKTtcbnZhciBzaGFyZWRfMSA9IHJlcXVpcmUoJy4vc2hhcmVkJyk7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xuZXhwb3J0cy5mb3JtRGlyZWN0aXZlUHJvdmlkZXIgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7XG4gICAgcHJvdmlkZTogY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0Zvcm1Nb2RlbDsgfSlcbn07XG52YXIgTmdGb3JtTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZ0Zvcm1Nb2RlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZ0Zvcm1Nb2RlbChfdmFsaWRhdG9ycywgX2FzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IF92YWxpZGF0b3JzO1xuICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBfYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1QcmVzZW50KCk7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhjaGFuZ2VzLCBcImZvcm1cIikpIHtcbiAgICAgICAgICAgIHZhciBzeW5jID0gc2hhcmVkXzEuY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0udmFsaWRhdG9yID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuY29tcG9zZShbdGhpcy5mb3JtLnZhbGlkYXRvciwgc3luY10pO1xuICAgICAgICAgICAgdmFyIGFzeW5jID0gc2hhcmVkXzEuY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLmFzeW5jVmFsaWRhdG9yID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFt0aGlzLmZvcm0uYXN5bmNWYWxpZGF0b3IsIGFzeW5jXSk7XG4gICAgICAgICAgICB0aGlzLmZvcm0udXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZURvbVZhbHVlKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtTW9kZWwucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtTW9kZWwucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZmluZChkaXIucGF0aCk7XG4gICAgICAgIHNoYXJlZF8xLnNldFVwQ29udHJvbChjdHJsLCBkaXIpO1xuICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMucHVzaChkaXIpO1xuICAgIH07XG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZmluZChkaXIucGF0aCk7IH07XG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUodGhpcy5kaXJlY3RpdmVzLCBkaXIpOyB9O1xuICAgIE5nRm9ybU1vZGVsLnByb3RvdHlwZS5hZGRDb250cm9sR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xuICAgICAgICBzaGFyZWRfMS5zZXRVcENvbnRyb2xHcm91cChjdHJsLCBkaXIpO1xuICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLnJlbW92ZUNvbnRyb2xHcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgfTtcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUuZ2V0Q29udHJvbEdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xuICAgIH07XG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLnVwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKGRpciwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZmluZChkaXIucGF0aCk7XG4gICAgICAgIGN0cmwudXBkYXRlVmFsdWUodmFsdWUpO1xuICAgIH07XG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLm9uU3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmNhbGxFbWl0KHRoaXMubmdTdWJtaXQsIG51bGwpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgTmdGb3JtTW9kZWwucHJvdG90eXBlLl91cGRhdGVEb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSBfdGhpcy5mb3JtLmZpbmQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShjdHJsLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOZ0Zvcm1Nb2RlbC5wcm90b3R5cGUuX2NoZWNrRm9ybVByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLmZvcm0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJuZ0Zvcm1Nb2RlbCBleHBlY3RzIGEgZm9ybS4gUGxlYXNlIHBhc3Mgb25lIGluLiBFeGFtcGxlOiA8Zm9ybSBbbmdGb3JtTW9kZWxdPVxcXCJteUNvb2xGb3JtXFxcIj5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nRm9ybU1vZGVsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmdGb3JtTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3M6IFtleHBvcnRzLmZvcm1EaXJlY3RpdmVQcm92aWRlcl0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydmb3JtOiBuZ0Zvcm1Nb2RlbCddLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbJ25nU3VibWl0J10sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTmdGb3JtTW9kZWwuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuU2VsZiB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFt2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLk9wdGlvbmFsIH0sIHsgdHlwZTogY29yZV8xLlNlbGYgfSwgeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbdmFsaWRhdG9yc18xLk5HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBOZ0Zvcm1Nb2RlbDtcbn0oY29udHJvbF9jb250YWluZXJfMS5Db250cm9sQ29udGFpbmVyKSk7XG5leHBvcnRzLk5nRm9ybU1vZGVsID0gTmdGb3JtTW9kZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19mb3JtX21vZGVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XG52YXIgbmdfY29udHJvbF8xID0gcmVxdWlyZSgnLi9uZ19jb250cm9sJyk7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoJy4uL21vZGVsJyk7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xudmFyIHNoYXJlZF8xID0gcmVxdWlyZSgnLi9zaGFyZWQnKTtcbmV4cG9ydHMuZm9ybUNvbnRyb2xCaW5kaW5nID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8ge1xuICAgIHByb3ZpZGU6IG5nX2NvbnRyb2xfMS5OZ0NvbnRyb2wsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nTW9kZWw7IH0pXG59O1xudmFyIE5nTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZ01vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5nTW9kZWwoX3ZhbGlkYXRvcnMsIF9hc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gX3ZhbGlkYXRvcnM7XG4gICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IF9hc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fY29udHJvbCA9IG5ldyBtb2RlbF8xLkNvbnRyb2woKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzaGFyZWRfMS5zZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICB9XG4gICAgTmdNb2RlbC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkKSB7XG4gICAgICAgICAgICBzaGFyZWRfMS5zZXRVcENvbnRyb2wodGhpcy5fY29udHJvbCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZWRfMS5pc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250cm9sOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZF8xLmNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZF8xLmNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fYXN5bmNWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTmdNb2RlbC5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsRW1pdCh0aGlzLnVwZGF0ZSwgbmV3VmFsdWUpO1xuICAgIH07XG4gICAgTmdNb2RlbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nTW9kZWxdOm5vdChbbmdDb250cm9sXSk6bm90KFtuZ0Zvcm1Db250cm9sXSknLFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogW2V4cG9ydHMuZm9ybUNvbnRyb2xCaW5kaW5nXSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbJ21vZGVsOiBuZ01vZGVsJ10sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsndXBkYXRlOiBuZ01vZGVsQ2hhbmdlJ10sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTmdNb2RlbC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5PcHRpb25hbCB9LCB7IHR5cGU6IGNvcmVfMS5TZWxmIH0sIHsgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW3ZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuU2VsZiB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFt2YWxpZGF0b3JzXzEuTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLk9wdGlvbmFsIH0sIHsgdHlwZTogY29yZV8xLlNlbGYgfSwgeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgXTtcbiAgICByZXR1cm4gTmdNb2RlbDtcbn0obmdfY29udHJvbF8xLk5nQ29udHJvbCkpO1xuZXhwb3J0cy5OZ01vZGVsID0gTmdNb2RlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX21vZGVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgIGlmICh2YWxpZGF0b3IudmFsaWRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHZhbGlkYXRvci52YWxpZGF0ZShjKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgfVxufVxuZXhwb3J0cy5ub3JtYWxpemVWYWxpZGF0b3IgPSBub3JtYWxpemVWYWxpZGF0b3I7XG5mdW5jdGlvbiBub3JtYWxpemVBc3luY1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICBpZiAodmFsaWRhdG9yLnZhbGlkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsaWRhdG9yLnZhbGlkYXRlKGMpKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgfVxufVxuZXhwb3J0cy5ub3JtYWxpemVBc3luY1ZhbGlkYXRvciA9IG5vcm1hbGl6ZUFzeW5jVmFsaWRhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplX3ZhbGlkYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9jb250cm9sX3ZhbHVlX2FjY2Vzc29yJyk7XG5leHBvcnRzLk5VTUJFUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGNvcmVfMS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE51bWJlclZhbHVlQWNjZXNzb3I7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIE51bWJlclZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE51bWJlclZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICAgIH07XG4gICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IGZuKHZhbHVlID09ICcnID8gbnVsbCA6IGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICB9O1xuICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1udW1iZXJdW25nQ29udHJvbF0saW5wdXRbdHlwZT1udW1iZXJdW25nRm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9bnVtYmVyXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogW2V4cG9ydHMuTlVNQkVSX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUmVuZGVyZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkVsZW1lbnRSZWYsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gTnVtYmVyVmFsdWVBY2Nlc3Nvcjtcbn0oKSk7XG5leHBvcnRzLk51bWJlclZhbHVlQWNjZXNzb3IgPSBOdW1iZXJWYWx1ZUFjY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyX3ZhbHVlX2FjY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBjb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcbnZhciBuZ19jb250cm9sXzEgPSByZXF1aXJlKCcuL25nX2NvbnRyb2wnKTtcbmV4cG9ydHMuUkFESU9fVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBSYWRpb0NvbnRyb2xSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFkaW9Db250cm9sUmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc29ycyA9IFtdO1xuICAgIH1cbiAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNvbnRyb2wsIGFjY2Vzc29yKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc29ycy5wdXNoKFtjb250cm9sLCBhY2Nlc3Nvcl0pO1xuICAgIH07XG4gICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY2Nlc3Nvcikge1xuICAgICAgICB2YXIgaW5kZXhUb1JlbW92ZSA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2FjY2Vzc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjY2Vzc29yc1tpXVsxXSA9PT0gYWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlQXQodGhpcy5fYWNjZXNzb3JzLCBpbmRleFRvUmVtb3ZlKTtcbiAgICB9O1xuICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgdGhpcy5fYWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmIChjWzBdLmNvbnRyb2wucm9vdCA9PT0gYWNjZXNzb3IuX2NvbnRyb2wuY29udHJvbC5yb290ICYmIGNbMV0gIT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgY1sxXS5maXJlVW5jaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIHJldHVybiBSYWRpb0NvbnRyb2xSZWdpc3RyeTtcbn0oKSk7XG5leHBvcnRzLlJhZGlvQ29udHJvbFJlZ2lzdHJ5ID0gUmFkaW9Db250cm9sUmVnaXN0cnk7XG4vKipcbiAqIFRoZSB2YWx1ZSBwcm92aWRlZCBieSB0aGUgZm9ybXMgQVBJIGZvciByYWRpbyBidXR0b25zLlxuICovXG52YXIgUmFkaW9CdXR0b25TdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFkaW9CdXR0b25TdGF0ZShjaGVja2VkLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBSYWRpb0J1dHRvblN0YXRlO1xufSgpKTtcbmV4cG9ydHMuUmFkaW9CdXR0b25TdGF0ZSA9IFJhZGlvQnV0dG9uU3RhdGU7XG52YXIgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmLCBfcmVnaXN0cnksIF9pbmplY3Rvcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IF9yZWdpc3RyeTtcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIH1cbiAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbCA9IHRoaXMuX2luamVjdG9yLmdldChuZ19jb250cm9sXzEuTmdDb250cm9sKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkuYWRkKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgIH07XG4gICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlZ2lzdHJ5LnJlbW92ZSh0aGlzKTsgfTtcbiAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdmFsdWU7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSAmJiB2YWx1ZS5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2hlY2tlZCcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbihuZXcgUmFkaW9CdXR0b25TdGF0ZSh0cnVlLCBfdGhpcy5fc3RhdGUudmFsdWUpKTtcbiAgICAgICAgICAgIF90aGlzLl9yZWdpc3RyeS5zZWxlY3QoX3RoaXMpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuZmlyZVVuY2hlY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2ZuKG5ldyBSYWRpb0J1dHRvblN0YXRlKGZhbHNlLCB0aGlzLl9zdGF0ZS52YWx1ZSkpOyB9O1xuICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1yYWRpb11bbmdDb250cm9sXSxpbnB1dFt0eXBlPXJhZGlvXVtuZ0Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhZGlvXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLlJBRElPX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUmVuZGVyZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogUmFkaW9Db250cm9sUmVnaXN0cnksIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdG9yLCB9LFxuICAgIF07XG4gICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBjb3JlXzEuSW5wdXQgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7XG59KCkpO1xuZXhwb3J0cy5SYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yID0gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhZGlvX2NvbnRyb2xfdmFsdWVfYWNjZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGNvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vY29udHJvbF92YWx1ZV9hY2Nlc3NvcicpO1xuZXhwb3J0cy5TRUxFQ1RfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogY29udHJvbF92YWx1ZV9hY2Nlc3Nvcl8xLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG5mdW5jdGlvbiBfYnVpbGRWYWx1ZVN0cmluZyhpZCwgdmFsdWUpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoaWQpKVxuICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIGlmICghbGFuZ18xLmlzUHJpbWl0aXZlKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSBcIk9iamVjdFwiO1xuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5zbGljZShpZCArIFwiOiBcIiArIHZhbHVlLCAwLCA1MCk7XG59XG5mdW5jdGlvbiBfZXh0cmFjdElkKHZhbHVlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlU3RyaW5nLnNwbGl0KFwiOlwiKVswXTtcbn1cbnZhciBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX29wdGlvbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9pZENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIHZhbHVlU3RyaW5nID0gX2J1aWxkVmFsdWVTdHJpbmcodGhpcy5fZ2V0T3B0aW9uSWQodmFsdWUpLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlU3RyaW5nKTtcbiAgICB9O1xuICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHsgZm4oX3RoaXMuX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKSk7IH07XG4gICAgfTtcbiAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9yZWdpc3Rlck9wdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl9pZENvdW50ZXIrKykudG9TdHJpbmcoKTsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25JZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIua2V5cyh0aGlzLl9vcHRpb25NYXApOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5sb29zZUlkZW50aWNhbCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbk1hcC5nZXQoX2V4dHJhY3RJZCh2YWx1ZVN0cmluZykpO1xuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlU3RyaW5nO1xuICAgIH07XG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlbGVjdFtuZ0NvbnRyb2xdLHNlbGVjdFtuZ0Zvcm1Db250cm9sXSxzZWxlY3RbbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2V4cG9ydHMuU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlJlbmRlcmVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xufSgpKTtcbmV4cG9ydHMuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcbnZhciBOZ1NlbGVjdE9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdTZWxlY3RPcHRpb24oX2VsZW1lbnQsIF9yZW5kZXJlciwgX3NlbGVjdCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9zZWxlY3QgPSBfc2VsZWN0O1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9zZWxlY3QpKVxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24oKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZSwgXCJuZ1ZhbHVlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5zZXQodGhpcy5pZCwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9zZWxlY3QpKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3NlbGVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5nU2VsZWN0T3B0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdvcHRpb24nIH0sXSB9LFxuICAgIF07XG4gICAgTmdTZWxlY3RPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlJlbmRlcmVyLCB9LFxuICAgICAgICB7IHR5cGU6IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuSG9zdCB9LF0gfSxcbiAgICBdO1xuICAgIE5nU2VsZWN0T3B0aW9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnbmdWYWx1ZSc6IFt7IHR5cGU6IGNvcmVfMS5JbnB1dCwgYXJnczogWyduZ1ZhbHVlJyxdIH0sXSxcbiAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogY29yZV8xLklucHV0LCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBOZ1NlbGVjdE9wdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5nU2VsZWN0T3B0aW9uID0gTmdTZWxlY3RPcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3RfY29udHJvbF92YWx1ZV9hY2Nlc3Nvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciB2YWxpZGF0b3JzXzEgPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJyk7XG52YXIgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xID0gcmVxdWlyZSgnLi9kZWZhdWx0X3ZhbHVlX2FjY2Vzc29yJyk7XG52YXIgbnVtYmVyX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL251bWJlcl92YWx1ZV9hY2Nlc3NvcicpO1xudmFyIGNoZWNrYm94X3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL2NoZWNrYm94X3ZhbHVlX2FjY2Vzc29yJyk7XG52YXIgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMSA9IHJlcXVpcmUoJy4vc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcbnZhciByYWRpb19jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEgPSByZXF1aXJlKCcuL3JhZGlvX2NvbnRyb2xfdmFsdWVfYWNjZXNzb3InKTtcbnZhciBub3JtYWxpemVfdmFsaWRhdG9yXzEgPSByZXF1aXJlKCcuL25vcm1hbGl6ZV92YWxpZGF0b3InKTtcbmZ1bmN0aW9uIGNvbnRyb2xQYXRoKG5hbWUsIHBhcmVudCkge1xuICAgIHZhciBwID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5wYXRoKTtcbiAgICBwLnB1c2gobmFtZSk7XG4gICAgcmV0dXJuIHA7XG59XG5leHBvcnRzLmNvbnRyb2xQYXRoID0gY29udHJvbFBhdGg7XG5mdW5jdGlvbiBzZXRVcENvbnRyb2woY29udHJvbCwgZGlyKSB7XG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbnRyb2wpKVxuICAgICAgICBfdGhyb3dFcnJvcihkaXIsIFwiQ2Fubm90IGZpbmQgY29udHJvbFwiKTtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoZGlyLnZhbHVlQWNjZXNzb3IpKVxuICAgICAgICBfdGhyb3dFcnJvcihkaXIsIFwiTm8gdmFsdWUgYWNjZXNzb3IgZm9yXCIpO1xuICAgIGNvbnRyb2wudmFsaWRhdG9yID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuY29tcG9zZShbY29udHJvbC52YWxpZGF0b3IsIGRpci52YWxpZGF0b3JdKTtcbiAgICBjb250cm9sLmFzeW5jVmFsaWRhdG9yID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFtjb250cm9sLmFzeW5jVmFsaWRhdG9yLCBkaXIuYXN5bmNWYWxpZGF0b3JdKTtcbiAgICBkaXIudmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKGNvbnRyb2wudmFsdWUpO1xuICAgIC8vIHZpZXcgLT4gbW9kZWxcbiAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICBkaXIudmlld1RvTW9kZWxVcGRhdGUobmV3VmFsdWUpO1xuICAgICAgICBjb250cm9sLnVwZGF0ZVZhbHVlKG5ld1ZhbHVlLCB7IGVtaXRNb2RlbFRvVmlld0NoYW5nZTogZmFsc2UgfSk7XG4gICAgICAgIGNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICB9KTtcbiAgICAvLyBtb2RlbCAtPiB2aWV3XG4gICAgY29udHJvbC5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSkgeyByZXR1cm4gZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShuZXdWYWx1ZSk7IH0pO1xuICAgIC8vIHRvdWNoZWRcbiAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLm1hcmtBc1RvdWNoZWQoKTsgfSk7XG59XG5leHBvcnRzLnNldFVwQ29udHJvbCA9IHNldFVwQ29udHJvbDtcbmZ1bmN0aW9uIHNldFVwQ29udHJvbEdyb3VwKGNvbnRyb2wsIGRpcikge1xuICAgIGlmIChsYW5nXzEuaXNCbGFuayhjb250cm9sKSlcbiAgICAgICAgX3Rocm93RXJyb3IoZGlyLCBcIkNhbm5vdCBmaW5kIGNvbnRyb2xcIik7XG4gICAgY29udHJvbC52YWxpZGF0b3IgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5jb21wb3NlKFtjb250cm9sLnZhbGlkYXRvciwgZGlyLnZhbGlkYXRvcl0pO1xuICAgIGNvbnRyb2wuYXN5bmNWYWxpZGF0b3IgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW2NvbnRyb2wuYXN5bmNWYWxpZGF0b3IsIGRpci5hc3luY1ZhbGlkYXRvcl0pO1xufVxuZXhwb3J0cy5zZXRVcENvbnRyb2xHcm91cCA9IHNldFVwQ29udHJvbEdyb3VwO1xuZnVuY3Rpb24gX3Rocm93RXJyb3IoZGlyLCBtZXNzYWdlKSB7XG4gICAgdmFyIHBhdGggPSBkaXIucGF0aC5qb2luKFwiIC0+IFwiKTtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24obWVzc2FnZSArIFwiICdcIiArIHBhdGggKyBcIidcIik7XG59XG5mdW5jdGlvbiBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodmFsaWRhdG9ycykgPyB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5jb21wb3NlKHZhbGlkYXRvcnMubWFwKG5vcm1hbGl6ZV92YWxpZGF0b3JfMS5ub3JtYWxpemVWYWxpZGF0b3IpKSA6IG51bGw7XG59XG5leHBvcnRzLmNvbXBvc2VWYWxpZGF0b3JzID0gY29tcG9zZVZhbGlkYXRvcnM7XG5mdW5jdGlvbiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh2YWxpZGF0b3JzKSA/IHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzLmNvbXBvc2VBc3luYyh2YWxpZGF0b3JzLm1hcChub3JtYWxpemVfdmFsaWRhdG9yXzEubm9ybWFsaXplQXN5bmNWYWxpZGF0b3IpKSA6XG4gICAgICAgIG51bGw7XG59XG5leHBvcnRzLmNvbXBvc2VBc3luY1ZhbGlkYXRvcnMgPSBjb21wb3NlQXN5bmNWYWxpZGF0b3JzO1xuZnVuY3Rpb24gaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdmlld01vZGVsKSB7XG4gICAgaWYgKCFjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhjaGFuZ2VzLCBcIm1vZGVsXCIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbXCJtb2RlbFwiXTtcbiAgICBpZiAoY2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuICFsYW5nXzEubG9vc2VJZGVudGljYWwodmlld01vZGVsLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNQcm9wZXJ0eVVwZGF0ZWQgPSBpc1Byb3BlcnR5VXBkYXRlZDtcbi8vIFRPRE86IHZzYXZraW4gcmVtb3ZlIGl0IG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuZnVuY3Rpb24gc2VsZWN0VmFsdWVBY2Nlc3NvcihkaXIsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZhbHVlQWNjZXNzb3JzKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGRlZmF1bHRBY2Nlc3NvcjtcbiAgICB2YXIgYnVpbHRpbkFjY2Vzc29yO1xuICAgIHZhciBjdXN0b21BY2Nlc3NvcjtcbiAgICB2YWx1ZUFjY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmIChsYW5nXzEuaGFzQ29uc3RydWN0b3IodiwgZGVmYXVsdF92YWx1ZV9hY2Nlc3Nvcl8xLkRlZmF1bHRWYWx1ZUFjY2Vzc29yKSkge1xuICAgICAgICAgICAgZGVmYXVsdEFjY2Vzc29yID0gdjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuaGFzQ29uc3RydWN0b3IodiwgY2hlY2tib3hfdmFsdWVfYWNjZXNzb3JfMS5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yKSB8fFxuICAgICAgICAgICAgbGFuZ18xLmhhc0NvbnN0cnVjdG9yKHYsIG51bWJlcl92YWx1ZV9hY2Nlc3Nvcl8xLk51bWJlclZhbHVlQWNjZXNzb3IpIHx8XG4gICAgICAgICAgICBsYW5nXzEuaGFzQ29uc3RydWN0b3Iodiwgc2VsZWN0X2NvbnRyb2xfdmFsdWVfYWNjZXNzb3JfMS5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcikgfHxcbiAgICAgICAgICAgIGxhbmdfMS5oYXNDb25zdHJ1Y3Rvcih2LCByYWRpb19jb250cm9sX3ZhbHVlX2FjY2Vzc29yXzEuUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcikpIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGJ1aWx0aW5BY2Nlc3NvcikpXG4gICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCBcIk1vcmUgdGhhbiBvbmUgYnVpbHQtaW4gdmFsdWUgYWNjZXNzb3IgbWF0Y2hlc1wiKTtcbiAgICAgICAgICAgIGJ1aWx0aW5BY2Nlc3NvciA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjdXN0b21BY2Nlc3NvcikpXG4gICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCBcIk1vcmUgdGhhbiBvbmUgY3VzdG9tIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXNcIik7XG4gICAgICAgICAgICBjdXN0b21BY2Nlc3NvciA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjdXN0b21BY2Nlc3NvcikpXG4gICAgICAgIHJldHVybiBjdXN0b21BY2Nlc3NvcjtcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChidWlsdGluQWNjZXNzb3IpKVxuICAgICAgICByZXR1cm4gYnVpbHRpbkFjY2Vzc29yO1xuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRlZmF1bHRBY2Nlc3NvcikpXG4gICAgICAgIHJldHVybiBkZWZhdWx0QWNjZXNzb3I7XG4gICAgX3Rocm93RXJyb3IoZGlyLCBcIk5vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvclwiKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuc2VsZWN0VmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL2ZhY2FkZS9sYW5nJyk7XG52YXIgdmFsaWRhdG9yc18xID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xudmFyIFJFUVVJUkVEID0gdmFsaWRhdG9yc18xLlZhbGlkYXRvcnMucmVxdWlyZWQ7XG5leHBvcnRzLlJFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiB2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUyxcbiAgICB1c2VWYWx1ZTogUkVRVUlSRUQsXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgUmVxdWlyZWRWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVpcmVkVmFsaWRhdG9yKCkge1xuICAgIH1cbiAgICBSZXF1aXJlZFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3JlcXVpcmVkXVtuZ0NvbnRyb2xdLFtyZXF1aXJlZF1bbmdGb3JtQ29udHJvbF0sW3JlcXVpcmVkXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2V4cG9ydHMuUkVRVUlSRURfVkFMSURBVE9SXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIFJlcXVpcmVkVmFsaWRhdG9yO1xufSgpKTtcbmV4cG9ydHMuUmVxdWlyZWRWYWxpZGF0b3IgPSBSZXF1aXJlZFZhbGlkYXRvcjtcbi8qKlxuICogUHJvdml2ZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1pbkxlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICoge0BleGFtcGxlIGNvbW1vbi9mb3Jtcy90cy92YWxpZGF0b3JzL3ZhbGlkYXRvcnMudHMgcmVnaW9uPSdtaW4nfVxuICovXG5leHBvcnRzLk1JTl9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgIHByb3ZpZGU6IHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIE1pbkxlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWluTGVuZ3RoVmFsaWRhdG9yKG1pbkxlbmd0aCkge1xuICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5taW5MZW5ndGgobGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnQobWluTGVuZ3RoLCAxMCkpO1xuICAgIH1cbiAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjKTsgfTtcbiAgICBNaW5MZW5ndGhWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttaW5sZW5ndGhdW25nQ29udHJvbF0sW21pbmxlbmd0aF1bbmdGb3JtQ29udHJvbF0sW21pbmxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLk1JTl9MRU5HVEhfVkFMSURBVE9SXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWluTGVuZ3RoVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLkF0dHJpYnV0ZSwgYXJnczogW1wibWlubGVuZ3RoXCIsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7XG59KCkpO1xuZXhwb3J0cy5NaW5MZW5ndGhWYWxpZGF0b3IgPSBNaW5MZW5ndGhWYWxpZGF0b3I7XG4vKipcbiAqIFByb3ZpZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1heExlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICoge0BleGFtcGxlIGNvbW1vbi9mb3Jtcy90cy92YWxpZGF0b3JzL3ZhbGlkYXRvcnMudHMgcmVnaW9uPSdtYXgnfVxuICovXG5leHBvcnRzLk1BWF9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgIHByb3ZpZGU6IHZhbGlkYXRvcnNfMS5OR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBjb3JlXzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhMZW5ndGhWYWxpZGF0b3I7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIE1heExlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF4TGVuZ3RoVmFsaWRhdG9yKG1heExlbmd0aCkge1xuICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSB2YWxpZGF0b3JzXzEuVmFsaWRhdG9ycy5tYXhMZW5ndGgobGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnQobWF4TGVuZ3RoLCAxMCkpO1xuICAgIH1cbiAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjKTsgfTtcbiAgICBNYXhMZW5ndGhWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXhsZW5ndGhdW25nQ29udHJvbF0sW21heGxlbmd0aF1bbmdGb3JtQ29udHJvbF0sW21heGxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtleHBvcnRzLk1BWF9MRU5HVEhfVkFMSURBVE9SXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgTWF4TGVuZ3RoVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLkF0dHJpYnV0ZSwgYXJnczogW1wibWF4bGVuZ3RoXCIsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBNYXhMZW5ndGhWYWxpZGF0b3I7XG59KCkpO1xuZXhwb3J0cy5NYXhMZW5ndGhWYWxpZGF0b3IgPSBNYXhMZW5ndGhWYWxpZGF0b3I7XG4vKipcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHBhdHRlcm5gIHZhbGlkYXRvciB0byBhbnkgY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gKiBgcGF0dGVybmAgYXR0cmlidXRlLCB2aWEgdGhlIHtAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLiBVc2VzIGF0dHJpYnV0ZSB2YWx1ZVxuICogYXMgdGhlIHJlZ2V4IHRvIHZhbGlkYXRlIENvbnRyb2wgdmFsdWUgYWdhaW5zdC4gIEZvbGxvd3MgcGF0dGVybiBhdHRyaWJ1dGVcbiAqIHNlbWFudGljczsgaS5lLiByZWdleCBtdXN0IG1hdGNoIGVudGlyZSBDb250cm9sIHZhbHVlLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiA8aW5wdXQgW25nQ29udHJvbF09XCJmdWxsTmFtZVwiIHBhdHRlcm49XCJbYS16QS1aIF0qXCI+XG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5QQVRURVJOX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiB2YWxpZGF0b3JzXzEuTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogY29yZV8xLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gUGF0dGVyblZhbGlkYXRvcjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgUGF0dGVyblZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0dGVyblZhbGlkYXRvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRvciA9IHZhbGlkYXRvcnNfMS5WYWxpZGF0b3JzLnBhdHRlcm4ocGF0dGVybik7XG4gICAgfVxuICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjKTsgfTtcbiAgICBQYXR0ZXJuVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbcGF0dGVybl1bbmdDb250cm9sXSxbcGF0dGVybl1bbmdGb3JtQ29udHJvbF0sW3BhdHRlcm5dW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZXhwb3J0cy5QQVRURVJOX1ZBTElEQVRPUl1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIFBhdHRlcm5WYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuQXR0cmlidXRlLCBhcmdzOiBbXCJwYXR0ZXJuXCIsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBQYXR0ZXJuVmFsaWRhdG9yO1xufSgpKTtcbmV4cG9ydHMuUGF0dGVyblZhbGlkYXRvciA9IFBhdHRlcm5WYWxpZGF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBtb2RlbE1vZHVsZSA9IHJlcXVpcmUoJy4vbW9kZWwnKTtcbnZhciBGb3JtQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9ybUJ1aWxkZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgQ29udHJvbEdyb3VwfSB3aXRoIHRoZSBnaXZlbiBtYXAgb2YgY29uZmlndXJhdGlvbi5cbiAgICAgKiBWYWxpZCBrZXlzIGZvciB0aGUgYGV4dHJhYCBwYXJhbWV0ZXIgbWFwIGFyZSBgb3B0aW9uYWxzYCBhbmQgYHZhbGlkYXRvcmAuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIHtAbGluayBDb250cm9sR3JvdXB9IGNvbnN0cnVjdG9yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCBleHRyYSkge1xuICAgICAgICBpZiAoZXh0cmEgPT09IHZvaWQgMCkgeyBleHRyYSA9IG51bGw7IH1cbiAgICAgICAgdmFyIGNvbnRyb2xzID0gdGhpcy5fcmVkdWNlQ29udHJvbHMoY29udHJvbHNDb25maWcpO1xuICAgICAgICB2YXIgb3B0aW9uYWxzID0gKGxhbmdfMS5pc1ByZXNlbnQoZXh0cmEpID8gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KGV4dHJhLCBcIm9wdGlvbmFsc1wiKSA6IG51bGwpO1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gbGFuZ18xLmlzUHJlc2VudChleHRyYSkgPyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoZXh0cmEsIFwidmFsaWRhdG9yXCIpIDogbnVsbDtcbiAgICAgICAgdmFyIGFzeW5jVmFsaWRhdG9yID0gbGFuZ18xLmlzUHJlc2VudChleHRyYSkgPyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoZXh0cmEsIFwiYXN5bmNWYWxpZGF0b3JcIikgOiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsTW9kdWxlLkNvbnRyb2xHcm91cChjb250cm9scywgb3B0aW9uYWxzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgQ29udHJvbH0gd2l0aCB0aGUgZ2l2ZW4gYHZhbHVlYCxgdmFsaWRhdG9yYCwgYW5kIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICovXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbiAodmFsdWUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgbW9kZWxNb2R1bGUuQ29udHJvbCh2YWx1ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2Yge0BsaW5rIENvbnRyb2x9cyBmcm9tIHRoZSBnaXZlbiBgY29udHJvbHNDb25maWdgIGFycmF5IG9mXG4gICAgICogY29uZmlndXJhdGlvbiwgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uYWwgYHZhbGlkYXRvcmAgYW5kIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICovXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICB2YXIgY29udHJvbHMgPSBjb250cm9sc0NvbmZpZy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVDb250cm9sKGMpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBtb2RlbE1vZHVsZS5Db250cm9sQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5fcmVkdWNlQ29udHJvbHMgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnRyb2xzID0ge307XG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goY29udHJvbHNDb25maWcsIGZ1bmN0aW9uIChjb250cm9sQ29uZmlnLCBjb250cm9sTmFtZSkge1xuICAgICAgICAgICAgY29udHJvbHNbY29udHJvbE5hbWVdID0gX3RoaXMuX2NyZWF0ZUNvbnRyb2woY29udHJvbENvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udHJvbHM7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2xDb25maWcpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBtb2RlbE1vZHVsZS5Db250cm9sIHx8XG4gICAgICAgICAgICBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgbW9kZWxNb2R1bGUuQ29udHJvbEdyb3VwIHx8XG4gICAgICAgICAgICBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgbW9kZWxNb2R1bGUuQ29udHJvbEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNBcnJheShjb250cm9sQ29uZmlnKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbENvbmZpZ1swXTtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBjb250cm9sQ29uZmlnLmxlbmd0aCA+IDEgPyBjb250cm9sQ29uZmlnWzFdIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBhc3luY1ZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMiA/IGNvbnRyb2xDb25maWdbMl0gOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCh2YWx1ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKGNvbnRyb2xDb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGb3JtQnVpbGRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gRm9ybUJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5Gb3JtQnVpbGRlciA9IEZvcm1CdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybV9idWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvYXN5bmMnKTtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL3Byb21pc2UnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgYSBDb250cm9sIGlzIHZhbGlkLCBpLmUuIHRoYXQgbm8gZXJyb3JzIGV4aXN0IGluIHRoZSBpbnB1dCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5WQUxJRCA9IFwiVkFMSURcIjtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgYSBDb250cm9sIGlzIGludmFsaWQsIGkuZS4gdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICovXG5leHBvcnRzLklOVkFMSUQgPSBcIklOVkFMSURcIjtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgYSBDb250cm9sIGlzIHBlbmRpbmcsIGkuZS4gdGhhdCBhc3luYyB2YWxpZGF0aW9uIGlzIG9jY3VycmluZyBhbmRcbiAqIGVycm9ycyBhcmUgbm90IHlldCBhdmFpbGFibGUgZm9yIHRoZSBpbnB1dCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5QRU5ESU5HID0gXCJQRU5ESU5HXCI7XG5mdW5jdGlvbiBpc0NvbnRyb2woY29udHJvbCkge1xuICAgIHJldHVybiBjb250cm9sIGluc3RhbmNlb2YgQWJzdHJhY3RDb250cm9sO1xufVxuZXhwb3J0cy5pc0NvbnRyb2wgPSBpc0NvbnRyb2w7XG5mdW5jdGlvbiBfZmluZChjb250cm9sLCBwYXRoKSB7XG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhdGgpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICB9XG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBBcnJheSAmJiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eShwYXRoKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhdGhcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAodiwgbmFtZSkge1xuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIENvbnRyb2xHcm91cCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodi5jb250cm9sc1tuYW1lXSkgPyB2LmNvbnRyb2xzW25hbWVdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQ29udHJvbEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodi5hdChpbmRleCkpID8gdi5hdChpbmRleCkgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LCBjb250cm9sKTtcbn1cbmZ1bmN0aW9uIHRvT2JzZXJ2YWJsZShyKSB7XG4gICAgcmV0dXJuIHByb21pc2VfMS5Qcm9taXNlV3JhcHBlci5pc1Byb21pc2UocikgPyBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmZyb21Qcm9taXNlKHIpIDogcjtcbn1cbi8qKlxuICpcbiAqL1xudmFyIEFic3RyYWN0Q29udHJvbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RDb250cm9sKHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4gICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBhc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl90b3VjaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IGV4cG9ydHMuVkFMSUQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImVycm9yc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBlcnJvcnMgb2YgdGhpcyBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lcnJvcnM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcmlzdGluZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLnByaXN0aW5lOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90b3VjaGVkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLl90b3VjaGVkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlQ2hhbmdlczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwic3RhdHVzQ2hhbmdlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzQ2hhbmdlczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicGVuZGluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09IGV4cG9ydHMuUEVORElORzsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNUb3VjaGVkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl90b3VjaGVkID0gdHJ1ZTsgfTtcbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc0RpcnR5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgIG9ubHlTZWxmID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2wob25seVNlbGYpO1xuICAgICAgICB0aGlzLl9wcmlzdGluZSA9IGZhbHNlO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9wYXJlbnQpICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc0RpcnR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1BlbmRpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgb25seVNlbGYgPSBsYW5nXzEubm9ybWFsaXplQm9vbChvbmx5U2VsZik7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IGV4cG9ydHMuUEVORElORztcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcGFyZW50KSAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNQZW5kaW5nKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHsgdGhpcy5fcGFyZW50ID0gcGFyZW50OyB9O1xuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICBvbmx5U2VsZiA9IGxhbmdfMS5ub3JtYWxpemVCb29sKG9ubHlTZWxmKTtcbiAgICAgICAgZW1pdEV2ZW50ID0gbGFuZ18xLmlzUHJlc2VudChlbWl0RXZlbnQpID8gZW1pdEV2ZW50IDogdHJ1ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gdGhpcy5fcnVuVmFsaWRhdG9yKCk7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdHVzID09IGV4cG9ydHMuVkFMSUQgfHwgdGhpcy5fc3RhdHVzID09IGV4cG9ydHMuUEVORElORykge1xuICAgICAgICAgICAgdGhpcy5fcnVuQXN5bmNWYWxpZGF0b3IoZW1pdEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmNhbGxFbWl0KHRoaXMuX3ZhbHVlQ2hhbmdlcywgdGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsRW1pdCh0aGlzLl9zdGF0dXNDaGFuZ2VzLCB0aGlzLl9zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3BhcmVudCkgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3J1blZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy52YWxpZGF0b3IpID8gdGhpcy52YWxpZGF0b3IodGhpcykgOiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fcnVuQXN5bmNWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZW1pdEV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuYXN5bmNWYWxpZGF0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBleHBvcnRzLlBFTkRJTkc7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxFeGlzdGluZ1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgdmFyIG9icyA9IHRvT2JzZXJ2YWJsZSh0aGlzLmFzeW5jVmFsaWRhdG9yKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbiA9IGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuc3Vic2NyaWJlKG9icywgZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuc2V0RXJyb3JzKHJlcywgeyBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2NhbmNlbEV4aXN0aW5nU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmRpc3Bvc2UodGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBlcnJvcnMgb24gYSBjb250cm9sLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VkIHdoZW4gdmFsaWRhdGlvbnMgYXJlIHJ1biBub3QgYXV0b21hdGljYWxseSwgYnV0IG1hbnVhbGx5IGJ5IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQ2FsbGluZyBgc2V0RXJyb3JzYCB3aWxsIGFsc28gdXBkYXRlIHRoZSB2YWxpZGl0eSBvZiB0aGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiAjIyBVc2FnZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmFyIGxvZ2luID0gbmV3IENvbnRyb2woXCJzb21lTG9naW5cIik7XG4gICAgICogbG9naW4uc2V0RXJyb3JzKHtcbiAgICAgKiAgIFwibm90VW5pcXVlXCI6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbChmYWxzZSk7XG4gICAgICogZXhwZWN0KGxvZ2luLmVycm9ycykudG9FcXVhbCh7XCJub3RVbmlxdWVcIjogdHJ1ZX0pO1xuICAgICAqXG4gICAgICogbG9naW4udXBkYXRlVmFsdWUoXCJzb21lT3RoZXJMb2dpblwiKTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbCh0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldEVycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMsIF9hKSB7XG4gICAgICAgIHZhciBlbWl0RXZlbnQgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmVtaXRFdmVudDtcbiAgICAgICAgZW1pdEV2ZW50ID0gbGFuZ18xLmlzUHJlc2VudChlbWl0RXZlbnQpID8gZW1pdEV2ZW50IDogdHJ1ZTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSB0aGlzLl9jYWxjdWxhdGVTdGF0dXMoKTtcbiAgICAgICAgaWYgKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsRW1pdCh0aGlzLl9zdGF0dXNDaGFuZ2VzLCB0aGlzLl9zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3BhcmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlQ29udHJvbHNFcnJvcnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIF9maW5kKHRoaXMsIHBhdGgpOyB9O1xuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgdmFyIGNvbnRyb2wgPSBsYW5nXzEuaXNQcmVzZW50KHBhdGgpICYmICFjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eShwYXRoKSA/IHRoaXMuZmluZChwYXRoKSA6IHRoaXM7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbnRyb2wpICYmIGxhbmdfMS5pc1ByZXNlbnQoY29udHJvbC5fZXJyb3JzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChjb250cm9sLl9lcnJvcnMsIGVycm9yQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQoeC5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHggPSB4Ll9wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSB0aGlzLl9jYWxjdWxhdGVTdGF0dXMoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcGFyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVDb250cm9sc0Vycm9ycygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5faW5pdE9ic2VydmFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcyA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcigpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fY2FsY3VsYXRlU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9lcnJvcnMpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuSU5WQUxJRDtcbiAgICAgICAgaWYgKHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhleHBvcnRzLlBFTkRJTkcpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuUEVORElORztcbiAgICAgICAgaWYgKHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhleHBvcnRzLklOVkFMSUQpKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuSU5WQUxJRDtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVkFMSUQ7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sO1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RDb250cm9sID0gQWJzdHJhY3RDb250cm9sO1xuLyoqXG4gKiBEZWZpbmVzIGEgcGFydCBvZiBhIGZvcm0gdGhhdCBjYW5ub3QgYmUgZGl2aWRlZCBpbnRvIG90aGVyIGNvbnRyb2xzLiBgQ29udHJvbGBzIGhhdmUgdmFsdWVzIGFuZFxuICogdmFsaWRhdGlvbiBzdGF0ZSwgd2hpY2ggaXMgZGV0ZXJtaW5lZCBieSBhbiBvcHRpb25hbCB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICpcbiAqIGBDb250cm9sYCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLCBhbG9uZ1xuICogd2l0aCB7QGxpbmsgQ29udHJvbEdyb3VwfSBhbmQge0BsaW5rIENvbnRyb2xBcnJheX0uXG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBCeSBkZWZhdWx0LCBhIGBDb250cm9sYCBpcyBjcmVhdGVkIGZvciBldmVyeSBgPGlucHV0PmAgb3Igb3RoZXIgZm9ybSBjb21wb25lbnQuXG4gKiBXaXRoIHtAbGluayBOZ0Zvcm1Db250cm9sfSBvciB7QGxpbmsgTmdGb3JtTW9kZWx9IGFuIGV4aXN0aW5nIHtAbGluayBDb250cm9sfSBjYW4gYmVcbiAqIGJvdW5kIHRvIGEgRE9NIGVsZW1lbnQgaW5zdGVhZC4gVGhpcyBgQ29udHJvbGAgY2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIGN1c3RvbVxuICogdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvMjNERVNPcGJObkJwQkhadDFCUjQ/cD1wcmV2aWV3KSlcbiAqL1xudmFyIENvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRyb2wodmFsdWUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBudWxsOyB9XG4gICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBJZiBgb25seVNlbGZgIGlzIGB0cnVlYCwgdGhpcyBjaGFuZ2Ugd2lsbCBvbmx5IGFmZmVjdCB0aGUgdmFsaWRhdGlvbiBvZiB0aGlzIGBDb250cm9sYFxuICAgICAqIGFuZCBub3QgaXRzIHBhcmVudCBjb21wb25lbnQuIElmIGBlbWl0RXZlbnRgIGlzIGB0cnVlYCwgdGhpcyBjaGFuZ2Ugd2lsbCBjYXVzZSBhXG4gICAgICogYHZhbHVlQ2hhbmdlc2AgZXZlbnQgb24gdGhlIGBDb250cm9sYCB0byBiZSBlbWl0dGVkLiBCb3RoIG9mIHRoZXNlIG9wdGlvbnMgZGVmYXVsdCB0b1xuICAgICAqIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlYCBpcyBgdHJ1ZWAsIHRoZSB2aWV3IHdpbGwgYmUgbm90aWZpZWQgYWJvdXQgdGhlIG5ldyB2YWx1ZVxuICAgICAqIHZpYSBhbiBgb25DaGFuZ2VgIGV2ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIG5vdFxuICAgICAqIHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBDb250cm9sLnByb3RvdHlwZS51cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudCwgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlID0gX2IuZW1pdE1vZGVsVG9WaWV3Q2hhbmdlO1xuICAgICAgICBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgPSBsYW5nXzEuaXNQcmVzZW50KGVtaXRNb2RlbFRvVmlld0NoYW5nZSkgPyBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgOiB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9vbkNoYW5nZSkgJiYgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlKVxuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQ29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc0hhdmVTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIGZvciBjaGFuZ2UgZXZlbnRzLlxuICAgICAqL1xuICAgIENvbnRyb2wucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICByZXR1cm4gQ29udHJvbDtcbn0oQWJzdHJhY3RDb250cm9sKSk7XG5leHBvcnRzLkNvbnRyb2wgPSBDb250cm9sO1xuLyoqXG4gKiBEZWZpbmVzIGEgcGFydCBvZiBhIGZvcm0sIG9mIGZpeGVkIGxlbmd0aCwgdGhhdCBjYW4gY29udGFpbiBvdGhlciBjb250cm9scy5cbiAqXG4gKiBBIGBDb250cm9sR3JvdXBgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBvZiBlYWNoIHtAbGluayBDb250cm9sfSBpbiB0aGUgZ3JvdXAuXG4gKiBUaGUgc3RhdHVzIG9mIGEgYENvbnRyb2xHcm91cGAgZGVwZW5kcyBvbiB0aGUgc3RhdHVzIG9mIGl0cyBjaGlsZHJlbi5cbiAqIElmIG9uZSBvZiB0aGUgY29udHJvbHMgaW4gYSBncm91cCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlIGdyb3VwIGlzIGludmFsaWQuXG4gKiBTaW1pbGFybHksIGlmIGEgY29udHJvbCBjaGFuZ2VzIGl0cyB2YWx1ZSwgdGhlIGVudGlyZSBncm91cCBjaGFuZ2VzIGFzIHdlbGwuXG4gKlxuICogYENvbnRyb2xHcm91cGAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAqIGFsb25nIHdpdGgge0BsaW5rIENvbnRyb2x9IGFuZCB7QGxpbmsgQ29udHJvbEFycmF5fS4ge0BsaW5rIENvbnRyb2xBcnJheX0gY2FuIGFsc28gY29udGFpbiBvdGhlclxuICogY29udHJvbHMsIGJ1dCBpcyBvZiB2YXJpYWJsZSBsZW5ndGguXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzIzREVTT3BiTm5CcEJIWnQxQlI0P3A9cHJldmlldykpXG4gKi9cbnZhciBDb250cm9sR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250cm9sR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udHJvbEdyb3VwKGNvbnRyb2xzLCBvcHRpb25hbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKG9wdGlvbmFscyA9PT0gdm9pZCAwKSB7IG9wdGlvbmFscyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgICAgIHRoaXMuX29wdGlvbmFscyA9IGxhbmdfMS5pc1ByZXNlbnQob3B0aW9uYWxzKSA/IG9wdGlvbmFscyA6IHt9O1xuICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50Rm9yQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnRyb2wgdG8gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdID0gY29udHJvbDtcbiAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjb250cm9sIGZyb20gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSkgeyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5kZWxldGUodGhpcy5jb250cm9scywgbmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogTWFyayB0aGUgbmFtZWQgY29udHJvbCBhcyBub24tb3B0aW9uYWwuXG4gICAgICovXG4gICAgQ29udHJvbEdyb3VwLnByb3RvdHlwZS5pbmNsdWRlID0gZnVuY3Rpb24gKGNvbnRyb2xOYW1lKSB7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLnNldCh0aGlzLl9vcHRpb25hbHMsIGNvbnRyb2xOYW1lLCB0cnVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXJrIHRoZSBuYW1lZCBjb250cm9sIGFzIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5zZXQodGhpcy5fb3B0aW9uYWxzLCBjb250cm9sTmFtZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlcmUgaXMgYSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcbiAgICAgICAgdmFyIGMgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyh0aGlzLmNvbnRyb2xzLCBjb250cm9sTmFtZSk7XG4gICAgICAgIHJldHVybiBjICYmIHRoaXMuX2luY2x1ZGVkKGNvbnRyb2xOYW1lKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLl9zZXRQYXJlbnRGb3JDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCh0aGlzLmNvbnRyb2xzLCBmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkgeyBjb250cm9sLnNldFBhcmVudChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWx1ZSA9IHRoaXMuX3JlZHVjZVZhbHVlKCk7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcyA9IGZhbHNlO1xuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHRoaXMuY29udHJvbHMsIGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICByZXMgPSByZXMgfHwgKF90aGlzLmNvbnRhaW5zKG5hbWUpICYmIGNvbnRyb2wuc3RhdHVzID09IHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIENvbnRyb2xHcm91cC5wcm90b3R5cGUuX3JlZHVjZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlQ2hpbGRyZW4oe30sIGZ1bmN0aW9uIChhY2MsIGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLl9yZWR1Y2VDaGlsZHJlbiA9IGZ1bmN0aW9uIChpbml0VmFsdWUsIGZuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXMgPSBpbml0VmFsdWU7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2godGhpcy5jb250cm9scywgZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faW5jbHVkZWQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBmbihyZXMsIGNvbnRyb2wsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBDb250cm9sR3JvdXAucHJvdG90eXBlLl9pbmNsdWRlZCA9IGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xuICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zKHRoaXMuX29wdGlvbmFscywgY29udHJvbE5hbWUpO1xuICAgICAgICByZXR1cm4gIWlzT3B0aW9uYWwgfHwgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KHRoaXMuX29wdGlvbmFscywgY29udHJvbE5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRyb2xHcm91cDtcbn0oQWJzdHJhY3RDb250cm9sKSk7XG5leHBvcnRzLkNvbnRyb2xHcm91cCA9IENvbnRyb2xHcm91cDtcbi8qKlxuICogRGVmaW5lcyBhIHBhcnQgb2YgYSBmb3JtLCBvZiB2YXJpYWJsZSBsZW5ndGgsIHRoYXQgY2FuIGNvbnRhaW4gb3RoZXIgY29udHJvbHMuXG4gKlxuICogQSBgQ29udHJvbEFycmF5YCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCB7QGxpbmsgQ29udHJvbH0gaW4gdGhlIGdyb3VwLlxuICogVGhlIHN0YXR1cyBvZiBhIGBDb250cm9sQXJyYXlgIGRlcGVuZHMgb24gdGhlIHN0YXR1cyBvZiBpdHMgY2hpbGRyZW4uXG4gKiBJZiBvbmUgb2YgdGhlIGNvbnRyb2xzIGluIGEgZ3JvdXAgaXMgaW52YWxpZCwgdGhlIGVudGlyZSBhcnJheSBpcyBpbnZhbGlkLlxuICogU2ltaWxhcmx5LCBpZiBhIGNvbnRyb2wgY2hhbmdlcyBpdHMgdmFsdWUsIHRoZSBlbnRpcmUgYXJyYXkgY2hhbmdlcyBhcyB3ZWxsLlxuICpcbiAqIGBDb250cm9sQXJyYXlgIGlzIG9uZSBvZiB0aGUgdGhyZWUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2tzIHVzZWQgdG8gZGVmaW5lIGZvcm1zIGluIEFuZ3VsYXIsXG4gKiBhbG9uZyB3aXRoIHtAbGluayBDb250cm9sfSBhbmQge0BsaW5rIENvbnRyb2xHcm91cH0uIHtAbGluayBDb250cm9sR3JvdXB9IGNhbiBhbHNvIGNvbnRhaW5cbiAqIG90aGVyIGNvbnRyb2xzLCBidXQgaXMgb2YgZml4ZWQgbGVuZ3RoLlxuICpcbiAqICMjIEFkZGluZyBvciByZW1vdmluZyBjb250cm9sc1xuICpcbiAqIFRvIGNoYW5nZSB0aGUgY29udHJvbHMgaW4gdGhlIGFycmF5LCB1c2UgdGhlIGBwdXNoYCwgYGluc2VydGAsIG9yIGByZW1vdmVBdGAgbWV0aG9kc1xuICogaW4gYENvbnRyb2xBcnJheWAgaXRzZWxmLiBUaGVzZSBtZXRob2RzIGVuc3VyZSB0aGUgY29udHJvbHMgYXJlIHByb3Blcmx5IHRyYWNrZWQgaW4gdGhlXG4gKiBmb3JtJ3MgaGllcmFyY2h5LiBEbyBub3QgbW9kaWZ5IHRoZSBhcnJheSBvZiBgQWJzdHJhY3RDb250cm9sYHMgdXNlZCB0byBpbnN0YW50aWF0ZVxuICogdGhlIGBDb250cm9sQXJyYXlgIGRpcmVjdGx5LCBhcyB0aGF0IHdpbGwgcmVzdWx0IGluIHN0cmFuZ2UgYW5kIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc3VjaFxuICogYXMgYnJva2VuIGNoYW5nZSBkZXRlY3Rpb24uXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzIzREVTT3BiTm5CcEJIWnQxQlI0P3A9cHJldmlldykpXG4gKi9cbnZhciBDb250cm9sQXJyYXkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250cm9sQXJyYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udHJvbEFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50Rm9yQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAqL1xuICAgIENvbnRyb2xBcnJheS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHNbaW5kZXhdOyB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKi9cbiAgICBDb250cm9sQXJyYXkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goY29udHJvbCk7XG4gICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbnRyb2wpIHtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmluc2VydCh0aGlzLmNvbnRyb2xzLCBpbmRleCwgY29udHJvbCk7XG4gICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgY29udHJvbCBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5yZW1vdmVBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlQXQodGhpcy5jb250cm9scywgaW5kZXgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQXJyYXkucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZW5ndGggb2YgdGhlIGNvbnRyb2wgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbHVlID0gdGhpcy5jb250cm9scy5tYXAoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wudmFsdWU7IH0pOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBDb250cm9sQXJyYXkucHJvdG90eXBlLl9hbnlDb250cm9sc0hhdmVTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc3RhdHVzID09IHN0YXR1czsgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgQ29udHJvbEFycmF5LnByb3RvdHlwZS5fc2V0UGFyZW50Rm9yQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLnNldFBhcmVudChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRyb2xBcnJheTtcbn0oQWJzdHJhY3RDb250cm9sKSk7XG5leHBvcnRzLkNvbnRyb2xBcnJheSA9IENvbnRyb2xBcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL3Byb21pc2UnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9hc3luYycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xuLyoqXG4gKiBQcm92aWRlcnMgZm9yIHZhbGlkYXRvcnMgdG8gYmUgdXNlZCBmb3Ige0BsaW5rIENvbnRyb2x9cyBpbiBhIGZvcm0uXG4gKlxuICogUHJvdmlkZSB0aGlzIHVzaW5nIGBtdWx0aTogdHJ1ZWAgdG8gYWRkIHZhbGlkYXRvcnMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiB7QGV4YW1wbGUgY29yZS9mb3Jtcy90cy9uZ192YWxpZGF0b3JzL25nX3ZhbGlkYXRvcnMudHMgcmVnaW9uPSduZ192YWxpZGF0b3JzJ31cbiAqL1xuZXhwb3J0cy5OR19WQUxJREFUT1JTID0gbmV3IGNvcmVfMS5PcGFxdWVUb2tlbihcIk5nVmFsaWRhdG9yc1wiKTtcbi8qKlxuICogUHJvdmlkZXJzIGZvciBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0byBiZSB1c2VkIGZvciB7QGxpbmsgQ29udHJvbH1zXG4gKiBpbiBhIGZvcm0uXG4gKlxuICogUHJvdmlkZSB0aGlzIHVzaW5nIGBtdWx0aTogdHJ1ZWAgdG8gYWRkIHZhbGlkYXRvcnMuXG4gKlxuICogU2VlIHtAbGluayBOR19WQUxJREFUT1JTfSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5leHBvcnRzLk5HX0FTWU5DX1ZBTElEQVRPUlMgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBuZXcgY29yZV8xLk9wYXF1ZVRva2VuKFwiTmdBc3luY1ZhbGlkYXRvcnNcIik7XG4vKipcbiAqIFByb3ZpZGVzIGEgc2V0IG9mIHZhbGlkYXRvcnMgdXNlZCBieSBmb3JtIGNvbnRyb2xzLlxuICpcbiAqIEEgdmFsaWRhdG9yIGlzIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSB7QGxpbmsgQ29udHJvbH0gb3IgY29sbGVjdGlvbiBvZlxuICogY29udHJvbHMgYW5kIHJldHVybnMgYSBtYXAgb2YgZXJyb3JzLiBBIG51bGwgbWFwIG1lYW5zIHRoYXQgdmFsaWRhdGlvbiBoYXMgcGFzc2VkLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogdmFyIGxvZ2luQ29udHJvbCA9IG5ldyBDb250cm9sKFwiXCIsIFZhbGlkYXRvcnMucmVxdWlyZWQpXG4gKiBgYGBcbiAqL1xudmFyIFZhbGlkYXRvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRvcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2xzIHRvIGhhdmUgYSBub24tZW1wdHkgdmFsdWUuXG4gICAgICovXG4gICAgVmFsaWRhdG9ycy5yZXF1aXJlZCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayhjb250cm9sLnZhbHVlKSB8fCAobGFuZ18xLmlzU3RyaW5nKGNvbnRyb2wudmFsdWUpICYmIGNvbnRyb2wudmFsdWUgPT0gXCJcIikgP1xuICAgICAgICAgICAgeyBcInJlcXVpcmVkXCI6IHRydWUgfSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWluaW11bSBsZW5ndGguXG4gICAgICovXG4gICAgVmFsaWRhdG9ycy5taW5MZW5ndGggPSBmdW5jdGlvbiAobWluTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdiA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPCBtaW5MZW5ndGggP1xuICAgICAgICAgICAgICAgIHsgXCJtaW5sZW5ndGhcIjogeyBcInJlcXVpcmVkTGVuZ3RoXCI6IG1pbkxlbmd0aCwgXCJhY3R1YWxMZW5ndGhcIjogdi5sZW5ndGggfSB9IDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWF4aW11bSBsZW5ndGguXG4gICAgICovXG4gICAgVmFsaWRhdG9ycy5tYXhMZW5ndGggPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdiA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPiBtYXhMZW5ndGggP1xuICAgICAgICAgICAgICAgIHsgXCJtYXhsZW5ndGhcIjogeyBcInJlcXVpcmVkTGVuZ3RoXCI6IG1heExlbmd0aCwgXCJhY3R1YWxMZW5ndGhcIjogdi5sZW5ndGggfSB9IDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgYSBjb250cm9sIHRvIG1hdGNoIGEgcmVnZXggdG8gaXRzIHZhbHVlLlxuICAgICAqL1xuICAgIFZhbGlkYXRvcnMucGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsgcGF0dGVybiArIFwiJFwiKTtcbiAgICAgICAgICAgIHZhciB2ID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZWdleC50ZXN0KHYpID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgeyBcInBhdHRlcm5cIjogeyBcInJlcXVpcmVkUGF0dGVyblwiOiBcIl5cIiArIHBhdHRlcm4gKyBcIiRcIiwgXCJhY3R1YWxWYWx1ZVwiOiB2IH0gfTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vLW9wIHZhbGlkYXRvci5cbiAgICAgKi9cbiAgICBWYWxpZGF0b3JzLm51bGxWYWxpZGF0b3IgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBDb21wb3NlIG11bHRpcGxlIHZhbGlkYXRvcnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHVuaW9uXG4gICAgICogb2YgdGhlIGluZGl2aWR1YWwgZXJyb3IgbWFwcy5cbiAgICAgKi9cbiAgICBWYWxpZGF0b3JzLmNvbXBvc2UgPSBmdW5jdGlvbiAodmFsaWRhdG9ycykge1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsaWRhdG9ycykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHByZXNlbnRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIobGFuZ18xLmlzUHJlc2VudCk7XG4gICAgICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWVyZ2VFcnJvcnMoX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyA9IGZ1bmN0aW9uICh2YWxpZGF0b3JzKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWxpZGF0b3JzKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgcHJlc2VudFZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzLmZpbHRlcihsYW5nXzEuaXNQcmVzZW50KTtcbiAgICAgICAgaWYgKHByZXNlbnRWYWxpZGF0b3JzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gX2V4ZWN1dGVBc3luY1ZhbGlkYXRvcnMoY29udHJvbCwgcHJlc2VudFZhbGlkYXRvcnMpLm1hcChfY29udmVydFRvUHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZV8xLlByb21pc2VXcmFwcGVyLmFsbChwcm9taXNlcykudGhlbihfbWVyZ2VFcnJvcnMpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFZhbGlkYXRvcnM7XG59KCkpO1xuZXhwb3J0cy5WYWxpZGF0b3JzID0gVmFsaWRhdG9ycztcbmZ1bmN0aW9uIF9jb252ZXJ0VG9Qcm9taXNlKG9iaikge1xuICAgIHJldHVybiBwcm9taXNlXzEuUHJvbWlzZVdyYXBwZXIuaXNQcm9taXNlKG9iaikgPyBvYmogOiBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnRvUHJvbWlzZShvYmopO1xufVxuZnVuY3Rpb24gX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHZhbGlkYXRvcnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdG9ycy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYoY29udHJvbCk7IH0pO1xufVxuZnVuY3Rpb24gX2V4ZWN1dGVBc3luY1ZhbGlkYXRvcnMoY29udHJvbCwgdmFsaWRhdG9ycykge1xuICAgIHJldHVybiB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdihjb250cm9sKTsgfSk7XG59XG5mdW5jdGlvbiBfbWVyZ2VFcnJvcnMoYXJyYXlPZkVycm9ycykge1xuICAgIHZhciByZXMgPSBhcnJheU9mRXJyb3JzLnJlZHVjZShmdW5jdGlvbiAocmVzLCBlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQoZXJyb3JzKSA/IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHJlcywgZXJyb3JzKSA6IHJlcztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmlzRW1wdHkocmVzKSA/IG51bGwgOiByZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0b3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vbG9jYXRpb24vcGxhdGZvcm1fbG9jYXRpb24nKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL2xvY2F0aW9uL2xvY2F0aW9uX3N0cmF0ZWd5JykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9sb2NhdGlvbi9oYXNoX2xvY2F0aW9uX3N0cmF0ZWd5JykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9sb2NhdGlvbi9wYXRoX2xvY2F0aW9uX3N0cmF0ZWd5JykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9sb2NhdGlvbi9sb2NhdGlvbicpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGxvY2F0aW9uX3N0cmF0ZWd5XzEgPSByZXF1aXJlKCcuL2xvY2F0aW9uX3N0cmF0ZWd5Jyk7XG52YXIgbG9jYXRpb25fMSA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKTtcbnZhciBwbGF0Zm9ybV9sb2NhdGlvbl8xID0gcmVxdWlyZSgnLi9wbGF0Zm9ybV9sb2NhdGlvbicpO1xudmFyIEhhc2hMb2NhdGlvblN0cmF0ZWd5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGFzaExvY2F0aW9uU3RyYXRlZ3ksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGFzaExvY2F0aW9uU3RyYXRlZ3koX3BsYXRmb3JtTG9jYXRpb24sIF9iYXNlSHJlZikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbiA9IF9wbGF0Zm9ybUxvY2F0aW9uO1xuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9ICcnO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChfYmFzZUhyZWYpKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IF9iYXNlSHJlZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uUG9wU3RhdGUoZm4pO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uSGFzaENoYW5nZShmbik7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9iYXNlSHJlZjsgfTtcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhlIGhhc2ggdmFsdWUgaXMgYWx3YXlzIHByZWZpeGVkIHdpdGggYSBgI2BcbiAgICAgICAgLy8gYW5kIGlmIGl0IGlzIGVtcHR5IHRoZW4gaXQgd2lsbCBzdGF5IGVtcHR5XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5oYXNoO1xuICAgICAgICBpZiAoIWxhbmdfMS5pc1ByZXNlbnQocGF0aCkpXG4gICAgICAgICAgICBwYXRoID0gJyMnO1xuICAgICAgICAvLyBEYXJ0IHdpbGwgY29tcGxhaW4gaWYgYSBjYWxsIHRvIHN1YnN0cmluZyBpc1xuICAgICAgICAvLyBleGVjdXRlZCB3aXRoIGEgcG9zaXRpb24gdmFsdWUgdGhhdCBleHRlbmRzIHRoZVxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nLlxuICAgICAgICByZXR1cm4gKHBhdGgubGVuZ3RoID4gMCA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aCk7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHJlcGFyZUV4dGVybmFsVXJsID0gZnVuY3Rpb24gKGludGVybmFsKSB7XG4gICAgICAgIHZhciB1cmwgPSBsb2NhdGlvbl8xLkxvY2F0aW9uLmpvaW5XaXRoU2xhc2godGhpcy5fYmFzZUhyZWYsIGludGVybmFsKTtcbiAgICAgICAgcmV0dXJuIHVybC5sZW5ndGggPiAwID8gKCcjJyArIHVybCkgOiB1cmw7XG4gICAgfTtcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgcGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHBhdGggKyBsb2NhdGlvbl8xLkxvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgIGlmICh1cmwubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHVybCA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICAgIH07XG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnByZXBhcmVFeHRlcm5hbFVybChwYXRoICsgbG9jYXRpb25fMS5Mb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykpO1xuICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB1cmwgPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICB9O1xuICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmZvcndhcmQoKTsgfTtcbiAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5iYWNrKCk7IH07XG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogcGxhdGZvcm1fbG9jYXRpb25fMS5QbGF0Zm9ybUxvY2F0aW9uLCB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLk9wdGlvbmFsIH0sIHsgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW2xvY2F0aW9uX3N0cmF0ZWd5XzEuQVBQX0JBU0VfSFJFRixdIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIEhhc2hMb2NhdGlvblN0cmF0ZWd5O1xufShsb2NhdGlvbl9zdHJhdGVneV8xLkxvY2F0aW9uU3RyYXRlZ3kpKTtcbmV4cG9ydHMuSGFzaExvY2F0aW9uU3RyYXRlZ3kgPSBIYXNoTG9jYXRpb25TdHJhdGVneTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2hfbG9jYXRpb25fc3RyYXRlZ3kuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgbG9jYXRpb25fc3RyYXRlZ3lfMSA9IHJlcXVpcmUoJy4vbG9jYXRpb25fc3RyYXRlZ3knKTtcbnZhciBMb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9jYXRpb24ocGxhdGZvcm1TdHJhdGVneSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBsYXRmb3JtU3RyYXRlZ3kgPSBwbGF0Zm9ybVN0cmF0ZWd5O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFyIGJyb3dzZXJCYXNlSHJlZiA9IHRoaXMucGxhdGZvcm1TdHJhdGVneS5nZXRCYXNlSHJlZigpO1xuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBJbmRleEh0bWwoYnJvd3NlckJhc2VIcmVmKSk7XG4gICAgICAgIHRoaXMucGxhdGZvcm1TdHJhdGVneS5vblBvcFN0YXRlKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5jYWxsRW1pdChfdGhpcy5fc3ViamVjdCwgeyAndXJsJzogX3RoaXMucGF0aCgpLCAncG9wJzogdHJ1ZSwgJ3R5cGUnOiBldi50eXBlIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBVUkwgcGF0aC5cbiAgICAgKi9cbiAgICBMb2NhdGlvbi5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9ybWFsaXplKHRoaXMucGxhdGZvcm1TdHJhdGVneS5wYXRoKCkpOyB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFVSTCwgcmV0dXJucyB0aGUgbm9ybWFsaXplZCBVUkwgcGF0aCB3aXRob3V0IGxlYWRpbmcgb3JcbiAgICAgKiB0cmFpbGluZyBzbGFzaGVzXG4gICAgICovXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaChfc3RyaXBCYXNlSHJlZih0aGlzLl9iYXNlSHJlZiwgX3N0cmlwSW5kZXhIdG1sKHVybCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFVSTCwgcmV0dXJucyB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgZXh0ZXJuYWwgVVJMIHBhdGguXG4gICAgICogSWYgdGhlIGdpdmVuIFVSTCBkb2Vzbid0IGJlZ2luIHdpdGggYSBsZWFkaW5nIHNsYXNoIChgJy8nYCksIHRoaXMgbWV0aG9kIGFkZHMgb25lXG4gICAgICogYmVmb3JlIG5vcm1hbGl6aW5nLiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gYWRkIGEgaGFzaCBpZiBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgIGlzXG4gICAgICogdXNlZCwgb3IgdGhlIGBBUFBfQkFTRV9IUkVGYCBpZiB0aGUgYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyBpbiB1c2UuXG4gICAgICovXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLnByZXBhcmVFeHRlcm5hbFVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgaWYgKHVybC5sZW5ndGggPiAwICYmICF1cmwuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICB1cmwgPSAnLycgKyB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGxhdGZvcm1TdHJhdGVneS5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IHJlbmFtZSB0aGlzIG1ldGhvZCB0byBwdXNoU3RhdGVcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBicm93c2VycyBVUkwgdG8gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLCBhbmQgcHVzaGVzIGFcbiAgICAgKiBuZXcgaXRlbSBvbnRvIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXG4gICAgICovXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0gJyc7IH1cbiAgICAgICAgdGhpcy5wbGF0Zm9ybVN0cmF0ZWd5LnB1c2hTdGF0ZShudWxsLCAnJywgcGF0aCwgcXVlcnkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcnMgVVJMIHRvIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIFVSTCwgYW5kIHJlcGxhY2VzXG4gICAgICogdGhlIHRvcCBpdGVtIG9uIHRoZSBwbGF0Zm9ybSdzIGhpc3Rvcnkgc3RhY2suXG4gICAgICovXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xuICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9ICcnOyB9XG4gICAgICAgIHRoaXMucGxhdGZvcm1TdHJhdGVneS5yZXBsYWNlU3RhdGUobnVsbCwgJycsIHBhdGgsIHF1ZXJ5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlcyBmb3J3YXJkIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXG4gICAgICovXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMucGxhdGZvcm1TdHJhdGVneS5mb3J3YXJkKCk7IH07XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIGJhY2sgaW4gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeS5cbiAgICAgKi9cbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5wbGF0Zm9ybVN0cmF0ZWd5LmJhY2soKTsgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIHBsYXRmb3JtJ3MgYHBvcFN0YXRlYCBldmVudHMuXG4gICAgICovXG4gICAgTG9jYXRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvbk5leHQsIG9uVGhyb3csIG9uUmV0dXJuKSB7XG4gICAgICAgIGlmIChvblRocm93ID09PSB2b2lkIDApIHsgb25UaHJvdyA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9uUmV0dXJuID09PSB2b2lkIDApIHsgb25SZXR1cm4gPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZSh0aGlzLl9zdWJqZWN0LCBvbk5leHQsIG9uVGhyb3csIG9uUmV0dXJuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3RyaW5nIG9mIHVybCBwYXJhbWV0ZXJzLCBwcmVwZW5kIHdpdGggJz8nIGlmIG5lZWRlZCwgb3RoZXJ3aXNlIHJldHVybiBwYXJhbWV0ZXJzIGFzXG4gICAgICogaXMuXG4gICAgICovXG4gICAgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgcGFyYW1zLnN1YnN0cmluZygwLCAxKSAhPSAnPycpID8gKCc/JyArIHBhcmFtcykgOiBwYXJhbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiAyIHBhcnRzIG9mIGEgdXJsLCBqb2luIHRoZW0gd2l0aCBhIHNsYXNoIGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBMb2NhdGlvbi5qb2luV2l0aFNsYXNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2xhc2hlcyA9IDA7XG4gICAgICAgIGlmIChzdGFydC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBzbGFzaGVzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHNsYXNoZXMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xhc2hlcyA9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgKyBlbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbGFzaGVzID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydCArIGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgKyAnLycgKyBlbmQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB1cmwgaGFzIGEgdHJhaWxpbmcgc2xhc2gsIHJlbW92ZSBpdCwgb3RoZXJ3aXNlIHJldHVybiB1cmwgYXMgaXMuXG4gICAgICovXG4gICAgTG9jYXRpb24uc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICBpZiAoL1xcLyQvZy50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICBMb2NhdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBMb2NhdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBsb2NhdGlvbl9zdHJhdGVneV8xLkxvY2F0aW9uU3RyYXRlZ3ksIH0sXG4gICAgXTtcbiAgICByZXR1cm4gTG9jYXRpb247XG59KCkpO1xuZXhwb3J0cy5Mb2NhdGlvbiA9IExvY2F0aW9uO1xuZnVuY3Rpb24gX3N0cmlwQmFzZUhyZWYoYmFzZUhyZWYsIHVybCkge1xuICAgIGlmIChiYXNlSHJlZi5sZW5ndGggPiAwICYmIHVybC5zdGFydHNXaXRoKGJhc2VIcmVmKSkge1xuICAgICAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhiYXNlSHJlZi5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gX3N0cmlwSW5kZXhIdG1sKHVybCkge1xuICAgIGlmICgvXFwvaW5kZXguaHRtbCQvZy50ZXN0KHVybCkpIHtcbiAgICAgICAgLy8gJy9pbmRleC5odG1sJy5sZW5ndGggPT0gMTFcbiAgICAgICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDExKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbi8qKlxuICogYExvY2F0aW9uU3RyYXRlZ3lgIGlzIHJlc3BvbnNpYmxlIGZvciByZXByZXNlbnRpbmcgYW5kIHJlYWRpbmcgcm91dGUgc3RhdGVcbiAqIGZyb20gdGhlIGJyb3dzZXIncyBVUkwuIEFuZ3VsYXIgcHJvdmlkZXMgdHdvIHN0cmF0ZWdpZXM6XG4gKiB7QGxpbmsgSGFzaExvY2F0aW9uU3RyYXRlZ3l9IGFuZCB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9IChkZWZhdWx0KS5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdW5kZXIgdGhlIGhvb2Qgb2YgdGhlIHtAbGluayBMb2NhdGlvbn0gc2VydmljZS5cbiAqXG4gKiBBcHBsaWNhdGlvbnMgc2hvdWxkIHVzZSB0aGUge0BsaW5rIFJvdXRlcn0gb3Ige0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlcyB0b1xuICogaW50ZXJhY3Qgd2l0aCBhcHBsaWNhdGlvbiByb3V0ZSBzdGF0ZS5cbiAqXG4gKiBGb3IgaW5zdGFuY2UsIHtAbGluayBIYXNoTG9jYXRpb25TdHJhdGVneX0gcHJvZHVjZXMgVVJMcyBsaWtlXG4gKiBgaHR0cDovL2V4YW1wbGUuY29tIy9mb29gLCBhbmQge0BsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fSBwcm9kdWNlc1xuICogYGh0dHA6Ly9leGFtcGxlLmNvbS9mb29gIGFzIGFuIGVxdWl2YWxlbnQgVVJMLlxuICpcbiAqIFNlZSB0aGVzZSB0d28gY2xhc3NlcyBmb3IgbW9yZS5cbiAqL1xudmFyIExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvY2F0aW9uU3RyYXRlZ3koKSB7XG4gICAgfVxuICAgIHJldHVybiBMb2NhdGlvblN0cmF0ZWd5O1xufSgpKTtcbmV4cG9ydHMuTG9jYXRpb25TdHJhdGVneSA9IExvY2F0aW9uU3RyYXRlZ3k7XG4vKipcbiAqIFRoZSBgQVBQX0JBU0VfSFJFRmAgdG9rZW4gcmVwcmVzZW50cyB0aGUgYmFzZSBocmVmIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAqIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0uXG4gKlxuICogSWYgeW91J3JlIHVzaW5nIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0sIHlvdSBtdXN0IHByb3ZpZGUgYSBwcm92aWRlciB0byBhIHN0cmluZ1xuICogcmVwcmVzZW50aW5nIHRoZSBVUkwgcHJlZml4IHRoYXQgc2hvdWxkIGJlIHByZXNlcnZlZCB3aGVuIGdlbmVyYXRpbmcgYW5kIHJlY29nbml6aW5nXG4gKiBVUkxzLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQge1JPVVRFUl9ESVJFQ1RJVkVTLCBST1VURVJfUFJPVklERVJTLCBSb3V0ZUNvbmZpZ30gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbiAqIGltcG9ydCB7QVBQX0JBU0VfSFJFRn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbiAqXG4gKiBAQ29tcG9uZW50KHtkaXJlY3RpdmVzOiBbUk9VVEVSX0RJUkVDVElWRVNdfSlcbiAqIEBSb3V0ZUNvbmZpZyhbXG4gKiAgey4uLn0sXG4gKiBdKVxuICogY2xhc3MgQXBwQ21wIHtcbiAqICAgLy8gLi4uXG4gKiB9XG4gKlxuICogYm9vdHN0cmFwKEFwcENtcCwgW1xuICogICBST1VURVJfUFJPVklERVJTLFxuICogICBwcm92aWRlKEFQUF9CQVNFX0hSRUYsIHt1c2VWYWx1ZTogJy9teS9hcHAnfSlcbiAqIF0pO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuQVBQX0JBU0VfSFJFRiA9IG5ldyBjb3JlXzEuT3BhcXVlVG9rZW4oJ2FwcEJhc2VIcmVmJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhdGlvbl9zdHJhdGVneS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBwbGF0Zm9ybV9sb2NhdGlvbl8xID0gcmVxdWlyZSgnLi9wbGF0Zm9ybV9sb2NhdGlvbicpO1xudmFyIGxvY2F0aW9uX3N0cmF0ZWd5XzEgPSByZXF1aXJlKCcuL2xvY2F0aW9uX3N0cmF0ZWd5Jyk7XG52YXIgbG9jYXRpb25fMSA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKTtcbnZhciBQYXRoTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhdGhMb2NhdGlvblN0cmF0ZWd5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhdGhMb2NhdGlvblN0cmF0ZWd5KF9wbGF0Zm9ybUxvY2F0aW9uLCBocmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uID0gX3BsYXRmb3JtTG9jYXRpb247XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhocmVmKSkge1xuICAgICAgICAgICAgaHJlZiA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uZ2V0QmFzZUhyZWZGcm9tRE9NKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGhyZWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyBiYXNlIGhyZWYgc2V0LiBQbGVhc2UgcHJvdmlkZSBhIHZhbHVlIGZvciB0aGUgQVBQX0JBU0VfSFJFRiB0b2tlbiBvciBhZGQgYSBiYXNlIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ub25Qb3BTdGF0ZShmbik7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ub25IYXNoQ2hhbmdlKGZuKTtcbiAgICB9O1xuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jhc2VIcmVmOyB9O1xuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wcmVwYXJlRXh0ZXJuYWxVcmwgPSBmdW5jdGlvbiAoaW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uXzEuTG9jYXRpb24uam9pbldpdGhTbGFzaCh0aGlzLl9iYXNlSHJlZiwgaW50ZXJuYWwpO1xuICAgIH07XG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgICAgICAgIGxvY2F0aW9uXzEuTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXModGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5zZWFyY2gpO1xuICAgIH07XG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgdmFyIGV4dGVybmFsVXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsICsgbG9jYXRpb25fMS5Mb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykpO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIGV4dGVybmFsVXJsKTtcbiAgICB9O1xuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIHZhciBleHRlcm5hbFVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHVybCArIGxvY2F0aW9uXzEuTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnlQYXJhbXMpKTtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBleHRlcm5hbFVybCk7XG4gICAgfTtcbiAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5mb3J3YXJkKCk7IH07XG4gICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uYmFjaygpOyB9O1xuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IHBsYXRmb3JtX2xvY2F0aW9uXzEuUGxhdGZvcm1Mb2NhdGlvbiwgfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5PcHRpb25hbCB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFtsb2NhdGlvbl9zdHJhdGVneV8xLkFQUF9CQVNFX0hSRUYsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBQYXRoTG9jYXRpb25TdHJhdGVneTtcbn0obG9jYXRpb25fc3RyYXRlZ3lfMS5Mb2NhdGlvblN0cmF0ZWd5KSk7XG5leHBvcnRzLlBhdGhMb2NhdGlvblN0cmF0ZWd5ID0gUGF0aExvY2F0aW9uU3RyYXRlZ3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoX2xvY2F0aW9uX3N0cmF0ZWd5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4qIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5IGJ5IGFuIGFwcGxpY2F0aW9uIGRldmVsb3Blci4gSW5zdGVhZCwgdXNlXG4qIHtAbGluayBMb2NhdGlvbn0uXG4qXG4qIGBQbGF0Zm9ybUxvY2F0aW9uYCBlbmNhcHN1bGF0ZXMgYWxsIGNhbGxzIHRvIERPTSBhcGlzLCB3aGljaCBhbGxvd3MgdGhlIFJvdXRlciB0byBiZSBwbGF0Zm9ybVxuKiBhZ25vc3RpYy5cbiogVGhpcyBtZWFucyB0aGF0IHdlIGNhbiBoYXZlIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbiBvZiBgUGxhdGZvcm1Mb2NhdGlvbmAgZm9yIHRoZSBkaWZmZXJlbnRcbiogcGxhdGZvcm1zXG4qIHRoYXQgYW5ndWxhciBzdXBwb3J0cy4gRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IGBQbGF0Zm9ybUxvY2F0aW9uYCBpcyB7QGxpbmtcbiogQnJvd3NlclBsYXRmb3JtTG9jYXRpb259LFxuKiBob3dldmVyIHdoZW4geW91IHJ1biB5b3VyIGFwcCBpbiBhIFdlYldvcmtlciB5b3UgdXNlIHtAbGluayBXZWJXb3JrZXJQbGF0Zm9ybUxvY2F0aW9ufS5cbipcbiogVGhlIGBQbGF0Zm9ybUxvY2F0aW9uYCBjbGFzcyBpcyB1c2VkIGRpcmVjdGx5IGJ5IGFsbCBpbXBsZW1lbnRhdGlvbnMgb2Yge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9XG4qIHdoZW5cbiogdGhleSBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhlIERPTSBhcGlzIGxpa2UgcHVzaFN0YXRlLCBwb3BTdGF0ZSwgZXRjLi4uXG4qXG4qIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBpbiB0dXJuIGlzIHVzZWQgYnkgdGhlIHtAbGluayBMb2NhdGlvbn0gc2VydmljZSB3aGljaCBpcyB1c2VkIGRpcmVjdGx5XG4qIGJ5XG4qIHRoZSB7QGxpbmsgUm91dGVyfSBpbiBvcmRlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHJvdXRlcy4gU2luY2UgYWxsIGludGVyYWN0aW9ucyBiZXR3ZWVuIHtAbGlua1xuKiBSb3V0ZXJ9IC9cbioge0BsaW5rIExvY2F0aW9ufSAvIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBhbmQgRE9NIGFwaXMgZmxvdyB0aHJvdWdoIHRoZSBgUGxhdGZvcm1Mb2NhdGlvbmBcbiogY2xhc3NcbiogdGhleSBhcmUgYWxsIHBsYXRmb3JtIGluZGVwZW5kZW50LlxuKi9cbnZhciBQbGF0Zm9ybUxvY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybUxvY2F0aW9uKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwicGF0aG5hbWVcIiwge1xuICAgICAgICAvKiBhYnN0cmFjdCAqLyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwge1xuICAgICAgICAvKiBhYnN0cmFjdCAqLyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJoYXNoXCIsIHtcbiAgICAgICAgLyogYWJzdHJhY3QgKi8gZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUGxhdGZvcm1Mb2NhdGlvbjtcbn0oKSk7XG5leHBvcnRzLlBsYXRmb3JtTG9jYXRpb24gPSBQbGF0Zm9ybUxvY2F0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm1fbG9jYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiogQG1vZHVsZVxuKiBAZGVzY3JpcHRpb25cbiogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBzZXQgb2YgY29tbW9uIFBpcGVzLlxuKi9cbnZhciBhc3luY19waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL2FzeW5jX3BpcGUnKTtcbmV4cG9ydHMuQXN5bmNQaXBlID0gYXN5bmNfcGlwZV8xLkFzeW5jUGlwZTtcbnZhciBkYXRlX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvZGF0ZV9waXBlJyk7XG5leHBvcnRzLkRhdGVQaXBlID0gZGF0ZV9waXBlXzEuRGF0ZVBpcGU7XG52YXIganNvbl9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL2pzb25fcGlwZScpO1xuZXhwb3J0cy5Kc29uUGlwZSA9IGpzb25fcGlwZV8xLkpzb25QaXBlO1xudmFyIHNsaWNlX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvc2xpY2VfcGlwZScpO1xuZXhwb3J0cy5TbGljZVBpcGUgPSBzbGljZV9waXBlXzEuU2xpY2VQaXBlO1xudmFyIGxvd2VyY2FzZV9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL2xvd2VyY2FzZV9waXBlJyk7XG5leHBvcnRzLkxvd2VyQ2FzZVBpcGUgPSBsb3dlcmNhc2VfcGlwZV8xLkxvd2VyQ2FzZVBpcGU7XG52YXIgbnVtYmVyX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvbnVtYmVyX3BpcGUnKTtcbmV4cG9ydHMuTnVtYmVyUGlwZSA9IG51bWJlcl9waXBlXzEuTnVtYmVyUGlwZTtcbmV4cG9ydHMuRGVjaW1hbFBpcGUgPSBudW1iZXJfcGlwZV8xLkRlY2ltYWxQaXBlO1xuZXhwb3J0cy5QZXJjZW50UGlwZSA9IG51bWJlcl9waXBlXzEuUGVyY2VudFBpcGU7XG5leHBvcnRzLkN1cnJlbmN5UGlwZSA9IG51bWJlcl9waXBlXzEuQ3VycmVuY3lQaXBlO1xudmFyIHVwcGVyY2FzZV9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL3VwcGVyY2FzZV9waXBlJyk7XG5leHBvcnRzLlVwcGVyQ2FzZVBpcGUgPSB1cHBlcmNhc2VfcGlwZV8xLlVwcGVyQ2FzZVBpcGU7XG52YXIgcmVwbGFjZV9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL3JlcGxhY2VfcGlwZScpO1xuZXhwb3J0cy5SZXBsYWNlUGlwZSA9IHJlcGxhY2VfcGlwZV8xLlJlcGxhY2VQaXBlO1xudmFyIGkxOG5fcGx1cmFsX3BpcGVfMSA9IHJlcXVpcmUoJy4vcGlwZXMvaTE4bl9wbHVyYWxfcGlwZScpO1xuZXhwb3J0cy5JMThuUGx1cmFsUGlwZSA9IGkxOG5fcGx1cmFsX3BpcGVfMS5JMThuUGx1cmFsUGlwZTtcbnZhciBpMThuX3NlbGVjdF9waXBlXzEgPSByZXF1aXJlKCcuL3BpcGVzL2kxOG5fc2VsZWN0X3BpcGUnKTtcbmV4cG9ydHMuSTE4blNlbGVjdFBpcGUgPSBpMThuX3NlbGVjdF9waXBlXzEuSTE4blNlbGVjdFBpcGU7XG52YXIgY29tbW9uX3BpcGVzXzEgPSByZXF1aXJlKCcuL3BpcGVzL2NvbW1vbl9waXBlcycpO1xuZXhwb3J0cy5DT01NT05fUElQRVMgPSBjb21tb25fcGlwZXNfMS5DT01NT05fUElQRVM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvYXN5bmMnKTtcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcbnZhciBPYnNlcnZhYmxlU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgT2JzZXJ2YWJsZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZShhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVN0cmF0ZWd5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmRpc3Bvc2Uoc3Vic2NyaXB0aW9uKTsgfTtcbiAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5kaXNwb3NlKHN1YnNjcmlwdGlvbik7IH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVTdHJhdGVneTtcbn0oKSk7XG52YXIgUHJvbWlzZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9taXNlU3RyYXRlZ3koKSB7XG4gICAgfVxuICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYXN5bmMudGhlbih1cGRhdGVMYXRlc3RWYWx1ZSk7XG4gICAgfTtcbiAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XG4gICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XG4gICAgcmV0dXJuIFByb21pc2VTdHJhdGVneTtcbn0oKSk7XG52YXIgX3Byb21pc2VTdHJhdGVneSA9IG5ldyBQcm9taXNlU3RyYXRlZ3koKTtcbnZhciBfb2JzZXJ2YWJsZVN0cmF0ZWd5ID0gbmV3IE9ic2VydmFibGVTdHJhdGVneSgpO1xudmFyIF9fdW51c2VkO1xudmFyIEFzeW5jUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNQaXBlKF9yZWYpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vYmogPSBudWxsO1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlZiA9IF9yZWY7XG4gICAgfVxuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3N1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLl9vYmopKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvYmopKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiAhPT0gdGhpcy5fb2JqKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGF0ZXN0VmFsdWUgPT09IHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVfMS5XcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSB0aGlzLl9zZWxlY3RTdHJhdGVneShvYmopO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9zdHJhdGVneS5jcmVhdGVTdWJzY3JpcHRpb24ob2JqLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl91cGRhdGVMYXRlc3RWYWx1ZShvYmosIHZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fc2VsZWN0U3RyYXRlZ3kgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcm9taXNlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZVN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuaXNPYnNlcnZhYmxlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JzZXJ2YWJsZVN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKEFzeW5jUGlwZSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX2Rpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5LmRpc3Bvc2UodGhpcy5fc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBBc3luY1BpcGUucHJvdG90eXBlLl91cGRhdGVMYXRlc3RWYWx1ZSA9IGZ1bmN0aW9uIChhc3luYywgdmFsdWUpIHtcbiAgICAgICAgaWYgKGFzeW5jID09PSB0aGlzLl9vYmopIHtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnYXN5bmMnLCBwdXJlOiBmYWxzZSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgQXN5bmNQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5DaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICBdO1xuICAgIHJldHVybiBBc3luY1BpcGU7XG59KCkpO1xuZXhwb3J0cy5Bc3luY1BpcGUgPSBBc3luY1BpcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luY19waXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4qIEBtb2R1bGVcbiogQGRlc2NyaXB0aW9uXG4qIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgc2V0IG9mIGNvbW1vbiBQaXBlcy5cbiovXG52YXIgYXN5bmNfcGlwZV8xID0gcmVxdWlyZSgnLi9hc3luY19waXBlJyk7XG52YXIgdXBwZXJjYXNlX3BpcGVfMSA9IHJlcXVpcmUoJy4vdXBwZXJjYXNlX3BpcGUnKTtcbnZhciBsb3dlcmNhc2VfcGlwZV8xID0gcmVxdWlyZSgnLi9sb3dlcmNhc2VfcGlwZScpO1xudmFyIGpzb25fcGlwZV8xID0gcmVxdWlyZSgnLi9qc29uX3BpcGUnKTtcbnZhciBzbGljZV9waXBlXzEgPSByZXF1aXJlKCcuL3NsaWNlX3BpcGUnKTtcbnZhciBkYXRlX3BpcGVfMSA9IHJlcXVpcmUoJy4vZGF0ZV9waXBlJyk7XG52YXIgbnVtYmVyX3BpcGVfMSA9IHJlcXVpcmUoJy4vbnVtYmVyX3BpcGUnKTtcbnZhciByZXBsYWNlX3BpcGVfMSA9IHJlcXVpcmUoJy4vcmVwbGFjZV9waXBlJyk7XG52YXIgaTE4bl9wbHVyYWxfcGlwZV8xID0gcmVxdWlyZSgnLi9pMThuX3BsdXJhbF9waXBlJyk7XG52YXIgaTE4bl9zZWxlY3RfcGlwZV8xID0gcmVxdWlyZSgnLi9pMThuX3NlbGVjdF9waXBlJyk7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBBbmd1bGFyIGNvcmUgcGlwZXMgdGhhdCBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgaW4gZWFjaCBhbmQgZXZlcnlcbiAqIGFwcGxpY2F0aW9uLlxuICpcbiAqIFRoaXMgY29sbGVjdGlvbiBjYW4gYmUgdXNlZCB0byBxdWlja2x5IGVudW1lcmF0ZSBhbGwgdGhlIGJ1aWx0LWluIHBpcGVzIGluIHRoZSBgcGlwZXNgXG4gKiBwcm9wZXJ0eSBvZiB0aGUgYEBDb21wb25lbnRgIGRlY29yYXRvci5cbiAqL1xuZXhwb3J0cy5DT01NT05fUElQRVMgPSBbXG4gICAgYXN5bmNfcGlwZV8xLkFzeW5jUGlwZSxcbiAgICB1cHBlcmNhc2VfcGlwZV8xLlVwcGVyQ2FzZVBpcGUsXG4gICAgbG93ZXJjYXNlX3BpcGVfMS5Mb3dlckNhc2VQaXBlLFxuICAgIGpzb25fcGlwZV8xLkpzb25QaXBlLFxuICAgIHNsaWNlX3BpcGVfMS5TbGljZVBpcGUsXG4gICAgbnVtYmVyX3BpcGVfMS5EZWNpbWFsUGlwZSxcbiAgICBudW1iZXJfcGlwZV8xLlBlcmNlbnRQaXBlLFxuICAgIG51bWJlcl9waXBlXzEuQ3VycmVuY3lQaXBlLFxuICAgIGRhdGVfcGlwZV8xLkRhdGVQaXBlLFxuICAgIHJlcGxhY2VfcGlwZV8xLlJlcGxhY2VQaXBlLFxuICAgIGkxOG5fcGx1cmFsX3BpcGVfMS5JMThuUGx1cmFsUGlwZSxcbiAgICBpMThuX3NlbGVjdF9waXBlXzEuSTE4blNlbGVjdFBpcGVcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb25fcGlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGludGxfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvaW50bCcpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMSA9IHJlcXVpcmUoJy4vaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbicpO1xuLy8gVE9ETzogbW92ZSB0byBhIGdsb2JhbCBjb25maWd1cmFibGUgbG9jYXRpb24gYWxvbmcgd2l0aCBvdGhlciBpMThuIGNvbXBvbmVudHMuXG52YXIgZGVmYXVsdExvY2FsZSA9ICdlbi1VUyc7XG52YXIgRGF0ZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGVQaXBlKCkge1xuICAgIH1cbiAgICBEYXRlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSB2b2lkIDApIHsgcGF0dGVybiA9ICdtZWRpdW1EYXRlJzsgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbihEYXRlUGlwZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGxhbmdfMS5EYXRlV3JhcHBlci5mcm9tTWlsbGlzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuY29udGFpbnMoRGF0ZVBpcGUuX0FMSUFTRVMsIHBhdHRlcm4pKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZ2V0KERhdGVQaXBlLl9BTElBU0VTLCBwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50bF8xLkRhdGVGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlLCBkZWZhdWx0TG9jYWxlLCBwYXR0ZXJuKTtcbiAgICB9O1xuICAgIERhdGVQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGxhbmdfMS5pc0RhdGUob2JqKSB8fCBsYW5nXzEuaXNOdW1iZXIob2JqKTsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGF0ZVBpcGUuX0FMSUFTRVMgPSB7XG4gICAgICAgICdtZWRpdW0nOiAneU1NTWRqbXMnLFxuICAgICAgICAnc2hvcnQnOiAneU1kam0nLFxuICAgICAgICAnZnVsbERhdGUnOiAneU1NTU1FRUVFZCcsXG4gICAgICAgICdsb25nRGF0ZSc6ICd5TU1NTWQnLFxuICAgICAgICAnbWVkaXVtRGF0ZSc6ICd5TU1NZCcsXG4gICAgICAgICdzaG9ydERhdGUnOiAneU1kJyxcbiAgICAgICAgJ21lZGl1bVRpbWUnOiAnam1zJyxcbiAgICAgICAgJ3Nob3J0VGltZSc6ICdqbSdcbiAgICB9O1xuICAgIERhdGVQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdkYXRlJywgcHVyZTogdHJ1ZSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIERhdGVQaXBlO1xufSgpKTtcbmV4cG9ydHMuRGF0ZVBpcGUgPSBEYXRlUGlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGVfcGlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XG52YXIgaW50ZXJwb2xhdGlvbkV4cCA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnIycpO1xudmFyIEkxOG5QbHVyYWxQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThuUGx1cmFsUGlwZSgpIHtcbiAgICB9XG4gICAgSTE4blBsdXJhbFBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGx1cmFsTWFwKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciB2YWx1ZVN0cjtcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNTdHJpbmdNYXAocGx1cmFsTWFwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKEkxOG5QbHVyYWxQaXBlLCBwbHVyYWxNYXApO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHZhbHVlID09PSAwIHx8IHZhbHVlID09PSAxID8gXCI9XCIgKyB2YWx1ZSA6ICdvdGhlcic7XG4gICAgICAgIHZhbHVlU3RyID0gbGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogJyc7XG4gICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHBsdXJhbE1hcFtrZXldLCBpbnRlcnBvbGF0aW9uRXhwLCB2YWx1ZVN0cik7XG4gICAgfTtcbiAgICBJMThuUGx1cmFsUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blBsdXJhbCcsIHB1cmU6IHRydWUgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIHJldHVybiBJMThuUGx1cmFsUGlwZTtcbn0oKSk7XG5leHBvcnRzLkkxOG5QbHVyYWxQaXBlID0gSTE4blBsdXJhbFBpcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pMThuX3BsdXJhbF9waXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcbnZhciBJMThuU2VsZWN0UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSTE4blNlbGVjdFBpcGUoKSB7XG4gICAgfVxuICAgIEkxOG5TZWxlY3RQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNTdHJpbmdNYXAobWFwcGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbihJMThuU2VsZWN0UGlwZSwgbWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zKG1hcHBpbmcsIHZhbHVlKSA/IG1hcHBpbmdbdmFsdWVdIDogbWFwcGluZ1snb3RoZXInXTtcbiAgICB9O1xuICAgIEkxOG5TZWxlY3RQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdpMThuU2VsZWN0JywgcHVyZTogdHJ1ZSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIEkxOG5TZWxlY3RQaXBlO1xufSgpKTtcbmV4cG9ydHMuSTE4blNlbGVjdFBpcGUgPSBJMThuU2VsZWN0UGlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWkxOG5fc2VsZWN0X3BpcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBJbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW52YWxpZCBhcmd1bWVudCAnXCIgKyB2YWx1ZSArIFwiJyBmb3IgcGlwZSAnXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHR5cGUpICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbjtcbn0oZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pKTtcbmV4cG9ydHMuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbiA9IEludmFsaWRQaXBlQXJndW1lbnRFeGNlcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBKc29uUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSnNvblBpcGUoKSB7XG4gICAgfVxuICAgIEpzb25QaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGxhbmdfMS5Kc29uLnN0cmluZ2lmeSh2YWx1ZSk7IH07XG4gICAgSnNvblBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUGlwZSwgYXJnczogW3sgbmFtZTogJ2pzb24nLCBwdXJlOiBmYWxzZSB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIEpzb25QaXBlO1xufSgpKTtcbmV4cG9ydHMuSnNvblBpcGUgPSBKc29uUGlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb25fcGlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XG52YXIgTG93ZXJDYXNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG93ZXJDYXNlUGlwZSgpIHtcbiAgICB9XG4gICAgTG93ZXJDYXNlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICghbGFuZ18xLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKExvd2VyQ2FzZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9O1xuICAgIExvd2VyQ2FzZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUGlwZSwgYXJnczogW3sgbmFtZTogJ2xvd2VyY2FzZScgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIHJldHVybiBMb3dlckNhc2VQaXBlO1xufSgpKTtcbmV4cG9ydHMuTG93ZXJDYXNlUGlwZSA9IExvd2VyQ2FzZVBpcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb3dlcmNhc2VfcGlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBpbnRsXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2ludGwnKTtcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcbnZhciBkZWZhdWx0TG9jYWxlID0gJ2VuLVVTJztcbnZhciBfcmUgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJ14oXFxcXGQrKT9cXFxcLigoXFxcXGQrKShcXFxcLShcXFxcZCspKT8pPyQnKTtcbnZhciBOdW1iZXJQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdW1iZXJQaXBlKCkge1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgTnVtYmVyUGlwZS5fZm9ybWF0ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHlsZSwgZGlnaXRzLCBjdXJyZW5jeSwgY3VycmVuY3lBc1N5bWJvbCkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT09IHZvaWQgMCkgeyBjdXJyZW5jeSA9IG51bGw7IH1cbiAgICAgICAgaWYgKGN1cnJlbmN5QXNTeW1ib2wgPT09IHZvaWQgMCkgeyBjdXJyZW5jeUFzU3ltYm9sID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIWxhbmdfMS5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbihOdW1iZXJQaXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbkludCA9IDEsIG1pbkZyYWN0aW9uID0gMCwgbWF4RnJhY3Rpb24gPSAzO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkaWdpdHMpKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKF9yZSwgZGlnaXRzKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJ0cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oZGlnaXRzICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW5mbyBmb3IgbnVtYmVyIHBpcGVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFydHNbMV0pKSB7XG4gICAgICAgICAgICAgICAgbWluSW50ID0gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFydHNbM10pKSB7XG4gICAgICAgICAgICAgICAgbWluRnJhY3Rpb24gPSBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChwYXJ0c1szXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJ0c1s1XSkpIHtcbiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbiA9IGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4KHBhcnRzWzVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50bF8xLk51bWJlckZvcm1hdHRlci5mb3JtYXQodmFsdWUsIGRlZmF1bHRMb2NhbGUsIHN0eWxlLCB7XG4gICAgICAgICAgICBtaW5pbXVtSW50ZWdlckRpZ2l0czogbWluSW50LFxuICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBtaW5GcmFjdGlvbixcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbWF4RnJhY3Rpb24sXG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgICBjdXJyZW5jeUFzU3ltYm9sOiBjdXJyZW5jeUFzU3ltYm9sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTnVtYmVyUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gTnVtYmVyUGlwZTtcbn0oKSk7XG5leHBvcnRzLk51bWJlclBpcGUgPSBOdW1iZXJQaXBlO1xudmFyIERlY2ltYWxQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVjaW1hbFBpcGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVjaW1hbFBpcGUoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBEZWNpbWFsUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBkaWdpdHMpIHtcbiAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIE51bWJlclBpcGUuX2Zvcm1hdCh2YWx1ZSwgaW50bF8xLk51bWJlckZvcm1hdFN0eWxlLkRlY2ltYWwsIGRpZ2l0cyk7XG4gICAgfTtcbiAgICBEZWNpbWFsUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnbnVtYmVyJyB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIERlY2ltYWxQaXBlO1xufShOdW1iZXJQaXBlKSk7XG5leHBvcnRzLkRlY2ltYWxQaXBlID0gRGVjaW1hbFBpcGU7XG52YXIgUGVyY2VudFBpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQZXJjZW50UGlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQZXJjZW50UGlwZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFBlcmNlbnRQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xuICAgICAgICBpZiAoZGlnaXRzID09PSB2b2lkIDApIHsgZGlnaXRzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gTnVtYmVyUGlwZS5fZm9ybWF0KHZhbHVlLCBpbnRsXzEuTnVtYmVyRm9ybWF0U3R5bGUuUGVyY2VudCwgZGlnaXRzKTtcbiAgICB9O1xuICAgIFBlcmNlbnRQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdwZXJjZW50JyB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIFBlcmNlbnRQaXBlO1xufShOdW1iZXJQaXBlKSk7XG5leHBvcnRzLlBlcmNlbnRQaXBlID0gUGVyY2VudFBpcGU7XG52YXIgQ3VycmVuY3lQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3VycmVuY3lQaXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1cnJlbmN5UGlwZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEN1cnJlbmN5UGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXksIGRpZ2l0cykge1xuICAgICAgICBpZiAoY3VycmVuY3lDb2RlID09PSB2b2lkIDApIHsgY3VycmVuY3lDb2RlID0gJ1VTRCc7IH1cbiAgICAgICAgaWYgKHN5bWJvbERpc3BsYXkgPT09IHZvaWQgMCkgeyBzeW1ib2xEaXNwbGF5ID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIE51bWJlclBpcGUuX2Zvcm1hdCh2YWx1ZSwgaW50bF8xLk51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5LCBkaWdpdHMsIGN1cnJlbmN5Q29kZSwgc3ltYm9sRGlzcGxheSk7XG4gICAgfTtcbiAgICBDdXJyZW5jeVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUGlwZSwgYXJnczogW3sgbmFtZTogJ2N1cnJlbmN5JyB9LF0gfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIEN1cnJlbmN5UGlwZTtcbn0oTnVtYmVyUGlwZSkpO1xuZXhwb3J0cy5DdXJyZW5jeVBpcGUgPSBDdXJyZW5jeVBpcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJfcGlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XG52YXIgUmVwbGFjZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcGxhY2VQaXBlKCkge1xuICAgIH1cbiAgICBSZXBsYWNlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXR0ZXJuLCByZXBsYWNlbWVudCkge1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0ZWRJbnB1dCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEuSW52YWxpZFBpcGVBcmd1bWVudEV4Y2VwdGlvbihSZXBsYWNlUGlwZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dCA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydGVkUGF0dGVybihwYXR0ZXJuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKFJlcGxhY2VQaXBlLCBwYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRlZFJlcGxhY2VtZW50KHJlcGxhY2VtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKFJlcGxhY2VQaXBlLCByZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVtcGxhdGUgZmFpbHMgd2l0aCBsaXRlcmFsIFJlZ0V4cCBlLmcgL3BhdHRlcm4vaWdtXG4gICAgICAgIC8vIHZhciByZ3ggPSBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwID8gcGF0dGVybiA6IFJlZ0V4cFdyYXBwZXIuY3JlYXRlKHBhdHRlcm4pO1xuICAgICAgICBpZiAobGFuZ18xLmlzRnVuY3Rpb24ocmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgcmd4UGF0dGVybiA9IGxhbmdfMS5pc1N0cmluZyhwYXR0ZXJuKSA/IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZShwYXR0ZXJuKSA6IHBhdHRlcm47XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgcmd4UGF0dGVybiwgcmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIHJlcGxhY2VBbGwgdmFyaWFudFxuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoaW5wdXQsIHBhdHRlcm4sIHJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZShpbnB1dCwgcGF0dGVybiwgcmVwbGFjZW1lbnQpO1xuICAgIH07XG4gICAgUmVwbGFjZVBpcGUucHJvdG90eXBlLl9zdXBwb3J0ZWRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbGFuZ18xLmlzU3RyaW5nKGlucHV0KSB8fCBsYW5nXzEuaXNOdW1iZXIoaW5wdXQpOyB9O1xuICAgIFJlcGxhY2VQaXBlLnByb3RvdHlwZS5fc3VwcG9ydGVkUGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNTdHJpbmcocGF0dGVybikgfHwgcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICB9O1xuICAgIFJlcGxhY2VQaXBlLnByb3RvdHlwZS5fc3VwcG9ydGVkUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiAocmVwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1N0cmluZyhyZXBsYWNlbWVudCkgfHwgbGFuZ18xLmlzRnVuY3Rpb24ocmVwbGFjZW1lbnQpO1xuICAgIH07XG4gICAgUmVwbGFjZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUGlwZSwgYXJnczogW3sgbmFtZTogJ3JlcGxhY2UnIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gUmVwbGFjZVBpcGU7XG59KCkpO1xuZXhwb3J0cy5SZXBsYWNlUGlwZSA9IFJlcGxhY2VQaXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwbGFjZV9waXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBpbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uXzEgPSByZXF1aXJlKCcuL2ludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb24nKTtcbnZhciBTbGljZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWNlUGlwZSgpIHtcbiAgICB9XG4gICAgU2xpY2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKFNsaWNlUGlwZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgU2xpY2VQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGxhbmdfMS5pc1N0cmluZyhvYmopIHx8IGxhbmdfMS5pc0FycmF5KG9iaik7IH07XG4gICAgU2xpY2VQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdzbGljZScsIHB1cmU6IGZhbHNlIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gU2xpY2VQaXBlO1xufSgpKTtcbmV4cG9ydHMuU2xpY2VQaXBlID0gU2xpY2VQaXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpY2VfcGlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgaW52YWxpZF9waXBlX2FyZ3VtZW50X2V4Y2VwdGlvbl8xID0gcmVxdWlyZSgnLi9pbnZhbGlkX3BpcGVfYXJndW1lbnRfZXhjZXB0aW9uJyk7XG52YXIgVXBwZXJDYXNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXBwZXJDYXNlUGlwZSgpIHtcbiAgICB9XG4gICAgVXBwZXJDYXNlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICghbGFuZ18xLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGludmFsaWRfcGlwZV9hcmd1bWVudF9leGNlcHRpb25fMS5JbnZhbGlkUGlwZUFyZ3VtZW50RXhjZXB0aW9uKFVwcGVyQ2FzZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuICAgIFVwcGVyQ2FzZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuUGlwZSwgYXJnczogW3sgbmFtZTogJ3VwcGVyY2FzZScgfSxdIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIHJldHVybiBVcHBlckNhc2VQaXBlO1xufSgpKTtcbmV4cG9ydHMuVXBwZXJDYXNlUGlwZSA9IFVwcGVyQ2FzZVBpcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cHBlcmNhc2VfcGlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG4vKipcbiogQG1vZHVsZVxuKiBAZGVzY3JpcHRpb25cbiogU3RhcnRpbmcgcG9pbnQgdG8gaW1wb3J0IGFsbCBjb21waWxlciBBUElzLlxuKi9cbnZhciBlbGVtZW50X3NjaGVtYV9yZWdpc3RyeV8xID0gcmVxdWlyZSgnLi9zcmMvc2NoZW1hL2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5Jyk7XG5leHBvcnRzLkVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKCcuL3NyYy9jb21waWxlcicpO1xuZXhwb3J0cy5DT01QSUxFUl9QUk9WSURFUlMgPSBjb21waWxlcl8xLkNPTVBJTEVSX1BST1ZJREVSUztcbmV4cG9ydHMuVEVNUExBVEVfVFJBTlNGT1JNUyA9IGNvbXBpbGVyXzEuVEVNUExBVEVfVFJBTlNGT1JNUztcbmV4cG9ydHMuQ29tcGlsZXJDb25maWcgPSBjb21waWxlcl8xLkNvbXBpbGVyQ29uZmlnO1xuZXhwb3J0cy5SZW5kZXJUeXBlcyA9IGNvbXBpbGVyXzEuUmVuZGVyVHlwZXM7XG5leHBvcnRzLlVybFJlc29sdmVyID0gY29tcGlsZXJfMS5VcmxSZXNvbHZlcjtcbmV4cG9ydHMuREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiA9IGNvbXBpbGVyXzEuREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUjtcbmV4cG9ydHMuY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlciA9IGNvbXBpbGVyXzEuY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcjtcbmV4cG9ydHMuWEhSID0gY29tcGlsZXJfMS5YSFI7XG5leHBvcnRzLlZpZXdSZXNvbHZlciA9IGNvbXBpbGVyXzEuVmlld1Jlc29sdmVyO1xuZXhwb3J0cy5EaXJlY3RpdmVSZXNvbHZlciA9IGNvbXBpbGVyXzEuRGlyZWN0aXZlUmVzb2x2ZXI7XG5leHBvcnRzLlBpcGVSZXNvbHZlciA9IGNvbXBpbGVyXzEuUGlwZVJlc29sdmVyO1xuZXhwb3J0cy5Tb3VyY2VNb2R1bGUgPSBjb21waWxlcl8xLlNvdXJjZU1vZHVsZTtcbmV4cG9ydHMuTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcyA9IGNvbXBpbGVyXzEuTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcztcbmV4cG9ydHMuT2ZmbGluZUNvbXBpbGVyID0gY29tcGlsZXJfMS5PZmZsaW5lQ29tcGlsZXI7XG5leHBvcnRzLkNvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyID0gY29tcGlsZXJfMS5Db21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllcjtcbmV4cG9ydHMuQ29tcGlsZU1ldGFkYXRhV2l0aFR5cGUgPSBjb21waWxlcl8xLkNvbXBpbGVNZXRhZGF0YVdpdGhUeXBlO1xuZXhwb3J0cy5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhID0gY29tcGlsZXJfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhO1xuZXhwb3J0cy5Db21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEgPSBjb21waWxlcl8xLkNvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YTtcbmV4cG9ydHMuQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEgPSBjb21waWxlcl8xLkNvbXBpbGVQcm92aWRlck1ldGFkYXRhO1xuZXhwb3J0cy5Db21waWxlRmFjdG9yeU1ldGFkYXRhID0gY29tcGlsZXJfMS5Db21waWxlRmFjdG9yeU1ldGFkYXRhO1xuZXhwb3J0cy5Db21waWxlVG9rZW5NZXRhZGF0YSA9IGNvbXBpbGVyXzEuQ29tcGlsZVRva2VuTWV0YWRhdGE7XG5leHBvcnRzLkNvbXBpbGVUeXBlTWV0YWRhdGEgPSBjb21waWxlcl8xLkNvbXBpbGVUeXBlTWV0YWRhdGE7XG5leHBvcnRzLkNvbXBpbGVRdWVyeU1ldGFkYXRhID0gY29tcGlsZXJfMS5Db21waWxlUXVlcnlNZXRhZGF0YTtcbmV4cG9ydHMuQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEgPSBjb21waWxlcl8xLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xuZXhwb3J0cy5Db21waWxlRGlyZWN0aXZlTWV0YWRhdGEgPSBjb21waWxlcl8xLkNvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YTtcbmV4cG9ydHMuQ29tcGlsZVBpcGVNZXRhZGF0YSA9IGNvbXBpbGVyXzEuQ29tcGlsZVBpcGVNZXRhZGF0YTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL3RlbXBsYXRlX2FzdCcpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vcHJpdmF0ZV9leHBvcnQnKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG5leHBvcnRzLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XG5leHBvcnRzLkNoYW5nZURldGVjdG9yU3RhdGUgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5DaGFuZ2VEZXRlY3RvclN0YXRlO1xuZXhwb3J0cy5DSEFOR0VfREVURUNUSU9OX1NUUkFURUdZX1ZBTFVFUyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLkNIQU5HRV9ERVRFQ1RJT05fU1RSQVRFR1lfVkFMVUVTO1xuZXhwb3J0cy5jb25zdHJ1Y3REZXBlbmRlbmNpZXMgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5jb25zdHJ1Y3REZXBlbmRlbmNpZXM7XG5leHBvcnRzLkxpZmVjeWNsZUhvb2tzID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uTGlmZWN5Y2xlSG9va3M7XG5leHBvcnRzLkxJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5MSUZFQ1lDTEVfSE9PS1NfVkFMVUVTO1xuZXhwb3J0cy5SZWZsZWN0b3JSZWFkZXIgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5SZWZsZWN0b3JSZWFkZXI7XG5leHBvcnRzLlJlZmxlY3RvckNvbXBvbmVudFJlc29sdmVyID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uUmVmbGVjdG9yQ29tcG9uZW50UmVzb2x2ZXI7XG5leHBvcnRzLkFwcEVsZW1lbnQgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5BcHBFbGVtZW50O1xuZXhwb3J0cy5BcHBWaWV3ID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uQXBwVmlldztcbmV4cG9ydHMuRGVidWdBcHBWaWV3ID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uRGVidWdBcHBWaWV3O1xuZXhwb3J0cy5WaWV3VHlwZSA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlZpZXdUeXBlO1xuZXhwb3J0cy5NQVhfSU5URVJQT0xBVElPTl9WQUxVRVMgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5NQVhfSU5URVJQT0xBVElPTl9WQUxVRVM7XG5leHBvcnRzLmNoZWNrQmluZGluZyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLmNoZWNrQmluZGluZztcbmV4cG9ydHMuZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLmZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXM7XG5leHBvcnRzLmludGVycG9sYXRlID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uaW50ZXJwb2xhdGU7XG5leHBvcnRzLlZpZXdVdGlscyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlZpZXdVdGlscztcbmV4cG9ydHMuVklFV19FTkNBUFNVTEFUSU9OX1ZBTFVFUyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlZJRVdfRU5DQVBTVUxBVElPTl9WQUxVRVM7XG5leHBvcnRzLkRlYnVnQ29udGV4dCA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLkRlYnVnQ29udGV4dDtcbmV4cG9ydHMuU3RhdGljTm9kZURlYnVnSW5mbyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlN0YXRpY05vZGVEZWJ1Z0luZm87XG5leHBvcnRzLmRldk1vZGVFcXVhbCA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLmRldk1vZGVFcXVhbDtcbmV4cG9ydHMudW5pbml0aWFsaXplZCA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLnVuaW5pdGlhbGl6ZWQ7XG5leHBvcnRzLlZhbHVlVW53cmFwcGVyID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uVmFsdWVVbndyYXBwZXI7XG5leHBvcnRzLlRlbXBsYXRlUmVmXyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlRlbXBsYXRlUmVmXztcbmV4cG9ydHMuUmVuZGVyRGVidWdJbmZvID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uUmVuZGVyRGVidWdJbmZvO1xuZXhwb3J0cy5TZWN1cml0eUNvbnRleHQgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5TZWN1cml0eUNvbnRleHQ7XG5leHBvcnRzLlNhbml0aXphdGlvblNlcnZpY2UgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5TYW5pdGl6YXRpb25TZXJ2aWNlO1xuZXhwb3J0cy5jcmVhdGVQcm92aWRlciA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLmNyZWF0ZVByb3ZpZGVyO1xuZXhwb3J0cy5pc1Byb3ZpZGVyTGl0ZXJhbCA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLmlzUHJvdmlkZXJMaXRlcmFsO1xuZXhwb3J0cy5FTVBUWV9BUlJBWSA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLkVNUFRZX0FSUkFZO1xuZXhwb3J0cy5FTVBUWV9NQVAgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5FTVBUWV9NQVA7XG5leHBvcnRzLnB1cmVQcm94eTEgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5wdXJlUHJveHkxO1xuZXhwb3J0cy5wdXJlUHJveHkyID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18ucHVyZVByb3h5MjtcbmV4cG9ydHMucHVyZVByb3h5MyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTM7XG5leHBvcnRzLnB1cmVQcm94eTQgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5wdXJlUHJveHk0O1xuZXhwb3J0cy5wdXJlUHJveHk1ID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18ucHVyZVByb3h5NTtcbmV4cG9ydHMucHVyZVByb3h5NiA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTY7XG5leHBvcnRzLnB1cmVQcm94eTcgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5wdXJlUHJveHk3O1xuZXhwb3J0cy5wdXJlUHJveHk4ID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18ucHVyZVByb3h5ODtcbmV4cG9ydHMucHVyZVByb3h5OSA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTk7XG5leHBvcnRzLnB1cmVQcm94eTEwID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18ucHVyZVByb3h5MTA7XG5leHBvcnRzLmNhc3RCeVZhbHVlID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uY2FzdEJ5VmFsdWU7XG5leHBvcnRzLkNvbnNvbGUgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5Db25zb2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZV9wcml2YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbl9fZXhwb3J0KHJlcXVpcmUoJy4vY29tcGlsZXInKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBzZWxlY3RvciA9IHJlcXVpcmUoJy4vc3JjL3NlbGVjdG9yJyk7XG52YXIgcGF0aFV0aWwgPSByZXF1aXJlKCcuL3NyYy9vdXRwdXQvcGF0aF91dGlsJyk7XG52YXIgX19jb21waWxlcl9wcml2YXRlX187XG4oZnVuY3Rpb24gKF9fY29tcGlsZXJfcHJpdmF0ZV9fKSB7XG4gICAgX19jb21waWxlcl9wcml2YXRlX18uU2VsZWN0b3JNYXRjaGVyID0gc2VsZWN0b3IuU2VsZWN0b3JNYXRjaGVyO1xuICAgIF9fY29tcGlsZXJfcHJpdmF0ZV9fLkNzc1NlbGVjdG9yID0gc2VsZWN0b3IuQ3NzU2VsZWN0b3I7XG4gICAgX19jb21waWxlcl9wcml2YXRlX18uQXNzZXRVcmwgPSBwYXRoVXRpbC5Bc3NldFVybDtcbiAgICBfX2NvbXBpbGVyX3ByaXZhdGVfXy5JbXBvcnRHZW5lcmF0b3IgPSBwYXRoVXRpbC5JbXBvcnRHZW5lcmF0b3I7XG59KShfX2NvbXBpbGVyX3ByaXZhdGVfXyA9IGV4cG9ydHMuX19jb21waWxlcl9wcml2YXRlX18gfHwgKGV4cG9ydHMuX19jb21waWxlcl9wcml2YXRlX18gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpdmF0ZV9leHBvcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG5mdW5jdGlvbiBhc3NlcnRBcnJheU9mU3RyaW5ncyhpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgIGlmICghbGFuZ18xLmFzc2VydGlvbnNFbmFibGVkKCkgfHwgbGFuZ18xLmlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFsYW5nXzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiRXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllciArIFwiJyB0byBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLlwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoIWxhbmdfMS5pc1N0cmluZyh2YWx1ZVtpXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFzc2VydEFycmF5T2ZTdHJpbmdzID0gYXNzZXJ0QXJyYXlPZlN0cmluZ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvcmVfcHJpdmF0ZV8xID0gcmVxdWlyZSgnLi4vY29yZV9wcml2YXRlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgc2VsZWN0b3JfMSA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB1cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vdXJsX3Jlc29sdmVyJyk7XG4vLyBncm91cCAxOiBcInByb3BlcnR5XCIgZnJvbSBcIltwcm9wZXJ0eV1cIlxuLy8gZ3JvdXAgMjogXCJldmVudFwiIGZyb20gXCIoZXZlbnQpXCJcbnZhciBIT1NUX1JFR19FWFAgPSAvXig/Oig/OlxcWyhbXlxcXV0rKVxcXSl8KD86XFwoKFteXFwpXSspXFwpKSkkL2c7XG52YXIgQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllcjtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyID0gQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXI7XG52YXIgQ29tcGlsZU1ldGFkYXRhV2l0aFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlTWV0YWRhdGFXaXRoVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21waWxlTWV0YWRhdGFXaXRoVHlwZSgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlTWV0YWRhdGFXaXRoVHlwZS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVNZXRhZGF0YVdpdGhUeXBlLnByb3RvdHlwZSwgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ29tcGlsZU1ldGFkYXRhV2l0aFR5cGU7XG59KENvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyKSk7XG5leHBvcnRzLkNvbXBpbGVNZXRhZGF0YVdpdGhUeXBlID0gQ29tcGlsZU1ldGFkYXRhV2l0aFR5cGU7XG5mdW5jdGlvbiBtZXRhZGF0YUZyb21Kc29uKGRhdGEpIHtcbiAgICByZXR1cm4gX0NPTVBJTEVfTUVUQURBVEFfRlJPTV9KU09OW2RhdGFbJ2NsYXNzJ11dKGRhdGEpO1xufVxuZXhwb3J0cy5tZXRhZGF0YUZyb21Kc29uID0gbWV0YWRhdGFGcm9tSnNvbjtcbnZhciBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBydW50aW1lID0gX2IucnVudGltZSwgbmFtZSA9IF9iLm5hbWUsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgcHJlZml4ID0gX2IucHJlZml4LCB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGxhbmdfMS5pc0FycmF5KGRhdGFbJ3ZhbHVlJ10pID8gX2FycmF5RnJvbUpzb24oZGF0YVsndmFsdWUnXSwgbWV0YWRhdGFGcm9tSnNvbikgOlxuICAgICAgICAgICAgX29iakZyb21Kc29uKGRhdGFbJ3ZhbHVlJ10sIG1ldGFkYXRhRnJvbUpzb24pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiBkYXRhWyduYW1lJ10sIHByZWZpeDogZGF0YVsncHJlZml4J10sIG1vZHVsZVVybDogZGF0YVsnbW9kdWxlVXJsJ10sIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEucHJvdG90eXBlLnRvSnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbGFuZ18xLmlzQXJyYXkodGhpcy52YWx1ZSkgPyBfYXJyYXlUb0pzb24odGhpcy52YWx1ZSkgOiBfb2JqVG9Kc29uKHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogUnVudGltZSB0eXBlIGNhbid0IGJlIHNlcmlhbGl6ZWQuLi5cbiAgICAgICAgICAgICdjbGFzcyc6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICduYW1lJzogdGhpcy5uYW1lLFxuICAgICAgICAgICAgJ21vZHVsZVVybCc6IHRoaXMubW9kdWxlVXJsLFxuICAgICAgICAgICAgJ3ByZWZpeCc6IHRoaXMucHJlZml4LFxuICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlSWRlbnRpZmllck1ldGFkYXRhLnByb3RvdHlwZSwgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEgPSBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhO1xudmFyIENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBpc0F0dHJpYnV0ZSA9IF9iLmlzQXR0cmlidXRlLCBpc1NlbGYgPSBfYi5pc1NlbGYsIGlzSG9zdCA9IF9iLmlzSG9zdCwgaXNTa2lwU2VsZiA9IF9iLmlzU2tpcFNlbGYsIGlzT3B0aW9uYWwgPSBfYi5pc09wdGlvbmFsLCBpc1ZhbHVlID0gX2IuaXNWYWx1ZSwgcXVlcnkgPSBfYi5xdWVyeSwgdmlld1F1ZXJ5ID0gX2Iudmlld1F1ZXJ5LCB0b2tlbiA9IF9iLnRva2VuLCB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICB0aGlzLmlzQXR0cmlidXRlID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woaXNBdHRyaWJ1dGUpO1xuICAgICAgICB0aGlzLmlzU2VsZiA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGlzU2VsZik7XG4gICAgICAgIHRoaXMuaXNIb3N0ID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woaXNIb3N0KTtcbiAgICAgICAgdGhpcy5pc1NraXBTZWxmID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woaXNTa2lwU2VsZik7XG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGlzT3B0aW9uYWwpO1xuICAgICAgICB0aGlzLmlzVmFsdWUgPSBsYW5nXzEubm9ybWFsaXplQm9vbChpc1ZhbHVlKTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnZpZXdRdWVyeSA9IHZpZXdRdWVyeTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHRva2VuOiBfb2JqRnJvbUpzb24oZGF0YVsndG9rZW4nXSwgQ29tcGlsZVRva2VuTWV0YWRhdGEuZnJvbUpzb24pLFxuICAgICAgICAgICAgcXVlcnk6IF9vYmpGcm9tSnNvbihkYXRhWydxdWVyeSddLCBDb21waWxlUXVlcnlNZXRhZGF0YS5mcm9tSnNvbiksXG4gICAgICAgICAgICB2aWV3UXVlcnk6IF9vYmpGcm9tSnNvbihkYXRhWyd2aWV3UXVlcnknXSwgQ29tcGlsZVF1ZXJ5TWV0YWRhdGEuZnJvbUpzb24pLFxuICAgICAgICAgICAgdmFsdWU6IGRhdGFbJ3ZhbHVlJ10sXG4gICAgICAgICAgICBpc0F0dHJpYnV0ZTogZGF0YVsnaXNBdHRyaWJ1dGUnXSxcbiAgICAgICAgICAgIGlzU2VsZjogZGF0YVsnaXNTZWxmJ10sXG4gICAgICAgICAgICBpc0hvc3Q6IGRhdGFbJ2lzSG9zdCddLFxuICAgICAgICAgICAgaXNTa2lwU2VsZjogZGF0YVsnaXNTa2lwU2VsZiddLFxuICAgICAgICAgICAgaXNPcHRpb25hbDogZGF0YVsnaXNPcHRpb25hbCddLFxuICAgICAgICAgICAgaXNWYWx1ZTogZGF0YVsnaXNWYWx1ZSddXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndG9rZW4nOiBfb2JqVG9Kc29uKHRoaXMudG9rZW4pLFxuICAgICAgICAgICAgJ3F1ZXJ5JzogX29ialRvSnNvbih0aGlzLnF1ZXJ5KSxcbiAgICAgICAgICAgICd2aWV3UXVlcnknOiBfb2JqVG9Kc29uKHRoaXMudmlld1F1ZXJ5KSxcbiAgICAgICAgICAgICd2YWx1ZSc6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAnaXNBdHRyaWJ1dGUnOiB0aGlzLmlzQXR0cmlidXRlLFxuICAgICAgICAgICAgJ2lzU2VsZic6IHRoaXMuaXNTZWxmLFxuICAgICAgICAgICAgJ2lzSG9zdCc6IHRoaXMuaXNIb3N0LFxuICAgICAgICAgICAgJ2lzU2tpcFNlbGYnOiB0aGlzLmlzU2tpcFNlbGYsXG4gICAgICAgICAgICAnaXNPcHRpb25hbCc6IHRoaXMuaXNPcHRpb25hbCxcbiAgICAgICAgICAgICdpc1ZhbHVlJzogdGhpcy5pc1ZhbHVlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhID0gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhO1xudmFyIENvbXBpbGVQcm92aWRlck1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlUHJvdmlkZXJNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBfYS50b2tlbiwgdXNlQ2xhc3MgPSBfYS51c2VDbGFzcywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlRmFjdG9yeSA9IF9hLnVzZUZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMudXNlQ2xhc3MgPSB1c2VDbGFzcztcbiAgICAgICAgdGhpcy51c2VWYWx1ZSA9IHVzZVZhbHVlO1xuICAgICAgICB0aGlzLnVzZUV4aXN0aW5nID0gdXNlRXhpc3Rpbmc7XG4gICAgICAgIHRoaXMudXNlRmFjdG9yeSA9IHVzZUZhY3Rvcnk7XG4gICAgICAgIHRoaXMuZGVwcyA9IGxhbmdfMS5ub3JtYWxpemVCbGFuayhkZXBzKTtcbiAgICAgICAgdGhpcy5tdWx0aSA9IGxhbmdfMS5ub3JtYWxpemVCb29sKG11bHRpKTtcbiAgICB9XG4gICAgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEuZnJvbUpzb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgIHRva2VuOiBfb2JqRnJvbUpzb24oZGF0YVsndG9rZW4nXSwgQ29tcGlsZVRva2VuTWV0YWRhdGEuZnJvbUpzb24pLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IF9vYmpGcm9tSnNvbihkYXRhWyd1c2VDbGFzcyddLCBDb21waWxlVHlwZU1ldGFkYXRhLmZyb21Kc29uKSxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBfb2JqRnJvbUpzb24oZGF0YVsndXNlRXhpc3RpbmcnXSwgQ29tcGlsZVRva2VuTWV0YWRhdGEuZnJvbUpzb24pLFxuICAgICAgICAgICAgdXNlVmFsdWU6IF9vYmpGcm9tSnNvbihkYXRhWyd1c2VWYWx1ZSddLCBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhLmZyb21Kc29uKSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IF9vYmpGcm9tSnNvbihkYXRhWyd1c2VGYWN0b3J5J10sIENvbXBpbGVGYWN0b3J5TWV0YWRhdGEuZnJvbUpzb24pLFxuICAgICAgICAgICAgbXVsdGk6IGRhdGFbJ211bHRpJ10sXG4gICAgICAgICAgICBkZXBzOiBfYXJyYXlGcm9tSnNvbihkYXRhWydkZXBzJ10sIENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YS5mcm9tSnNvbilcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21waWxlUHJvdmlkZXJNZXRhZGF0YS5wcm90b3R5cGUudG9Kc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogUnVudGltZSB0eXBlIGNhbid0IGJlIHNlcmlhbGl6ZWQuLi5cbiAgICAgICAgICAgICdjbGFzcyc6ICdQcm92aWRlcicsXG4gICAgICAgICAgICAndG9rZW4nOiBfb2JqVG9Kc29uKHRoaXMudG9rZW4pLFxuICAgICAgICAgICAgJ3VzZUNsYXNzJzogX29ialRvSnNvbih0aGlzLnVzZUNsYXNzKSxcbiAgICAgICAgICAgICd1c2VFeGlzdGluZyc6IF9vYmpUb0pzb24odGhpcy51c2VFeGlzdGluZyksXG4gICAgICAgICAgICAndXNlVmFsdWUnOiBfb2JqVG9Kc29uKHRoaXMudXNlVmFsdWUpLFxuICAgICAgICAgICAgJ3VzZUZhY3RvcnknOiBfb2JqVG9Kc29uKHRoaXMudXNlRmFjdG9yeSksXG4gICAgICAgICAgICAnbXVsdGknOiB0aGlzLm11bHRpLFxuICAgICAgICAgICAgJ2RlcHMnOiBfYXJyYXlUb0pzb24odGhpcy5kZXBzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVQcm92aWRlck1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEgPSBDb21waWxlUHJvdmlkZXJNZXRhZGF0YTtcbnZhciBDb21waWxlRmFjdG9yeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlRmFjdG9yeU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBydW50aW1lID0gX2EucnVudGltZSwgbmFtZSA9IF9hLm5hbWUsIG1vZHVsZVVybCA9IF9hLm1vZHVsZVVybCwgcHJlZml4ID0gX2EucHJlZml4LCBkaURlcHMgPSBfYS5kaURlcHMsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgdGhpcy5kaURlcHMgPSBfbm9ybWFsaXplQXJyYXkoZGlEZXBzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZUZhY3RvcnlNZXRhZGF0YS5wcm90b3R5cGUsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29tcGlsZUZhY3RvcnlNZXRhZGF0YS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSh7XG4gICAgICAgICAgICBuYW1lOiBkYXRhWyduYW1lJ10sXG4gICAgICAgICAgICBwcmVmaXg6IGRhdGFbJ3ByZWZpeCddLFxuICAgICAgICAgICAgbW9kdWxlVXJsOiBkYXRhWydtb2R1bGVVcmwnXSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhWyd2YWx1ZSddLFxuICAgICAgICAgICAgZGlEZXBzOiBfYXJyYXlGcm9tSnNvbihkYXRhWydkaURlcHMnXSwgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhLmZyb21Kc29uKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVGYWN0b3J5TWV0YWRhdGEucHJvdG90eXBlLnRvSnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjbGFzcyc6ICdGYWN0b3J5JyxcbiAgICAgICAgICAgICduYW1lJzogdGhpcy5uYW1lLFxuICAgICAgICAgICAgJ3ByZWZpeCc6IHRoaXMucHJlZml4LFxuICAgICAgICAgICAgJ21vZHVsZVVybCc6IHRoaXMubW9kdWxlVXJsLFxuICAgICAgICAgICAgJ3ZhbHVlJzogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICdkaURlcHMnOiBfYXJyYXlUb0pzb24odGhpcy5kaURlcHMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZUZhY3RvcnlNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSBDb21waWxlRmFjdG9yeU1ldGFkYXRhO1xudmFyIENvbXBpbGVUb2tlbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlVG9rZW5NZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgaWRlbnRpZmllciA9IF9hLmlkZW50aWZpZXIsIGlkZW50aWZpZXJJc0luc3RhbmNlID0gX2EuaWRlbnRpZmllcklzSW5zdGFuY2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVySXNJbnN0YW5jZSA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGlkZW50aWZpZXJJc0luc3RhbmNlKTtcbiAgICB9XG4gICAgQ29tcGlsZVRva2VuTWV0YWRhdGEuZnJvbUpzb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHtcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhWyd2YWx1ZSddLFxuICAgICAgICAgICAgaWRlbnRpZmllcjogX29iakZyb21Kc29uKGRhdGFbJ2lkZW50aWZpZXInXSwgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YS5mcm9tSnNvbiksXG4gICAgICAgICAgICBpZGVudGlmaWVySXNJbnN0YW5jZTogZGF0YVsnaWRlbnRpZmllcklzSW5zdGFuY2UnXVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVUb2tlbk1ldGFkYXRhLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndmFsdWUnOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgJ2lkZW50aWZpZXInOiBfb2JqVG9Kc29uKHRoaXMuaWRlbnRpZmllciksXG4gICAgICAgICAgICAnaWRlbnRpZmllcklzSW5zdGFuY2UnOiB0aGlzLmlkZW50aWZpZXJJc0luc3RhbmNlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVRva2VuTWV0YWRhdGEucHJvdG90eXBlLCBcInJ1bnRpbWVDYWNoZUtleVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXIucnVudGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVRva2VuTWV0YWRhdGEucHJvdG90eXBlLCBcImFzc2V0Q2FjaGVLZXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmlkZW50aWZpZXIubW9kdWxlVXJsKSAmJlxuICAgICAgICAgICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KHVybF9yZXNvbHZlcl8xLmdldFVybFNjaGVtZSh0aGlzLmlkZW50aWZpZXIubW9kdWxlVXJsKSkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXIubmFtZSArIFwifFwiICsgdGhpcy5pZGVudGlmaWVyLm1vZHVsZVVybCArIFwifFwiICsgdGhpcy5pZGVudGlmaWVySXNJbnN0YW5jZSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29tcGlsZVRva2VuTWV0YWRhdGEucHJvdG90eXBlLmVxdWFsc1RvID0gZnVuY3Rpb24gKHRva2VuMikge1xuICAgICAgICB2YXIgcmsgPSB0aGlzLnJ1bnRpbWVDYWNoZUtleTtcbiAgICAgICAgdmFyIGFrID0gdGhpcy5hc3NldENhY2hlS2V5O1xuICAgICAgICByZXR1cm4gKGxhbmdfMS5pc1ByZXNlbnQocmspICYmIHJrID09IHRva2VuMi5ydW50aW1lQ2FjaGVLZXkpIHx8XG4gICAgICAgICAgICAobGFuZ18xLmlzUHJlc2VudChhaykgJiYgYWsgPT0gdG9rZW4yLmFzc2V0Q2FjaGVLZXkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVUb2tlbk1ldGFkYXRhLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLnZhbHVlKSA/IHV0aWxfMS5zYW5pdGl6ZUlkZW50aWZpZXIodGhpcy52YWx1ZSkgOiB0aGlzLmlkZW50aWZpZXIubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbXBpbGVUb2tlbk1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuQ29tcGlsZVRva2VuTWV0YWRhdGEgPSBDb21waWxlVG9rZW5NZXRhZGF0YTtcbnZhciBDb21waWxlVG9rZW5NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVUb2tlbk1hcCgpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBDb21waWxlVG9rZW5NYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQodG9rZW4pO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChleGlzdGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbiBvbmx5IGFkZCB0byBhIFRva2VuTWFwISBUb2tlbjogXCIgKyB0b2tlbi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHZhciByayA9IHRva2VuLnJ1bnRpbWVDYWNoZUtleTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmspKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZU1hcC5zZXQocmssIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWsgPSB0b2tlbi5hc3NldENhY2hlS2V5O1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlTWFwLnNldChhaywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21waWxlVG9rZW5NYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgcmsgPSB0b2tlbi5ydW50aW1lQ2FjaGVLZXk7XG4gICAgICAgIHZhciBhayA9IHRva2VuLmFzc2V0Q2FjaGVLZXk7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHJrKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fdmFsdWVNYXAuZ2V0KHJrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSAmJiBsYW5nXzEuaXNQcmVzZW50KGFrKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fdmFsdWVNYXAuZ2V0KGFrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29tcGlsZVRva2VuTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZXM7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVUb2tlbk1hcC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbXBpbGVUb2tlbk1hcDtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVUb2tlbk1hcCA9IENvbXBpbGVUb2tlbk1hcDtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdHlwZS5cbiAqL1xudmFyIENvbXBpbGVUeXBlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVUeXBlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHJ1bnRpbWUgPSBfYi5ydW50aW1lLCBuYW1lID0gX2IubmFtZSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBwcmVmaXggPSBfYi5wcmVmaXgsIGlzSG9zdCA9IF9iLmlzSG9zdCwgdmFsdWUgPSBfYi52YWx1ZSwgZGlEZXBzID0gX2IuZGlEZXBzO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMuaXNIb3N0ID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woaXNIb3N0KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpRGVwcyA9IF9ub3JtYWxpemVBcnJheShkaURlcHMpO1xuICAgIH1cbiAgICBDb21waWxlVHlwZU1ldGFkYXRhLmZyb21Kc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlVHlwZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGFbJ25hbWUnXSxcbiAgICAgICAgICAgIG1vZHVsZVVybDogZGF0YVsnbW9kdWxlVXJsJ10sXG4gICAgICAgICAgICBwcmVmaXg6IGRhdGFbJ3ByZWZpeCddLFxuICAgICAgICAgICAgaXNIb3N0OiBkYXRhWydpc0hvc3QnXSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhWyd2YWx1ZSddLFxuICAgICAgICAgICAgZGlEZXBzOiBfYXJyYXlGcm9tSnNvbihkYXRhWydkaURlcHMnXSwgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhLmZyb21Kc29uKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlVHlwZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVR5cGVNZXRhZGF0YS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29tcGlsZVR5cGVNZXRhZGF0YS5wcm90b3R5cGUudG9Kc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTm90ZTogUnVudGltZSB0eXBlIGNhbid0IGJlIHNlcmlhbGl6ZWQuLi5cbiAgICAgICAgICAgICdjbGFzcyc6ICdUeXBlJyxcbiAgICAgICAgICAgICduYW1lJzogdGhpcy5uYW1lLFxuICAgICAgICAgICAgJ21vZHVsZVVybCc6IHRoaXMubW9kdWxlVXJsLFxuICAgICAgICAgICAgJ3ByZWZpeCc6IHRoaXMucHJlZml4LFxuICAgICAgICAgICAgJ2lzSG9zdCc6IHRoaXMuaXNIb3N0LFxuICAgICAgICAgICAgJ3ZhbHVlJzogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICdkaURlcHMnOiBfYXJyYXlUb0pzb24odGhpcy5kaURlcHMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZVR5cGVNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVUeXBlTWV0YWRhdGEgPSBDb21waWxlVHlwZU1ldGFkYXRhO1xudmFyIENvbXBpbGVRdWVyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlUXVlcnlNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgc2VsZWN0b3JzID0gX2Iuc2VsZWN0b3JzLCBkZXNjZW5kYW50cyA9IF9iLmRlc2NlbmRhbnRzLCBmaXJzdCA9IF9iLmZpcnN0LCBwcm9wZXJ0eU5hbWUgPSBfYi5wcm9wZXJ0eU5hbWUsIHJlYWQgPSBfYi5yZWFkO1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5kZXNjZW5kYW50cyA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGRlc2NlbmRhbnRzKTtcbiAgICAgICAgdGhpcy5maXJzdCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGZpcnN0KTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIHRoaXMucmVhZCA9IHJlYWQ7XG4gICAgfVxuICAgIENvbXBpbGVRdWVyeU1ldGFkYXRhLmZyb21Kc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlUXVlcnlNZXRhZGF0YSh7XG4gICAgICAgICAgICBzZWxlY3RvcnM6IF9hcnJheUZyb21Kc29uKGRhdGFbJ3NlbGVjdG9ycyddLCBDb21waWxlVG9rZW5NZXRhZGF0YS5mcm9tSnNvbiksXG4gICAgICAgICAgICBkZXNjZW5kYW50czogZGF0YVsnZGVzY2VuZGFudHMnXSxcbiAgICAgICAgICAgIGZpcnN0OiBkYXRhWydmaXJzdCddLFxuICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBkYXRhWydwcm9wZXJ0eU5hbWUnXSxcbiAgICAgICAgICAgIHJlYWQ6IF9vYmpGcm9tSnNvbihkYXRhWydyZWFkJ10sIENvbXBpbGVUb2tlbk1ldGFkYXRhLmZyb21Kc29uKVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVRdWVyeU1ldGFkYXRhLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc2VsZWN0b3JzJzogX2FycmF5VG9Kc29uKHRoaXMuc2VsZWN0b3JzKSxcbiAgICAgICAgICAgICdkZXNjZW5kYW50cyc6IHRoaXMuZGVzY2VuZGFudHMsXG4gICAgICAgICAgICAnZmlyc3QnOiB0aGlzLmZpcnN0LFxuICAgICAgICAgICAgJ3Byb3BlcnR5TmFtZSc6IHRoaXMucHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgJ3JlYWQnOiBfb2JqVG9Kc29uKHRoaXMucmVhZClcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlUXVlcnlNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVRdWVyeU1ldGFkYXRhID0gQ29tcGlsZVF1ZXJ5TWV0YWRhdGE7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIHRlbXBsYXRlLlxuICovXG52YXIgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBlbmNhcHN1bGF0aW9uID0gX2IuZW5jYXBzdWxhdGlvbiwgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgdGVtcGxhdGVVcmwgPSBfYi50ZW1wbGF0ZVVybCwgc3R5bGVzID0gX2Iuc3R5bGVzLCBzdHlsZVVybHMgPSBfYi5zdHlsZVVybHMsIG5nQ29udGVudFNlbGVjdG9ycyA9IF9iLm5nQ29udGVudFNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gbGFuZ18xLmlzUHJlc2VudChlbmNhcHN1bGF0aW9uKSA/IGVuY2Fwc3VsYXRpb24gOiBjb3JlXzEuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IGxhbmdfMS5pc1ByZXNlbnQoc3R5bGVzKSA/IHN0eWxlcyA6IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IGxhbmdfMS5pc1ByZXNlbnQoc3R5bGVVcmxzKSA/IHN0eWxlVXJscyA6IFtdO1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IGxhbmdfMS5pc1ByZXNlbnQobmdDb250ZW50U2VsZWN0b3JzKSA/IG5nQ29udGVudFNlbGVjdG9ycyA6IFtdO1xuICAgIH1cbiAgICBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogbGFuZ18xLmlzUHJlc2VudChkYXRhWydlbmNhcHN1bGF0aW9uJ10pID9cbiAgICAgICAgICAgICAgICBjb3JlX3ByaXZhdGVfMS5WSUVXX0VOQ0FQU1VMQVRJT05fVkFMVUVTW2RhdGFbJ2VuY2Fwc3VsYXRpb24nXV0gOlxuICAgICAgICAgICAgICAgIGRhdGFbJ2VuY2Fwc3VsYXRpb24nXSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBkYXRhWyd0ZW1wbGF0ZSddLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IGRhdGFbJ3RlbXBsYXRlVXJsJ10sXG4gICAgICAgICAgICBzdHlsZXM6IGRhdGFbJ3N0eWxlcyddLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiBkYXRhWydzdHlsZVVybHMnXSxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogZGF0YVsnbmdDb250ZW50U2VsZWN0b3JzJ11cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5wcm90b3R5cGUudG9Kc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2VuY2Fwc3VsYXRpb24nOiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuZW5jYXBzdWxhdGlvbikgPyBsYW5nXzEuc2VyaWFsaXplRW51bSh0aGlzLmVuY2Fwc3VsYXRpb24pIDogdGhpcy5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgJ3RlbXBsYXRlJzogdGhpcy50ZW1wbGF0ZSxcbiAgICAgICAgICAgICd0ZW1wbGF0ZVVybCc6IHRoaXMudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAnc3R5bGVzJzogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICAnc3R5bGVVcmxzJzogdGhpcy5zdHlsZVVybHMsXG4gICAgICAgICAgICAnbmdDb250ZW50U2VsZWN0b3JzJzogdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIGRpcmVjdGl2ZS5cbiAqL1xudmFyIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0TGlzdGVuZXJzID0gX2IuaG9zdExpc3RlbmVycywgaG9zdFByb3BlcnRpZXMgPSBfYi5ob3N0UHJvcGVydGllcywgaG9zdEF0dHJpYnV0ZXMgPSBfYi5ob3N0QXR0cmlidXRlcywgbGlmZWN5Y2xlSG9va3MgPSBfYi5saWZlY3ljbGVIb29rcywgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Iudmlld1F1ZXJpZXMsIHRlbXBsYXRlID0gX2IudGVtcGxhdGU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaXNDb21wb25lbnQgPSBpc0NvbXBvbmVudDtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmV4cG9ydEFzID0gZXhwb3J0QXM7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uID0gY2hhbmdlRGV0ZWN0aW9uO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5ob3N0TGlzdGVuZXJzID0gaG9zdExpc3RlbmVycztcbiAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmhvc3RBdHRyaWJ1dGVzID0gaG9zdEF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBfbm9ybWFsaXplQXJyYXkobGlmZWN5Y2xlSG9va3MpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICB0aGlzLnZpZXdQcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkodmlld1Byb3ZpZGVycyk7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IF9ub3JtYWxpemVBcnJheShxdWVyaWVzKTtcbiAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IF9ub3JtYWxpemVBcnJheSh2aWV3UXVlcmllcyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIGlzQ29tcG9uZW50ID0gX2IuaXNDb21wb25lbnQsIHNlbGVjdG9yID0gX2Iuc2VsZWN0b3IsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9iLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgaG9zdCA9IF9iLmhvc3QsIGxpZmVjeWNsZUhvb2tzID0gX2IubGlmZWN5Y2xlSG9va3MsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgdmlld1Byb3ZpZGVycyA9IF9iLnZpZXdQcm92aWRlcnMsIHF1ZXJpZXMgPSBfYi5xdWVyaWVzLCB2aWV3UXVlcmllcyA9IF9iLnZpZXdRdWVyaWVzLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlO1xuICAgICAgICB2YXIgaG9zdExpc3RlbmVycyA9IHt9O1xuICAgICAgICB2YXIgaG9zdFByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIGhvc3RBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGhvc3QpKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGhvc3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKEhPU1RfUkVHX0VYUCwga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoZXNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzW21hdGNoZXNbMV1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdExpc3RlbmVyc1ttYXRjaGVzWzJdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dHNNYXAgPSB7fTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5wdXRzKSkge1xuICAgICAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSB1dGlsXzEuc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgaW5wdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dHNNYXAgPSB7fTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3V0cHV0cykpIHtcbiAgICAgICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHV0aWxfMS5zcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcbiAgICAgICAgICAgICAgICBvdXRwdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiBsYW5nXzEubm9ybWFsaXplQm9vbChpc0NvbXBvbmVudCksXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBleHBvcnRBczogZXhwb3J0QXMsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzTWFwLFxuICAgICAgICAgICAgb3V0cHV0czogb3V0cHV0c01hcCxcbiAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IGhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICBob3N0UHJvcGVydGllczogaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogaG9zdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBsaWZlY3ljbGVIb29rczogbGFuZ18xLmlzUHJlc2VudChsaWZlY3ljbGVIb29rcykgPyBsaWZlY3ljbGVIb29rcyA6IFtdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB2aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgcXVlcmllczogcXVlcmllcyxcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzOiB2aWV3UXVlcmllcyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmZyb21Kc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgICAgaXNDb21wb25lbnQ6IGRhdGFbJ2lzQ29tcG9uZW50J10sXG4gICAgICAgICAgICBzZWxlY3RvcjogZGF0YVsnc2VsZWN0b3InXSxcbiAgICAgICAgICAgIGV4cG9ydEFzOiBkYXRhWydleHBvcnRBcyddLFxuICAgICAgICAgICAgdHlwZTogbGFuZ18xLmlzUHJlc2VudChkYXRhWyd0eXBlJ10pID8gQ29tcGlsZVR5cGVNZXRhZGF0YS5mcm9tSnNvbihkYXRhWyd0eXBlJ10pIDogZGF0YVsndHlwZSddLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBsYW5nXzEuaXNQcmVzZW50KGRhdGFbJ2NoYW5nZURldGVjdGlvbiddKSA/XG4gICAgICAgICAgICAgICAgY29yZV9wcml2YXRlXzEuQ0hBTkdFX0RFVEVDVElPTl9TVFJBVEVHWV9WQUxVRVNbZGF0YVsnY2hhbmdlRGV0ZWN0aW9uJ11dIDpcbiAgICAgICAgICAgICAgICBkYXRhWydjaGFuZ2VEZXRlY3Rpb24nXSxcbiAgICAgICAgICAgIGlucHV0czogZGF0YVsnaW5wdXRzJ10sXG4gICAgICAgICAgICBvdXRwdXRzOiBkYXRhWydvdXRwdXRzJ10sXG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBkYXRhWydob3N0TGlzdGVuZXJzJ10sXG4gICAgICAgICAgICBob3N0UHJvcGVydGllczogZGF0YVsnaG9zdFByb3BlcnRpZXMnXSxcbiAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBkYXRhWydob3N0QXR0cmlidXRlcyddLFxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IGRhdGFbJ2xpZmVjeWNsZUhvb2tzJ10ubWFwKGZ1bmN0aW9uIChob29rVmFsdWUpIHsgcmV0dXJuIGNvcmVfcHJpdmF0ZV8xLkxJRkVDWUNMRV9IT09LU19WQUxVRVNbaG9va1ZhbHVlXTsgfSksXG4gICAgICAgICAgICB0ZW1wbGF0ZTogbGFuZ18xLmlzUHJlc2VudChkYXRhWyd0ZW1wbGF0ZSddKSA/IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLmZyb21Kc29uKGRhdGFbJ3RlbXBsYXRlJ10pIDpcbiAgICAgICAgICAgICAgICBkYXRhWyd0ZW1wbGF0ZSddLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBfYXJyYXlGcm9tSnNvbihkYXRhWydwcm92aWRlcnMnXSwgbWV0YWRhdGFGcm9tSnNvbiksXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBfYXJyYXlGcm9tSnNvbihkYXRhWyd2aWV3UHJvdmlkZXJzJ10sIG1ldGFkYXRhRnJvbUpzb24pLFxuICAgICAgICAgICAgcXVlcmllczogX2FycmF5RnJvbUpzb24oZGF0YVsncXVlcmllcyddLCBDb21waWxlUXVlcnlNZXRhZGF0YS5mcm9tSnNvbiksXG4gICAgICAgICAgICB2aWV3UXVlcmllczogX2FycmF5RnJvbUpzb24oZGF0YVsndmlld1F1ZXJpZXMnXSwgQ29tcGlsZVF1ZXJ5TWV0YWRhdGEuZnJvbUpzb24pXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZS50b0pzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY2xhc3MnOiAnRGlyZWN0aXZlJyxcbiAgICAgICAgICAgICdpc0NvbXBvbmVudCc6IHRoaXMuaXNDb21wb25lbnQsXG4gICAgICAgICAgICAnc2VsZWN0b3InOiB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgJ2V4cG9ydEFzJzogdGhpcy5leHBvcnRBcyxcbiAgICAgICAgICAgICd0eXBlJzogbGFuZ18xLmlzUHJlc2VudCh0aGlzLnR5cGUpID8gdGhpcy50eXBlLnRvSnNvbigpIDogdGhpcy50eXBlLFxuICAgICAgICAgICAgJ2NoYW5nZURldGVjdGlvbic6IGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jaGFuZ2VEZXRlY3Rpb24pID8gbGFuZ18xLnNlcmlhbGl6ZUVudW0odGhpcy5jaGFuZ2VEZXRlY3Rpb24pIDpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICdpbnB1dHMnOiB0aGlzLmlucHV0cyxcbiAgICAgICAgICAgICdvdXRwdXRzJzogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgJ2hvc3RMaXN0ZW5lcnMnOiB0aGlzLmhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAnaG9zdFByb3BlcnRpZXMnOiB0aGlzLmhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgJ2hvc3RBdHRyaWJ1dGVzJzogdGhpcy5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICdsaWZlY3ljbGVIb29rcyc6IHRoaXMubGlmZWN5Y2xlSG9va3MubWFwKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBsYW5nXzEuc2VyaWFsaXplRW51bShob29rKTsgfSksXG4gICAgICAgICAgICAndGVtcGxhdGUnOiBsYW5nXzEuaXNQcmVzZW50KHRoaXMudGVtcGxhdGUpID8gdGhpcy50ZW1wbGF0ZS50b0pzb24oKSA6IHRoaXMudGVtcGxhdGUsXG4gICAgICAgICAgICAncHJvdmlkZXJzJzogX2FycmF5VG9Kc29uKHRoaXMucHJvdmlkZXJzKSxcbiAgICAgICAgICAgICd2aWV3UHJvdmlkZXJzJzogX2FycmF5VG9Kc29uKHRoaXMudmlld1Byb3ZpZGVycyksXG4gICAgICAgICAgICAncXVlcmllcyc6IF9hcnJheVRvSnNvbih0aGlzLnF1ZXJpZXMpLFxuICAgICAgICAgICAgJ3ZpZXdRdWVyaWVzJzogX2FycmF5VG9Kc29uKHRoaXMudmlld1F1ZXJpZXMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xuLyoqXG4gKiBDb25zdHJ1Y3Qge0BsaW5rIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YX0gZnJvbSB7QGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSG9zdENvbXBvbmVudE1ldGEoY29tcG9uZW50VHlwZSwgY29tcG9uZW50U2VsZWN0b3IpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBzZWxlY3Rvcl8xLkNzc1NlbGVjdG9yLnBhcnNlKGNvbXBvbmVudFNlbGVjdG9yKVswXS5nZXRNYXRjaGluZ0VsZW1lbnRUZW1wbGF0ZSgpO1xuICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgdHlwZTogbmV3IENvbXBpbGVUeXBlTWV0YWRhdGEoe1xuICAgICAgICAgICAgcnVudGltZTogT2JqZWN0LFxuICAgICAgICAgICAgbmFtZTogY29tcG9uZW50VHlwZS5uYW1lICsgXCJfSG9zdFwiLFxuICAgICAgICAgICAgbW9kdWxlVXJsOiBjb21wb25lbnRUeXBlLm1vZHVsZVVybCxcbiAgICAgICAgICAgIGlzSG9zdDogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgdGVtcGxhdGU6IG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7IHRlbXBsYXRlOiB0ZW1wbGF0ZSwgdGVtcGxhdGVVcmw6ICcnLCBzdHlsZXM6IFtdLCBzdHlsZVVybHM6IFtdLCBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdIH0pLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNvcmVfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgaG9zdDoge30sXG4gICAgICAgIGxpZmVjeWNsZUhvb2tzOiBbXSxcbiAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIHNlbGVjdG9yOiAnKicsXG4gICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICBxdWVyaWVzOiBbXSxcbiAgICAgICAgdmlld1F1ZXJpZXM6IFtdXG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUhvc3RDb21wb25lbnRNZXRhID0gY3JlYXRlSG9zdENvbXBvbmVudE1ldGE7XG52YXIgQ29tcGlsZVBpcGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZVBpcGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIG5hbWUgPSBfYi5uYW1lLCBwdXJlID0gX2IucHVyZSwgbGlmZWN5Y2xlSG9va3MgPSBfYi5saWZlY3ljbGVIb29rcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wdXJlID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2wocHVyZSk7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBfbm9ybWFsaXplQXJyYXkobGlmZWN5Y2xlSG9va3MpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVBpcGVNZXRhZGF0YS5wcm90b3R5cGUsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb21waWxlUGlwZU1ldGFkYXRhLmZyb21Kc29uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlUGlwZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IGxhbmdfMS5pc1ByZXNlbnQoZGF0YVsndHlwZSddKSA/IENvbXBpbGVUeXBlTWV0YWRhdGEuZnJvbUpzb24oZGF0YVsndHlwZSddKSA6IGRhdGFbJ3R5cGUnXSxcbiAgICAgICAgICAgIG5hbWU6IGRhdGFbJ25hbWUnXSxcbiAgICAgICAgICAgIHB1cmU6IGRhdGFbJ3B1cmUnXVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVQaXBlTWV0YWRhdGEucHJvdG90eXBlLnRvSnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjbGFzcyc6ICdQaXBlJyxcbiAgICAgICAgICAgICd0eXBlJzogbGFuZ18xLmlzUHJlc2VudCh0aGlzLnR5cGUpID8gdGhpcy50eXBlLnRvSnNvbigpIDogbnVsbCxcbiAgICAgICAgICAgICduYW1lJzogdGhpcy5uYW1lLFxuICAgICAgICAgICAgJ3B1cmUnOiB0aGlzLnB1cmVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlUGlwZU1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuQ29tcGlsZVBpcGVNZXRhZGF0YSA9IENvbXBpbGVQaXBlTWV0YWRhdGE7XG52YXIgX0NPTVBJTEVfTUVUQURBVEFfRlJPTV9KU09OID0ge1xuICAgICdEaXJlY3RpdmUnOiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuZnJvbUpzb24sXG4gICAgJ1BpcGUnOiBDb21waWxlUGlwZU1ldGFkYXRhLmZyb21Kc29uLFxuICAgICdUeXBlJzogQ29tcGlsZVR5cGVNZXRhZGF0YS5mcm9tSnNvbixcbiAgICAnUHJvdmlkZXInOiBDb21waWxlUHJvdmlkZXJNZXRhZGF0YS5mcm9tSnNvbixcbiAgICAnSWRlbnRpZmllcic6IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEuZnJvbUpzb24sXG4gICAgJ0ZhY3RvcnknOiBDb21waWxlRmFjdG9yeU1ldGFkYXRhLmZyb21Kc29uXG59O1xuZnVuY3Rpb24gX2FycmF5RnJvbUpzb24ob2JqLCBmbikge1xuICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayhvYmopID8gbnVsbCA6IG9iai5tYXAoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIF9vYmpGcm9tSnNvbihvLCBmbik7IH0pO1xufVxuZnVuY3Rpb24gX2FycmF5VG9Kc29uKG9iaikge1xuICAgIHJldHVybiBsYW5nXzEuaXNCbGFuayhvYmopID8gbnVsbCA6IG9iai5tYXAoX29ialRvSnNvbik7XG59XG5mdW5jdGlvbiBfb2JqRnJvbUpzb24ob2JqLCBmbikge1xuICAgIGlmIChsYW5nXzEuaXNBcnJheShvYmopKVxuICAgICAgICByZXR1cm4gX2FycmF5RnJvbUpzb24ob2JqLCBmbik7XG4gICAgaWYgKGxhbmdfMS5pc1N0cmluZyhvYmopIHx8IGxhbmdfMS5pc0JsYW5rKG9iaikgfHwgbGFuZ18xLmlzQm9vbGVhbihvYmopIHx8IGxhbmdfMS5pc051bWJlcihvYmopKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIHJldHVybiBmbihvYmopO1xufVxuZnVuY3Rpb24gX29ialRvSnNvbihvYmopIHtcbiAgICBpZiAobGFuZ18xLmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIF9hcnJheVRvSnNvbihvYmopO1xuICAgIGlmIChsYW5nXzEuaXNTdHJpbmcob2JqKSB8fCBsYW5nXzEuaXNCbGFuayhvYmopIHx8IGxhbmdfMS5pc0Jvb2xlYW4ob2JqKSB8fCBsYW5nXzEuaXNOdW1iZXIob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gb2JqLnRvSnNvbigpO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUFycmF5KG9iaikge1xuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KG9iaikgPyBvYmogOiBbXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVfbWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vdGVtcGxhdGVfYXN0JykpO1xudmFyIHRlbXBsYXRlX3BhcnNlcl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9wYXJzZXInKTtcbmV4cG9ydHMuVEVNUExBVEVfVFJBTlNGT1JNUyA9IHRlbXBsYXRlX3BhcnNlcl8xLlRFTVBMQVRFX1RSQU5TRk9STVM7XG52YXIgY29uZmlnXzEgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuZXhwb3J0cy5Db21waWxlckNvbmZpZyA9IGNvbmZpZ18xLkNvbXBpbGVyQ29uZmlnO1xuZXhwb3J0cy5SZW5kZXJUeXBlcyA9IGNvbmZpZ18xLlJlbmRlclR5cGVzO1xuX19leHBvcnQocmVxdWlyZSgnLi9jb21waWxlX21ldGFkYXRhJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9vZmZsaW5lX2NvbXBpbGVyJykpO1xudmFyIHJ1bnRpbWVfY29tcGlsZXJfMSA9IHJlcXVpcmUoJy4vcnVudGltZV9jb21waWxlcicpO1xuZXhwb3J0cy5SdW50aW1lQ29tcGlsZXIgPSBydW50aW1lX2NvbXBpbGVyXzEuUnVudGltZUNvbXBpbGVyO1xuX19leHBvcnQocmVxdWlyZSgnLi91cmxfcmVzb2x2ZXInKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3hocicpKTtcbnZhciB2aWV3X3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL3ZpZXdfcmVzb2x2ZXInKTtcbmV4cG9ydHMuVmlld1Jlc29sdmVyID0gdmlld19yZXNvbHZlcl8xLlZpZXdSZXNvbHZlcjtcbnZhciBkaXJlY3RpdmVfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX3Jlc29sdmVyJyk7XG5leHBvcnRzLkRpcmVjdGl2ZVJlc29sdmVyID0gZGlyZWN0aXZlX3Jlc29sdmVyXzEuRGlyZWN0aXZlUmVzb2x2ZXI7XG52YXIgcGlwZV9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9waXBlX3Jlc29sdmVyJyk7XG5leHBvcnRzLlBpcGVSZXNvbHZlciA9IHBpcGVfcmVzb2x2ZXJfMS5QaXBlUmVzb2x2ZXI7XG52YXIgdGVtcGxhdGVfcGFyc2VyXzIgPSByZXF1aXJlKCcuL3RlbXBsYXRlX3BhcnNlcicpO1xudmFyIGh0bWxfcGFyc2VyXzEgPSByZXF1aXJlKCcuL2h0bWxfcGFyc2VyJyk7XG52YXIgZGlyZWN0aXZlX25vcm1hbGl6ZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX25vcm1hbGl6ZXInKTtcbnZhciBtZXRhZGF0YV9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9tZXRhZGF0YV9yZXNvbHZlcicpO1xudmFyIHN0eWxlX2NvbXBpbGVyXzEgPSByZXF1aXJlKCcuL3N0eWxlX2NvbXBpbGVyJyk7XG52YXIgdmlld19jb21waWxlcl8xID0gcmVxdWlyZSgnLi92aWV3X2NvbXBpbGVyL3ZpZXdfY29tcGlsZXInKTtcbnZhciBjb25maWdfMiA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgcnVudGltZV9jb21waWxlcl8yID0gcmVxdWlyZSgnLi9ydW50aW1lX2NvbXBpbGVyJyk7XG52YXIgZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMSA9IHJlcXVpcmUoJy4vc2NoZW1hL2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5Jyk7XG52YXIgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKCcuL3NjaGVtYS9kb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnknKTtcbnZhciB1cmxfcmVzb2x2ZXJfMiA9IHJlcXVpcmUoJy4vdXJsX3Jlc29sdmVyJyk7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKCcuL2V4cHJlc3Npb25fcGFyc2VyL3BhcnNlcicpO1xudmFyIGxleGVyXzEgPSByZXF1aXJlKCcuL2V4cHJlc3Npb25fcGFyc2VyL2xleGVyJyk7XG52YXIgdmlld19yZXNvbHZlcl8yID0gcmVxdWlyZSgnLi92aWV3X3Jlc29sdmVyJyk7XG52YXIgZGlyZWN0aXZlX3Jlc29sdmVyXzIgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZV9yZXNvbHZlcicpO1xudmFyIHBpcGVfcmVzb2x2ZXJfMiA9IHJlcXVpcmUoJy4vcGlwZV9yZXNvbHZlcicpO1xuZnVuY3Rpb24gX2NyZWF0ZUNvbXBpbGVyQ29uZmlnKCkge1xuICAgIHJldHVybiBuZXcgY29uZmlnXzIuQ29tcGlsZXJDb25maWcobGFuZ18xLmFzc2VydGlvbnNFbmFibGVkKCksIGZhbHNlLCB0cnVlKTtcbn1cbi8qKlxuICogQSBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgcHJvdmlkZSBgUnVudGltZUNvbXBpbGVyYCBhbmQgaXRzIGRlcGVuZGVuY2llcyB0byB1c2UgZm9yXG4gKiB0ZW1wbGF0ZSBjb21waWxhdGlvbi5cbiAqL1xuZXhwb3J0cy5DT01QSUxFUl9QUk9WSURFUlMgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBbXG4gICAgbGV4ZXJfMS5MZXhlcixcbiAgICBwYXJzZXJfMS5QYXJzZXIsXG4gICAgaHRtbF9wYXJzZXJfMS5IdG1sUGFyc2VyLFxuICAgIHRlbXBsYXRlX3BhcnNlcl8yLlRlbXBsYXRlUGFyc2VyLFxuICAgIGRpcmVjdGl2ZV9ub3JtYWxpemVyXzEuRGlyZWN0aXZlTm9ybWFsaXplcixcbiAgICBtZXRhZGF0YV9yZXNvbHZlcl8xLkNvbXBpbGVNZXRhZGF0YVJlc29sdmVyLFxuICAgIHVybF9yZXNvbHZlcl8yLkRFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIsXG4gICAgc3R5bGVfY29tcGlsZXJfMS5TdHlsZUNvbXBpbGVyLFxuICAgIHZpZXdfY29tcGlsZXJfMS5WaWV3Q29tcGlsZXIsXG4gICAgLypAdHMyZGFydF9Qcm92aWRlciovIHsgcHJvdmlkZTogY29uZmlnXzIuQ29tcGlsZXJDb25maWcsIHVzZUZhY3Rvcnk6IF9jcmVhdGVDb21waWxlckNvbmZpZywgZGVwczogW10gfSxcbiAgICBydW50aW1lX2NvbXBpbGVyXzIuUnVudGltZUNvbXBpbGVyLFxuICAgIC8qQHRzMmRhcnRfUHJvdmlkZXIqLyB7IHByb3ZpZGU6IGNvcmVfMS5Db21wb25lbnRSZXNvbHZlciwgdXNlRXhpc3Rpbmc6IHJ1bnRpbWVfY29tcGlsZXJfMi5SdW50aW1lQ29tcGlsZXIgfSxcbiAgICBkb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnksXG4gICAgLypAdHMyZGFydF9Qcm92aWRlciovIHsgcHJvdmlkZTogZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5FbGVtZW50U2NoZW1hUmVnaXN0cnksIHVzZUV4aXN0aW5nOiBkb21fZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5Eb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgfSxcbiAgICB1cmxfcmVzb2x2ZXJfMi5VcmxSZXNvbHZlcixcbiAgICB2aWV3X3Jlc29sdmVyXzIuVmlld1Jlc29sdmVyLFxuICAgIGRpcmVjdGl2ZV9yZXNvbHZlcl8yLkRpcmVjdGl2ZVJlc29sdmVyLFxuICAgIHBpcGVfcmVzb2x2ZXJfMi5QaXBlUmVzb2x2ZXJcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBpZGVudGlmaWVyc18xID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xudmFyIENvbXBpbGVyQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlckNvbmZpZyhnZW5EZWJ1Z0luZm8sIGxvZ0JpbmRpbmdVcGRhdGUsIHVzZUppdCwgcmVuZGVyVHlwZXMpIHtcbiAgICAgICAgaWYgKHJlbmRlclR5cGVzID09PSB2b2lkIDApIHsgcmVuZGVyVHlwZXMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZ2VuRGVidWdJbmZvID0gZ2VuRGVidWdJbmZvO1xuICAgICAgICB0aGlzLmxvZ0JpbmRpbmdVcGRhdGUgPSBsb2dCaW5kaW5nVXBkYXRlO1xuICAgICAgICB0aGlzLnVzZUppdCA9IHVzZUppdDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlbmRlclR5cGVzKSkge1xuICAgICAgICAgICAgcmVuZGVyVHlwZXMgPSBuZXcgRGVmYXVsdFJlbmRlclR5cGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJUeXBlcyA9IHJlbmRlclR5cGVzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZXJDb25maWc7XG59KCkpO1xuZXhwb3J0cy5Db21waWxlckNvbmZpZyA9IENvbXBpbGVyQ29uZmlnO1xuLyoqXG4gKiBUeXBlcyB1c2VkIGZvciB0aGUgcmVuZGVyZXIuXG4gKiBDYW4gYmUgcmVwbGFjZWQgdG8gc3BlY2lhbGl6ZSB0aGUgZ2VuZXJhdGVkIG91dHB1dCB0byBhIHNwZWNpZmljIHJlbmRlcmVyXG4gKiB0byBoZWxwIHRyZWUgc2hha2luZy5cbiAqL1xudmFyIFJlbmRlclR5cGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJUeXBlcygpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJUZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyQ29tbWVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJOb2RlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckV2ZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUmVuZGVyVHlwZXM7XG59KCkpO1xuZXhwb3J0cy5SZW5kZXJUeXBlcyA9IFJlbmRlclR5cGVzO1xudmFyIERlZmF1bHRSZW5kZXJUeXBlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdFJlbmRlclR5cGVzKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5SZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJUZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJDb21tZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJFdmVudCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBEZWZhdWx0UmVuZGVyVHlwZXM7XG59KCkpO1xuZXhwb3J0cy5EZWZhdWx0UmVuZGVyVHlwZXMgPSBEZWZhdWx0UmVuZGVyVHlwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV9wcml2YXRlXzEgPSByZXF1aXJlKCcuLi9jb3JlX3ByaXZhdGUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbmZ1bmN0aW9uIGhhc0xpZmVjeWNsZUhvb2sobGNJbnRlcmZhY2UsIHRva2VuKSB7XG4gICAgaWYgKCEodG9rZW4gaW5zdGFuY2VvZiBsYW5nXzEuVHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcHJvdG8gPSB0b2tlbi5wcm90b3R5cGU7XG4gICAgc3dpdGNoIChsY0ludGVyZmFjZSkge1xuICAgICAgICBjYXNlIGNvcmVfcHJpdmF0ZV8xLkxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQ6XG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5uZ0FmdGVyQ29udGVudEluaXQ7XG4gICAgICAgIGNhc2UgY29yZV9wcml2YXRlXzEuTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZDpcbiAgICAgICAgICAgIHJldHVybiAhIXByb3RvLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZDtcbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5MaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0OlxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8ubmdBZnRlclZpZXdJbml0O1xuICAgICAgICBjYXNlIGNvcmVfcHJpdmF0ZV8xLkxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQ6XG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5uZ0FmdGVyVmlld0NoZWNrZWQ7XG4gICAgICAgIGNhc2UgY29yZV9wcml2YXRlXzEuTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzOlxuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG8ubmdPbkNoYW5nZXM7XG4gICAgICAgIGNhc2UgY29yZV9wcml2YXRlXzEuTGlmZWN5Y2xlSG9va3MuRG9DaGVjazpcbiAgICAgICAgICAgIHJldHVybiAhIXByb3RvLm5nRG9DaGVjaztcbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5MaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3k6XG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5uZ09uRGVzdHJveTtcbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5MaWZlY3ljbGVIb29rcy5PbkluaXQ6XG4gICAgICAgICAgICByZXR1cm4gISFwcm90by5uZ09uSW5pdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmhhc0xpZmVjeWNsZUhvb2sgPSBoYXNMaWZlY3ljbGVIb29rO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgY29tcGlsZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9jb21waWxlX21ldGFkYXRhJyk7XG52YXIgeGhyXzEgPSByZXF1aXJlKCcuL3hocicpO1xudmFyIHVybF9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi91cmxfcmVzb2x2ZXInKTtcbnZhciBzdHlsZV91cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vc3R5bGVfdXJsX3Jlc29sdmVyJyk7XG52YXIgaHRtbF9hc3RfMSA9IHJlcXVpcmUoJy4vaHRtbF9hc3QnKTtcbnZhciBodG1sX3BhcnNlcl8xID0gcmVxdWlyZSgnLi9odG1sX3BhcnNlcicpO1xudmFyIHRlbXBsYXRlX3ByZXBhcnNlcl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9wcmVwYXJzZXInKTtcbnZhciBEaXJlY3RpdmVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVOb3JtYWxpemVyKF94aHIsIF91cmxSZXNvbHZlciwgX2h0bWxQYXJzZXIpIHtcbiAgICAgICAgdGhpcy5feGhyID0gX3hocjtcbiAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICB9XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplRGlyZWN0aXZlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoIWRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gRm9yIG5vbiBjb21wb25lbnRzIHRoZXJlIGlzIG5vdGhpbmcgdG8gYmUgbm9ybWFsaXplZCB5ZXQuXG4gICAgICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKGRpcmVjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplVGVtcGxhdGUoZGlyZWN0aXZlLnR5cGUsIGRpcmVjdGl2ZS50ZW1wbGF0ZSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkVGVtcGxhdGUpIHsgcmV0dXJuIG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IGRpcmVjdGl2ZS50eXBlLFxuICAgICAgICAgICAgaXNDb21wb25lbnQ6IGRpcmVjdGl2ZS5pc0NvbXBvbmVudCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlLmV4cG9ydEFzLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkaXJlY3RpdmUuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgaW5wdXRzOiBkaXJlY3RpdmUuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogZGlyZWN0aXZlLm91dHB1dHMsXG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBkaXJlY3RpdmUuaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBkaXJlY3RpdmUuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogZGlyZWN0aXZlLmhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IGRpcmVjdGl2ZS5saWZlY3ljbGVIb29rcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVycyxcbiAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgcXVlcmllczogZGlyZWN0aXZlLnF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogZGlyZWN0aXZlLnZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgdGVtcGxhdGU6IG5vcm1hbGl6ZWRUZW1wbGF0ZVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0ZW1wbGF0ZS50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodGhpcy5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZShkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSwgdGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudCh0ZW1wbGF0ZS50ZW1wbGF0ZVVybCkpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VBYnNVcmwgPSB0aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsLCB0ZW1wbGF0ZS50ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feGhyLmdldChzb3VyY2VBYnNVcmwpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlQ29udGVudCkgeyByZXR1cm4gX3RoaXMubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGUsIHRlbXBsYXRlQ29udGVudCwgc291cmNlQWJzVXJsKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyB0ZW1wbGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIGRpcmVjdGl2ZVR5cGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlTWV0YSwgdGVtcGxhdGUsIHRlbXBsYXRlQWJzVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByb290Tm9kZXNBbmRFcnJvcnMgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCBkaXJlY3RpdmVUeXBlLm5hbWUpO1xuICAgICAgICBpZiAocm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSByb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCk7XG4gICAgICAgIGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHZpc2l0b3IsIHJvb3ROb2Rlc0FuZEVycm9ycy5yb290Tm9kZXMpO1xuICAgICAgICB2YXIgYWxsU3R5bGVzID0gdGVtcGxhdGVNZXRhLnN0eWxlcy5jb25jYXQodmlzaXRvci5zdHlsZXMpO1xuICAgICAgICB2YXIgYWxsU3R5bGVBYnNVcmxzID0gdmlzaXRvci5zdHlsZVVybHMuZmlsdGVyKHN0eWxlX3VybF9yZXNvbHZlcl8xLmlzU3R5bGVVcmxSZXNvbHZhYmxlKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodXJsKSB7IHJldHVybiBfdGhpcy5fdXJsUmVzb2x2ZXIucmVzb2x2ZSh0ZW1wbGF0ZUFic1VybCwgdXJsKTsgfSlcbiAgICAgICAgICAgIC5jb25jYXQodGVtcGxhdGVNZXRhLnN0eWxlVXJscy5maWx0ZXIoc3R5bGVfdXJsX3Jlc29sdmVyXzEuaXNTdHlsZVVybFJlc29sdmFibGUpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIF90aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsLCB1cmwpOyB9KSk7XG4gICAgICAgIHZhciBhbGxSZXNvbHZlZFN0eWxlcyA9IGFsbFN0eWxlcy5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVXaXRoSW1wb3J0cyA9IHN0eWxlX3VybF9yZXNvbHZlcl8xLmV4dHJhY3RTdHlsZVVybHMoX3RoaXMuX3VybFJlc29sdmVyLCB0ZW1wbGF0ZUFic1VybCwgc3R5bGUpO1xuICAgICAgICAgICAgc3R5bGVXaXRoSW1wb3J0cy5zdHlsZVVybHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuIGFsbFN0eWxlQWJzVXJscy5wdXNoKHN0eWxlVXJsKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVXaXRoSW1wb3J0cy5zdHlsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbmNhcHN1bGF0aW9uID0gdGVtcGxhdGVNZXRhLmVuY2Fwc3VsYXRpb247XG4gICAgICAgIGlmIChlbmNhcHN1bGF0aW9uID09PSBjb3JlXzEuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgJiYgYWxsUmVzb2x2ZWRTdHlsZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBhbGxTdHlsZUFic1VybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gY29yZV8xLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiB0ZW1wbGF0ZUFic1VybCxcbiAgICAgICAgICAgIHN0eWxlczogYWxsUmVzb2x2ZWRTdHlsZXMsXG4gICAgICAgICAgICBzdHlsZVVybHM6IGFsbFN0eWxlQWJzVXJscyxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdmlzaXRvci5uZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogeGhyXzEuWEhSLCB9LFxuICAgICAgICB7IHR5cGU6IHVybF9yZXNvbHZlcl8xLlVybFJlc29sdmVyLCB9LFxuICAgICAgICB7IHR5cGU6IGh0bWxfcGFyc2VyXzEuSHRtbFBhcnNlciwgfSxcbiAgICBdO1xuICAgIHJldHVybiBEaXJlY3RpdmVOb3JtYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuRGlyZWN0aXZlTm9ybWFsaXplciA9IERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG52YXIgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCkge1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID0gMDtcbiAgICB9XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5wcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgc3dpdGNoIChwcmVwYXJzZWRFbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuc2VsZWN0QXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgaHRtbF9hc3RfMS5IdG1sVGV4dEFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgKz0gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGVtcGxhdGVfcHJlcGFyc2VyXzEuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDpcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlVXJscy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBEREMgcmVwb3J0cyB0aGlzIGFzIGVycm9yLiBTZWU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhcnQtbGFuZy9kZXZfY29tcGlsZXIvaXNzdWVzLzQyOFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbF9hc3RfMS5odG1sVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZV9ub3JtYWxpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xuZnVuY3Rpb24gX2lzRGlyZWN0aXZlTWV0YWRhdGEodHlwZSkge1xuICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgY29yZV8xLkRpcmVjdGl2ZU1ldGFkYXRhO1xufVxudmFyIERpcmVjdGl2ZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KF9yZWZsZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gY29yZV8xLnJlZmxlY3RvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge0BsaW5rIERpcmVjdGl2ZU1ldGFkYXRhfSBmb3IgYSBnaXZlbiBgVHlwZWAuXG4gICAgICovXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKGNvcmVfMS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHR5cGVNZXRhZGF0YS5maW5kKF9pc0RpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLnByb3BNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YShtZXRhZGF0YSwgcHJvcGVydHlNZXRhZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiTm8gRGlyZWN0aXZlIGFubm90YXRpb24gZm91bmQgb24gXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHR5cGUpKTtcbiAgICB9O1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YSA9IGZ1bmN0aW9uIChkbSwgcHJvcGVydHlNZXRhZGF0YSwgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgaW5wdXRzID0gW107XG4gICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgIHZhciBob3N0ID0ge307XG4gICAgICAgIHZhciBxdWVyaWVzID0ge307XG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2gocHJvcGVydHlNZXRhZGF0YSwgZnVuY3Rpb24gKG1ldGFkYXRhLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgbWV0YWRhdGEuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgY29yZV8xLklucHV0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYS5iaW5kaW5nUHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgY29yZV8xLk91dHB1dE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGEuYmluZGluZ1Byb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChwcm9wTmFtZSArIFwiOiBcIiArIGEuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgY29yZV8xLkhvc3RCaW5kaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYS5ob3N0UHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFsoXCJbXCIgKyBhLmhvc3RQcm9wZXJ0eU5hbWUgKyBcIl1cIildID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIltcIiArIHByb3BOYW1lICsgXCJdXCIpXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgY29yZV8xLkhvc3RMaXN0ZW5lck1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gbGFuZ18xLmlzUHJlc2VudChhLmFyZ3MpID8gYS5hcmdzLmpvaW4oJywgJykgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgaG9zdFsoXCIoXCIgKyBhLmV2ZW50TmFtZSArIFwiKVwiKV0gPSBwcm9wTmFtZSArIFwiKFwiICsgYXJncyArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIGNvcmVfMS5Db250ZW50Q2hpbGRyZW5NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgY29yZV8xLlZpZXdDaGlsZHJlbk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXNbcHJvcE5hbWVdID0gYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBjb3JlXzEuQ29udGVudENoaWxkTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllc1twcm9wTmFtZV0gPSBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIGNvcmVfMS5WaWV3Q2hpbGRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2UoZG0sIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcywgZGlyZWN0aXZlVHlwZSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlID0gZnVuY3Rpb24gKGRtLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIG1lcmdlZElucHV0cyA9IGxhbmdfMS5pc1ByZXNlbnQoZG0uaW5wdXRzKSA/IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb25jYXQoZG0uaW5wdXRzLCBpbnB1dHMpIDogaW5wdXRzO1xuICAgICAgICB2YXIgbWVyZ2VkT3V0cHV0cztcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZG0ub3V0cHV0cykpIHtcbiAgICAgICAgICAgIGRtLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbnRhaW5zKG91dHB1dHMsIHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJPdXRwdXQgZXZlbnQgJ1wiICsgcHJvcE5hbWUgKyBcIicgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyBpbiAnXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGRpcmVjdGl2ZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVyZ2VkT3V0cHV0cyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb25jYXQoZG0ub3V0cHV0cywgb3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXJnZWRPdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVyZ2VkSG9zdCA9IGxhbmdfMS5pc1ByZXNlbnQoZG0uaG9zdCkgPyBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5tZXJnZShkbS5ob3N0LCBob3N0KSA6IGhvc3Q7XG4gICAgICAgIHZhciBtZXJnZWRRdWVyaWVzID0gbGFuZ18xLmlzUHJlc2VudChkbS5xdWVyaWVzKSA/IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLm1lcmdlKGRtLnF1ZXJpZXMsIHF1ZXJpZXMpIDogcXVlcmllcztcbiAgICAgICAgaWYgKGRtIGluc3RhbmNlb2YgY29yZV8xLkNvbXBvbmVudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmVfMS5Db21wb25lbnRNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRtLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogZG0uZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IGRtLm1vZHVsZUlkLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkbS5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBkbS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogZG0udmlld1Byb3ZpZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmVfMS5EaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRtLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogZG0uZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRtLnByb3ZpZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfcHJpdmF0ZV8xLlJlZmxlY3RvclJlYWRlciwgfSxcbiAgICBdO1xuICAgIHJldHVybiBEaXJlY3RpdmVSZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLkRpcmVjdGl2ZVJlc29sdmVyID0gRGlyZWN0aXZlUmVzb2x2ZXI7XG5leHBvcnRzLkNPREVHRU5fRElSRUNUSVZFX1JFU09MVkVSID0gbmV3IERpcmVjdGl2ZVJlc29sdmVyKGNvcmVfMS5yZWZsZWN0b3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlX3Jlc29sdmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU1QoKSB7XG4gICAgfVxuICAgIEFTVC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQVNUXCI7IH07XG4gICAgcmV0dXJuIEFTVDtcbn0oKSk7XG5leHBvcnRzLkFTVCA9IEFTVDtcbi8qKlxuICogUmVwcmVzZW50cyBhIHF1b3RlZCBleHByZXNzaW9uIG9mIHRoZSBmb3JtOlxuICpcbiAqIHF1b3RlID0gcHJlZml4IGA6YCB1bmludGVycHJldGVkRXhwcmVzc2lvblxuICogcHJlZml4ID0gaWRlbnRpZmllclxuICogdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBhcmJpdHJhcnkgc3RyaW5nXG4gKlxuICogQSBxdW90ZWQgZXhwcmVzc2lvbiBpcyBtZWFudCB0byBiZSBwcmUtcHJvY2Vzc2VkIGJ5IGFuIEFTVCB0cmFuc2Zvcm1lciB0aGF0XG4gKiBjb252ZXJ0cyBpdCBpbnRvIGFub3RoZXIgQVNUIHRoYXQgbm8gbG9uZ2VyIGNvbnRhaW5zIHF1b3RlZCBleHByZXNzaW9ucy5cbiAqIEl0IGlzIG1lYW50IHRvIGFsbG93IHRoaXJkLXBhcnR5IGRldmVsb3BlcnMgdG8gZXh0ZW5kIEFuZ3VsYXIgdGVtcGxhdGVcbiAqIGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFRoZSBgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25gIHBhcnQgb2YgdGhlIHF1b3RlIGlzXG4gKiB0aGVyZWZvcmUgbm90IGludGVycHJldGVkIGJ5IHRoZSBBbmd1bGFyJ3Mgb3duIGV4cHJlc3Npb24gcGFyc2VyLlxuICovXG52YXIgUXVvdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdW90ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdW90ZShwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSB1bmludGVycHJldGVkRXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIH1cbiAgICBRdW90ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UXVvdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICBRdW90ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlF1b3RlXCI7IH07XG4gICAgcmV0dXJuIFF1b3RlO1xufShBU1QpKTtcbmV4cG9ydHMuUXVvdGUgPSBRdW90ZTtcbnZhciBFbXB0eUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlFeHByKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRW1wdHlFeHByLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgcmV0dXJuIEVtcHR5RXhwcjtcbn0oQVNUKSk7XG5leHBvcnRzLkVtcHR5RXhwciA9IEVtcHR5RXhwcjtcbnZhciBJbXBsaWNpdFJlY2VpdmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbXBsaWNpdFJlY2VpdmVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgSW1wbGljaXRSZWNlaXZlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW1wbGljaXRSZWNlaXZlcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbXBsaWNpdFJlY2VpdmVyO1xufShBU1QpKTtcbmV4cG9ydHMuSW1wbGljaXRSZWNlaXZlciA9IEltcGxpY2l0UmVjZWl2ZXI7XG4vKipcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqL1xudmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhaW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhaW4oZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG4gICAgQ2hhaW4ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoYWluKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENoYWluO1xufShBU1QpKTtcbmV4cG9ydHMuQ2hhaW4gPSBDaGFpbjtcbnZhciBDb25kaXRpb25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsKGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnRydWVFeHAgPSB0cnVlRXhwO1xuICAgICAgICB0aGlzLmZhbHNlRXhwID0gZmFsc2VFeHA7XG4gICAgfVxuICAgIENvbmRpdGlvbmFsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25kaXRpb25hbDtcbn0oQVNUKSk7XG5leHBvcnRzLkNvbmRpdGlvbmFsID0gQ29uZGl0aW9uYWw7XG52YXIgUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5UmVhZChyZWNlaXZlciwgbmFtZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5UmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBQcm9wZXJ0eVJlYWQ7XG59KEFTVCkpO1xuZXhwb3J0cy5Qcm9wZXJ0eVJlYWQgPSBQcm9wZXJ0eVJlYWQ7XG52YXIgUHJvcGVydHlXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5V3JpdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvcGVydHlXcml0ZShyZWNlaXZlciwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBQcm9wZXJ0eVdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XG59KEFTVCkpO1xuZXhwb3J0cy5Qcm9wZXJ0eVdyaXRlID0gUHJvcGVydHlXcml0ZTtcbnZhciBTYWZlUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIFNhZmVQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG5leHBvcnRzLlNhZmVQcm9wZXJ0eVJlYWQgPSBTYWZlUHJvcGVydHlSZWFkO1xudmFyIEtleWVkUmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEtleWVkUmVhZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBLZXllZFJlYWQob2JqLCBrZXkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgS2V5ZWRSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRSZWFkO1xufShBU1QpKTtcbmV4cG9ydHMuS2V5ZWRSZWFkID0gS2V5ZWRSZWFkO1xudmFyIEtleWVkV3JpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXllZFdyaXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEtleWVkV3JpdGUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgS2V5ZWRXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZWRXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBLZXllZFdyaXRlO1xufShBU1QpKTtcbmV4cG9ydHMuS2V5ZWRXcml0ZSA9IEtleWVkV3JpdGU7XG52YXIgQmluZGluZ1BpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5kaW5nUGlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5kaW5nUGlwZShleHAsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXhwID0gZXhwO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBCaW5kaW5nUGlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nUGlwZTtcbn0oQVNUKSk7XG5leHBvcnRzLkJpbmRpbmdQaXBlID0gQmluZGluZ1BpcGU7XG52YXIgTGl0ZXJhbFByaW1pdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsUHJpbWl0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxQcmltaXRpdmU7XG59KEFTVCkpO1xuZXhwb3J0cy5MaXRlcmFsUHJpbWl0aXZlID0gTGl0ZXJhbFByaW1pdGl2ZTtcbnZhciBMaXRlcmFsQXJyYXkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsQXJyYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KGV4cHJlc3Npb25zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIExpdGVyYWxBcnJheS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxBcnJheTtcbn0oQVNUKSk7XG5leHBvcnRzLkxpdGVyYWxBcnJheSA9IExpdGVyYWxBcnJheTtcbnZhciBMaXRlcmFsTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbE1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXRlcmFsTWFwKGtleXMsIHZhbHVlcykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIExpdGVyYWxNYXAucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXAodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbE1hcDtcbn0oQVNUKSk7XG5leHBvcnRzLkxpdGVyYWxNYXAgPSBMaXRlcmFsTWFwO1xudmFyIEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnRlcnBvbGF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG4gICAgSW50ZXJwb2xhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW50ZXJwb2xhdGlvbih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcnBvbGF0aW9uO1xufShBU1QpKTtcbmV4cG9ydHMuSW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRpb247XG52YXIgQmluYXJ5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmluYXJ5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpbmFyeShvcGVyYXRpb24sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICBCaW5hcnkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5hcnk7XG59KEFTVCkpO1xuZXhwb3J0cy5CaW5hcnkgPSBCaW5hcnk7XG52YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlZml4Tm90LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByZWZpeE5vdChleHByZXNzaW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICBQcmVmaXhOb3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByZWZpeE5vdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBQcmVmaXhOb3Q7XG59KEFTVCkpO1xuZXhwb3J0cy5QcmVmaXhOb3QgPSBQcmVmaXhOb3Q7XG52YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChyZWNlaXZlciwgbmFtZSwgYXJncykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRNZXRob2RDYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1ldGhvZENhbGw7XG59KEFTVCkpO1xuZXhwb3J0cy5NZXRob2RDYWxsID0gTWV0aG9kQ2FsbDtcbnZhciBTYWZlTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVNZXRob2RDYWxsKHJlY2VpdmVyLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG5leHBvcnRzLlNhZmVNZXRob2RDYWxsID0gU2FmZU1ldGhvZENhbGw7XG52YXIgRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uQ2FsbCh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBGdW5jdGlvbkNhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBGdW5jdGlvbkNhbGw7XG59KEFTVCkpO1xuZXhwb3J0cy5GdW5jdGlvbkNhbGwgPSBGdW5jdGlvbkNhbGw7XG52YXIgQVNUV2l0aFNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFTVFdpdGhTb3VyY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgbG9jYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIH1cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNvdXJjZSArIFwiIGluIFwiICsgdGhpcy5sb2NhdGlvbjsgfTtcbiAgICByZXR1cm4gQVNUV2l0aFNvdXJjZTtcbn0oQVNUKSk7XG5leHBvcnRzLkFTVFdpdGhTb3VyY2UgPSBBU1RXaXRoU291cmNlO1xudmFyIFRlbXBsYXRlQmluZGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVCaW5kaW5nKGtleSwga2V5SXNWYXIsIG5hbWUsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMua2V5SXNWYXIgPSBrZXlJc1ZhcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZztcbn0oKSk7XG5leHBvcnRzLlRlbXBsYXRlQmluZGluZyA9IFRlbXBsYXRlQmluZGluZztcbnZhciBSZWN1cnNpdmVBc3RWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVBc3RWaXNpdG9yKCkge1xuICAgIH1cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmxlZnQudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5yaWdodC52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpOyB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnRhcmdldC52aXNpdCh0aGlzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5vYmoudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcywgY29udGV4dCk7IH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBSZWN1cnNpdmVBc3RWaXNpdG9yO1xufSgpKTtcbmV4cG9ydHMuUmVjdXJzaXZlQXN0VmlzaXRvciA9IFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG52YXIgQXN0VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzdFRyYW5zZm9ybWVyKCkge1xuICAgIH1cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbihhc3Quc3RyaW5ncywgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZShhc3QudmFsdWUpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZChhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZShhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCBhc3QudmFsdWUpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RDYWxsKGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVNZXRob2RDYWxsKGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwoYXN0LnRhcmdldC52aXNpdCh0aGlzKSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheSh0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwKGFzdC5rZXlzLCB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkoYXN0Lm9wZXJhdGlvbiwgYXN0LmxlZnQudmlzaXQodGhpcyksIGFzdC5yaWdodC52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5jb25kaXRpb24udmlzaXQodGhpcyksIGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpLCBhc3QuZmFsc2VFeHAudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUGlwZShhc3QuZXhwLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEtleWVkUmVhZChhc3Qub2JqLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZShhc3Qub2JqLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpLCBhc3QudmFsdWUudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgdmFyIHJlcyA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUoYXN0cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbmV3IENoYWluKHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7IH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGUoYXN0LnByZWZpeCwgYXN0LnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBhc3QubG9jYXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyO1xufSgpKTtcbmV4cG9ydHMuQXN0VHJhbnNmb3JtZXIgPSBBc3RUcmFuc2Zvcm1lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbihmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNoYXJhY3RlclwiXSA9IDBdID0gXCJDaGFyYWN0ZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiSWRlbnRpZmllclwiXSA9IDFdID0gXCJJZGVudGlmaWVyXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIktleXdvcmRcIl0gPSAyXSA9IFwiS2V5d29yZFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk9wZXJhdG9yXCJdID0gNF0gPSBcIk9wZXJhdG9yXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk51bWJlclwiXSA9IDVdID0gXCJOdW1iZXJcIjtcbn0pKGV4cG9ydHMuVG9rZW5UeXBlIHx8IChleHBvcnRzLlRva2VuVHlwZSA9IHt9KSk7XG52YXIgVG9rZW5UeXBlID0gZXhwb3J0cy5Ub2tlblR5cGU7XG52YXIgTGV4ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExleGVyKCkge1xuICAgIH1cbiAgICBMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcih0ZXh0KTtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB3aGlsZSAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcbiAgICBMZXhlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gTGV4ZXI7XG59KCkpO1xuZXhwb3J0cy5MZXhlciA9IExleGVyO1xudmFyIFRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbihpbmRleCwgdHlwZSwgbnVtVmFsdWUsIHN0clZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5udW1WYWx1ZSA9IG51bVZhbHVlO1xuICAgICAgICB0aGlzLnN0clZhbHVlID0gc3RyVmFsdWU7XG4gICAgfVxuICAgIFRva2VuLnByb3RvdHlwZS5pc0NoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlKTtcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc051bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlcik7IH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuU3RyaW5nKTsgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRlcikge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IgJiYgdGhpcy5zdHJWYWx1ZSA9PSBvcGVyYXRlcik7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuSWRlbnRpZmllcik7IH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQpOyB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmREZXByZWNhdGVkVmFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09IFwidmFyXCIpO1xuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSBcImxldFwiKTsgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkTnVsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSBcIm51bGxcIik7IH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSBcInVuZGVmaW5lZFwiKTtcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRUcnVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09IFwidHJ1ZVwiKTsgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkRmFsc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gXCJmYWxzZVwiKTsgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIC0xIGluc3RlYWQgb2YgTlVMTCBvaz9cbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlcikgPyB0aGlzLm51bVZhbHVlIDogLTE7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5DaGFyYWN0ZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5JZGVudGlmaWVyOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuS2V5d29yZDpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLk9wZXJhdG9yOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVG9rZW47XG59KCkpO1xuZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuZnVuY3Rpb24gbmV3Q2hhcmFjdGVyVG9rZW4oaW5kZXgsIGNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuQ2hhcmFjdGVyLCBjb2RlLCBsYW5nXzEuU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUoY29kZSkpO1xufVxuZnVuY3Rpb24gbmV3SWRlbnRpZmllclRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLklkZW50aWZpZXIsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3S2V5d29yZFRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLktleXdvcmQsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3T3BlcmF0b3JUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5PcGVyYXRvciwgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdTdHJpbmdUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5TdHJpbmcsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3TnVtYmVyVG9rZW4oaW5kZXgsIG4pIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuTnVtYmVyLCBuLCBcIlwiKTtcbn1cbmV4cG9ydHMuRU9GID0gbmV3IFRva2VuKC0xLCBUb2tlblR5cGUuQ2hhcmFjdGVyLCAwLCBcIlwiKTtcbmV4cG9ydHMuJEVPRiA9IDA7XG5leHBvcnRzLiRUQUIgPSA5O1xuZXhwb3J0cy4kTEYgPSAxMDtcbmV4cG9ydHMuJFZUQUIgPSAxMTtcbmV4cG9ydHMuJEZGID0gMTI7XG5leHBvcnRzLiRDUiA9IDEzO1xuZXhwb3J0cy4kU1BBQ0UgPSAzMjtcbmV4cG9ydHMuJEJBTkcgPSAzMztcbmV4cG9ydHMuJERRID0gMzQ7XG5leHBvcnRzLiRIQVNIID0gMzU7XG5leHBvcnRzLiQkID0gMzY7XG5leHBvcnRzLiRQRVJDRU5UID0gMzc7XG5leHBvcnRzLiRBTVBFUlNBTkQgPSAzODtcbmV4cG9ydHMuJFNRID0gMzk7XG5leHBvcnRzLiRMUEFSRU4gPSA0MDtcbmV4cG9ydHMuJFJQQVJFTiA9IDQxO1xuZXhwb3J0cy4kU1RBUiA9IDQyO1xuZXhwb3J0cy4kUExVUyA9IDQzO1xuZXhwb3J0cy4kQ09NTUEgPSA0NDtcbmV4cG9ydHMuJE1JTlVTID0gNDU7XG5leHBvcnRzLiRQRVJJT0QgPSA0NjtcbmV4cG9ydHMuJFNMQVNIID0gNDc7XG5leHBvcnRzLiRDT0xPTiA9IDU4O1xuZXhwb3J0cy4kU0VNSUNPTE9OID0gNTk7XG5leHBvcnRzLiRMVCA9IDYwO1xuZXhwb3J0cy4kRVEgPSA2MTtcbmV4cG9ydHMuJEdUID0gNjI7XG5leHBvcnRzLiRRVUVTVElPTiA9IDYzO1xudmFyICQwID0gNDg7XG52YXIgJDkgPSA1NztcbnZhciAkQSA9IDY1LCAkRSA9IDY5LCAkWiA9IDkwO1xuZXhwb3J0cy4kTEJSQUNLRVQgPSA5MTtcbmV4cG9ydHMuJEJBQ0tTTEFTSCA9IDkyO1xuZXhwb3J0cy4kUkJSQUNLRVQgPSA5MztcbnZhciAkQ0FSRVQgPSA5NDtcbnZhciAkXyA9IDk1O1xuZXhwb3J0cy4kQlQgPSA5NjtcbnZhciAkYSA9IDk3LCAkZSA9IDEwMSwgJGYgPSAxMDI7XG52YXIgJG4gPSAxMTAsICRyID0gMTE0LCAkdCA9IDExNiwgJHUgPSAxMTcsICR2ID0gMTE4LCAkeiA9IDEyMjtcbmV4cG9ydHMuJExCUkFDRSA9IDEyMztcbmV4cG9ydHMuJEJBUiA9IDEyNDtcbmV4cG9ydHMuJFJCUkFDRSA9IDEyNTtcbnZhciAkTkJTUCA9IDE2MDtcbnZhciBTY2FubmVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FubmVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Nhbm5lckVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIFNjYW5uZXJFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lc3NhZ2U7IH07XG4gICAgcmV0dXJuIFNjYW5uZXJFcnJvcjtcbn0oZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pKTtcbmV4cG9ydHMuU2Nhbm5lckVycm9yID0gU2Nhbm5lckVycm9yO1xudmFyIF9TY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfU2Nhbm5lcihpbnB1dCkge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucGVlayA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wZWVrID1cbiAgICAgICAgICAgICsrdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/IGV4cG9ydHMuJEVPRiA6IGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQodGhpcy5pbnB1dCwgdGhpcy5pbmRleCk7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LCBsZW5ndGggPSB0aGlzLmxlbmd0aCwgcGVlayA9IHRoaXMucGVlaywgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgIHdoaWxlIChwZWVrIDw9IGV4cG9ydHMuJFNQQUNFKSB7XG4gICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwZWVrID0gZXhwb3J0cy4kRU9GO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVlayA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQoaW5wdXQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlZWsgPSBwZWVrO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpZGVudGlmaWVycyBhbmQgbnVtYmVycy5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKGlzRGlnaXQocGVlaykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtYmVyKGluZGV4KTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRQRVJJT0Q6XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGlnaXQodGhpcy5wZWVrKSA/IHRoaXMuc2Nhbk51bWJlcihzdGFydCkgOiBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgZXhwb3J0cy4kUEVSSU9EKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kTFBBUkVOOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRSUEFSRU46XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJExCUkFDRTpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kUkJSQUNFOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRMQlJBQ0tFVDpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kUkJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJENPTU1BOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRDT0xPTjpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kU0VNSUNPTE9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5DaGFyYWN0ZXIoc3RhcnQsIHBlZWspO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRTUTpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kRFE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRIQVNIOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRQTFVTOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRNSU5VUzpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kU1RBUjpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kU0xBU0g6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJFBFUkNFTlQ6XG4gICAgICAgICAgICBjYXNlICRDQVJFVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT3BlcmF0b3Ioc3RhcnQsIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShwZWVrKSk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuJFFVRVNUSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICc/JywgZXhwb3J0cy4kUEVSSU9ELCAnLicpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRMVDpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kR1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspLCBleHBvcnRzLiRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kQkFORzpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspLCBleHBvcnRzLiRFUSwgJz0nLCBleHBvcnRzLiRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy4kQU1QRVJTQU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICcmJywgZXhwb3J0cy4kQU1QRVJTQU5ELCAnJicpO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLiRCQVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJ3wnLCBleHBvcnRzLiRCQVIsICd8Jyk7XG4gICAgICAgICAgICBjYXNlICROQlNQOlxuICAgICAgICAgICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFtcIiArIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShwZWVrKSArIFwiXVwiLCAwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNoYXJhY3RlciA9IGZ1bmN0aW9uIChzdGFydCwgY29kZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCBjb2RlKTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuT3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIHN0cikge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZSBhIDIvMyBjaGFyIGxvbmcgb3BlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBpbmRleCBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXG4gICAgICogQHBhcmFtIHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcbiAgICAgKiBAcGFyYW0gdHdvIHNlY29uZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gdGhlIHNlY29uZCBjb2RlIHBvaW50IG1hdGNoZXMpXG4gICAgICogQHBhcmFtIHRocmVlQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgdGhpcmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgKiBAcmV0dXJucyB7VG9rZW59XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Db21wbGV4T3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIG9uZSwgdHdvQ29kZSwgdHdvLCB0aHJlZUNvZGUsIHRocmVlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB2YXIgc3RyID0gb25lO1xuICAgICAgICBpZiAodGhpcy5wZWVrID09IHR3b0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHR3bztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aHJlZUNvZGUpICYmIHRoaXMucGVlayA9PSB0aHJlZUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHRocmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgIH07XG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5JZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICBpZiAoY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKEtFWVdPUkRTLCBzdHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3S2V5d29yZFRva2VuKHN0YXJ0LCBzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0lkZW50aWZpZXJUb2tlbihzdGFydCwgc3RyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1iZXIgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIHNpbXBsZSA9ICh0aGlzLmluZGV4ID09PSBzdGFydCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgZGlnaXQuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gZXhwb3J0cy4kUEVSSU9EKSB7XG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9uZW50U3RhcnQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0V4cG9uZW50U2lnbih0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlnaXQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignSW52YWxpZCBleHBvbmVudCcsIC0xKTtcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICB2YXIgdmFsdWUgPSBzaW1wbGUgPyBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChzdHIpIDogbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VGbG9hdChzdHIpO1xuICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHZhbHVlKTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnBlZWs7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgcXVvdGUuXG4gICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9IHF1b3RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrID09IGV4cG9ydHMuJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IGxhbmdfMS5TdHJpbmdKb2luZXIoKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuYWRkKGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkQ29kZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrID09ICR1KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDQgY2hhcmFjdGVyIGhleCBjb2RlIGZvciB1bmljb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhleCA9IGlucHV0LnN1YnN0cmluZyh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDUpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IGxhbmdfMS5OdW1iZXJXcmFwcGVyLnBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZSBbXFxcXHVcIiArIGhleCArIFwiXVwiLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZENvZGUgPSB1bmVzY2FwZSh0aGlzLnBlZWspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChsYW5nXzEuU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUodW5lc2NhcGVkQ29kZSkpO1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gZXhwb3J0cy4kRU9GKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdCA9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCB0ZXJtaW5hdGluZyBxdW90ZS5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgdW5lc2NhcGVkIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIHVuZXNjYXBlZCA9IGxhc3Q7XG4gICAgICAgIGlmIChidWZmZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgYnVmZmVyLmFkZChsYXN0KTtcbiAgICAgICAgICAgIHVuZXNjYXBlZCA9IGJ1ZmZlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdHJpbmdUb2tlbihzdGFydCwgdW5lc2NhcGVkKTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgdGhyb3cgbmV3IFNjYW5uZXJFcnJvcihcIkxleGVyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBhdCBjb2x1bW4gXCIgKyBwb3NpdGlvbiArIFwiIGluIGV4cHJlc3Npb24gW1wiICsgdGhpcy5pbnB1dCArIFwiXVwiKTtcbiAgICB9O1xuICAgIHJldHVybiBfU2Nhbm5lcjtcbn0oKSk7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSBleHBvcnRzLiRUQUIgJiYgY29kZSA8PSBleHBvcnRzLiRTUEFDRSkgfHwgKGNvZGUgPT0gJE5CU1ApO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fCAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gZXhwb3J0cy4kJCk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcihpbnB1dCk7XG4gICAgaWYgKCFpc0lkZW50aWZpZXJTdGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgc2Nhbm5lci5hZHZhbmNlKCk7XG4gICAgd2hpbGUgKHNjYW5uZXIucGVlayAhPT0gZXhwb3J0cy4kRU9GKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSWRlbnRpZmllciA9IGlzSWRlbnRpZmllcjtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY29kZSkge1xuICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fCAoJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5KSB8fFxuICAgICAgICAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gZXhwb3J0cy4kJCk7XG59XG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xufVxuZnVuY3Rpb24gaXNFeHBvbmVudFN0YXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkZSB8fCBjb2RlID09ICRFO1xufVxuZnVuY3Rpb24gaXNFeHBvbmVudFNpZ24oY29kZSkge1xuICAgIHJldHVybiBjb2RlID09IGV4cG9ydHMuJE1JTlVTIHx8IGNvZGUgPT0gZXhwb3J0cy4kUExVUztcbn1cbmZ1bmN0aW9uIGlzUXVvdGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBleHBvcnRzLiRTUSB8fCBjb2RlID09PSBleHBvcnRzLiREUSB8fCBjb2RlID09PSBleHBvcnRzLiRCVDtcbn1cbmV4cG9ydHMuaXNRdW90ZSA9IGlzUXVvdGU7XG5mdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgJG46XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kTEY7XG4gICAgICAgIGNhc2UgJGY6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kRkY7XG4gICAgICAgIGNhc2UgJHI6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kQ1I7XG4gICAgICAgIGNhc2UgJHQ6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy4kVEFCO1xuICAgICAgICBjYXNlICR2OlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuJFZUQUI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG52YXIgT1BFUkFUT1JTID0gY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuY3JlYXRlRnJvbUxpc3QoW1xuICAgICcrJyxcbiAgICAnLScsXG4gICAgJyonLFxuICAgICcvJyxcbiAgICAnJScsXG4gICAgJ14nLFxuICAgICc9JyxcbiAgICAnPT0nLFxuICAgICchPScsXG4gICAgJz09PScsXG4gICAgJyE9PScsXG4gICAgJzwnLFxuICAgICc+JyxcbiAgICAnPD0nLFxuICAgICc+PScsXG4gICAgJyYmJyxcbiAgICAnfHwnLFxuICAgICcmJyxcbiAgICAnfCcsXG4gICAgJyEnLFxuICAgICc/JyxcbiAgICAnIycsXG4gICAgJz8uJ1xuXSk7XG52YXIgS0VZV09SRFMgPSBjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5jcmVhdGVGcm9tTGlzdChbJ3ZhcicsICdsZXQnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJ10pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbGV4ZXJfMSA9IHJlcXVpcmUoJy4vbGV4ZXInKTtcbnZhciBhc3RfMSA9IHJlcXVpcmUoJy4vYXN0Jyk7XG52YXIgX2ltcGxpY2l0UmVjZWl2ZXIgPSBuZXcgYXN0XzEuSW1wbGljaXRSZWNlaXZlcigpO1xuLy8gVE9ETyh0Ym9zY2gpOiBDYW5ub3QgbWFrZSB0aGlzIGNvbnN0L2ZpbmFsIHJpZ2h0IG5vdyBiZWNhdXNlIG9mIHRoZSB0cmFuc3BpbGVyLi4uXG52YXIgSU5URVJQT0xBVElPTl9SRUdFWFAgPSAvXFx7XFx7KFtcXHNcXFNdKj8pXFx9XFx9L2c7XG52YXIgUGFyc2VFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJzZUV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJzZUV4Y2VwdGlvbihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiUGFyc2VyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBcIiArIGVyckxvY2F0aW9uICsgXCIgW1wiICsgaW5wdXQgKyBcIl0gaW4gXCIgKyBjdHhMb2NhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZUV4Y2VwdGlvbjtcbn0oZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pKTtcbnZhciBTcGxpdEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHJldHVybiBTcGxpdEludGVycG9sYXRpb247XG59KCkpO1xuZXhwb3J0cy5TcGxpdEludGVycG9sYXRpb24gPSBTcGxpdEludGVycG9sYXRpb247XG52YXIgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KHRlbXBsYXRlQmluZGluZ3MsIHdhcm5pbmdzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVCaW5kaW5ncyA9IHRlbXBsYXRlQmluZGluZ3M7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdDtcbnZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcigvKiogQGludGVybmFsICovIF9sZXhlcikge1xuICAgICAgICB0aGlzLl9sZXhlciA9IF9sZXhlcjtcbiAgICB9XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpKTtcbiAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHRydWUpLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbik7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2ltcGxlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICBpZiAoIVNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrKGFzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignSG9zdCBiaW5kaW5nIGV4cHJlc3Npb24gY2FuIG9ubHkgY29udGFpbiBmaWVsZCBhY2Nlc3MgYW5kIGNvbnN0YW50cycsIGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZ0FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgLy8gUXVvdGVzIGV4cHJlc3Npb25zIHVzZSAzcmQtcGFydHkgZXhwcmVzc2lvbiBsYW5ndWFnZS4gV2UgZG9uJ3Qgd2FudCB0byB1c2VcbiAgICAgICAgLy8gb3VyIGxleGVyIG9yIHBhcnNlciBmb3IgdGhhdCwgc28gd2UgY2hlY2sgZm9yIHRoYXQgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgdmFyIHF1b3RlID0gdGhpcy5fcGFyc2VRdW90ZShpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChxdW90ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCkpO1xuICAgICAgICByZXR1cm4gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgZmFsc2UpLnBhcnNlQ2hhaW4oKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlUXVvdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnB1dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHByZWZpeFNlcGFyYXRvckluZGV4ID0gaW5wdXQuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAocHJlZml4U2VwYXJhdG9ySW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHByZWZpeCA9IGlucHV0LnN1YnN0cmluZygwLCBwcmVmaXhTZXBhcmF0b3JJbmRleCkudHJpbSgpO1xuICAgICAgICBpZiAoIWxleGVyXzEuaXNJZGVudGlmaWVyKHByZWZpeCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gaW5wdXQuc3Vic3RyaW5nKHByZWZpeFNlcGFyYXRvckluZGV4ICsgMSk7XG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuUXVvdGUocHJlZml4LCB1bmludGVycHJldGVkRXhwcmVzc2lvbiwgbG9jYXRpb24pO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBmYWxzZSkucGFyc2VUZW1wbGF0ZUJpbmRpbmdzKCk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gdGhpcy5zcGxpdEludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHNwbGl0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXQuZXhwcmVzc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKHNwbGl0LmV4cHJlc3Npb25zW2ldKSk7XG4gICAgICAgICAgICB2YXIgYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgZmFsc2UpLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goYXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkFTVFdpdGhTb3VyY2UobmV3IGFzdF8xLkludGVycG9sYXRpb24oc3BsaXQuc3RyaW5ncywgZXhwcmVzc2lvbnMpLCBpbnB1dCwgbG9jYXRpb24pO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5zcGxpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KGlucHV0LCBJTlRFUlBPTEFUSU9OX1JFR0VYUCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmaXhlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbignQmxhbmsgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGludGVycG9sYXRlZCBzdHJpbmdzJywgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgaSkgKyBcIiBpblwiLCBsb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTcGxpdEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS53cmFwTGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKG5ldyBhc3RfMS5MaXRlcmFsUHJpbWl0aXZlKGlucHV0KSwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3N0cmlwQ29tbWVudHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9jb21tZW50U3RhcnQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChpKSA/IGlucHV0LnN1YnN0cmluZygwLCBpKS50cmltKCkgOiBpbnB1dDtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX2NvbW1lbnRTdGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgb3V0ZXJRdW90ZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQoaW5wdXQsIGkpO1xuICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdChpbnB1dCwgaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09IGxleGVyXzEuJFNMQVNIICYmIG5leHRDaGFyID09IGxleGVyXzEuJFNMQVNIICYmIGxhbmdfMS5pc0JsYW5rKG91dGVyUXVvdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgaWYgKG91dGVyUXVvdGUgPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc0JsYW5rKG91dGVyUXVvdGUpICYmIGxleGVyXzEuaXNRdW90ZShjaGFyKSkge1xuICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tOb0ludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KGlucHV0LCBJTlRFUlBPTEFUSU9OX1JFR0VYUCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFeGNlcHRpb24oJ0dvdCBpbnRlcnBvbGF0aW9uICh7e319KSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZCcsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIDEpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uID0gZnVuY3Rpb24gKHBhcnRzLCBwYXJ0SW5FcnJJZHgpIHtcbiAgICAgICAgdmFyIGVyckxvY2F0aW9uID0gJyc7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydEluRXJySWR4OyBqKyspIHtcbiAgICAgICAgICAgIGVyckxvY2F0aW9uICs9IGogJSAyID09PSAwID8gcGFydHNbal0gOiBcInt7XCIgKyBwYXJ0c1tqXSArIFwifX1cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyTG9jYXRpb24ubGVuZ3RoO1xuICAgIH07XG4gICAgUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIFBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBsZXhlcl8xLkxleGVyLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbnZhciBfUGFyc2VBU1QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgcGFyc2VBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLnBhcnNlQWN0aW9uID0gcGFyc2VBY3Rpb247XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vuc1tpXSA6IGxleGVyXzEuRU9GO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwibmV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wZWVrKDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gdGhpcy5uZXh0LmluZGV4IDogdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmRleCsrOyB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWtLZXl3b3JkTGV0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZExldCgpOyB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0RlcHJlY2F0ZWRLZXl3b3JkVmFyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZERlcHJlY2F0ZWRWYXIoKTsgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWtEZXByZWNhdGVkT3BlcmF0b3JIYXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5uZXh0LmlzT3BlcmF0b3IoJyMnKTsgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdENoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGNvZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBcIiArIGxhbmdfMS5TdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsT3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc09wZXJhdG9yKG9wKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKG9wZXJhdG9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgXCIgKyBvcGVyYXRvcik7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSAmJiAhbi5pc1N0cmluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciwga2V5d29yZCwgb3Igc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIGV4cHJzLnB1c2goZXhwcik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJCaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gY2hhaW5lZCBleHByZXNzaW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgfSAvLyByZWFkIGFsbCBzZW1pY29sb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgdGhpcy5uZXh0ICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuRW1wdHlFeHByKCk7XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByc1swXTtcbiAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5DaGFpbihleHBycyk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoXCJ8XCIpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5kaW5nUGlwZShyZXN1bHQsIG5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKFwifFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7IH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTG9naWNhbE9yKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz8nKSkge1xuICAgICAgICAgICAgdmFyIHllcyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb25kaXRpb25hbCBleHByZXNzaW9uIFwiICsgZXhwcmVzc2lvbiArIFwiIHJlcXVpcmVzIGFsbCAzIGV4cHJlc3Npb25zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuQ29uZGl0aW9uYWwocmVzdWx0LCB5ZXMsIG5vKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsT3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICd8fCdcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJ3x8JywgcmVzdWx0LCB0aGlzLnBhcnNlTG9naWNhbEFuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcmJidcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcmJicpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCcmJicsIHJlc3VsdCwgdGhpcy5wYXJzZUVxdWFsaXR5KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXF1YWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICc9PScsJyE9JywnPT09JywnIT09J1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz09JykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCc9PScsIHJlc3VsdCwgdGhpcy5wYXJzZVJlbGF0aW9uYWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz09PScpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnPT09JywgcmVzdWx0LCB0aGlzLnBhcnNlUmVsYXRpb25hbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignIT0nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJyE9JywgcmVzdWx0LCB0aGlzLnBhcnNlUmVsYXRpb25hbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignIT09JykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCchPT0nLCByZXN1bHQsIHRoaXMucGFyc2VSZWxhdGlvbmFsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVJlbGF0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICc8JywgJz4nLCAnPD0nLCAnPj0nXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJzwnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJzwnLCByZXN1bHQsIHRoaXMucGFyc2VBZGRpdGl2ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnPicsIHJlc3VsdCwgdGhpcy5wYXJzZUFkZGl0aXZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc8PScpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnPD0nLCByZXN1bHQsIHRoaXMucGFyc2VBZGRpdGl2ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPj0nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJz49JywgcmVzdWx0LCB0aGlzLnBhcnNlQWRkaXRpdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWRkaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcrJywgJy0nXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJysnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBhc3RfMS5CaW5hcnkoJysnLCByZXN1bHQsIHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignLScpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkJpbmFyeSgnLScsIHJlc3VsdCwgdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZU11bHRpcGxpY2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnKicsICclJywgJy8nXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcqJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCcqJywgcmVzdWx0LCB0aGlzLnBhcnNlUHJlZml4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCclJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCclJywgcmVzdWx0LCB0aGlzLnBhcnNlUHJlZml4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCcvJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuQmluYXJ5KCcvJywgcmVzdWx0LCB0aGlzLnBhcnNlUHJlZml4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignKycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignLScpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkJpbmFyeSgnLScsIG5ldyBhc3RfMS5MaXRlcmFsUHJpbWl0aXZlKDApLCB0aGlzLnBhcnNlUHJlZml4KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignIScpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLlByZWZpeE5vdCh0aGlzLnBhcnNlUHJlZml4KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDYWxsQ2hhaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxDaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRQRVJJT0QpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgYXN0XzEuS2V5ZWRXcml0ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLktleWVkUmVhZChyZXN1bHQsIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKGxleGVyXzEuJFJQQVJFTik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGFzdF8xLkZ1bmN0aW9uQ2FsbChyZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByaW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJExQQVJFTikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUlBBUkVOKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZE51bGwoKSB8fCB0aGlzLm5leHQuaXNLZXl3b3JkVW5kZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5MaXRlcmFsUHJpbWl0aXZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUcnVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5MaXRlcmFsUHJpbWl0aXZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRGYWxzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcihsZXhlcl8xLiRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucGFyc2VFeHByZXNzaW9uTGlzdChsZXhlcl8xLiRSQlJBQ0tFVCk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0tFVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkxpdGVyYWxBcnJheShlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGxleGVyXzEuJExCUkFDRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwoX2ltcGxpY2l0UmVjZWl2ZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNOdW1iZXIoKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHZhciBsaXRlcmFsVmFsdWUgPSB0aGlzLm5leHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5MaXRlcmFsUHJpbWl0aXZlKGxpdGVyYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiBcIiArIHRoaXMuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyB0aGlzLm5leHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVycm9yKCkgdGhyb3dzLCBzbyB3ZSBkb24ndCByZWFjaCBoZXJlLlxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJGZWxsIHRocm91Z2ggYWxsIGNhc2VzIGluIHBhcnNlUHJpbWFyeVwiKTtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uICh0ZXJtaW5hdG9yKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLm5leHQuaXNDaGFyYWN0ZXIodGVybWluYXRvcikpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09NTUEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxpdGVyYWxNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kTEJSQUNFKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJFJCUkFDRSkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRDT0xPTik7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTU1BKSk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuTGl0ZXJhbE1hcChrZXlzLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgaXNTYWZlKSB7XG4gICAgICAgIGlmIChpc1NhZmUgPT09IHZvaWQgMCkgeyBpc1NhZmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgaWQgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kTFBBUkVOKSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIobGV4ZXJfMS4kUlBBUkVOKTtcbiAgICAgICAgICAgIHJldHVybiBpc1NhZmUgPyBuZXcgYXN0XzEuU2FmZU1ldGhvZENhbGwocmVjZWl2ZXIsIGlkLCBhcmdzKSA6IG5ldyBhc3RfMS5NZXRob2RDYWxsKHJlY2VpdmVyLCBpZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNTYWZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihcIj1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlRoZSAnPy4nIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluIHRoZSBhc3NpZ25tZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc3RfMS5TYWZlUHJvcGVydHlSZWFkKHJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihcIj1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQmluZGluZ3MgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuUHJvcGVydHlXcml0ZShyZWNlaXZlciwgaWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXN0XzEuUHJvcGVydHlSZWFkKHJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIobGV4ZXJfMS4kUlBBUkVOKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uYWxzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBvc2l0aW9uYWxzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09NTUEpKTtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uYWxzO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUJsb2NrQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiQmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIGNoYWluZWQgZXhwcmVzc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgIXRoaXMubmV4dC5pc0NoYXJhY3RlcihsZXhlcl8xLiRSQlJBQ0UpKSB7XG4gICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICB9IC8vIHJlYWQgYWxsIHNlbWljb2xvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzdF8xLkVtcHR5RXhwcigpO1xuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XG4gICAgICAgIHJldHVybiBuZXcgYXN0XzEuQ2hhaW4oZXhwcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaWRlbnRpZmllciwgYSBrZXl3b3JkLCBhIHN0cmluZyB3aXRoIGFuIG9wdGlvbmFsIGAtYCBpbmJldHdlZW4uXG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIG9wZXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XG4gICAgICAgICAgICBvcGVyYXRvckZvdW5kID0gdGhpcy5vcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gW107XG4gICAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXlJc1ZhciA9IHRoaXMucGVla0tleXdvcmRMZXQoKTtcbiAgICAgICAgICAgIGlmICgha2V5SXNWYXIgJiYgdGhpcy5wZWVrRGVwcmVjYXRlZEtleXdvcmRWYXIoKSkge1xuICAgICAgICAgICAgICAgIGtleUlzVmFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKFwiXFxcInZhclxcXCIgaW5zaWRlIG9mIGV4cHJlc3Npb25zIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXFwibGV0XFxcIiBpbnN0ZWFkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2V5SXNWYXIgJiYgdGhpcy5wZWVrRGVwcmVjYXRlZE9wZXJhdG9ySGFzaCgpKSB7XG4gICAgICAgICAgICAgICAga2V5SXNWYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2goXCJcXFwiI1xcXCIgaW5zaWRlIG9mIGV4cHJlc3Npb25zIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXFwibGV0XFxcIiBpbnN0ZWFkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICBpZiAoIWtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCArIGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKGxleGVyXzEuJENPTE9OKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICdcXCRpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0ICE9PSBsZXhlcl8xLkVPRiAmJiAhdGhpcy5wZWVrS2V5d29yZExldCgpICYmICF0aGlzLnBlZWtEZXByZWNhdGVkS2V5d29yZFZhcigpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucGVla0RlcHJlY2F0ZWRPcGVyYXRvckhhc2goKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5wdXRJbmRleCk7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBhc3RfMS5BU1RXaXRoU291cmNlKGFzdCwgc291cmNlLCB0aGlzLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IGFzdF8xLlRlbXBsYXRlQmluZGluZyhrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIobGV4ZXJfMS4kQ09NTUEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQoYmluZGluZ3MsIHdhcm5pbmdzKTtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbmRleCkpXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IChpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyBcImF0IGNvbHVtbiBcIiArICh0aGlzLnRva2Vuc1tpbmRleF0uaW5kZXggKyAxKSArIFwiIGluXCIgOlxuICAgICAgICAgICAgXCJhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uXCI7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUV4Y2VwdGlvbihtZXNzYWdlLCB0aGlzLmlucHV0LCBsb2NhdGlvbiwgdGhpcy5sb2NhdGlvbik7XG4gICAgfTtcbiAgICByZXR1cm4gX1BhcnNlQVNUO1xufSgpKTtcbmV4cG9ydHMuX1BhcnNlQVNUID0gX1BhcnNlQVNUO1xudmFyIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpIHtcbiAgICAgICAgdGhpcy5zaW1wbGUgPSB0cnVlO1xuICAgIH1cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5jaGVjayA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKTtcbiAgICAgICAgYXN0LnZpc2l0KHMpO1xuICAgICAgICByZXR1cm4gcy5zaW1wbGU7XG4gICAgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcyk7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XG4gICAgICAgIHZhciByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGFzdHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBhc3RzW2ldLnZpc2l0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgZ2xvYmFsU2NvcGU7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBhbnkgd2l0aCBXb3JrZXJHbG9iYWxTY29wZSBmcm9tIGxpYi53ZWJ3b3JrZXIuZC50cyAjMzQ5MlxuICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICB9XG59XG5lbHNlIHtcbiAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGZuKSB7XG4gICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdzY2hlZHVsZU1pY3JvdGFzaycsIGZuKTtcbn1cbmV4cG9ydHMuc2NoZWR1bGVNaWNyb1Rhc2sgPSBzY2hlZHVsZU1pY3JvVGFzaztcbmV4cG9ydHMuSVNfREFSVCA9IGZhbHNlO1xuLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4vLyBleHBvcnRzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgc3ltYm9sLlxudmFyIF9nbG9iYWwgPSBnbG9iYWxTY29wZTtcbmV4cG9ydHMuZ2xvYmFsID0gX2dsb2JhbDtcbmV4cG9ydHMuVHlwZSA9IEZ1bmN0aW9uO1xuZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgIGlmICh0eXBlWyduYW1lJ10pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVbJ25hbWUnXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlO1xufVxuZXhwb3J0cy5nZXRUeXBlTmFtZUZvckRlYnVnZ2luZyA9IGdldFR5cGVOYW1lRm9yRGVidWdnaW5nO1xuZXhwb3J0cy5NYXRoID0gX2dsb2JhbC5NYXRoO1xuZXhwb3J0cy5EYXRlID0gX2dsb2JhbC5EYXRlO1xudmFyIF9kZXZNb2RlID0gdHJ1ZTtcbnZhciBfbW9kZUxvY2tlZCA9IGZhbHNlO1xuZnVuY3Rpb24gbG9ja01vZGUoKSB7XG4gICAgX21vZGVMb2NrZWQgPSB0cnVlO1xufVxuZXhwb3J0cy5sb2NrTW9kZSA9IGxvY2tNb2RlO1xuLyoqXG4gKiBEaXNhYmxlIEFuZ3VsYXIncyBkZXZlbG9wbWVudCBtb2RlLCB3aGljaCB0dXJucyBvZmYgYXNzZXJ0aW9ucyBhbmQgb3RoZXJcbiAqIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yay5cbiAqXG4gKiBPbmUgaW1wb3J0YW50IGFzc2VydGlvbiB0aGlzIGRpc2FibGVzIHZlcmlmaWVzIHRoYXQgYSBjaGFuZ2UgZGV0ZWN0aW9uIHBhc3NcbiAqIGRvZXMgbm90IHJlc3VsdCBpbiBhZGRpdGlvbmFsIGNoYW5nZXMgdG8gYW55IGJpbmRpbmdzIChhbHNvIGtub3duIGFzXG4gKiB1bmlkaXJlY3Rpb25hbCBkYXRhIGZsb3cpLlxuICovXG5mdW5jdGlvbiBlbmFibGVQcm9kTW9kZSgpIHtcbiAgICBpZiAoX21vZGVMb2NrZWQpIHtcbiAgICAgICAgLy8gQ2Fubm90IHVzZSBCYXNlRXhjZXB0aW9uIGFzIHRoYXQgZW5kcyB1cCBpbXBvcnRpbmcgZnJvbSBmYWNhZGUvbGFuZy5cbiAgICAgICAgdGhyb3cgJ0Nhbm5vdCBlbmFibGUgcHJvZCBtb2RlIGFmdGVyIHBsYXRmb3JtIHNldHVwLic7XG4gICAgfVxuICAgIF9kZXZNb2RlID0gZmFsc2U7XG59XG5leHBvcnRzLmVuYWJsZVByb2RNb2RlID0gZW5hYmxlUHJvZE1vZGU7XG5mdW5jdGlvbiBhc3NlcnRpb25zRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gX2Rldk1vZGU7XG59XG5leHBvcnRzLmFzc2VydGlvbnNFbmFibGVkID0gYXNzZXJ0aW9uc0VuYWJsZWQ7XG4vLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbi8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbl9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgIC8vIFRPRE86IHRvIGJlIGZpeGVkIHByb3Blcmx5IHZpYSAjMjgzMCwgbm9vcCBmb3Igbm93XG59O1xuZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGw7XG59XG5leHBvcnRzLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbmZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNCbGFuayA9IGlzQmxhbms7XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiYm9vbGVhblwiO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIjtcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmZ1bmN0aW9uIGlzVHlwZShvYmopIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvYmopO1xufVxuZXhwb3J0cy5pc1R5cGUgPSBpc1R5cGU7XG5mdW5jdGlvbiBpc1N0cmluZ01hcChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1N0cmluZ01hcCA9IGlzU3RyaW5nTWFwO1xudmFyIFNUUklOR19NQVBfUFJPVE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuZnVuY3Rpb24gaXNTdHJpY3RTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nTWFwKG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IFNUUklOR19NQVBfUFJPVE87XG59XG5leHBvcnRzLmlzU3RyaWN0U3RyaW5nTWFwID0gaXNTdHJpY3RTdHJpbmdNYXA7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIF9nbG9iYWwuUHJvbWlzZTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgZXhwb3J0cy5EYXRlICYmICFpc05hTihvYmoudmFsdWVPZigpKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZXhwb3J0cy5ub29wID0gbm9vcDtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xuICAgIH1cbiAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgIH1cbiAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoXCJcXG5cIik7XG4gICAgcmV0dXJuIChuZXdMaW5lSW5kZXggPT09IC0xKSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuLy8gc2VyaWFsaXplIC8gZGVzZXJpYWxpemUgZW51bSBleGlzdCBvbmx5IGZvciBjb25zaXN0ZW5jeSB3aXRoIGRhcnQgQVBJXG4vLyBlbnVtcyBpbiB0eXBlc2NyaXB0IGRvbid0IG5lZWQgdG8gYmUgc2VyaWFsaXplZFxuZnVuY3Rpb24gc2VyaWFsaXplRW51bSh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0cy5zZXJpYWxpemVFbnVtID0gc2VyaWFsaXplRW51bTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRW51bSh2YWwsIHZhbHVlcykge1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplRW51bSA9IGRlc2VyaWFsaXplRW51bTtcbmZ1bmN0aW9uIHJlc29sdmVFbnVtVG9rZW4oZW51bVZhbHVlLCB2YWwpIHtcbiAgICByZXR1cm4gZW51bVZhbHVlW3ZhbF07XG59XG5leHBvcnRzLnJlc29sdmVFbnVtVG9rZW4gPSByZXNvbHZlRW51bVRva2VuO1xudmFyIFN0cmluZ1dyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ1dyYXBwZXIoKSB7XG4gICAgfVxuICAgIFN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7IH07XG4gICAgU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0ID0gZnVuY3Rpb24gKHMsIGluZGV4KSB7IHJldHVybiBzLmNoYXJDb2RlQXQoaW5kZXgpOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3BsaXQgPSBmdW5jdGlvbiAocywgcmVnRXhwKSB7IHJldHVybiBzLnNwbGl0KHJlZ0V4cCk7IH07XG4gICAgU3RyaW5nV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAocywgczIpIHsgcmV0dXJuIHMgPT09IHMyOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBMZWZ0ID0gZnVuY3Rpb24gKHMsIGNoYXJWYWwpIHtcbiAgICAgICAgaWYgKHMgJiYgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT0gY2hhclZhbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcocG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBSaWdodCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHMuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQgPSBmdW5jdGlvbiAocywgZnJvbSwgY2IpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9mZnNldCAmIHN0cmluZyBmcm9tIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKC0yLCAyKTtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayByZWNlaXZlcyBtYXRjaCwgcDEsIC4uLiwgcG5cbiAgICAgICAgICAgIHJldHVybiBjYihtYXRjaGVzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKHMsIHN1YnN0cikgeyByZXR1cm4gcy5pbmRleE9mKHN1YnN0cikgIT0gLTE7IH07XG4gICAgU3RyaW5nV3JhcHBlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nV3JhcHBlciA9IFN0cmluZ1dyYXBwZXI7XG52YXIgU3RyaW5nSm9pbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdKb2luZXIocGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHsgcGFydHMgPSBbXTsgfVxuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgfVxuICAgIFN0cmluZ0pvaW5lci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHBhcnQpIHsgdGhpcy5wYXJ0cy5wdXNoKHBhcnQpOyB9O1xuICAgIFN0cmluZ0pvaW5lci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnRzLmpvaW4oXCJcIik7IH07XG4gICAgcmV0dXJuIFN0cmluZ0pvaW5lcjtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ0pvaW5lciA9IFN0cmluZ0pvaW5lcjtcbnZhciBOdW1iZXJQYXJzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVtYmVyUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJQYXJzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIE51bWJlclBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9O1xuICAgIHJldHVybiBOdW1iZXJQYXJzZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5OdW1iZXJQYXJzZUVycm9yID0gTnVtYmVyUGFyc2VFcnJvcjtcbnZhciBOdW1iZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgIH1cbiAgICBOdW1iZXJXcmFwcGVyLnRvRml4ZWQgPSBmdW5jdGlvbiAobiwgZnJhY3Rpb25EaWdpdHMpIHsgcmV0dXJuIG4udG9GaXhlZChmcmFjdGlvbkRpZ2l0cyk7IH07XG4gICAgTnVtYmVyV3JhcHBlci5lcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09PSBiOyB9O1xuICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50ID0gZnVuY3Rpb24gKHRleHQsIHJhZGl4KSB7XG4gICAgICAgIGlmIChyYWRpeCA9PSAxMCkge1xuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTldKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhZGl4ID09IDE2KSB7XG4gICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOUFCQ0RFRmFiY2RlZl0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQgKyBcIiBpbiBiYXNlIFwiICtcbiAgICAgICAgICAgIHJhZGl4KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IE5hTiBpcyBhIHZhbGlkIGxpdGVyYWwgYnV0IGlzIHJldHVybmVkIGJ5IHBhcnNlRmxvYXQgdG8gaW5kaWNhdGUgYW4gZXJyb3IuXG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUZsb2F0ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGV4dCk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIFwiTmFOXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOYU47IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE51bWJlcldyYXBwZXIuaXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzTmFOKHZhbHVlKTsgfTtcbiAgICBOdW1iZXJXcmFwcGVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7IH07XG4gICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5OdW1iZXJXcmFwcGVyID0gTnVtYmVyV3JhcHBlcjtcbmV4cG9ydHMuUmVnRXhwID0gX2dsb2JhbC5SZWdFeHA7XG52YXIgUmVnRXhwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnRXhwV3JhcHBlcigpIHtcbiAgICB9XG4gICAgUmVnRXhwV3JhcHBlci5jcmVhdGUgPSBmdW5jdGlvbiAocmVnRXhwU3RyLCBmbGFncykge1xuICAgICAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9ICcnOyB9XG4gICAgICAgIGZsYWdzID0gZmxhZ3MucmVwbGFjZSgvZy9nLCAnJyk7XG4gICAgICAgIHJldHVybiBuZXcgX2dsb2JhbC5SZWdFeHAocmVnRXhwU3RyLCBmbGFncyArICdnJyk7XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2ggPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xuICAgICAgICAvLyBSZXNldCBtdWx0aW1hdGNoIHJlZ2V4IHN0YXRlXG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci50ZXN0ID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiByZWdFeHAudGVzdChpbnB1dCk7XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLm1hdGNoZXIgPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xuICAgICAgICAvLyBSZXNldCByZWdleCBzdGF0ZSBmb3IgdGhlIGNhc2VcbiAgICAgICAgLy8gc29tZW9uZSBkaWQgbm90IGxvb3Agb3ZlciBhbGwgbWF0Y2hlc1xuICAgICAgICAvLyBsYXN0IHRpbWUuXG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4geyByZTogcmVnRXhwLCBpbnB1dDogaW5wdXQgfTtcbiAgICB9O1xuICAgIFJlZ0V4cFdyYXBwZXIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0LCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBjID0gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgICAgICB2YXIgcmVzID0gJyc7XG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcHJldiA9IDA7XG4gICAgICAgIHdoaWxlIChjKSB7XG4gICAgICAgICAgICByZXMgKz0gaW5wdXQuc3Vic3RyaW5nKHByZXYsIGMuaW5kZXgpO1xuICAgICAgICAgICAgcmVzICs9IHJlcGxhY2UoYyk7XG4gICAgICAgICAgICBwcmV2ID0gYy5pbmRleCArIGNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IHByZXY7XG4gICAgICAgICAgICBjID0gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBpbnB1dC5zdWJzdHJpbmcocHJldik7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnRXhwV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlJlZ0V4cFdyYXBwZXIgPSBSZWdFeHBXcmFwcGVyO1xudmFyIFJlZ0V4cE1hdGNoZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdFeHBNYXRjaGVyV3JhcHBlcigpIHtcbiAgICB9XG4gICAgUmVnRXhwTWF0Y2hlcldyYXBwZXIubmV4dCA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLnJlLmV4ZWMobWF0Y2hlci5pbnB1dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnRXhwTWF0Y2hlcldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5SZWdFeHBNYXRjaGVyV3JhcHBlciA9IFJlZ0V4cE1hdGNoZXJXcmFwcGVyO1xudmFyIEZ1bmN0aW9uV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25XcmFwcGVyKCkge1xuICAgIH1cbiAgICBGdW5jdGlvbldyYXBwZXIuYXBwbHkgPSBmdW5jdGlvbiAoZm4sIHBvc0FyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KG51bGwsIHBvc0FyZ3MpOyB9O1xuICAgIHJldHVybiBGdW5jdGlvbldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5GdW5jdGlvbldyYXBwZXIgPSBGdW5jdGlvbldyYXBwZXI7XG4vLyBKUyBoYXMgTmFOICE9PSBOYU5cbmZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbn1cbmV4cG9ydHMubG9vc2VJZGVudGljYWwgPSBsb29zZUlkZW50aWNhbDtcbi8vIEpTIGNvbnNpZGVycyBOYU4gaXMgdGhlIHNhbWUgYXMgTmFOIGZvciBtYXAgS2V5ICh3aGlsZSBOYU4gIT09IE5hTiBvdGhlcndpc2UpXG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwXG5mdW5jdGlvbiBnZXRNYXBLZXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLmdldE1hcEtleSA9IGdldE1hcEtleTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsYW5rKG9iaikge1xuICAgIHJldHVybiBpc0JsYW5rKG9iaikgPyBudWxsIDogb2JqO1xufVxuZXhwb3J0cy5ub3JtYWxpemVCbGFuayA9IG5vcm1hbGl6ZUJsYW5rO1xuZnVuY3Rpb24gbm9ybWFsaXplQm9vbChvYmopIHtcbiAgICByZXR1cm4gaXNCbGFuayhvYmopID8gZmFsc2UgOiBvYmo7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUJvb2wgPSBub3JtYWxpemVCb29sO1xuZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIpO1xufVxuZXhwb3J0cy5pc0pzT2JqZWN0ID0gaXNKc09iamVjdDtcbmZ1bmN0aW9uIHByaW50KG9iaikge1xuICAgIGNvbnNvbGUubG9nKG9iaik7XG59XG5leHBvcnRzLnByaW50ID0gcHJpbnQ7XG5mdW5jdGlvbiB3YXJuKG9iaikge1xuICAgIGNvbnNvbGUud2FybihvYmopO1xufVxuZXhwb3J0cy53YXJuID0gd2Fybjtcbi8vIENhbid0IGJlIGFsbCB1cHBlcmNhc2UgYXMgb3VyIHRyYW5zcGlsZXIgd291bGQgdGhpbmsgaXQgaXMgYSBzcGVjaWFsIGRpcmVjdGl2ZS4uLlxudmFyIEpzb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb24oKSB7XG4gICAgfVxuICAgIEpzb24ucGFyc2UgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gX2dsb2JhbC5KU09OLnBhcnNlKHMpOyB9O1xuICAgIEpzb24uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gRGFydCBkb2Vzbid0IHRha2UgMyBhcmd1bWVudHNcbiAgICAgICAgcmV0dXJuIF9nbG9iYWwuSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvbjtcbn0oKSk7XG5leHBvcnRzLkpzb24gPSBKc29uO1xudmFyIERhdGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlV3JhcHBlcigpIHtcbiAgICB9XG4gICAgRGF0ZVdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcykge1xuICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IDE7IH1cbiAgICAgICAgaWYgKGRheSA9PT0gdm9pZCAwKSB7IGRheSA9IDE7IH1cbiAgICAgICAgaWYgKGhvdXIgPT09IHZvaWQgMCkgeyBob3VyID0gMDsgfVxuICAgICAgICBpZiAobWludXRlcyA9PT0gdm9pZCAwKSB7IG1pbnV0ZXMgPSAwOyB9XG4gICAgICAgIGlmIChzZWNvbmRzID09PSB2b2lkIDApIHsgc2Vjb25kcyA9IDA7IH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdm9pZCAwKSB7IG1pbGxpc2Vjb25kcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XG4gICAgfTtcbiAgICBEYXRlV3JhcHBlci5mcm9tSVNPU3RyaW5nID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gbmV3IGV4cG9ydHMuRGF0ZShzdHIpOyB9O1xuICAgIERhdGVXcmFwcGVyLmZyb21NaWxsaXMgPSBmdW5jdGlvbiAobXMpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUobXMpOyB9O1xuICAgIERhdGVXcmFwcGVyLnRvTWlsbGlzID0gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpOyB9O1xuICAgIERhdGVXcmFwcGVyLm5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoKTsgfTtcbiAgICBEYXRlV3JhcHBlci50b0pzb24gPSBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS50b0pTT04oKTsgfTtcbiAgICByZXR1cm4gRGF0ZVdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5EYXRlV3JhcHBlciA9IERhdGVXcmFwcGVyO1xuZnVuY3Rpb24gc2V0VmFsdWVPblBhdGgoZ2xvYmFsLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgb2JqID0gZ2xvYmFsO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1ByZXNlbnQob2JqW25hbWVdKSkge1xuICAgICAgICAgICAgb2JqID0gb2JqW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb2JqW25hbWVdID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICB9XG4gICAgb2JqW3BhcnRzLnNoaWZ0KCldID0gdmFsdWU7XG59XG5leHBvcnRzLnNldFZhbHVlT25QYXRoID0gc2V0VmFsdWVPblBhdGg7XG52YXIgX3N5bWJvbEl0ZXJhdG9yID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICAgIGlmIChpc0JsYW5rKF9zeW1ib2xJdGVyYXRvcikpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChnbG9iYWxTY29wZS5TeW1ib2wpICYmIGlzUHJlc2VudChTeW1ib2wuaXRlcmF0b3IpKSB7XG4gICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJlxuICAgICAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW2tleV0gPT09IE1hcC5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfc3ltYm9sSXRlcmF0b3I7XG59XG5leHBvcnRzLmdldFN5bWJvbEl0ZXJhdG9yID0gZ2V0U3ltYm9sSXRlcmF0b3I7XG5mdW5jdGlvbiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwsIGV4cHIsIGRlY2xhcmF0aW9ucywgdmFycykge1xuICAgIHZhciBmbkJvZHkgPSBkZWNsYXJhdGlvbnMgKyBcIlxcbnJldHVybiBcIiArIGV4cHIgKyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBzb3VyY2VVcmw7XG4gICAgdmFyIGZuQXJnTmFtZXMgPSBbXTtcbiAgICB2YXIgZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgZm5BcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICBmbkFyZ1ZhbHVlcy5wdXNoKHZhcnNbYXJnTmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBbdm9pZCAwXS5jb25jYXQoZm5BcmdOYW1lcy5jb25jYXQoZm5Cb2R5KSkpKSgpLmFwcGx5KHZvaWQgMCwgZm5BcmdWYWx1ZXMpO1xufVxuZXhwb3J0cy5ldmFsRXhwcmVzc2lvbiA9IGV2YWxFeHByZXNzaW9uO1xuZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgcmV0dXJuICFpc0pzT2JqZWN0KG9iaik7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5mdW5jdGlvbiBoYXNDb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSkge1xuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gdHlwZTtcbn1cbmV4cG9ydHMuaGFzQ29uc3RydWN0b3IgPSBoYXNDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGJpdFdpc2VPcih2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSB8IGI7IH0pO1xufVxuZXhwb3J0cy5iaXRXaXNlT3IgPSBiaXRXaXNlT3I7XG5mdW5jdGlvbiBiaXRXaXNlQW5kKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XG59XG5leHBvcnRzLmJpdFdpc2VBbmQgPSBiaXRXaXNlQW5kO1xuZnVuY3Rpb24gZXNjYXBlKHMpIHtcbiAgICByZXR1cm4gX2dsb2JhbC5lbmNvZGVVUkkocyk7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgSHRtbFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxUZXh0QXN0KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgSHRtbFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBIdG1sVGV4dEFzdDtcbn0oKSk7XG5leHBvcnRzLkh0bWxUZXh0QXN0ID0gSHRtbFRleHRBc3Q7XG52YXIgSHRtbEV4cGFuc2lvbkFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbEV4cGFuc2lvbkFzdChzd2l0Y2hWYWx1ZSwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnN3aXRjaFZhbHVlID0gc3dpdGNoVmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4gPSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW47XG4gICAgfVxuICAgIEh0bWxFeHBhbnNpb25Bc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb24odGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbEV4cGFuc2lvbkFzdDtcbn0oKSk7XG5leHBvcnRzLkh0bWxFeHBhbnNpb25Bc3QgPSBIdG1sRXhwYW5zaW9uQXN0O1xudmFyIEh0bWxFeHBhbnNpb25DYXNlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sRXhwYW5zaW9uQ2FzZUFzdCh2YWx1ZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdmFsdWVTb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNvdXJjZVNwYW4gPSB2YWx1ZVNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZXhwU291cmNlU3BhbiA9IGV4cFNvdXJjZVNwYW47XG4gICAgfVxuICAgIEh0bWxFeHBhbnNpb25DYXNlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uQ2FzZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sRXhwYW5zaW9uQ2FzZUFzdDtcbn0oKSk7XG5leHBvcnRzLkh0bWxFeHBhbnNpb25DYXNlQXN0ID0gSHRtbEV4cGFuc2lvbkNhc2VBc3Q7XG52YXIgSHRtbEF0dHJBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgSHRtbEF0dHJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBIdG1sQXR0ckFzdDtcbn0oKSk7XG5leHBvcnRzLkh0bWxBdHRyQXN0ID0gSHRtbEF0dHJBc3Q7XG52YXIgSHRtbEVsZW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxFbGVtZW50QXN0KG5hbWUsIGF0dHJzLCBjaGlsZHJlbiwgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICB9XG4gICAgSHRtbEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBIdG1sRWxlbWVudEFzdDtcbn0oKSk7XG5leHBvcnRzLkh0bWxFbGVtZW50QXN0ID0gSHRtbEVsZW1lbnRBc3Q7XG52YXIgSHRtbENvbW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxDb21tZW50QXN0KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgSHRtbENvbW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tZW50KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBIdG1sQ29tbWVudEFzdDtcbn0oKSk7XG5leHBvcnRzLkh0bWxDb21tZW50QXN0ID0gSHRtbENvbW1lbnRBc3Q7XG5mdW5jdGlvbiBodG1sVmlzaXRBbGwodmlzaXRvciwgYXN0cywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIGFzdFJlc3VsdCA9IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXN0UmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmh0bWxWaXNpdEFsbCA9IGh0bWxWaXNpdEFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWxfYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgcGFyc2VfdXRpbF8xID0gcmVxdWlyZSgnLi9wYXJzZV91dGlsJyk7XG52YXIgaHRtbF90YWdzXzEgPSByZXF1aXJlKCcuL2h0bWxfdGFncycpO1xuKGZ1bmN0aW9uIChIdG1sVG9rZW5UeXBlKSB7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiVEFHX09QRU5fU1RBUlRcIl0gPSAwXSA9IFwiVEFHX09QRU5fU1RBUlRcIjtcbiAgICBIdG1sVG9rZW5UeXBlW0h0bWxUb2tlblR5cGVbXCJUQUdfT1BFTl9FTkRcIl0gPSAxXSA9IFwiVEFHX09QRU5fRU5EXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiVEFHX09QRU5fRU5EX1ZPSURcIl0gPSAyXSA9IFwiVEFHX09QRU5fRU5EX1ZPSURcIjtcbiAgICBIdG1sVG9rZW5UeXBlW0h0bWxUb2tlblR5cGVbXCJUQUdfQ0xPU0VcIl0gPSAzXSA9IFwiVEFHX0NMT1NFXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiVEVYVFwiXSA9IDRdID0gXCJURVhUXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiRVNDQVBBQkxFX1JBV19URVhUXCJdID0gNV0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuICAgIEh0bWxUb2tlblR5cGVbSHRtbFRva2VuVHlwZVtcIlJBV19URVhUXCJdID0gNl0gPSBcIlJBV19URVhUXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiQ09NTUVOVF9TVEFSVFwiXSA9IDddID0gXCJDT01NRU5UX1NUQVJUXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiQ09NTUVOVF9FTkRcIl0gPSA4XSA9IFwiQ09NTUVOVF9FTkRcIjtcbiAgICBIdG1sVG9rZW5UeXBlW0h0bWxUb2tlblR5cGVbXCJDREFUQV9TVEFSVFwiXSA9IDldID0gXCJDREFUQV9TVEFSVFwiO1xuICAgIEh0bWxUb2tlblR5cGVbSHRtbFRva2VuVHlwZVtcIkNEQVRBX0VORFwiXSA9IDEwXSA9IFwiQ0RBVEFfRU5EXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiQVRUUl9OQU1FXCJdID0gMTFdID0gXCJBVFRSX05BTUVcIjtcbiAgICBIdG1sVG9rZW5UeXBlW0h0bWxUb2tlblR5cGVbXCJBVFRSX1ZBTFVFXCJdID0gMTJdID0gXCJBVFRSX1ZBTFVFXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiRE9DX1RZUEVcIl0gPSAxM10gPSBcIkRPQ19UWVBFXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0ZPUk1fU1RBUlRcIl0gPSAxNF0gPSBcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfVkFMVUVcIl0gPSAxNV0gPSBcIkVYUEFOU0lPTl9DQVNFX1ZBTFVFXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCJdID0gMTZdID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRcIjtcbiAgICBIdG1sVG9rZW5UeXBlW0h0bWxUb2tlblR5cGVbXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCJdID0gMTddID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCI7XG4gICAgSHRtbFRva2VuVHlwZVtIdG1sVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0ZPUk1fRU5EXCJdID0gMThdID0gXCJFWFBBTlNJT05fRk9STV9FTkRcIjtcbiAgICBIdG1sVG9rZW5UeXBlW0h0bWxUb2tlblR5cGVbXCJFT0ZcIl0gPSAxOV0gPSBcIkVPRlwiO1xufSkoZXhwb3J0cy5IdG1sVG9rZW5UeXBlIHx8IChleHBvcnRzLkh0bWxUb2tlblR5cGUgPSB7fSkpO1xudmFyIEh0bWxUb2tlblR5cGUgPSBleHBvcnRzLkh0bWxUb2tlblR5cGU7XG52YXIgSHRtbFRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sVG9rZW4odHlwZSwgcGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICByZXR1cm4gSHRtbFRva2VuO1xufSgpKTtcbmV4cG9ydHMuSHRtbFRva2VuID0gSHRtbFRva2VuO1xudmFyIEh0bWxUb2tlbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHRtbFRva2VuRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHRtbFRva2VuRXJyb3IoZXJyb3JNc2csIHRva2VuVHlwZSwgc3Bhbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZyk7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgIH1cbiAgICByZXR1cm4gSHRtbFRva2VuRXJyb3I7XG59KHBhcnNlX3V0aWxfMS5QYXJzZUVycm9yKSk7XG5leHBvcnRzLkh0bWxUb2tlbkVycm9yID0gSHRtbFRva2VuRXJyb3I7XG52YXIgSHRtbFRva2VuaXplUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sVG9rZW5pemVSZXN1bHQodG9rZW5zLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gSHRtbFRva2VuaXplUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuSHRtbFRva2VuaXplUmVzdWx0ID0gSHRtbFRva2VuaXplUmVzdWx0O1xuZnVuY3Rpb24gdG9rZW5pemVIdG1sKHNvdXJjZUNvbnRlbnQsIHNvdXJjZVVybCwgdG9rZW5pemVFeHBhbnNpb25Gb3Jtcykge1xuICAgIGlmICh0b2tlbml6ZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIG5ldyBfSHRtbFRva2VuaXplcihuZXcgcGFyc2VfdXRpbF8xLlBhcnNlU291cmNlRmlsZShzb3VyY2VDb250ZW50LCBzb3VyY2VVcmwpLCB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zKVxuICAgICAgICAudG9rZW5pemUoKTtcbn1cbmV4cG9ydHMudG9rZW5pemVIdG1sID0gdG9rZW5pemVIdG1sO1xudmFyICRFT0YgPSAwO1xudmFyICRUQUIgPSA5O1xudmFyICRMRiA9IDEwO1xudmFyICRGRiA9IDEyO1xudmFyICRDUiA9IDEzO1xudmFyICRTUEFDRSA9IDMyO1xudmFyICRCQU5HID0gMzM7XG52YXIgJERRID0gMzQ7XG52YXIgJEhBU0ggPSAzNTtcbnZhciAkJCA9IDM2O1xudmFyICRBTVBFUlNBTkQgPSAzODtcbnZhciAkU1EgPSAzOTtcbnZhciAkTUlOVVMgPSA0NTtcbnZhciAkU0xBU0ggPSA0NztcbnZhciAkMCA9IDQ4O1xudmFyICRTRU1JQ09MT04gPSA1OTtcbnZhciAkOSA9IDU3O1xudmFyICRDT0xPTiA9IDU4O1xudmFyICRMVCA9IDYwO1xudmFyICRFUSA9IDYxO1xudmFyICRHVCA9IDYyO1xudmFyICRRVUVTVElPTiA9IDYzO1xudmFyICRMQlJBQ0tFVCA9IDkxO1xudmFyICRSQlJBQ0tFVCA9IDkzO1xudmFyICRMQlJBQ0UgPSAxMjM7XG52YXIgJFJCUkFDRSA9IDEyNTtcbnZhciAkQ09NTUEgPSA0NDtcbnZhciAkQSA9IDY1O1xudmFyICRGID0gNzA7XG52YXIgJFggPSA4ODtcbnZhciAkWiA9IDkwO1xudmFyICRhID0gOTc7XG52YXIgJGYgPSAxMDI7XG52YXIgJHogPSAxMjI7XG52YXIgJHggPSAxMjA7XG52YXIgJE5CU1AgPSAxNjA7XG52YXIgQ1JfT1JfQ1JMRl9SRUdFWFAgPSAvXFxyXFxuPy9nO1xuZnVuY3Rpb24gdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKGNoYXJDb2RlKSB7XG4gICAgdmFyIGNoYXIgPSBjaGFyQ29kZSA9PT0gJEVPRiA/ICdFT0YnIDogbGFuZ18xLlN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICByZXR1cm4gXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBcXFwiXCIgKyBjaGFyICsgXCJcXFwiXCI7XG59XG5mdW5jdGlvbiB1bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5U3JjKSB7XG4gICAgcmV0dXJuIFwiVW5rbm93biBlbnRpdHkgXFxcIlwiICsgZW50aXR5U3JjICsgXCJcXFwiIC0gdXNlIHRoZSBcXFwiJiM8ZGVjaW1hbD47XFxcIiBvciAgXFxcIiYjeDxoZXg+O1xcXCIgc3ludGF4XCI7XG59XG52YXIgQ29udHJvbEZsb3dFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udHJvbEZsb3dFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBDb250cm9sRmxvd0Vycm9yO1xufSgpKTtcbi8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjd3JpdGluZ1xudmFyIF9IdG1sVG9rZW5pemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfSHRtbFRva2VuaXplcihmaWxlLCB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMudG9rZW5pemVFeHBhbnNpb25Gb3JtcyA9IHRva2VuaXplRXhwYW5zaW9uRm9ybXM7XG4gICAgICAgIC8vIE5vdGU6IHRoaXMgaXMgYWx3YXlzIGxvd2VyY2FzZSFcbiAgICAgICAgdGhpcy5wZWVrID0gLTE7XG4gICAgICAgIHRoaXMubmV4dFBlZWsgPSAtMTtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmUgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IC0xO1xuICAgICAgICB0aGlzLmV4cGFuc2lvbkNhc2VTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmlucHV0ID0gZmlsZS5jb250ZW50O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZpbGUuY29udGVudC5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGtlZXAgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UsIHdlIGNhbiBub3RcbiAgICAgICAgLy8gcHJlLXByb2Nlc3MgaXQuXG4gICAgICAgIC8vIEluc3RlYWQgQ1JzIGFyZSBwcm9jZXNzZWQgcmlnaHQgYmVmb3JlIGluc3RhbnRpYXRpbmcgdGhlIHRva2Vucy5cbiAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoY29udGVudCwgQ1JfT1JfQ1JMRl9SRUdFWFAsICdcXG4nKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPT0gJEVPRikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRNSU5VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTcGVjaWFsRm9ybVN0YXJ0KHRoaXMucGVlaywgdGhpcy5uZXh0UGVlaykgJiYgdGhpcy50b2tlbml6ZUV4cGFuc2lvbkZvcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09PSAkRVEgJiYgdGhpcy50b2tlbml6ZUV4cGFuc2lvbkZvcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09PSAkUkJSQUNFICYmIHRoaXMuaXNJbkV4cGFuc2lvbkNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplRXhwYW5zaW9uRm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09PSAkUkJSQUNFICYmIHRoaXMuaXNJbkV4cGFuc2lvbkZvcm0oKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplRXhwYW5zaW9uRm9ybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oSHRtbFRva2VuVHlwZS5FT0YpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0aGlzLnRva2VucyksIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgcGFyc2VfdXRpbF8xLlBhcnNlTG9jYXRpb24odGhpcy5maWxlLCB0aGlzLmluZGV4LCB0aGlzLmxpbmUsIHRoaXMuY29sdW1uKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U3BhbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhzdGFydCkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoZW5kKSkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHBhcnNlX3V0aWxfMS5QYXJzZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2JlZ2luVG9rZW4gPSBmdW5jdGlvbiAodHlwZSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSBudWxsOyB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhzdGFydCkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuVHlwZSA9IHR5cGU7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2VuZFRva2VuID0gZnVuY3Rpb24gKHBhcnRzLCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGVuZCkpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuID0gbmV3IEh0bWxUb2tlbih0aGlzLmN1cnJlbnRUb2tlblR5cGUsIHBhcnRzLCBuZXcgcGFyc2VfdXRpbF8xLlBhcnNlU291cmNlU3Bhbih0aGlzLmN1cnJlbnRUb2tlblN0YXJ0LCBlbmQpKTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlblR5cGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1zZywgc3Bhbikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgSHRtbFRva2VuRXJyb3IobXNnLCB0aGlzLmN1cnJlbnRUb2tlblR5cGUsIHNwYW4pO1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sRmxvd0Vycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKHVuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZygkRU9GKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZWVrID09PSAkTEYpIHtcbiAgICAgICAgICAgIHRoaXMubGluZSsrO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayAhPT0gJExGICYmIHRoaXMucGVlayAhPT0gJENSKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgdGhpcy5wZWVrID0gdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/ICRFT0YgOiBsYW5nXzEuU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0KHRoaXMuaW5wdXQsIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLm5leHRQZWVrID1cbiAgICAgICAgICAgIHRoaXMuaW5kZXggKyAxID49IHRoaXMubGVuZ3RoID8gJEVPRiA6IGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQodGhpcy5pbnB1dCwgdGhpcy5pbmRleCArIDEpO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVlayA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmIChjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUodGhpcy5wZWVrLCBjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZUNoYXJDb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IodW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMucGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24sIGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShsYW5nXzEuU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0KGNoYXJzLCBpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRTdHJDYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUobGFuZ18xLlN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdChjaGFycywgaSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlU3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdFN0cihjaGFycykpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKHVuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLnBlZWspLCB0aGlzLl9nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgd2hpbGUgKCFwcmVkaWNhdGUodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlLCBsZW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihwcmVkaWNhdGUpO1xuICAgICAgICBpZiAodGhpcy5pbmRleCAtIHN0YXJ0Lm9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IodW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMucGVlayksIHRoaXMuX2dldFNwYW4oc3RhcnQsIHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFVudGlsQ2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9yZWFkQ2hhciA9IGZ1bmN0aW9uIChkZWNvZGVFbnRpdGllcykge1xuICAgICAgICBpZiAoZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5wZWVrID09PSAkQU1QRVJTQU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlRW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRbaW5kZXhdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2RlY29kZUVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRIQVNIKSkge1xuICAgICAgICAgICAgdmFyIGlzSGV4ID0gdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCR4KSB8fCB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFgpO1xuICAgICAgICAgICAgdmFyIG51bWJlclN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKS5vZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzRGlnaXRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlayAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IodW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMucGVlayksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgc3RyTnVtID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcobnVtYmVyU3RhcnQsIHRoaXMuaW5kZXggLSAxKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMSwgdGhpcy5pbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKHVua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHkpLCB0aGlzLl9nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05hbWVkRW50aXR5RW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuaW5kZXggLSAxKTtcbiAgICAgICAgICAgIHZhciBjaGFyID0gaHRtbF90YWdzXzEuTkFNRURfRU5USVRJRVNbbmFtZV8xXTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhjaGFyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKHVua25vd25FbnRpdHlFcnJvck1zZyhuYW1lXzEpLCB0aGlzLl9nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUmF3VGV4dCA9IGZ1bmN0aW9uIChkZWNvZGVFbnRpdGllcywgZmlyc3RDaGFyT2ZFbmQsIGF0dGVtcHRFbmRSZXN0KSB7XG4gICAgICAgIHZhciB0YWdDbG9zZVN0YXJ0O1xuICAgICAgICB2YXIgdGV4dFN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihkZWNvZGVFbnRpdGllcyA/IEh0bWxUb2tlblR5cGUuRVNDQVBBQkxFX1JBV19URVhUIDogSHRtbFRva2VuVHlwZS5SQVdfVEVYVCwgdGV4dFN0YXJ0KTtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoZmlyc3RDaGFyT2ZFbmQpICYmIGF0dGVtcHRFbmRSZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID4gdGFnQ2xvc2VTdGFydC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRhZ0Nsb3NlU3RhcnQub2Zmc2V0LCB0aGlzLmluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9PSBmaXJzdENoYXJPZkVuZCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoZGVjb2RlRW50aXRpZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSwgdGFnQ2xvc2VTdGFydCk7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVDb21tZW50ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oSHRtbFRva2VuVHlwZS5DT01NRU5UX1NUQVJULCBzdGFydCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTUlOVVMpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHZhciB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgJE1JTlVTLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYXR0ZW1wdFN0cignLT4nKTsgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oSHRtbFRva2VuVHlwZS5DT01NRU5UX0VORCwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihIdG1sVG9rZW5UeXBlLkNEQVRBX1NUQVJULCBzdGFydCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVTdHIoJ0NEQVRBWycpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHZhciB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgJFJCUkFDS0VULCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYXR0ZW1wdFN0cignXT4nKTsgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oSHRtbFRva2VuVHlwZS5DREFUQV9FTkQsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZURvY1R5cGUgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihIdG1sVG9rZW5UeXBlLkRPQ19UWVBFLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoJEdUKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMiwgdGhpcy5pbmRleCAtIDEpXSk7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVQcmVmaXhBbmROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZU9yUHJlZml4U3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgcHJlZml4ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPT0gJENPTE9OICYmICFpc1ByZWZpeEVuZCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVTdGFydDtcbiAgICAgICAgaWYgKHRoaXMucGVlayA9PT0gJENPTE9OKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBwcmVmaXggPSB0aGlzLmlucHV0LnN1YnN0cmluZyhuYW1lT3JQcmVmaXhTdGFydCwgdGhpcy5pbmRleCAtIDEpO1xuICAgICAgICAgICAgbmFtZVN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCB0aGlzLmluZGV4ID09PSBuYW1lU3RhcnQgPyAxIDogMCk7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcobmFtZVN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIG5hbWVdO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlbiA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgc2F2ZWRQb3MgPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGxvd2VyY2FzZVRhZ05hbWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzQXNjaWlMZXR0ZXIodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKHVuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLnBlZWspLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hbWVTdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlblN0YXJ0KHN0YXJ0KTtcbiAgICAgICAgICAgIGxvd2VyY2FzZVRhZ05hbWUgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhuYW1lU3RhcnQsIHRoaXMuaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9PSAkU0xBU0ggJiYgdGhpcy5wZWVrICE9PSAkR1QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQXR0cmlidXRlTmFtZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRFUSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW5FbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgc3RhcnQgdGFnIGlzIGludmFsaWQsIGFzc3VtZSB3ZSB3YW50IGEgXCI8XCJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oc2F2ZWRQb3MpO1xuICAgICAgICAgICAgICAgIC8vIEJhY2sgdG8gYmFjayB0ZXh0IHRva2VucyBhcmUgbWVyZ2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKEh0bWxUb2tlblR5cGUuVEVYVCwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFsnPCddKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZW50VG9rZW5UeXBlID0gaHRtbF90YWdzXzEuZ2V0SHRtbFRhZ0RlZmluaXRpb24obG93ZXJjYXNlVGFnTmFtZSkuY29udGVudFR5cGU7XG4gICAgICAgIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBodG1sX3RhZ3NfMS5IdG1sVGFnQ29udGVudFR5cGUuUkFXX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKGxvd2VyY2FzZVRhZ05hbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBodG1sX3RhZ3NfMS5IdG1sVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZSA9IGZ1bmN0aW9uIChsb3dlcmNhc2VUYWdOYW1lLCBkZWNvZGVFbnRpdGllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZGVjb2RlRW50aXRpZXMsICRMVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRTdHJDYXNlSW5zZW5zaXRpdmUobG93ZXJjYXNlVGFnTmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkR1QpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihIdG1sVG9rZW5UeXBlLlRBR19DTE9TRSwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW251bGwsIGxvd2VyY2FzZVRhZ05hbWVdKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5TdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKEh0bWxUb2tlblR5cGUuVEFHX09QRU5fU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihIdG1sVG9rZW5UeXBlLkFUVFJfTkFNRSk7XG4gICAgICAgIHZhciBwcmVmaXhBbmROYW1lID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocHJlZml4QW5kTmFtZSk7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihIdG1sVG9rZW5UeXBlLkFUVFJfVkFMVUUpO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT09ICRTUSB8fCB0aGlzLnBlZWsgPT09ICREUSkge1xuICAgICAgICAgICAgdmFyIHF1b3RlQ2hhciA9IHRoaXMucGVlaztcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPT0gcXVvdGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihpc05hbWVFbmQsIDEpO1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmlucHV0LnN1YnN0cmluZyh2YWx1ZVN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlblR5cGUgPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSA/IEh0bWxUb2tlblR5cGUuVEFHX09QRU5fRU5EX1ZPSUQgOlxuICAgICAgICAgICAgSHRtbFRva2VuVHlwZS5UQUdfT1BFTl9FTkQ7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odG9rZW5UeXBlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ0Nsb3NlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oSHRtbFRva2VuVHlwZS5UQUdfQ0xPU0UsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB2YXIgcHJlZml4QW5kTmFtZTtcbiAgICAgICAgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKEh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihIdG1sVG9rZW5UeXBlLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbY29uZGl0aW9uXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oSHRtbFRva2VuVHlwZS5SQVdfVEVYVCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0eXBlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uQ2FzZVN0YWNrLnB1c2goSHRtbFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCk7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkRVEpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKEh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfVkFMVUUsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWFkVW50aWwoJExCUkFDRSkudHJpbSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdmFsdWVdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKEh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRMQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5leHBhbnNpb25DYXNlU3RhY2sucHVzaChIdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCk7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKEh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uQ2FzZVN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihIdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLmV4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oSHRtbFRva2VuVHlwZS5URVhULCBzdGFydCk7XG4gICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wZWVrID09PSAkTEJSQUNFICYmIHRoaXMubmV4dFBlZWsgPT09ICRMQlJBQ0UpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICghdGhpcy5pc1RleHRFbmQoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT09ICRMQlJBQ0UgJiYgdGhpcy5uZXh0UGVlayA9PT0gJExCUkFDRSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09PSAkUkJSQUNFICYmIHRoaXMubmV4dFBlZWsgPT09ICRSQlJBQ0UgJiYgaW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLmlzVGV4dEVuZCA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT09ICRMVCB8fCB0aGlzLnBlZWsgPT09ICRFT0YpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVFeHBhbnNpb25Gb3Jtcykge1xuICAgICAgICAgICAgaWYgKGlzU3BlY2lhbEZvcm1TdGFydCh0aGlzLnBlZWssIHRoaXMubmV4dFBlZWspKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PT0gJFJCUkFDRSAmJiAhaW50ZXJwb2xhdGlvbiAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmlzSW5FeHBhbnNpb25DYXNlKCkgfHwgdGhpcy5pc0luRXhwYW5zaW9uRm9ybSgpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX3NhdmVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnBlZWssIHRoaXMuaW5kZXgsIHRoaXMuY29sdW1uLCB0aGlzLmxpbmUsIHRoaXMudG9rZW5zLmxlbmd0aF07XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX3JlYWRVbnRpbCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoY2hhcik7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgfTtcbiAgICBfSHRtbFRva2VuaXplci5wcm90b3R5cGUuX3Jlc3RvcmVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB0aGlzLnBlZWsgPSBwb3NpdGlvblswXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IHBvc2l0aW9uWzFdO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IHBvc2l0aW9uWzJdO1xuICAgICAgICB0aGlzLmxpbmUgPSBwb3NpdGlvblszXTtcbiAgICAgICAgdmFyIG5iVG9rZW5zID0gcG9zaXRpb25bNF07XG4gICAgICAgIGlmIChuYlRva2VucyA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSBleHRyYSB0b2tlbnNcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnNsaWNlKHRoaXMudG9rZW5zLCAwLCBuYlRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9IdG1sVG9rZW5pemVyLnByb3RvdHlwZS5pc0luRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIEh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUO1xuICAgIH07XG4gICAgX0h0bWxUb2tlbml6ZXIucHJvdG90eXBlLmlzSW5FeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoIC0gMV0gPT09XG4gICAgICAgICAgICAgICAgSHRtbFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVDtcbiAgICB9O1xuICAgIHJldHVybiBfSHRtbFRva2VuaXplcjtcbn0oKSk7XG5mdW5jdGlvbiBpc05vdFdoaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAhaXNXaGl0ZXNwYWNlKGNvZGUpIHx8IGNvZGUgPT09ICRFT0Y7XG59XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSAkVEFCICYmIGNvZGUgPD0gJFNQQUNFKSB8fCAoY29kZSA9PT0gJE5CU1ApO1xufVxuZnVuY3Rpb24gaXNOYW1lRW5kKGNvZGUpIHtcbiAgICByZXR1cm4gaXNXaGl0ZXNwYWNlKGNvZGUpIHx8IGNvZGUgPT09ICRHVCB8fCBjb2RlID09PSAkU0xBU0ggfHwgY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fFxuICAgICAgICBjb2RlID09PSAkRVE7XG59XG5mdW5jdGlvbiBpc1ByZWZpeEVuZChjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlIDwgJGEgfHwgJHogPCBjb2RlKSAmJiAoY29kZSA8ICRBIHx8ICRaIDwgY29kZSkgJiYgKGNvZGUgPCAkMCB8fCBjb2RlID4gJDkpO1xufVxuZnVuY3Rpb24gaXNEaWdpdEVudGl0eUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlIZXhEaWdpdChjb2RlKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZWRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRTRU1JQ09MT04gfHwgY29kZSA9PSAkRU9GIHx8ICFpc0FzY2lpTGV0dGVyKGNvZGUpO1xufVxuZnVuY3Rpb24gaXNTcGVjaWFsRm9ybVN0YXJ0KHBlZWssIG5leHRQZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgPT09ICRMQlJBQ0UgJiYgbmV4dFBlZWsgIT0gJExCUkFDRTtcbn1cbmZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRaO1xufVxuZnVuY3Rpb24gaXNBc2NpaUhleERpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICRmIHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkRiB8fCBjb2RlID49ICQwICYmIGNvZGUgPD0gJDk7XG59XG5mdW5jdGlvbiBjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY29kZTEsIGNvZGUyKSB7XG4gICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09IHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTIpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiA/IGNvZGUgLSAkYSArICRBIDogY29kZTtcbn1cbmZ1bmN0aW9uIG1lcmdlVGV4dFRva2VucyhzcmNUb2tlbnMpIHtcbiAgICB2YXIgZHN0VG9rZW5zID0gW107XG4gICAgdmFyIGxhc3REc3RUb2tlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGxhc3REc3RUb2tlbikgJiYgbGFzdERzdFRva2VuLnR5cGUgPT0gSHRtbFRva2VuVHlwZS5URVhUICYmXG4gICAgICAgICAgICB0b2tlbi50eXBlID09IEh0bWxUb2tlblR5cGUuVEVYVCkge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnNvdXJjZVNwYW4uZW5kID0gdG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdFRva2Vucztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWxfbGV4ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgaHRtbF9hc3RfMSA9IHJlcXVpcmUoJy4vaHRtbF9hc3QnKTtcbnZhciBodG1sX2xleGVyXzEgPSByZXF1aXJlKCcuL2h0bWxfbGV4ZXInKTtcbnZhciBwYXJzZV91dGlsXzEgPSByZXF1aXJlKCcuL3BhcnNlX3V0aWwnKTtcbnZhciBodG1sX3RhZ3NfMSA9IHJlcXVpcmUoJy4vaHRtbF90YWdzJyk7XG52YXIgSHRtbFRyZWVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEh0bWxUcmVlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHRtbFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZyk7XG4gICAgICAgIHRoaXMuZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICB9XG4gICAgSHRtbFRyZWVFcnJvci5jcmVhdGUgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZyk7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbFRyZWVFcnJvcjtcbn0ocGFyc2VfdXRpbF8xLlBhcnNlRXJyb3IpKTtcbmV4cG9ydHMuSHRtbFRyZWVFcnJvciA9IEh0bWxUcmVlRXJyb3I7XG52YXIgSHRtbFBhcnNlVHJlZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbFBhcnNlVHJlZVJlc3VsdChyb290Tm9kZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHJvb3ROb2RlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBIdG1sUGFyc2VUcmVlUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuSHRtbFBhcnNlVHJlZVJlc3VsdCA9IEh0bWxQYXJzZVRyZWVSZXN1bHQ7XG52YXIgSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbFBhcnNlcigpIHtcbiAgICB9XG4gICAgSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlQ29udGVudCwgc291cmNlVXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zKSB7XG4gICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0b2tlbnNBbmRFcnJvcnMgPSBodG1sX2xleGVyXzEudG9rZW5pemVIdG1sKHNvdXJjZUNvbnRlbnQsIHNvdXJjZVVybCwgcGFyc2VFeHBhbnNpb25Gb3Jtcyk7XG4gICAgICAgIHZhciB0cmVlQW5kRXJyb3JzID0gbmV3IFRyZWVCdWlsZGVyKHRva2Vuc0FuZEVycm9ycy50b2tlbnMpLmJ1aWxkKCk7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFBhcnNlVHJlZVJlc3VsdCh0cmVlQW5kRXJyb3JzLnJvb3ROb2RlcywgdG9rZW5zQW5kRXJyb3JzLmVycm9yc1xuICAgICAgICAgICAgLmNvbmNhdCh0cmVlQW5kRXJyb3JzLmVycm9ycykpO1xuICAgIH07XG4gICAgSHRtbFBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gSHRtbFBhcnNlcjtcbn0oKSk7XG5leHBvcnRzLkh0bWxQYXJzZXIgPSBIdG1sUGFyc2VyO1xudmFyIFRyZWVCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlQnVpbGRlcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5yb290Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgIH1cbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsudHlwZSAhPT0gaHRtbF9sZXhlcl8xLkh0bWxUb2tlblR5cGUuRU9GKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLlRBR19PUEVOX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsudHlwZSA9PT0gaHRtbF9sZXhlcl8xLkh0bWxUb2tlblR5cGUuVEFHX0NMT1NFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVuZFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkNEQVRBX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YSh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkNPTU1FTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlay50eXBlID09PSBodG1sX2xleGVyXzEuSHRtbFRva2VuVHlwZS5URVhUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLlJBV19URVhUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbih0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBhbGwgb3RoZXIgdG9rZW5zLi4uXG4gICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFBhcnNlVHJlZVJlc3VsdCh0aGlzLnJvb3ROb2RlcywgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMucGVlaztcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbHdheXMgYW4gRU9GIHRva2VuIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlZWsgPSB0aGlzLnRva2Vuc1t0aGlzLmluZGV4XTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2VJZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlZWsudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUNkYXRhID0gZnVuY3Rpb24gKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZUlmKGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkNEQVRBX0VORCk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVDb21tZW50ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fYWR2YW5jZUlmKGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLlJBV19URVhUKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZUlmKGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkNPTU1FTlRfRU5EKTtcbiAgICAgICAgdmFyIHZhbHVlID0gbGFuZ18xLmlzUHJlc2VudCh0ZXh0KSA/IHRleHQucGFydHNbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IGh0bWxfYXN0XzEuSHRtbENvbW1lbnRBc3QodmFsdWUsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgc3dpdGNoVmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgY2FzZXMgPSBbXTtcbiAgICAgICAgLy8gcmVhZCA9XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsudHlwZSA9PT0gaHRtbF9sZXhlcl8xLkh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciBleHBDYXNlID0gdGhpcy5fcGFyc2VFeHBhbnNpb25DYXNlKCk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoZXhwQ2FzZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlcnJvclxuICAgICAgICAgICAgY2FzZXMucHVzaChleHBDYXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkIHRoZSBmaW5hbCB9XG4gICAgICAgIGlmICh0aGlzLnBlZWsudHlwZSAhPT0gaHRtbF9sZXhlcl8xLkh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKEh0bWxUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMucGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgZXhwYW5zaW9uIGZvcm0uIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgbWFpblNvdXJjZVNwYW4gPSBuZXcgcGFyc2VfdXRpbF8xLlBhcnNlU291cmNlU3Bhbih0b2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCB0aGlzLnBlZWsuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgaHRtbF9hc3RfMS5IdG1sRXhwYW5zaW9uQXN0KHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgbWFpblNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlLnNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5fcGFyc2VFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIC8vIHJlYWQge1xuICAgICAgICBpZiAodGhpcy5wZWVrLnR5cGUgIT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChIdG1sVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLnBlZWsuc291cmNlU3BhbiwgXCJJbnZhbGlkIGV4cGFuc2lvbiBmb3JtLiBNaXNzaW5nICd7Jy4sXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdW50aWwgfVxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciBleHAgPSB0aGlzLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGV4cCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgZXhwLnB1c2gobmV3IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW4oaHRtbF9sZXhlcl8xLkh0bWxUb2tlblR5cGUuRU9GLCBbXSwgZW5kLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgLy8gcGFyc2UgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHsgYW5kIH1cbiAgICAgICAgdmFyIHBhcnNlZEV4cCA9IG5ldyBUcmVlQnVpbGRlcihleHApLmJ1aWxkKCk7XG4gICAgICAgIGlmIChwYXJzZWRFeHAuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuY29uY2F0KHBhcnNlZEV4cC5lcnJvcnMpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgcGFyc2VfdXRpbF8xLlBhcnNlU291cmNlU3Bhbih2YWx1ZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB2YXIgZXhwU291cmNlU3BhbiA9IG5ldyBwYXJzZV91dGlsXzEuUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgaHRtbF9hc3RfMS5IdG1sRXhwYW5zaW9uQ2FzZUFzdCh2YWx1ZS5wYXJ0c1swXSwgcGFyc2VkRXhwLnJvb3ROb2Rlcywgc291cmNlU3BhbiwgdmFsdWUuc291cmNlU3BhbiwgZXhwU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIGV4cCA9IFtdO1xuICAgICAgICB2YXIgZXhwYW5zaW9uRm9ybVN0YWNrID0gW2h0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVF07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wdXNoKHRoaXMucGVlay50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsudHlwZSA9PT0gaHRtbF9sZXhlcl8xLkh0bWxUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5zaW9uRm9ybVN0YWNrLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goSHRtbFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIGV4cGFuc2lvbiBmb3JtLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX0VORCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKEh0bWxUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBleHBhbnNpb24gZm9ybS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGVlay50eXBlID09PSBodG1sX2xleGVyXzEuSHRtbFRva2VuVHlwZS5FT0YpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKEh0bWxUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBleHBhbnNpb24gZm9ybS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cC5wdXNoKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVRleHQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHRleHQgPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJlbnRfMSkgJiYgcGFyZW50XzEuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICBodG1sX3RhZ3NfMS5nZXRIdG1sVGFnRGVmaW5pdGlvbihwYXJlbnRfMS5uYW1lKS5pZ25vcmVGaXJzdExmKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBodG1sX2FzdF8xLkh0bWxUZXh0QXN0KHRleHQsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jbG9zZVZvaWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGVsID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmxhc3QodGhpcy5lbGVtZW50U3RhY2spO1xuICAgICAgICAgICAgaWYgKGh0bWxfdGFnc18xLmdldEh0bWxUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVTdGFydFRhZyA9IGZ1bmN0aW9uIChzdGFydFRhZ1Rva2VuKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBzdGFydFRhZ1Rva2VuLnBhcnRzWzBdO1xuICAgICAgICB2YXIgbmFtZSA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgIHZhciBhdHRycyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkFUVFJfTkFNRSkge1xuICAgICAgICAgICAgYXR0cnMucHVzaCh0aGlzLl9jb25zdW1lQXR0cih0aGlzLl9hZHZhbmNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVsbE5hbWUgPSBnZXRFbGVtZW50RnVsbE5hbWUocHJlZml4LCBuYW1lLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gTm90ZTogVGhlcmUgY291bGQgaGF2ZSBiZWVuIGEgdG9rZW5pemVyIGVycm9yXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IGEgdG9rZW4gZm9yIHRoZSBlbmQgdGFnLi4uXG4gICAgICAgIGlmICh0aGlzLnBlZWsudHlwZSA9PT0gaHRtbF9sZXhlcl8xLkh0bWxUb2tlblR5cGUuVEFHX09QRU5fRU5EX1ZPSUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChodG1sX3RhZ3NfMS5nZXROc1ByZWZpeChmdWxsTmFtZSkgPT0gbnVsbCAmJiAhaHRtbF90YWdzXzEuZ2V0SHRtbFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goSHRtbFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3BhbiwgXCJPbmx5IHZvaWQgYW5kIGZvcmVpZ24gZWxlbWVudHMgY2FuIGJlIHNlbGYgY2xvc2VkIFxcXCJcIiArIHN0YXJ0VGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVlay50eXBlID09PSBodG1sX2xleGVyXzEuSHRtbFRva2VuVHlwZS5UQUdfT1BFTl9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucGVlay5zb3VyY2VTcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgc3BhbiA9IG5ldyBwYXJzZV91dGlsXzEuUGFyc2VTb3VyY2VTcGFuKHN0YXJ0VGFnVG9rZW4uc291cmNlU3Bhbi5zdGFydCwgZW5kKTtcbiAgICAgICAgdmFyIGVsID0gbmV3IGh0bWxfYXN0XzEuSHRtbEVsZW1lbnRBc3QoZnVsbE5hbWUsIGF0dHJzLCBbXSwgc3Bhbiwgc3BhbiwgbnVsbCk7XG4gICAgICAgIHRoaXMuX3B1c2hFbGVtZW50KGVsKTtcbiAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lKTtcbiAgICAgICAgICAgIGVsLmVuZFNvdXJjZVNwYW4gPSBzcGFuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuX3B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIubGFzdCh0aGlzLmVsZW1lbnRTdGFjayk7XG4gICAgICAgICAgICBpZiAoaHRtbF90YWdzXzEuZ2V0SHRtbFRhZ0RlZmluaXRpb24ocGFyZW50RWwubmFtZSkuaXNDbG9zZWRCeUNoaWxkKGVsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZ0RlZiA9IGh0bWxfdGFnc18xLmdldEh0bWxUYWdEZWZpbml0aW9uKGVsLm5hbWUpO1xuICAgICAgICB2YXIgcGFyZW50RWwgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmICh0YWdEZWYucmVxdWlyZUV4dHJhUGFyZW50KGxhbmdfMS5pc1ByZXNlbnQocGFyZW50RWwpID8gcGFyZW50RWwubmFtZSA6IG51bGwpKSB7XG4gICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3IGh0bWxfYXN0XzEuSHRtbEVsZW1lbnRBc3QodGFnRGVmLnBhcmVudFRvQWRkLCBbXSwgW2VsXSwgZWwuc291cmNlU3BhbiwgZWwuc3RhcnRTb3VyY2VTcGFuLCBlbC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ld1BhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKG5ld1BhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KGVsKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2goZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFbmRUYWcgPSBmdW5jdGlvbiAoZW5kVGFnVG9rZW4pIHtcbiAgICAgICAgdmFyIGZ1bGxOYW1lID0gZ2V0RWxlbWVudEZ1bGxOYW1lKGVuZFRhZ1Rva2VuLnBhcnRzWzBdLCBlbmRUYWdUb2tlbi5wYXJ0c1sxXSwgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpLmVuZFNvdXJjZVNwYW4gPSBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICBpZiAoaHRtbF90YWdzXzEuZ2V0SHRtbFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChIdG1sVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgXCJWb2lkIGVsZW1lbnRzIGRvIG5vdCBoYXZlIGVuZCB0YWdzIFxcXCJcIiArIGVuZFRhZ1Rva2VuLnBhcnRzWzFdICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goSHRtbFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVW5leHBlY3RlZCBjbG9zaW5nIHRhZyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5fcG9wRWxlbWVudCA9IGZ1bmN0aW9uIChmdWxsTmFtZSkge1xuICAgICAgICBmb3IgKHZhciBzdGFja0luZGV4ID0gdGhpcy5lbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgc3RhY2tJbmRleCA+PSAwOyBzdGFja0luZGV4LS0pIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudFN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gZnVsbE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuc3BsaWNlKHRoaXMuZWxlbWVudFN0YWNrLCBzdGFja0luZGV4LCB0aGlzLmVsZW1lbnRTdGFjay5sZW5ndGggLSBzdGFja0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaHRtbF90YWdzXzEuZ2V0SHRtbFRhZ0RlZmluaXRpb24oZWwubmFtZSkuY2xvc2VkQnlQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICB2YXIgZnVsbE5hbWUgPSBodG1sX3RhZ3NfMS5tZXJnZU5zQW5kTmFtZShhdHRyTmFtZS5wYXJ0c1swXSwgYXR0ck5hbWUucGFydHNbMV0pO1xuICAgICAgICB2YXIgZW5kID0gYXR0ck5hbWUuc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5wZWVrLnR5cGUgPT09IGh0bWxfbGV4ZXJfMS5IdG1sVG9rZW5UeXBlLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgZW5kID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGh0bWxfYXN0XzEuSHRtbEF0dHJBc3QoZnVsbE5hbWUsIHZhbHVlLCBuZXcgcGFyc2VfdXRpbF8xLlBhcnNlU291cmNlU3BhbihhdHRyTmFtZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpKTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UGFyZW50RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrLmxlbmd0aCA+IDAgPyBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIubGFzdCh0aGlzLmVsZW1lbnRTdGFjaykgOiBudWxsO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZGRUb1BhcmVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyZWVCdWlsZGVyO1xufSgpKTtcbmZ1bmN0aW9uIGdldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgIGlmIChsYW5nXzEuaXNCbGFuayhwcmVmaXgpKSB7XG4gICAgICAgIHByZWZpeCA9IGh0bWxfdGFnc18xLmdldEh0bWxUYWdEZWZpbml0aW9uKGxvY2FsTmFtZSkuaW1wbGljaXROYW1lc3BhY2VQcmVmaXg7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwcmVmaXgpICYmIGxhbmdfMS5pc1ByZXNlbnQocGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGh0bWxfdGFnc18xLmdldE5zUHJlZml4KHBhcmVudEVsZW1lbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWxfdGFnc18xLm1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKTtcbn1cbmZ1bmN0aW9uIGxhc3RPblN0YWNrKHN0YWNrLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGVsZW1lbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sX3BhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbi8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZXNcbi8vIHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbnRpdGllcy5qc29uXG4vLyBUaGlzIGxpc3QgaXMgbm90IGV4aGF1c3RpdmUgdG8ga2VlcCB0aGUgY29tcGlsZXIgZm9vdHByaW50IGxvdy5cbi8vIFRoZSBgJiMxMjM7YCAvIGAmI3gxYWI7YCBzeW50YXggc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBkb2VzIG5vdCBleGlzdC5cbmV4cG9ydHMuTkFNRURfRU5USVRJRVMgPSB7XG4gICAgJ0FhY3V0ZSc6ICdcXHUwMEMxJyxcbiAgICAnYWFjdXRlJzogJ1xcdTAwRTEnLFxuICAgICdBY2lyYyc6ICdcXHUwMEMyJyxcbiAgICAnYWNpcmMnOiAnXFx1MDBFMicsXG4gICAgJ2FjdXRlJzogJ1xcdTAwQjQnLFxuICAgICdBRWxpZyc6ICdcXHUwMEM2JyxcbiAgICAnYWVsaWcnOiAnXFx1MDBFNicsXG4gICAgJ0FncmF2ZSc6ICdcXHUwMEMwJyxcbiAgICAnYWdyYXZlJzogJ1xcdTAwRTAnLFxuICAgICdhbGVmc3ltJzogJ1xcdTIxMzUnLFxuICAgICdBbHBoYSc6ICdcXHUwMzkxJyxcbiAgICAnYWxwaGEnOiAnXFx1MDNCMScsXG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnYW5kJzogJ1xcdTIyMjcnLFxuICAgICdhbmcnOiAnXFx1MjIyMCcsXG4gICAgJ2Fwb3MnOiAnXFx1MDAyNycsXG4gICAgJ0FyaW5nJzogJ1xcdTAwQzUnLFxuICAgICdhcmluZyc6ICdcXHUwMEU1JyxcbiAgICAnYXN5bXAnOiAnXFx1MjI0OCcsXG4gICAgJ0F0aWxkZSc6ICdcXHUwMEMzJyxcbiAgICAnYXRpbGRlJzogJ1xcdTAwRTMnLFxuICAgICdBdW1sJzogJ1xcdTAwQzQnLFxuICAgICdhdW1sJzogJ1xcdTAwRTQnLFxuICAgICdiZHF1byc6ICdcXHUyMDFFJyxcbiAgICAnQmV0YSc6ICdcXHUwMzkyJyxcbiAgICAnYmV0YSc6ICdcXHUwM0IyJyxcbiAgICAnYnJ2YmFyJzogJ1xcdTAwQTYnLFxuICAgICdidWxsJzogJ1xcdTIwMjInLFxuICAgICdjYXAnOiAnXFx1MjIyOScsXG4gICAgJ0NjZWRpbCc6ICdcXHUwMEM3JyxcbiAgICAnY2NlZGlsJzogJ1xcdTAwRTcnLFxuICAgICdjZWRpbCc6ICdcXHUwMEI4JyxcbiAgICAnY2VudCc6ICdcXHUwMEEyJyxcbiAgICAnQ2hpJzogJ1xcdTAzQTcnLFxuICAgICdjaGknOiAnXFx1MDNDNycsXG4gICAgJ2NpcmMnOiAnXFx1MDJDNicsXG4gICAgJ2NsdWJzJzogJ1xcdTI2NjMnLFxuICAgICdjb25nJzogJ1xcdTIyNDUnLFxuICAgICdjb3B5JzogJ1xcdTAwQTknLFxuICAgICdjcmFycic6ICdcXHUyMUI1JyxcbiAgICAnY3VwJzogJ1xcdTIyMkEnLFxuICAgICdjdXJyZW4nOiAnXFx1MDBBNCcsXG4gICAgJ2RhZ2dlcic6ICdcXHUyMDIwJyxcbiAgICAnRGFnZ2VyJzogJ1xcdTIwMjEnLFxuICAgICdkYXJyJzogJ1xcdTIxOTMnLFxuICAgICdkQXJyJzogJ1xcdTIxRDMnLFxuICAgICdkZWcnOiAnXFx1MDBCMCcsXG4gICAgJ0RlbHRhJzogJ1xcdTAzOTQnLFxuICAgICdkZWx0YSc6ICdcXHUwM0I0JyxcbiAgICAnZGlhbXMnOiAnXFx1MjY2NicsXG4gICAgJ2RpdmlkZSc6ICdcXHUwMEY3JyxcbiAgICAnRWFjdXRlJzogJ1xcdTAwQzknLFxuICAgICdlYWN1dGUnOiAnXFx1MDBFOScsXG4gICAgJ0VjaXJjJzogJ1xcdTAwQ0EnLFxuICAgICdlY2lyYyc6ICdcXHUwMEVBJyxcbiAgICAnRWdyYXZlJzogJ1xcdTAwQzgnLFxuICAgICdlZ3JhdmUnOiAnXFx1MDBFOCcsXG4gICAgJ2VtcHR5JzogJ1xcdTIyMDUnLFxuICAgICdlbXNwJzogJ1xcdTIwMDMnLFxuICAgICdlbnNwJzogJ1xcdTIwMDInLFxuICAgICdFcHNpbG9uJzogJ1xcdTAzOTUnLFxuICAgICdlcHNpbG9uJzogJ1xcdTAzQjUnLFxuICAgICdlcXVpdic6ICdcXHUyMjYxJyxcbiAgICAnRXRhJzogJ1xcdTAzOTcnLFxuICAgICdldGEnOiAnXFx1MDNCNycsXG4gICAgJ0VUSCc6ICdcXHUwMEQwJyxcbiAgICAnZXRoJzogJ1xcdTAwRjAnLFxuICAgICdFdW1sJzogJ1xcdTAwQ0InLFxuICAgICdldW1sJzogJ1xcdTAwRUInLFxuICAgICdldXJvJzogJ1xcdTIwQUMnLFxuICAgICdleGlzdCc6ICdcXHUyMjAzJyxcbiAgICAnZm5vZic6ICdcXHUwMTkyJyxcbiAgICAnZm9yYWxsJzogJ1xcdTIyMDAnLFxuICAgICdmcmFjMTInOiAnXFx1MDBCRCcsXG4gICAgJ2ZyYWMxNCc6ICdcXHUwMEJDJyxcbiAgICAnZnJhYzM0JzogJ1xcdTAwQkUnLFxuICAgICdmcmFzbCc6ICdcXHUyMDQ0JyxcbiAgICAnR2FtbWEnOiAnXFx1MDM5MycsXG4gICAgJ2dhbW1hJzogJ1xcdTAzQjMnLFxuICAgICdnZSc6ICdcXHUyMjY1JyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2hhcnInOiAnXFx1MjE5NCcsXG4gICAgJ2hBcnInOiAnXFx1MjFENCcsXG4gICAgJ2hlYXJ0cyc6ICdcXHUyNjY1JyxcbiAgICAnaGVsbGlwJzogJ1xcdTIwMjYnLFxuICAgICdJYWN1dGUnOiAnXFx1MDBDRCcsXG4gICAgJ2lhY3V0ZSc6ICdcXHUwMEVEJyxcbiAgICAnSWNpcmMnOiAnXFx1MDBDRScsXG4gICAgJ2ljaXJjJzogJ1xcdTAwRUUnLFxuICAgICdpZXhjbCc6ICdcXHUwMEExJyxcbiAgICAnSWdyYXZlJzogJ1xcdTAwQ0MnLFxuICAgICdpZ3JhdmUnOiAnXFx1MDBFQycsXG4gICAgJ2ltYWdlJzogJ1xcdTIxMTEnLFxuICAgICdpbmZpbic6ICdcXHUyMjFFJyxcbiAgICAnaW50JzogJ1xcdTIyMkInLFxuICAgICdJb3RhJzogJ1xcdTAzOTknLFxuICAgICdpb3RhJzogJ1xcdTAzQjknLFxuICAgICdpcXVlc3QnOiAnXFx1MDBCRicsXG4gICAgJ2lzaW4nOiAnXFx1MjIwOCcsXG4gICAgJ0l1bWwnOiAnXFx1MDBDRicsXG4gICAgJ2l1bWwnOiAnXFx1MDBFRicsXG4gICAgJ0thcHBhJzogJ1xcdTAzOUEnLFxuICAgICdrYXBwYSc6ICdcXHUwM0JBJyxcbiAgICAnTGFtYmRhJzogJ1xcdTAzOUInLFxuICAgICdsYW1iZGEnOiAnXFx1MDNCQicsXG4gICAgJ2xhbmcnOiAnXFx1MjdFOCcsXG4gICAgJ2xhcXVvJzogJ1xcdTAwQUInLFxuICAgICdsYXJyJzogJ1xcdTIxOTAnLFxuICAgICdsQXJyJzogJ1xcdTIxRDAnLFxuICAgICdsY2VpbCc6ICdcXHUyMzA4JyxcbiAgICAnbGRxdW8nOiAnXFx1MjAxQycsXG4gICAgJ2xlJzogJ1xcdTIyNjQnLFxuICAgICdsZmxvb3InOiAnXFx1MjMwQScsXG4gICAgJ2xvd2FzdCc6ICdcXHUyMjE3JyxcbiAgICAnbG96JzogJ1xcdTI1Q0EnLFxuICAgICdscm0nOiAnXFx1MjAwRScsXG4gICAgJ2xzYXF1byc6ICdcXHUyMDM5JyxcbiAgICAnbHNxdW8nOiAnXFx1MjAxOCcsXG4gICAgJ2x0JzogJzwnLFxuICAgICdtYWNyJzogJ1xcdTAwQUYnLFxuICAgICdtZGFzaCc6ICdcXHUyMDE0JyxcbiAgICAnbWljcm8nOiAnXFx1MDBCNScsXG4gICAgJ21pZGRvdCc6ICdcXHUwMEI3JyxcbiAgICAnbWludXMnOiAnXFx1MjIxMicsXG4gICAgJ011JzogJ1xcdTAzOUMnLFxuICAgICdtdSc6ICdcXHUwM0JDJyxcbiAgICAnbmFibGEnOiAnXFx1MjIwNycsXG4gICAgJ25ic3AnOiAnXFx1MDBBMCcsXG4gICAgJ25kYXNoJzogJ1xcdTIwMTMnLFxuICAgICduZSc6ICdcXHUyMjYwJyxcbiAgICAnbmknOiAnXFx1MjIwQicsXG4gICAgJ25vdCc6ICdcXHUwMEFDJyxcbiAgICAnbm90aW4nOiAnXFx1MjIwOScsXG4gICAgJ25zdWInOiAnXFx1MjI4NCcsXG4gICAgJ050aWxkZSc6ICdcXHUwMEQxJyxcbiAgICAnbnRpbGRlJzogJ1xcdTAwRjEnLFxuICAgICdOdSc6ICdcXHUwMzlEJyxcbiAgICAnbnUnOiAnXFx1MDNCRCcsXG4gICAgJ09hY3V0ZSc6ICdcXHUwMEQzJyxcbiAgICAnb2FjdXRlJzogJ1xcdTAwRjMnLFxuICAgICdPY2lyYyc6ICdcXHUwMEQ0JyxcbiAgICAnb2NpcmMnOiAnXFx1MDBGNCcsXG4gICAgJ09FbGlnJzogJ1xcdTAxNTInLFxuICAgICdvZWxpZyc6ICdcXHUwMTUzJyxcbiAgICAnT2dyYXZlJzogJ1xcdTAwRDInLFxuICAgICdvZ3JhdmUnOiAnXFx1MDBGMicsXG4gICAgJ29saW5lJzogJ1xcdTIwM0UnLFxuICAgICdPbWVnYSc6ICdcXHUwM0E5JyxcbiAgICAnb21lZ2EnOiAnXFx1MDNDOScsXG4gICAgJ09taWNyb24nOiAnXFx1MDM5RicsXG4gICAgJ29taWNyb24nOiAnXFx1MDNCRicsXG4gICAgJ29wbHVzJzogJ1xcdTIyOTUnLFxuICAgICdvcic6ICdcXHUyMjI4JyxcbiAgICAnb3JkZic6ICdcXHUwMEFBJyxcbiAgICAnb3JkbSc6ICdcXHUwMEJBJyxcbiAgICAnT3NsYXNoJzogJ1xcdTAwRDgnLFxuICAgICdvc2xhc2gnOiAnXFx1MDBGOCcsXG4gICAgJ090aWxkZSc6ICdcXHUwMEQ1JyxcbiAgICAnb3RpbGRlJzogJ1xcdTAwRjUnLFxuICAgICdvdGltZXMnOiAnXFx1MjI5NycsXG4gICAgJ091bWwnOiAnXFx1MDBENicsXG4gICAgJ291bWwnOiAnXFx1MDBGNicsXG4gICAgJ3BhcmEnOiAnXFx1MDBCNicsXG4gICAgJ3Blcm1pbCc6ICdcXHUyMDMwJyxcbiAgICAncGVycCc6ICdcXHUyMkE1JyxcbiAgICAnUGhpJzogJ1xcdTAzQTYnLFxuICAgICdwaGknOiAnXFx1MDNDNicsXG4gICAgJ1BpJzogJ1xcdTAzQTAnLFxuICAgICdwaSc6ICdcXHUwM0MwJyxcbiAgICAncGl2JzogJ1xcdTAzRDYnLFxuICAgICdwbHVzbW4nOiAnXFx1MDBCMScsXG4gICAgJ3BvdW5kJzogJ1xcdTAwQTMnLFxuICAgICdwcmltZSc6ICdcXHUyMDMyJyxcbiAgICAnUHJpbWUnOiAnXFx1MjAzMycsXG4gICAgJ3Byb2QnOiAnXFx1MjIwRicsXG4gICAgJ3Byb3AnOiAnXFx1MjIxRCcsXG4gICAgJ1BzaSc6ICdcXHUwM0E4JyxcbiAgICAncHNpJzogJ1xcdTAzQzgnLFxuICAgICdxdW90JzogJ1xcdTAwMjInLFxuICAgICdyYWRpYyc6ICdcXHUyMjFBJyxcbiAgICAncmFuZyc6ICdcXHUyN0U5JyxcbiAgICAncmFxdW8nOiAnXFx1MDBCQicsXG4gICAgJ3JhcnInOiAnXFx1MjE5MicsXG4gICAgJ3JBcnInOiAnXFx1MjFEMicsXG4gICAgJ3JjZWlsJzogJ1xcdTIzMDknLFxuICAgICdyZHF1byc6ICdcXHUyMDFEJyxcbiAgICAncmVhbCc6ICdcXHUyMTFDJyxcbiAgICAncmVnJzogJ1xcdTAwQUUnLFxuICAgICdyZmxvb3InOiAnXFx1MjMwQicsXG4gICAgJ1Jobyc6ICdcXHUwM0ExJyxcbiAgICAncmhvJzogJ1xcdTAzQzEnLFxuICAgICdybG0nOiAnXFx1MjAwRicsXG4gICAgJ3JzYXF1byc6ICdcXHUyMDNBJyxcbiAgICAncnNxdW8nOiAnXFx1MjAxOScsXG4gICAgJ3NicXVvJzogJ1xcdTIwMUEnLFxuICAgICdTY2Fyb24nOiAnXFx1MDE2MCcsXG4gICAgJ3NjYXJvbic6ICdcXHUwMTYxJyxcbiAgICAnc2RvdCc6ICdcXHUyMkM1JyxcbiAgICAnc2VjdCc6ICdcXHUwMEE3JyxcbiAgICAnc2h5JzogJ1xcdTAwQUQnLFxuICAgICdTaWdtYSc6ICdcXHUwM0EzJyxcbiAgICAnc2lnbWEnOiAnXFx1MDNDMycsXG4gICAgJ3NpZ21hZic6ICdcXHUwM0MyJyxcbiAgICAnc2ltJzogJ1xcdTIyM0MnLFxuICAgICdzcGFkZXMnOiAnXFx1MjY2MCcsXG4gICAgJ3N1Yic6ICdcXHUyMjgyJyxcbiAgICAnc3ViZSc6ICdcXHUyMjg2JyxcbiAgICAnc3VtJzogJ1xcdTIyMTEnLFxuICAgICdzdXAnOiAnXFx1MjI4MycsXG4gICAgJ3N1cDEnOiAnXFx1MDBCOScsXG4gICAgJ3N1cDInOiAnXFx1MDBCMicsXG4gICAgJ3N1cDMnOiAnXFx1MDBCMycsXG4gICAgJ3N1cGUnOiAnXFx1MjI4NycsXG4gICAgJ3N6bGlnJzogJ1xcdTAwREYnLFxuICAgICdUYXUnOiAnXFx1MDNBNCcsXG4gICAgJ3RhdSc6ICdcXHUwM0M0JyxcbiAgICAndGhlcmU0JzogJ1xcdTIyMzQnLFxuICAgICdUaGV0YSc6ICdcXHUwMzk4JyxcbiAgICAndGhldGEnOiAnXFx1MDNCOCcsXG4gICAgJ3RoZXRhc3ltJzogJ1xcdTAzRDEnLFxuICAgICd0aGluc3AnOiAnXFx1MjAwOScsXG4gICAgJ1RIT1JOJzogJ1xcdTAwREUnLFxuICAgICd0aG9ybic6ICdcXHUwMEZFJyxcbiAgICAndGlsZGUnOiAnXFx1MDJEQycsXG4gICAgJ3RpbWVzJzogJ1xcdTAwRDcnLFxuICAgICd0cmFkZSc6ICdcXHUyMTIyJyxcbiAgICAnVWFjdXRlJzogJ1xcdTAwREEnLFxuICAgICd1YWN1dGUnOiAnXFx1MDBGQScsXG4gICAgJ3VhcnInOiAnXFx1MjE5MScsXG4gICAgJ3VBcnInOiAnXFx1MjFEMScsXG4gICAgJ1VjaXJjJzogJ1xcdTAwREInLFxuICAgICd1Y2lyYyc6ICdcXHUwMEZCJyxcbiAgICAnVWdyYXZlJzogJ1xcdTAwRDknLFxuICAgICd1Z3JhdmUnOiAnXFx1MDBGOScsXG4gICAgJ3VtbCc6ICdcXHUwMEE4JyxcbiAgICAndXBzaWgnOiAnXFx1MDNEMicsXG4gICAgJ1Vwc2lsb24nOiAnXFx1MDNBNScsXG4gICAgJ3Vwc2lsb24nOiAnXFx1MDNDNScsXG4gICAgJ1V1bWwnOiAnXFx1MDBEQycsXG4gICAgJ3V1bWwnOiAnXFx1MDBGQycsXG4gICAgJ3dlaWVycCc6ICdcXHUyMTE4JyxcbiAgICAnWGknOiAnXFx1MDM5RScsXG4gICAgJ3hpJzogJ1xcdTAzQkUnLFxuICAgICdZYWN1dGUnOiAnXFx1MDBERCcsXG4gICAgJ3lhY3V0ZSc6ICdcXHUwMEZEJyxcbiAgICAneWVuJzogJ1xcdTAwQTUnLFxuICAgICd5dW1sJzogJ1xcdTAwRkYnLFxuICAgICdZdW1sJzogJ1xcdTAxNzgnLFxuICAgICdaZXRhJzogJ1xcdTAzOTYnLFxuICAgICd6ZXRhJzogJ1xcdTAzQjYnLFxuICAgICd6d2onOiAnXFx1MjAwRCcsXG4gICAgJ3p3bmonOiAnXFx1MjAwQycsXG59O1xuKGZ1bmN0aW9uIChIdG1sVGFnQ29udGVudFR5cGUpIHtcbiAgICBIdG1sVGFnQ29udGVudFR5cGVbSHRtbFRhZ0NvbnRlbnRUeXBlW1wiUkFXX1RFWFRcIl0gPSAwXSA9IFwiUkFXX1RFWFRcIjtcbiAgICBIdG1sVGFnQ29udGVudFR5cGVbSHRtbFRhZ0NvbnRlbnRUeXBlW1wiRVNDQVBBQkxFX1JBV19URVhUXCJdID0gMV0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuICAgIEh0bWxUYWdDb250ZW50VHlwZVtIdG1sVGFnQ29udGVudFR5cGVbXCJQQVJTQUJMRV9EQVRBXCJdID0gMl0gPSBcIlBBUlNBQkxFX0RBVEFcIjtcbn0pKGV4cG9ydHMuSHRtbFRhZ0NvbnRlbnRUeXBlIHx8IChleHBvcnRzLkh0bWxUYWdDb250ZW50VHlwZSA9IHt9KSk7XG52YXIgSHRtbFRhZ0NvbnRlbnRUeXBlID0gZXhwb3J0cy5IdG1sVGFnQ29udGVudFR5cGU7XG52YXIgSHRtbFRhZ0RlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxUYWdEZWZpbml0aW9uKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBjbG9zZWRCeUNoaWxkcmVuID0gX2IuY2xvc2VkQnlDaGlsZHJlbiwgcmVxdWlyZWRQYXJlbnRzID0gX2IucmVxdWlyZWRQYXJlbnRzLCBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeCA9IF9iLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4LCBjb250ZW50VHlwZSA9IF9iLmNvbnRlbnRUeXBlLCBjbG9zZWRCeVBhcmVudCA9IF9iLmNsb3NlZEJ5UGFyZW50LCBpc1ZvaWQgPSBfYi5pc1ZvaWQsIGlnbm9yZUZpcnN0TGYgPSBfYi5pZ25vcmVGaXJzdExmO1xuICAgICAgICB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjbG9zZWRCeUNoaWxkcmVuKSAmJiBjbG9zZWRCeUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkgeyByZXR1cm4gX3RoaXMuY2xvc2VkQnlDaGlsZHJlblt0YWdOYW1lXSA9IHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWb2lkID0gbGFuZ18xLm5vcm1hbGl6ZUJvb2woaXNWb2lkKTtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGxhbmdfMS5ub3JtYWxpemVCb29sKGNsb3NlZEJ5UGFyZW50KSB8fCB0aGlzLmlzVm9pZDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmVxdWlyZWRQYXJlbnRzKSAmJiByZXF1aXJlZFBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZFBhcmVudHMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50VG9BZGQgPSByZXF1aXJlZFBhcmVudHNbMF07XG4gICAgICAgICAgICByZXF1aXJlZFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkgeyByZXR1cm4gX3RoaXMucmVxdWlyZWRQYXJlbnRzW3RhZ05hbWVdID0gdHJ1ZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXBsaWNpdE5hbWVzcGFjZVByZWZpeCA9IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4O1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gbGFuZ18xLmlzUHJlc2VudChjb250ZW50VHlwZSkgPyBjb250ZW50VHlwZSA6IEh0bWxUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBsYW5nXzEubm9ybWFsaXplQm9vbChpZ25vcmVGaXJzdExmKTtcbiAgICB9XG4gICAgSHRtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0aGlzLnJlcXVpcmVkUGFyZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY3VycmVudFBhcmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsY1BhcmVudCA9IGN1cnJlbnRQYXJlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZWRQYXJlbnRzW2xjUGFyZW50XSAhPSB0cnVlICYmIGxjUGFyZW50ICE9ICd0ZW1wbGF0ZSc7XG4gICAgfTtcbiAgICBIdG1sVGFnRGVmaW5pdGlvbi5wcm90b3R5cGUuaXNDbG9zZWRCeUNoaWxkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWb2lkIHx8IGxhbmdfMS5ub3JtYWxpemVCb29sKHRoaXMuY2xvc2VkQnlDaGlsZHJlbltuYW1lLnRvTG93ZXJDYXNlKCldKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sVGFnRGVmaW5pdGlvbjtcbn0oKSk7XG5leHBvcnRzLkh0bWxUYWdEZWZpbml0aW9uID0gSHRtbFRhZ0RlZmluaXRpb247XG4vLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3Ncbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgZnVsbHkgY29uZm9ybSB0byB0aGUgSFRNTDUgc3BlYy5cbnZhciBUQUdfREVGSU5JVElPTlMgPSB7XG4gICAgJ2Jhc2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ21ldGEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2FyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2VtYmVkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdsaW5rJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdpbWcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2lucHV0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdwYXJhbSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnaHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdzb3VyY2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3RyYWNrJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICd3YnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3AnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbXG4gICAgICAgICAgICAnYWRkcmVzcycsXG4gICAgICAgICAgICAnYXJ0aWNsZScsXG4gICAgICAgICAgICAnYXNpZGUnLFxuICAgICAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAnZGwnLFxuICAgICAgICAgICAgJ2ZpZWxkc2V0JyxcbiAgICAgICAgICAgICdmb290ZXInLFxuICAgICAgICAgICAgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2gxJyxcbiAgICAgICAgICAgICdoMicsXG4gICAgICAgICAgICAnaDMnLFxuICAgICAgICAgICAgJ2g0JyxcbiAgICAgICAgICAgICdoNScsXG4gICAgICAgICAgICAnaDYnLFxuICAgICAgICAgICAgJ2hlYWRlcicsXG4gICAgICAgICAgICAnaGdyb3VwJyxcbiAgICAgICAgICAgICdocicsXG4gICAgICAgICAgICAnbWFpbicsXG4gICAgICAgICAgICAnbmF2JyxcbiAgICAgICAgICAgICdvbCcsXG4gICAgICAgICAgICAncCcsXG4gICAgICAgICAgICAncHJlJyxcbiAgICAgICAgICAgICdzZWN0aW9uJyxcbiAgICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAgICAndWwnXG4gICAgICAgIF0sXG4gICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgfSksXG4gICAgJ3RoZWFkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddIH0pLFxuICAgICd0Ym9keSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAndHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RyJ10sXG4gICAgICAgIHJlcXVpcmVkUGFyZW50czogWyd0Ym9keScsICd0Zm9vdCcsICd0aGVhZCddLFxuICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgIH0pLFxuICAgICd0ZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnY29sJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgcmVxdWlyZWRQYXJlbnRzOiBbJ2NvbGdyb3VwJ10sIGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICdtYXRoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdtYXRoJyB9KSxcbiAgICAnbGknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2xpJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAnZGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdyYic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydGMnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncnAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdvcHRpb24nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGlvbicsICdvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncHJlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgJ3N0eWxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IEh0bWxUYWdDb250ZW50VHlwZS5SQVdfVEVYVCB9KSxcbiAgICAnc2NyaXB0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IEh0bWxUYWdDb250ZW50VHlwZS5SQVdfVEVYVCB9KSxcbiAgICAndGl0bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogSHRtbFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCB9KSxcbiAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogSHRtbFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCwgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbn07XG52YXIgREVGQVVMVF9UQUdfREVGSU5JVElPTiA9IG5ldyBIdG1sVGFnRGVmaW5pdGlvbigpO1xuZnVuY3Rpb24gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgIHZhciByZXN1bHQgPSBUQUdfREVGSU5JVElPTlNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXN1bHQpID8gcmVzdWx0IDogREVGQVVMVF9UQUdfREVGSU5JVElPTjtcbn1cbmV4cG9ydHMuZ2V0SHRtbFRhZ0RlZmluaXRpb24gPSBnZXRIdG1sVGFnRGVmaW5pdGlvbjtcbnZhciBOU19QUkVGSVhfUkUgPSAvXkAoW146XSspOiguKykvZztcbmZ1bmN0aW9uIHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKSB7XG4gICAgaWYgKGVsZW1lbnROYW1lWzBdICE9ICdAJykge1xuICAgICAgICByZXR1cm4gW251bGwsIGVsZW1lbnROYW1lXTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChOU19QUkVGSVhfUkUsIGVsZW1lbnROYW1lKTtcbiAgICByZXR1cm4gW21hdGNoWzFdLCBtYXRjaFsyXV07XG59XG5leHBvcnRzLnNwbGl0TnNOYW1lID0gc3BsaXROc05hbWU7XG5mdW5jdGlvbiBnZXROc1ByZWZpeChlbGVtZW50TmFtZSkge1xuICAgIHJldHVybiBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSlbMF07XG59XG5leHBvcnRzLmdldE5zUHJlZml4ID0gZ2V0TnNQcmVmaXg7XG5mdW5jdGlvbiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSkge1xuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHByZWZpeCkgPyBcIkBcIiArIHByZWZpeCArIFwiOlwiICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xufVxuZXhwb3J0cy5tZXJnZU5zQW5kTmFtZSA9IG1lcmdlTnNBbmROYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHRtbF90YWdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGNvcmVfcHJpdmF0ZV8yID0gcmVxdWlyZSgnLi4vY29yZV9wcml2YXRlJyk7XG52YXIgY29tcGlsZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9jb21waWxlX21ldGFkYXRhJyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQVBQX1ZJRVdfTU9EVUxFX1VSTCA9IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlldycpO1xudmFyIFZJRVdfVVRJTFNfTU9EVUxFX1VSTCA9IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlld191dGlscycpO1xudmFyIENEX01PRFVMRV9VUkwgPSB1dGlsXzEuYXNzZXRVcmwoJ2NvcmUnLCAnY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0aW9uJyk7XG4vLyBSZWFzc2lnbiB0aGUgaW1wb3J0cyB0byBkaWZmZXJlbnQgdmFyaWFibGVzIHNvIHdlIGNhblxuLy8gZGVmaW5lIHN0YXRpYyB2YXJpYWJsZXMgd2l0aCB0aGUgbmFtZSBvZiB0aGUgaW1wb3J0LlxuLy8gKG9ubHkgbmVlZGVkIGZvciBEYXJ0KS5cbnZhciBpbXBWaWV3VXRpbHMgPSBjb3JlX3ByaXZhdGVfMi5WaWV3VXRpbHM7XG52YXIgaW1wQXBwVmlldyA9IGNvcmVfcHJpdmF0ZV8yLkFwcFZpZXc7XG52YXIgaW1wRGVidWdBcHBWaWV3ID0gY29yZV9wcml2YXRlXzIuRGVidWdBcHBWaWV3O1xudmFyIGltcERlYnVnQ29udGV4dCA9IGNvcmVfcHJpdmF0ZV8yLkRlYnVnQ29udGV4dDtcbnZhciBpbXBBcHBFbGVtZW50ID0gY29yZV9wcml2YXRlXzIuQXBwRWxlbWVudDtcbnZhciBpbXBFbGVtZW50UmVmID0gY29yZV8xLkVsZW1lbnRSZWY7XG52YXIgaW1wVmlld0NvbnRhaW5lclJlZiA9IGNvcmVfMS5WaWV3Q29udGFpbmVyUmVmO1xudmFyIGltcENoYW5nZURldGVjdG9yUmVmID0gY29yZV8xLkNoYW5nZURldGVjdG9yUmVmO1xudmFyIGltcFJlbmRlckNvbXBvbmVudFR5cGUgPSBjb3JlXzEuUmVuZGVyQ29tcG9uZW50VHlwZTtcbnZhciBpbXBRdWVyeUxpc3QgPSBjb3JlXzEuUXVlcnlMaXN0O1xudmFyIGltcFRlbXBsYXRlUmVmID0gY29yZV8xLlRlbXBsYXRlUmVmO1xudmFyIGltcFRlbXBsYXRlUmVmXyA9IGNvcmVfcHJpdmF0ZV8yLlRlbXBsYXRlUmVmXztcbnZhciBpbXBWYWx1ZVVud3JhcHBlciA9IGNvcmVfcHJpdmF0ZV8yLlZhbHVlVW53cmFwcGVyO1xudmFyIGltcEluamVjdG9yID0gY29yZV8xLkluamVjdG9yO1xudmFyIGltcFZpZXdFbmNhcHN1bGF0aW9uID0gY29yZV8xLlZpZXdFbmNhcHN1bGF0aW9uO1xudmFyIGltcFZpZXdUeXBlID0gY29yZV9wcml2YXRlXzIuVmlld1R5cGU7XG52YXIgaW1wQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBjb3JlXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XG52YXIgaW1wU3RhdGljTm9kZURlYnVnSW5mbyA9IGNvcmVfcHJpdmF0ZV8yLlN0YXRpY05vZGVEZWJ1Z0luZm87XG52YXIgaW1wUmVuZGVyZXIgPSBjb3JlXzEuUmVuZGVyZXI7XG52YXIgaW1wU2ltcGxlQ2hhbmdlID0gY29yZV8xLlNpbXBsZUNoYW5nZTtcbnZhciBpbXBVbmluaXRpYWxpemVkID0gY29yZV9wcml2YXRlXzIudW5pbml0aWFsaXplZDtcbnZhciBpbXBDaGFuZ2VEZXRlY3RvclN0YXRlID0gY29yZV9wcml2YXRlXzIuQ2hhbmdlRGV0ZWN0b3JTdGF0ZTtcbnZhciBpbXBGbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzID0gY29yZV9wcml2YXRlXzIuZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcztcbnZhciBpbXBEZXZNb2RlRXF1YWwgPSBjb3JlX3ByaXZhdGVfMi5kZXZNb2RlRXF1YWw7XG52YXIgaW1wSW50ZXJwb2xhdGUgPSBjb3JlX3ByaXZhdGVfMi5pbnRlcnBvbGF0ZTtcbnZhciBpbXBDaGVja0JpbmRpbmcgPSBjb3JlX3ByaXZhdGVfMi5jaGVja0JpbmRpbmc7XG52YXIgaW1wQ2FzdEJ5VmFsdWUgPSBjb3JlX3ByaXZhdGVfMi5jYXN0QnlWYWx1ZTtcbnZhciBpbXBFTVBUWV9BUlJBWSA9IGNvcmVfcHJpdmF0ZV8yLkVNUFRZX0FSUkFZO1xudmFyIGltcEVNUFRZX01BUCA9IGNvcmVfcHJpdmF0ZV8yLkVNUFRZX01BUDtcbnZhciBJZGVudGlmaWVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWRlbnRpZmllcnMoKSB7XG4gICAgfVxuICAgIElkZW50aWZpZXJzLlZpZXdVdGlscyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdWaWV3VXRpbHMnLCBtb2R1bGVVcmw6IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlld191dGlscycpLCBydW50aW1lOiBpbXBWaWV3VXRpbHMgfSk7XG4gICAgSWRlbnRpZmllcnMuQXBwVmlldyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdBcHBWaWV3JywgbW9kdWxlVXJsOiBBUFBfVklFV19NT0RVTEVfVVJMLCBydW50aW1lOiBpbXBBcHBWaWV3IH0pO1xuICAgIElkZW50aWZpZXJzLkRlYnVnQXBwVmlldyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdEZWJ1Z0FwcFZpZXcnLCBtb2R1bGVVcmw6IEFQUF9WSUVXX01PRFVMRV9VUkwsIHJ1bnRpbWU6IGltcERlYnVnQXBwVmlldyB9KTtcbiAgICBJZGVudGlmaWVycy5BcHBFbGVtZW50ID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ0FwcEVsZW1lbnQnLCBtb2R1bGVVcmw6IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdsaW5rZXIvZWxlbWVudCcpLCBydW50aW1lOiBpbXBBcHBFbGVtZW50IH0pO1xuICAgIElkZW50aWZpZXJzLkVsZW1lbnRSZWYgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoe1xuICAgICAgICBuYW1lOiAnRWxlbWVudFJlZicsXG4gICAgICAgIG1vZHVsZVVybDogdXRpbF8xLmFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9lbGVtZW50X3JlZicpLFxuICAgICAgICBydW50aW1lOiBpbXBFbGVtZW50UmVmXG4gICAgfSk7XG4gICAgSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZiA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7XG4gICAgICAgIG5hbWU6ICdWaWV3Q29udGFpbmVyUmVmJyxcbiAgICAgICAgbW9kdWxlVXJsOiB1dGlsXzEuYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZicpLFxuICAgICAgICBydW50aW1lOiBpbXBWaWV3Q29udGFpbmVyUmVmXG4gICAgfSk7XG4gICAgSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoe1xuICAgICAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JSZWYnLFxuICAgICAgICBtb2R1bGVVcmw6IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdjaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rvcl9yZWYnKSxcbiAgICAgICAgcnVudGltZTogaW1wQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgICB9KTtcbiAgICBJZGVudGlmaWVycy5SZW5kZXJDb21wb25lbnRUeXBlID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogJ1JlbmRlckNvbXBvbmVudFR5cGUnLFxuICAgICAgICBtb2R1bGVVcmw6IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdyZW5kZXIvYXBpJyksXG4gICAgICAgIHJ1bnRpbWU6IGltcFJlbmRlckNvbXBvbmVudFR5cGVcbiAgICB9KTtcbiAgICBJZGVudGlmaWVycy5RdWVyeUxpc3QgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiAnUXVlcnlMaXN0JywgbW9kdWxlVXJsOiB1dGlsXzEuYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3F1ZXJ5X2xpc3QnKSwgcnVudGltZTogaW1wUXVlcnlMaXN0IH0pO1xuICAgIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogJ1RlbXBsYXRlUmVmJyxcbiAgICAgICAgbW9kdWxlVXJsOiB1dGlsXzEuYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3RlbXBsYXRlX3JlZicpLFxuICAgICAgICBydW50aW1lOiBpbXBUZW1wbGF0ZVJlZlxuICAgIH0pO1xuICAgIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmXyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7XG4gICAgICAgIG5hbWU6ICdUZW1wbGF0ZVJlZl8nLFxuICAgICAgICBtb2R1bGVVcmw6IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdsaW5rZXIvdGVtcGxhdGVfcmVmJyksXG4gICAgICAgIHJ1bnRpbWU6IGltcFRlbXBsYXRlUmVmX1xuICAgIH0pO1xuICAgIElkZW50aWZpZXJzLlZhbHVlVW53cmFwcGVyID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ1ZhbHVlVW53cmFwcGVyJywgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLCBydW50aW1lOiBpbXBWYWx1ZVVud3JhcHBlciB9KTtcbiAgICBJZGVudGlmaWVycy5JbmplY3RvciA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdJbmplY3RvcicsIG1vZHVsZVVybDogdXRpbF8xLmFzc2V0VXJsKCdjb3JlJywgJ2RpL2luamVjdG9yJyksIHJ1bnRpbWU6IGltcEluamVjdG9yIH0pO1xuICAgIElkZW50aWZpZXJzLlZpZXdFbmNhcHN1bGF0aW9uID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogJ1ZpZXdFbmNhcHN1bGF0aW9uJyxcbiAgICAgICAgbW9kdWxlVXJsOiB1dGlsXzEuYXNzZXRVcmwoJ2NvcmUnLCAnbWV0YWRhdGEvdmlldycpLFxuICAgICAgICBydW50aW1lOiBpbXBWaWV3RW5jYXBzdWxhdGlvblxuICAgIH0pO1xuICAgIElkZW50aWZpZXJzLlZpZXdUeXBlID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ1ZpZXdUeXBlJywgbW9kdWxlVXJsOiB1dGlsXzEuYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfdHlwZScpLCBydW50aW1lOiBpbXBWaWV3VHlwZSB9KTtcbiAgICBJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7XG4gICAgICAgIG5hbWU6ICdDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneScsXG4gICAgICAgIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCxcbiAgICAgICAgcnVudGltZTogaW1wQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbiAgICB9KTtcbiAgICBJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogJ1N0YXRpY05vZGVEZWJ1Z0luZm8nLFxuICAgICAgICBtb2R1bGVVcmw6IHV0aWxfMS5hc3NldFVybCgnY29yZScsICdsaW5rZXIvZGVidWdfY29udGV4dCcpLFxuICAgICAgICBydW50aW1lOiBpbXBTdGF0aWNOb2RlRGVidWdJbmZvXG4gICAgfSk7XG4gICAgSWRlbnRpZmllcnMuRGVidWdDb250ZXh0ID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogJ0RlYnVnQ29udGV4dCcsXG4gICAgICAgIG1vZHVsZVVybDogdXRpbF8xLmFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9kZWJ1Z19jb250ZXh0JyksXG4gICAgICAgIHJ1bnRpbWU6IGltcERlYnVnQ29udGV4dFxuICAgIH0pO1xuICAgIElkZW50aWZpZXJzLlJlbmRlcmVyID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ1JlbmRlcmVyJywgbW9kdWxlVXJsOiB1dGlsXzEuYXNzZXRVcmwoJ2NvcmUnLCAncmVuZGVyL2FwaScpLCBydW50aW1lOiBpbXBSZW5kZXJlciB9KTtcbiAgICBJZGVudGlmaWVycy5TaW1wbGVDaGFuZ2UgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiAnU2ltcGxlQ2hhbmdlJywgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLCBydW50aW1lOiBpbXBTaW1wbGVDaGFuZ2UgfSk7XG4gICAgSWRlbnRpZmllcnMudW5pbml0aWFsaXplZCA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICd1bmluaXRpYWxpemVkJywgbW9kdWxlVXJsOiBDRF9NT0RVTEVfVVJMLCBydW50aW1lOiBpbXBVbmluaXRpYWxpemVkIH0pO1xuICAgIElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yU3RhdGUgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JTdGF0ZScsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogaW1wQ2hhbmdlRGV0ZWN0b3JTdGF0ZSB9KTtcbiAgICBJZGVudGlmaWVycy5jaGVja0JpbmRpbmcgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiAnY2hlY2tCaW5kaW5nJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IGltcENoZWNrQmluZGluZyB9KTtcbiAgICBJZGVudGlmaWVycy5mbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogJ2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMnLFxuICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgcnVudGltZTogaW1wRmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlc1xuICAgIH0pO1xuICAgIElkZW50aWZpZXJzLmRldk1vZGVFcXVhbCA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdkZXZNb2RlRXF1YWwnLCBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsIHJ1bnRpbWU6IGltcERldk1vZGVFcXVhbCB9KTtcbiAgICBJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdpbnRlcnBvbGF0ZScsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiBpbXBJbnRlcnBvbGF0ZSB9KTtcbiAgICBJZGVudGlmaWVycy5jYXN0QnlWYWx1ZSA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdjYXN0QnlWYWx1ZScsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiBpbXBDYXN0QnlWYWx1ZSB9KTtcbiAgICBJZGVudGlmaWVycy5FTVBUWV9BUlJBWSA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6ICdFTVBUWV9BUlJBWScsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiBpbXBFTVBUWV9BUlJBWSB9KTtcbiAgICBJZGVudGlmaWVycy5FTVBUWV9NQVAgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiAnRU1QVFlfTUFQJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IGltcEVNUFRZX01BUCB9KTtcbiAgICBJZGVudGlmaWVycy5wdXJlUHJveGllcyA9IFtcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTEnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5MSB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTInLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5MiB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTMnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5MyB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTQnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5NCB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTUnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5NSB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTYnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5NiB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTcnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5NyB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTgnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5OCB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTknLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogY29yZV9wcml2YXRlXzIucHVyZVByb3h5OSB9KSxcbiAgICAgICAgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogJ3B1cmVQcm94eTEwJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IGNvcmVfcHJpdmF0ZV8yLnB1cmVQcm94eTEwIH0pLFxuICAgIF07XG4gICAgSWRlbnRpZmllcnMuU2VjdXJpdHlDb250ZXh0ID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogJ1NlY3VyaXR5Q29udGV4dCcsXG4gICAgICAgIG1vZHVsZVVybDogdXRpbF8xLmFzc2V0VXJsKCdjb3JlJywgJ3NlY3VyaXR5JyksXG4gICAgICAgIHJ1bnRpbWU6IGNvcmVfcHJpdmF0ZV8xLlNlY3VyaXR5Q29udGV4dCxcbiAgICB9KTtcbiAgICByZXR1cm4gSWRlbnRpZmllcnM7XG59KCkpO1xuZXhwb3J0cy5JZGVudGlmaWVycyA9IElkZW50aWZpZXJzO1xuZnVuY3Rpb24gaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlVG9rZW5NZXRhZGF0YSh7IGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfSk7XG59XG5leHBvcnRzLmlkZW50aWZpZXJUb2tlbiA9IGlkZW50aWZpZXJUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkZW50aWZpZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvcmVfcHJpdmF0ZV8xID0gcmVxdWlyZSgnLi4vY29yZV9wcml2YXRlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY3BsID0gcmVxdWlyZSgnLi9jb21waWxlX21ldGFkYXRhJyk7XG52YXIgZGlyZWN0aXZlX3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZV9yZXNvbHZlcicpO1xudmFyIHBpcGVfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vcGlwZV9yZXNvbHZlcicpO1xudmFyIHZpZXdfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vdmlld19yZXNvbHZlcicpO1xudmFyIGRpcmVjdGl2ZV9saWZlY3ljbGVfcmVmbGVjdG9yXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZV9saWZlY3ljbGVfcmVmbGVjdG9yJyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYXNzZXJ0aW9uc18xID0gcmVxdWlyZSgnLi9hc3NlcnRpb25zJyk7XG52YXIgdXJsX3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL3VybF9yZXNvbHZlcicpO1xudmFyIGNvcmVfcHJpdmF0ZV8yID0gcmVxdWlyZShcIi4uL2NvcmVfcHJpdmF0ZVwiKTtcbnZhciBDb21waWxlTWV0YWRhdGFSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoX2RpcmVjdGl2ZVJlc29sdmVyLCBfcGlwZVJlc29sdmVyLCBfdmlld1Jlc29sdmVyLCBfcGxhdGZvcm1EaXJlY3RpdmVzLCBfcGxhdGZvcm1QaXBlcywgX3JlZmxlY3Rvcikge1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciA9IF9kaXJlY3RpdmVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fcGlwZVJlc29sdmVyID0gX3BpcGVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fdmlld1Jlc29sdmVyID0gX3ZpZXdSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1EaXJlY3RpdmVzID0gX3BsYXRmb3JtRGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1QaXBlcyA9IF9wbGF0Zm9ybVBpcGVzO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hbm9ueW1vdXNUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYW5vbnltb3VzVHlwZUluZGV4ID0gMDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3JlZmxlY3RvcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBjb3JlXzEucmVmbGVjdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5zYW5pdGl6ZVRva2VuTmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IGxhbmdfMS5zdHJpbmdpZnkodG9rZW4pO1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAgICAgLy8gY2FzZTogYW5vbnltb3VzIGZ1bmN0aW9ucyFcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHRoaXMuX2Fub255bW91c1R5cGVzLmdldCh0b2tlbik7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoZm91bmQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5vbnltb3VzVHlwZXMuc2V0KHRva2VuLCB0aGlzLl9hbm9ueW1vdXNUeXBlSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLl9hbm9ueW1vdXNUeXBlcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRlbnRpZmllciA9IFwiYW5vbnltb3VzX3Rva2VuX1wiICsgZm91bmQgKyBcIl9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbF8xLnNhbml0aXplSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBtZXRhID0gdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZ2V0KGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWV0YSkpIHtcbiAgICAgICAgICAgIHZhciBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIucmVzb2x2ZShkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU1ldGEgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB2aWV3UHJvdmlkZXJzID0gW107XG4gICAgICAgICAgICB2YXIgbW9kdWxlVXJsID0gc3RhdGljVHlwZU1vZHVsZVVybChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgIGlmIChkaXJNZXRhIGluc3RhbmNlb2YgY29yZV8xLkNvbXBvbmVudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0aW9uc18xLmFzc2VydEFycmF5T2ZTdHJpbmdzKCdzdHlsZXMnLCBkaXJNZXRhLnN0eWxlcyk7XG4gICAgICAgICAgICAgICAgdmFyIGNtcE1ldGEgPSBkaXJNZXRhO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3TWV0YSA9IHRoaXMuX3ZpZXdSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgIGFzc2VydGlvbnNfMS5hc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVzJywgdmlld01ldGEuc3R5bGVzKTtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZU1ldGEgPSBuZXcgY3BsLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdmlld01ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHZpZXdNZXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogdmlld01ldGEudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogdmlld01ldGEuc3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVVybHM6IHZpZXdNZXRhLnN0eWxlVXJsc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gY21wTWV0YS5jaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGlyTWV0YS52aWV3UHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzID0gdGhpcy5nZXRQcm92aWRlcnNNZXRhZGF0YShkaXJNZXRhLnZpZXdQcm92aWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2R1bGVVcmwgPSBjb21wb25lbnRNb2R1bGVVcmwodGhpcy5fcmVmbGVjdG9yLCBkaXJlY3RpdmVUeXBlLCBjbXBNZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRpck1ldGEucHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVycyA9IHRoaXMuZ2V0UHJvdmlkZXJzTWV0YWRhdGEoZGlyTWV0YS5wcm92aWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciB2aWV3UXVlcmllcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGlyTWV0YS5xdWVyaWVzKSkge1xuICAgICAgICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLmdldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2aWV3UXVlcmllcyA9IHRoaXMuZ2V0UXVlcmllc01ldGFkYXRhKGRpck1ldGEucXVlcmllcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhID0gY3BsLkNvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJNZXRhLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJNZXRhLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgIGlzQ29tcG9uZW50OiBsYW5nXzEuaXNQcmVzZW50KHRlbXBsYXRlTWV0YSksXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRUeXBlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSwgbW9kdWxlVXJsKSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVNZXRhLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBkaXJNZXRhLmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBkaXJNZXRhLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdDogZGlyTWV0YS5ob3N0LFxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBjb3JlX3ByaXZhdGVfMS5MSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gZGlyZWN0aXZlX2xpZmVjeWNsZV9yZWZsZWN0b3JfMS5oYXNMaWZlY3ljbGVIb29rKGhvb2ssIGRpcmVjdGl2ZVR5cGUpOyB9KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB2aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzb21lVHlwZSBhIHN5bWJvbCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBhIGRpcmVjdGl2ZSB0eXBlXG4gICAgICogQHJldHVybnMge2NwbC5Db21waWxlRGlyZWN0aXZlTWV0YWRhdGF9IGlmIHBvc3NpYmxlLCBvdGhlcndpc2UgbnVsbC5cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUubWF5YmVHZXREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChzb21lVHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoc29tZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5tZXNzYWdlLmluZGV4T2YoJ05vIERpcmVjdGl2ZSBhbm5vdGF0aW9uJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0VHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIG1vZHVsZVVybCkge1xuICAgICAgICByZXR1cm4gbmV3IGNwbC5Db21waWxlVHlwZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuc2FuaXRpemVUb2tlbk5hbWUodHlwZSksXG4gICAgICAgICAgICBtb2R1bGVVcmw6IG1vZHVsZVVybCxcbiAgICAgICAgICAgIHJ1bnRpbWU6IHR5cGUsXG4gICAgICAgICAgICBkaURlcHM6IHRoaXMuZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEodHlwZSwgbnVsbClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RmFjdG9yeU1ldGFkYXRhID0gZnVuY3Rpb24gKGZhY3RvcnksIG1vZHVsZVVybCkge1xuICAgICAgICByZXR1cm4gbmV3IGNwbC5Db21waWxlRmFjdG9yeU1ldGFkYXRhKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuc2FuaXRpemVUb2tlbk5hbWUoZmFjdG9yeSksXG4gICAgICAgICAgICBtb2R1bGVVcmw6IG1vZHVsZVVybCxcbiAgICAgICAgICAgIHJ1bnRpbWU6IGZhY3RvcnksXG4gICAgICAgICAgICBkaURlcHM6IHRoaXMuZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEoZmFjdG9yeSwgbnVsbClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciBtZXRhID0gdGhpcy5fcGlwZUNhY2hlLmdldChwaXBlVHlwZSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtZXRhKSkge1xuICAgICAgICAgICAgdmFyIHBpcGVNZXRhID0gdGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUocGlwZVR5cGUpO1xuICAgICAgICAgICAgbWV0YSA9IG5ldyBjcGwuQ29tcGlsZVBpcGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRUeXBlTWV0YWRhdGEocGlwZVR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwocGlwZVR5cGUpKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBwaXBlTWV0YS5uYW1lLFxuICAgICAgICAgICAgICAgIHB1cmU6IHBpcGVNZXRhLnB1cmUsXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IGNvcmVfcHJpdmF0ZV8xLkxJRkVDWUNMRV9IT09LU19WQUxVRVMuZmlsdGVyKGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBkaXJlY3RpdmVfbGlmZWN5Y2xlX3JlZmxlY3Rvcl8xLmhhc0xpZmVjeWNsZUhvb2soaG9vaywgcGlwZVR5cGUpOyB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcGlwZUNhY2hlLnNldChwaXBlVHlwZSwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0Vmlld0RpcmVjdGl2ZXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3UmVzb2x2ZXIucmVzb2x2ZShjb21wb25lbnQpO1xuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGZsYXR0ZW5EaXJlY3RpdmVzKHZpZXcsIHRoaXMuX3BsYXRmb3JtRGlyZWN0aXZlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShkaXJlY3RpdmVzW2ldKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVuZXhwZWN0ZWQgZGlyZWN0aXZlIHZhbHVlICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoZGlyZWN0aXZlc1tpXSkgKyBcIicgb24gdGhlIFZpZXcgb2YgY29tcG9uZW50ICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoY29tcG9uZW50KSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLmdldERpcmVjdGl2ZU1ldGFkYXRhKHR5cGUpOyB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRWaWV3UGlwZXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3UmVzb2x2ZXIucmVzb2x2ZShjb21wb25lbnQpO1xuICAgICAgICB2YXIgcGlwZXMgPSBmbGF0dGVuUGlwZXModmlldywgdGhpcy5fcGxhdGZvcm1QaXBlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUocGlwZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5leHBlY3RlZCBwaXBlZCB2YWx1ZSAnXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHBpcGVzW2ldKSArIFwiJyBvbiB0aGUgVmlldyBvZiBjb21wb25lbnQgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShjb21wb25lbnQpICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLmdldFBpcGVNZXRhZGF0YSh0eXBlKTsgfSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJhbXMgPSBsYW5nXzEuaXNQcmVzZW50KGRlcGVuZGVuY2llcykgPyBkZXBlbmRlbmNpZXMgOiB0aGlzLl9yZWZsZWN0b3IucGFyYW1ldGVycyh0eXBlT3JGdW5jKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmFtcykpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzQXR0cmlidXRlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNIb3N0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNTa2lwU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdmlld1F1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1cbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBjb3JlXzEuSG9zdE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0hvc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBjb3JlXzEuU2VsZk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBjb3JlXzEuU2tpcFNlbGZNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTa2lwU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIGNvcmVfMS5PcHRpb25hbE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgY29yZV8xLkF0dHJpYnV0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgY29yZV8xLlF1ZXJ5TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbUVudHJ5LmlzVmlld1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1F1ZXJ5ID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgY29yZV8xLkluamVjdE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZFR5cGUocGFyYW1FbnRyeSkgJiYgbGFuZ18xLmlzQmxhbmsodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNwbC5Db21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlOiBpc0F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgICAgICBpc1NlbGY6IGlzU2VsZixcbiAgICAgICAgICAgICAgICBpc1NraXBTZWxmOiBpc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGxhbmdfMS5pc1ByZXNlbnQocXVlcnkpID8gX3RoaXMuZ2V0UXVlcnlNZXRhZGF0YShxdWVyeSwgbnVsbCkgOiBudWxsLFxuICAgICAgICAgICAgICAgIHZpZXdRdWVyeTogbGFuZ18xLmlzUHJlc2VudCh2aWV3UXVlcnkpID8gX3RoaXMuZ2V0UXVlcnlNZXRhZGF0YSh2aWV3UXVlcnksIG51bGwpIDogbnVsbCxcbiAgICAgICAgICAgICAgICB0b2tlbjogX3RoaXMuZ2V0VG9rZW5NZXRhZGF0YSh0b2tlbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRUb2tlbk1ldGFkYXRhID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHRva2VuID0gY29yZV8xLnJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgdmFyIGNvbXBpbGVUb2tlbjtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1N0cmluZyh0b2tlbikpIHtcbiAgICAgICAgICAgIGNvbXBpbGVUb2tlbiA9IG5ldyBjcGwuQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21waWxlVG9rZW4gPSBuZXcgY3BsLkNvbXBpbGVUb2tlbk1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBuZXcgY3BsLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgICBydW50aW1lOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5zYW5pdGl6ZVRva2VuTmFtZSh0b2tlbiksXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVVybDogc3RhdGljVHlwZU1vZHVsZVVybCh0b2tlbilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVUb2tlbjtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQcm92aWRlcnNNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IGNvcmVfMS5yZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlcik7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQXJyYXkocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFByb3ZpZGVyc01ldGFkYXRhKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgY29yZV8xLlByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFByb3ZpZGVyTWV0YWRhdGEocHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29yZV9wcml2YXRlXzIuaXNQcm92aWRlckxpdGVyYWwocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFByb3ZpZGVyTWV0YWRhdGEoY29yZV9wcml2YXRlXzIuY3JlYXRlUHJvdmlkZXIocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUeXBlTWV0YWRhdGEocHJvdmlkZXIsIHN0YXRpY1R5cGVNb2R1bGVVcmwocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgY29tcGlsZURlcHM7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgY29tcGlsZURlcHMgPSB0aGlzLmdldERlcGVuZGVuY2llc01ldGFkYXRhKHByb3ZpZGVyLnVzZUNsYXNzLCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgIGNvbXBpbGVEZXBzID0gdGhpcy5nZXREZXBlbmRlbmNpZXNNZXRhZGF0YShwcm92aWRlci51c2VGYWN0b3J5LCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY3BsLkNvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmdldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXIudXNlQ2xhc3MpID9cbiAgICAgICAgICAgICAgICB0aGlzLmdldFR5cGVNZXRhZGF0YShwcm92aWRlci51c2VDbGFzcywgc3RhdGljVHlwZU1vZHVsZVVybChwcm92aWRlci51c2VDbGFzcykpIDpcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdXNlVmFsdWU6IGNvbnZlcnRUb0NvbXBpbGVWYWx1ZShwcm92aWRlci51c2VWYWx1ZSksXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpID9cbiAgICAgICAgICAgICAgICB0aGlzLmdldEZhY3RvcnlNZXRhZGF0YShwcm92aWRlci51c2VGYWN0b3J5LCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyLnVzZUZhY3RvcnkpKSA6XG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSA/IHRoaXMuZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci51c2VFeGlzdGluZykgOlxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBkZXBzOiBjb21waWxlRGVwcyxcbiAgICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRRdWVyaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAocXVlcmllcywgaXNWaWV3UXVlcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbXBpbGVRdWVyaWVzID0gW107XG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2gocXVlcmllcywgZnVuY3Rpb24gKHF1ZXJ5LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeS5pc1ZpZXdRdWVyeSA9PT0gaXNWaWV3UXVlcnkpIHtcbiAgICAgICAgICAgICAgICBjb21waWxlUXVlcmllcy5wdXNoKF90aGlzLmdldFF1ZXJ5TWV0YWRhdGEocXVlcnksIHByb3BlcnR5TmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVRdWVyaWVzO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFF1ZXJ5TWV0YWRhdGEgPSBmdW5jdGlvbiAocSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICAgIGlmIChxLmlzVmFyQmluZGluZ1F1ZXJ5KSB7XG4gICAgICAgICAgICBzZWxlY3RvcnMgPSBxLnZhckJpbmRpbmdzLm1hcChmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gX3RoaXMuZ2V0VG9rZW5NZXRhZGF0YSh2YXJOYW1lKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RvcnMgPSBbdGhpcy5nZXRUb2tlbk1ldGFkYXRhKHEuc2VsZWN0b3IpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNwbC5Db21waWxlUXVlcnlNZXRhZGF0YSh7XG4gICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9ycyxcbiAgICAgICAgICAgIGZpcnN0OiBxLmZpcnN0LFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHEuZGVzY2VuZGFudHMsXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHJlYWQ6IGxhbmdfMS5pc1ByZXNlbnQocS5yZWFkKSA/IHRoaXMuZ2V0VG9rZW5NZXRhZGF0YShxLnJlYWQpIDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGRpcmVjdGl2ZV9yZXNvbHZlcl8xLkRpcmVjdGl2ZVJlc29sdmVyLCB9LFxuICAgICAgICB7IHR5cGU6IHBpcGVfcmVzb2x2ZXJfMS5QaXBlUmVzb2x2ZXIsIH0sXG4gICAgICAgIHsgdHlwZTogdmlld19yZXNvbHZlcl8xLlZpZXdSZXNvbHZlciwgfSxcbiAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5PcHRpb25hbCB9LCB7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFtjb3JlXzEuUExBVEZPUk1fRElSRUNUSVZFUyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLk9wdGlvbmFsIH0sIHsgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW2NvcmVfMS5QTEFURk9STV9QSVBFUyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfcHJpdmF0ZV8xLlJlZmxlY3RvclJlYWRlciwgfSxcbiAgICBdO1xuICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVNZXRhZGF0YVJlc29sdmVyID0gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXI7XG5mdW5jdGlvbiBmbGF0dGVuRGlyZWN0aXZlcyh2aWV3LCBwbGF0Zm9ybURpcmVjdGl2ZXMpIHtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBsYXRmb3JtRGlyZWN0aXZlcykpIHtcbiAgICAgICAgZmxhdHRlbkFycmF5KHBsYXRmb3JtRGlyZWN0aXZlcywgZGlyZWN0aXZlcyk7XG4gICAgfVxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZpZXcuZGlyZWN0aXZlcykpIHtcbiAgICAgICAgZmxhdHRlbkFycmF5KHZpZXcuZGlyZWN0aXZlcywgZGlyZWN0aXZlcyk7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3RpdmVzO1xufVxuZnVuY3Rpb24gZmxhdHRlblBpcGVzKHZpZXcsIHBsYXRmb3JtUGlwZXMpIHtcbiAgICB2YXIgcGlwZXMgPSBbXTtcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwbGF0Zm9ybVBpcGVzKSkge1xuICAgICAgICBmbGF0dGVuQXJyYXkocGxhdGZvcm1QaXBlcywgcGlwZXMpO1xuICAgIH1cbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh2aWV3LnBpcGVzKSkge1xuICAgICAgICBmbGF0dGVuQXJyYXkodmlldy5waXBlcywgcGlwZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZXM7XG59XG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkodHJlZSwgb3V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gY29yZV8xLnJlc29sdmVGb3J3YXJkUmVmKHRyZWVbaV0pO1xuICAgICAgICBpZiAobGFuZ18xLmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BcnJheShpdGVtLCBvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpY1R5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gbGFuZ18xLmlzU3RyaW5nTWFwKHZhbHVlKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZhbHVlWyduYW1lJ10pICYmIGxhbmdfMS5pc1ByZXNlbnQodmFsdWVbJ2ZpbGVQYXRoJ10pO1xufVxuZnVuY3Rpb24gaXNWYWxpZFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdGF0aWNUeXBlKHZhbHVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBsYW5nXzEuVHlwZSk7XG59XG5mdW5jdGlvbiBzdGF0aWNUeXBlTW9kdWxlVXJsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU3RhdGljVHlwZSh2YWx1ZSkgPyB2YWx1ZVsnZmlsZVBhdGgnXSA6IG51bGw7XG59XG5mdW5jdGlvbiBjb21wb25lbnRNb2R1bGVVcmwocmVmbGVjdG9yLCB0eXBlLCBjbXBNZXRhZGF0YSkge1xuICAgIGlmIChpc1N0YXRpY1R5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRpY1R5cGVNb2R1bGVVcmwodHlwZSk7XG4gICAgfVxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNtcE1ldGFkYXRhLm1vZHVsZUlkKSkge1xuICAgICAgICB2YXIgbW9kdWxlSWQgPSBjbXBNZXRhZGF0YS5tb2R1bGVJZDtcbiAgICAgICAgdmFyIHNjaGVtZSA9IHVybF9yZXNvbHZlcl8xLmdldFVybFNjaGVtZShtb2R1bGVJZCk7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHNjaGVtZSkgJiYgc2NoZW1lLmxlbmd0aCA+IDAgPyBtb2R1bGVJZCA6XG4gICAgICAgICAgICBcInBhY2thZ2U6XCIgKyBtb2R1bGVJZCArIHV0aWxfMS5NT0RVTEVfU1VGRklYO1xuICAgIH1cbiAgICByZXR1cm4gcmVmbGVjdG9yLmltcG9ydFVyaSh0eXBlKTtcbn1cbi8vIE9ubHkgZmlsbCBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhLnJ1bnRpbWUgaWYgbmVlZGVkLi4uXG5mdW5jdGlvbiBjb252ZXJ0VG9Db21waWxlVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbF8xLnZpc2l0VmFsdWUodmFsdWUsIG5ldyBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCksIG51bGwpO1xufVxudmFyIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfQ29tcGlsZVZhbHVlQ29udmVydGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBfQ29tcGlsZVZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc1N0YXRpY1R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNwbC5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogdmFsdWVbJ25hbWUnXSwgbW9kdWxlVXJsOiBzdGF0aWNUeXBlTW9kdWxlVXJsKHZhbHVlKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3BsLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBydW50aW1lOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9Db21waWxlVmFsdWVDb252ZXJ0ZXI7XG59KHV0aWxfMS5WYWx1ZVRyYW5zZm9ybWVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YV9yZXNvbHZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgY29tcGlsZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9jb21waWxlX21ldGFkYXRhJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbyA9IHJlcXVpcmUoJy4vb3V0cHV0L291dHB1dF9hc3QnKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBfQ09NUE9ORU5UX0ZBQ1RPUllfSURFTlRJRklFUiA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7XG4gICAgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnknLFxuICAgIHJ1bnRpbWU6IGNvcmVfMS5Db21wb25lbnRGYWN0b3J5LFxuICAgIG1vZHVsZVVybDogdXRpbF8xLmFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9jb21wb25lbnRfZmFjdG9yeScpXG59KTtcbnZhciBTb3VyY2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNvdXJjZU1vZHVsZShtb2R1bGVVcmwsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiBTb3VyY2VNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5Tb3VyY2VNb2R1bGUgPSBTb3VyY2VNb2R1bGU7XG52YXIgU3R5bGVTaGVldFNvdXJjZVdpdGhJbXBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZVNoZWV0U291cmNlV2l0aEltcG9ydHMoc291cmNlLCBpbXBvcnRlZFVybHMpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuaW1wb3J0ZWRVcmxzID0gaW1wb3J0ZWRVcmxzO1xuICAgIH1cbiAgICByZXR1cm4gU3R5bGVTaGVldFNvdXJjZVdpdGhJbXBvcnRzO1xufSgpKTtcbmV4cG9ydHMuU3R5bGVTaGVldFNvdXJjZVdpdGhJbXBvcnRzID0gU3R5bGVTaGVldFNvdXJjZVdpdGhJbXBvcnRzO1xudmFyIE5vcm1hbGl6ZWRDb21wb25lbnRXaXRoVmlld0RpcmVjdGl2ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vcm1hbGl6ZWRDb21wb25lbnRXaXRoVmlld0RpcmVjdGl2ZXMoY29tcG9uZW50LCBkaXJlY3RpdmVzLCBwaXBlcykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xuICAgIH1cbiAgICByZXR1cm4gTm9ybWFsaXplZENvbXBvbmVudFdpdGhWaWV3RGlyZWN0aXZlcztcbn0oKSk7XG5leHBvcnRzLk5vcm1hbGl6ZWRDb21wb25lbnRXaXRoVmlld0RpcmVjdGl2ZXMgPSBOb3JtYWxpemVkQ29tcG9uZW50V2l0aFZpZXdEaXJlY3RpdmVzO1xudmFyIE9mZmxpbmVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2ZmbGluZUNvbXBpbGVyKF9kaXJlY3RpdmVOb3JtYWxpemVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfb3V0cHV0RW1pdHRlciwgX3hocikge1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyID0gX2RpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX291dHB1dEVtaXR0ZXIgPSBfb3V0cHV0RW1pdHRlcjtcbiAgICAgICAgdGhpcy5feGhyID0gX3hocjtcbiAgICB9XG4gICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5ub3JtYWxpemVEaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIubm9ybWFsaXplRGlyZWN0aXZlKGRpcmVjdGl2ZSk7XG4gICAgfTtcbiAgICBPZmZsaW5lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVUZW1wbGF0ZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignTm8gY29tcG9uZW50cyBnaXZlbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIHZhciBleHBvcnRlZFZhcnMgPSBbXTtcbiAgICAgICAgdmFyIG1vZHVsZVVybCA9IF90ZW1wbGF0ZU1vZHVsZVVybChjb21wb25lbnRzWzBdLmNvbXBvbmVudCk7XG4gICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50V2l0aERpcnMpIHtcbiAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IGNvbXBvbmVudFdpdGhEaXJzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIF9hc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgdmFyIGNvbXBWaWV3RmFjdG9yeVZhciA9IF90aGlzLl9jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhLCBjb21wb25lbnRXaXRoRGlycy5kaXJlY3RpdmVzLCBjb21wb25lbnRXaXRoRGlycy5waXBlcywgc3RhdGVtZW50cyk7XG4gICAgICAgICAgICBleHBvcnRlZFZhcnMucHVzaChjb21wVmlld0ZhY3RvcnlWYXIpO1xuICAgICAgICAgICAgdmFyIGhvc3RNZXRhID0gY29tcGlsZV9tZXRhZGF0YV8xLmNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhLnR5cGUsIGNvbXBNZXRhLnNlbGVjdG9yKTtcbiAgICAgICAgICAgIHZhciBob3N0Vmlld0ZhY3RvcnlWYXIgPSBfdGhpcy5fY29tcGlsZUNvbXBvbmVudChob3N0TWV0YSwgW2NvbXBNZXRhXSwgW10sIHN0YXRlbWVudHMpO1xuICAgICAgICAgICAgdmFyIGNvbXBGYWN0b3J5VmFyID0gY29tcE1ldGEudHlwZS5uYW1lICsgXCJOZ0ZhY3RvcnlcIjtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChvLnZhcmlhYmxlKGNvbXBGYWN0b3J5VmFyKVxuICAgICAgICAgICAgICAgIC5zZXQoby5pbXBvcnRFeHByKF9DT01QT05FTlRfRkFDVE9SWV9JREVOVElGSUVSLCBbby5pbXBvcnRUeXBlKGNvbXBNZXRhLnR5cGUpXSlcbiAgICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICAgIG8ubGl0ZXJhbChjb21wTWV0YS5zZWxlY3RvciksXG4gICAgICAgICAgICAgICAgby52YXJpYWJsZShob3N0Vmlld0ZhY3RvcnlWYXIpLFxuICAgICAgICAgICAgICAgIG8uaW1wb3J0RXhwcihjb21wTWV0YS50eXBlKVxuICAgICAgICAgICAgXSwgby5pbXBvcnRUeXBlKF9DT01QT05FTlRfRkFDVE9SWV9JREVOVElGSUVSLCBbby5pbXBvcnRUeXBlKGNvbXBNZXRhLnR5cGUpXSwgW28uVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtvLlN0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgICAgICAgIGV4cG9ydGVkVmFycy5wdXNoKGNvbXBGYWN0b3J5VmFyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKG1vZHVsZVVybCwgc3RhdGVtZW50cywgZXhwb3J0ZWRWYXJzKTtcbiAgICB9O1xuICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUubG9hZEFuZENvbXBpbGVTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKHN0eWxlc2hlZXRVcmwsIHNoaW0sIHN1ZmZpeCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5feGhyLmdldChzdHlsZXNoZWV0VXJsKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZVN0eWxlc2hlZXQoc3R5bGVzaGVldFVybCwgY3NzVGV4dCwgc2hpbSk7XG4gICAgICAgICAgICB2YXIgaW1wb3J0ZWRVcmxzID0gW107XG4gICAgICAgICAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRlZFVybHMucHVzaChkZXAubW9kdWxlVXJsKTtcbiAgICAgICAgICAgICAgICBkZXAudmFsdWVQbGFjZWhvbGRlci5tb2R1bGVVcmwgPSBfc3R5bGVzTW9kdWxlVXJsKGRlcC5tb2R1bGVVcmwsIGRlcC5pc1NoaW1tZWQsIHN1ZmZpeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3R5bGVTaGVldFNvdXJjZVdpdGhJbXBvcnRzKF90aGlzLl9jb2RnZW5TdHlsZXMoc3R5bGVzaGVldFVybCwgc2hpbSwgc3VmZml4LCBjb21waWxlUmVzdWx0KSwgaW1wb3J0ZWRVcmxzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPZmZsaW5lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBkaXJlY3RpdmVzLCBwaXBlcywgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICB2YXIgc3R5bGVSZXN1bHQgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICB2YXIgcGFyc2VkVGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBjb21wTWV0YS50eXBlLm5hbWUpO1xuICAgICAgICB2YXIgdmlld1Jlc3VsdCA9IHRoaXMuX3ZpZXdDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgby52YXJpYWJsZShzdHlsZVJlc3VsdC5zdHlsZXNWYXIpLCBwaXBlcyk7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5hZGRBbGwodGFyZ2V0U3RhdGVtZW50cywgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHMoY29tcE1ldGEudHlwZS5tb2R1bGVVcmwsIHN0eWxlUmVzdWx0KSk7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5hZGRBbGwodGFyZ2V0U3RhdGVtZW50cywgX3Jlc29sdmVWaWV3U3RhdGVtZW50cyh2aWV3UmVzdWx0KSk7XG4gICAgICAgIHJldHVybiB2aWV3UmVzdWx0LnZpZXdGYWN0b3J5VmFyO1xuICAgIH07XG4gICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29kZ2VuU3R5bGVzID0gZnVuY3Rpb24gKGlucHV0VXJsLCBzaGltLCBzdWZmaXgsIHN0eWxlc0NvbXBpbGVSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoX3N0eWxlc01vZHVsZVVybChpbnB1dFVybCwgc2hpbSwgc3VmZml4KSwgc3R5bGVzQ29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzLCBbc3R5bGVzQ29tcGlsZVJlc3VsdC5zdHlsZXNWYXJdKTtcbiAgICB9O1xuICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvZGVnZW5Tb3VyY2VNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVXJsLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VNb2R1bGUobW9kdWxlVXJsLCB0aGlzLl9vdXRwdXRFbWl0dGVyLmVtaXRTdGF0ZW1lbnRzKG1vZHVsZVVybCwgc3RhdGVtZW50cywgZXhwb3J0ZWRWYXJzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2ZmbGluZUNvbXBpbGVyO1xufSgpKTtcbmV4cG9ydHMuT2ZmbGluZUNvbXBpbGVyID0gT2ZmbGluZUNvbXBpbGVyO1xuZnVuY3Rpb24gX3Jlc29sdmVWaWV3U3RhdGVtZW50cyhjb21waWxlUmVzdWx0KSB7XG4gICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7IGRlcC5mYWN0b3J5UGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX3RlbXBsYXRlTW9kdWxlVXJsKGRlcC5jb21wKTsgfSk7XG4gICAgcmV0dXJuIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cztcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKGNvbnRhaW5pbmdNb2R1bGVVcmwsIGNvbXBpbGVSZXN1bHQpIHtcbiAgICB2YXIgY29udGFpbmluZ1N1ZmZpeCA9IF9zcGxpdFN1ZmZpeChjb250YWluaW5nTW9kdWxlVXJsKVsxXTtcbiAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIubW9kdWxlVXJsID1cbiAgICAgICAgICAgIF9zdHlsZXNNb2R1bGVVcmwoZGVwLm1vZHVsZVVybCwgZGVwLmlzU2hpbW1lZCwgY29udGFpbmluZ1N1ZmZpeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cztcbn1cbmZ1bmN0aW9uIF90ZW1wbGF0ZU1vZHVsZVVybChjb21wKSB7XG4gICAgdmFyIHVybFdpdGhTdWZmaXggPSBfc3BsaXRTdWZmaXgoY29tcC50eXBlLm1vZHVsZVVybCk7XG4gICAgcmV0dXJuIHVybFdpdGhTdWZmaXhbMF0gKyBcIi5uZ2ZhY3RvcnlcIiArIHVybFdpdGhTdWZmaXhbMV07XG59XG5mdW5jdGlvbiBfc3R5bGVzTW9kdWxlVXJsKHN0eWxlc2hlZXRVcmwsIHNoaW0sIHN1ZmZpeCkge1xuICAgIHJldHVybiBzaGltID8gc3R5bGVzaGVldFVybCArIFwiLnNoaW1cIiArIHN1ZmZpeCA6IFwiXCIgKyBzdHlsZXNoZWV0VXJsICsgc3VmZml4O1xufVxuZnVuY3Rpb24gX2Fzc2VydENvbXBvbmVudChtZXRhKSB7XG4gICAgaWYgKCFtZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNvdWxkIG5vdCBjb21waWxlICdcIiArIG1ldGEudHlwZS5uYW1lICsgXCInIGJlY2F1c2UgaXQgaXMgbm90IGEgY29tcG9uZW50LlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfc3BsaXRTdWZmaXgocGF0aCkge1xuICAgIHZhciBsYXN0RG90ID0gcGF0aC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChsYXN0RG90ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gW3BhdGguc3Vic3RyaW5nKDAsIGxhc3REb3QpLCBwYXRoLnN1YnN0cmluZyhsYXN0RG90KV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3BhdGgsICcnXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZmZsaW5lX2NvbXBpbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIG8gPSByZXF1aXJlKCcuL291dHB1dF9hc3QnKTtcbnZhciBfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUgPSAvJ3xcXFxcfFxcbnxcXHJ8XFwkL2c7XG5leHBvcnRzLkNBVENIX0VSUk9SX1ZBUiA9IG8udmFyaWFibGUoJ2Vycm9yJyk7XG5leHBvcnRzLkNBVENIX1NUQUNLX1ZBUiA9IG8udmFyaWFibGUoJ3N0YWNrJyk7XG52YXIgT3V0cHV0RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3V0cHV0RW1pdHRlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIE91dHB1dEVtaXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5PdXRwdXRFbWl0dGVyID0gT3V0cHV0RW1pdHRlcjtcbnZhciBfRW1pdHRlZExpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9FbWl0dGVkTGluZShpbmRlbnQpIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIF9FbWl0dGVkTGluZTtcbn0oKSk7XG52YXIgRW1pdHRlclZpc2l0b3JDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWl0dGVyVmlzaXRvckNvbnRleHQoX2V4cG9ydGVkVmFycywgX2luZGVudCkge1xuICAgICAgICB0aGlzLl9leHBvcnRlZFZhcnMgPSBfZXhwb3J0ZWRWYXJzO1xuICAgICAgICB0aGlzLl9pbmRlbnQgPSBfaW5kZW50O1xuICAgICAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgIH1cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIChleHBvcnRlZFZhcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbWl0dGVyVmlzaXRvckNvbnRleHQoZXhwb3J0ZWRWYXJzLCAwKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcIl9jdXJyZW50TGluZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuaXNFeHBvcnRlZFZhciA9IGZ1bmN0aW9uICh2YXJOYW1lKSB7IHJldHVybiB0aGlzLl9leHBvcnRlZFZhcnMuaW5kZXhPZih2YXJOYW1lKSAhPT0gLTE7IH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludGxuID0gZnVuY3Rpb24gKGxhc3RQYXJ0KSB7XG4gICAgICAgIGlmIChsYXN0UGFydCA9PT0gdm9pZCAwKSB7IGxhc3RQYXJ0ID0gJyc7IH1cbiAgICAgICAgdGhpcy5wcmludChsYXN0UGFydCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmxpbmVJc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudExpbmUucGFydHMubGVuZ3RoID09PSAwOyB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiAocGFydCwgbmV3TGluZSkge1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wdXNoKG5ldyBfRW1pdHRlZExpbmUodGhpcy5faW5kZW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlRW1wdHlMYXN0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZUlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuaW5jSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQrKztcbiAgICAgICAgdGhpcy5fY3VycmVudExpbmUuaW5kZW50ID0gdGhpcy5faW5kZW50O1xuICAgIH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5kZWNJbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luZGVudC0tO1xuICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnB1c2hDbGFzcyA9IGZ1bmN0aW9uIChjbGF6eikgeyB0aGlzLl9jbGFzc2VzLnB1c2goY2xhenopOyB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucG9wQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFzc2VzLnBvcCgpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcImN1cnJlbnRDbGFzc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMubGVuZ3RoID4gMCA/IHRoaXMuX2NsYXNzZXNbdGhpcy5fY2xhc3Nlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICBpZiAobGluZXNbbGluZXMubGVuZ3RoIC0gMV0ucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIGxpbmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLnBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZUluZGVudChsaW5lLmluZGVudCkgKyBsaW5lLnBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgcmV0dXJuIEVtaXR0ZXJWaXNpdG9yQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLkVtaXR0ZXJWaXNpdG9yQ29udGV4dCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dDtcbnZhciBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKF9lc2NhcGVEb2xsYXJJblN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzID0gX2VzY2FwZURvbGxhckluU3RyaW5ncztcbiAgICB9XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbignOycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KFwicmV0dXJuIFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KFwiaWYgKFwiKTtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIikge1wiKTtcbiAgICAgICAgdmFyIGhhc0Vsc2VDYXNlID0gbGFuZ18xLmlzUHJlc2VudChzdG10LmZhbHNlQ2FzZSkgJiYgc3RtdC5mYWxzZUNhc2UubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHN0bXQudHJ1ZUNhc2UubGVuZ3RoIDw9IDEgJiYgIWhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZW1vdmVFbXB0eUxhc3RMaW5lKCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBpZiAoaGFzRWxzZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihcIn0gZWxzZSB7XCIpO1xuICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoXCJ0aHJvdyBcIik7XG4gICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgbGluZXMgPSBzdG10LmNvbW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7IGN0eC5wcmludGxuKFwiLy8gXCIgKyBsaW5lKTsgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludCgnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludCgnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIltcIik7XG4gICAgICAgIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIl0gPSBcIik7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KFwiLlwiICsgZXhwci5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIG5hbWUgPSBleHByLm5hbWU7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGV4cHIuYnVpbHRpbikpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLmdldEJ1aWx0aW5NZXRob2ROYW1lKGV4cHIuYnVpbHRpbik7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lIGJ1aWx0aW5zIGp1c3QgbWVhbiB0byBza2lwIHRoZSBjYWxsLlxuICAgICAgICAgICAgICAgIC8vIGUuZy4gYGJpbmRgIGluIERhcnQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KFwiLlwiICsgbmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCBcIixcIik7XG4gICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciB2YXJOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFzdC5idWlsdGluKSkge1xuICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVmFyLlN1cGVyOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gJ3N1cGVyJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5WYXIuVGhpczpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9ICd0aGlzJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IGV4cG9ydHMuQ0FUQ0hfRVJST1JfVkFSLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVmFyLkNhdGNoU3RhY2s6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBleHBvcnRzLkNBVENIX1NUQUNLX1ZBUi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbmtub3duIGJ1aWx0aW4gdmFyaWFibGUgXCIgKyBhc3QuYnVpbHRpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KHZhck5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChcIm5ldyBcIik7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICBpZiAobGFuZ18xLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGVzY2FwZVNpbmdsZVF1b3RlU3RyaW5nKHZhbHVlLCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludCgnbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50KFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoXCIoXCIpO1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoJz8gJyk7XG4gICAgICAgIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KCc6ICcpO1xuICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoJyEnKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5JZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICchPT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLkFuZDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnfHwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnKyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuTWludXM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnLSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyonO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLk1vZHVsbzpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICclJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuQmlnZ2VyOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIiBcIiArIG9wU3RyICsgXCIgXCIpO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KFwiLlwiKTtcbiAgICAgICAgY3R4LnByaW50KGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KFwiW1wiKTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoXCJdXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgIGN0eC5wcmludChcIltcIiwgdXNlTmV3TGluZSk7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgsICcsJywgdXNlTmV3TGluZSk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KFwiXVwiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1c2VOZXdMaW5lID0gYXN0LmVudHJpZXMubGVuZ3RoID4gMTtcbiAgICAgICAgY3R4LnByaW50KFwie1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChlc2NhcGVTaW5nbGVRdW90ZVN0cmluZyhlbnRyeVswXSwgX3RoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncykgKyBcIjogXCIpO1xuICAgICAgICAgICAgZW50cnlbMV0udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpO1xuICAgICAgICB9LCBhc3QuZW50cmllcywgY3R4LCAnLCcsIHVzZU5ld0xpbmUpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChcIn1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxPYmplY3RzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSkge1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoc2VwYXJhdG9yLCBuZXdMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIoZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICBjdHgucHJpbnRsbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY3R4KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RFbWl0dGVyVmlzaXRvcjtcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0RW1pdHRlclZpc2l0b3IgPSBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yO1xuZnVuY3Rpb24gZXNjYXBlU2luZ2xlUXVvdGVTdHJpbmcoaW5wdXQsIGVzY2FwZURvbGxhcikge1xuICAgIGlmIChsYW5nXzEuaXNCbGFuayhpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBib2R5ID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgX1NJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKG1hdGNoWzBdID09ICckJykge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZURvbGxhciA/ICdcXFxcJCcgOiAnJCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXHInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIG1hdGNoWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFwiJ1wiICsgYm9keSArIFwiJ1wiO1xufVxuZXhwb3J0cy5lc2NhcGVTaW5nbGVRdW90ZVN0cmluZyA9IGVzY2FwZVNpbmdsZVF1b3RlU3RyaW5nO1xuZnVuY3Rpb24gX2NyZWF0ZUluZGVudChjb3VudCkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcmVzICs9ICcgICc7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdF9lbWl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgbyA9IHJlcXVpcmUoJy4vb3V0cHV0X2FzdCcpO1xudmFyIGFic3RyYWN0X2VtaXR0ZXJfMSA9IHJlcXVpcmUoJy4vYWJzdHJhY3RfZW1pdHRlcicpO1xudmFyIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGN0eC5wdXNoQ2xhc3Moc3RtdCk7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvcihzdG10LCBjdHgpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdG10LnBhcmVudCkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFwiKTtcbiAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50bG4oXCIucHJvdG90eXBlKTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoc3RtdCwgZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2Qoc3RtdCwgbWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN0bXQuY29uc3RydWN0b3JNZXRob2QpKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihcInZhciBzZWxmID0gdGhpcztcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0dldHRlciA9IGZ1bmN0aW9uIChzdG10LCBnZXR0ZXIsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnRsbihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcIiArIHN0bXQubmFtZSArIFwiLnByb3RvdHlwZSwgJ1wiICsgZ2V0dGVyLm5hbWUgKyBcIicsIHsgZ2V0OiBmdW5jdGlvbigpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgaWYgKGdldHRlci5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9fSk7XCIpO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChzdG10LCBtZXRob2QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdC5uYW1lICsgXCIucHJvdG90eXBlLlwiICsgbWV0aG9kLm5hbWUgKyBcIiA9IGZ1bmN0aW9uKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMobWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgaWYgKG1ldGhvZC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9O1wiKTtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBpZiAoYXN0LmJ1aWx0aW4gPT09IG8uQnVpbHRpblZhci5UaGlzKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoJ3NlbGYnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuYnVpbHRpbiA9PT0gby5CdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCInc3VwZXInIG5lZWRzIHRvIGJlIGhhbmRsZWQgYXQgYSBwYXJlbnQgYXN0IG5vZGUsIG5vdCBhdCB0aGUgdmFyaWFibGUgbGV2ZWwhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoXCJ2YXIgXCIgKyBzdG10Lm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIGZuRXhwciA9IGV4cHIuZm47XG4gICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBvLlJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBvLkJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgIGN0eC5jdXJyZW50Q2xhc3MucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50KFwiLmNhbGwodGhpc1wiKTtcbiAgICAgICAgICAgIGlmIChleHByLmFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChcIiwgXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByLmNhbGwodGhpcywgZXhwciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KFwiZnVuY3Rpb24oXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnQoXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ0cnkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn0gY2F0Y2ggKFwiICsgYWJzdHJhY3RfZW1pdHRlcl8xLkNBVENIX0VSUk9SX1ZBUi5uYW1lICsgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdmFyIGNhdGNoU3RtdHMgPSBbXG4gICAgICAgICAgICBhYnN0cmFjdF9lbWl0dGVyXzEuQ0FUQ0hfU1RBQ0tfVkFSLnNldChhYnN0cmFjdF9lbWl0dGVyXzEuQ0FUQ0hfRVJST1JfVkFSLnByb3AoJ3N0YWNrJykpXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW28uU3RtdE1vZGlmaWVyLkZpbmFsXSlcbiAgICAgICAgXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBjdHgucHJpbnQocGFyYW0ubmFtZSk7IH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIG8uQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG8uQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluTWV0aG9kLmJpbmQ6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdiaW5kJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5rbm93biBidWlsdGluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcjtcbn0oYWJzdHJhY3RfZW1pdHRlcl8xLkFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcbmV4cG9ydHMuQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yID0gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3RfanNfZW1pdHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIG8gPSByZXF1aXJlKCcuL291dHB1dF9hc3QnKTtcbnZhciBhYnN0cmFjdF9lbWl0dGVyXzEgPSByZXF1aXJlKCcuL2Fic3RyYWN0X2VtaXR0ZXInKTtcbnZhciBfZGVidWdNb2R1bGVVcmwgPSAnYXNzZXQ6Ly9kZWJ1Zy9saWInO1xuZnVuY3Rpb24gZGVidWdPdXRwdXRBc3RBc0RhcnQoYXN0KSB7XG4gICAgdmFyIGNvbnZlcnRlciA9IG5ldyBfRGFydEVtaXR0ZXJWaXNpdG9yKF9kZWJ1Z01vZHVsZVVybCk7XG4gICAgdmFyIGN0eCA9IGFic3RyYWN0X2VtaXR0ZXJfMS5FbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdChbXSk7XG4gICAgdmFyIGFzdHM7XG4gICAgaWYgKGxhbmdfMS5pc0FycmF5KGFzdCkpIHtcbiAgICAgICAgYXN0cyA9IGFzdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzdHMgPSBbYXN0XTtcbiAgICB9XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIG8uU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBhc3QudmlzaXRTdGF0ZW1lbnQoY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIG8uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgYXN0LnZpc2l0RXhwcmVzc2lvbihjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0IGluc3RhbmNlb2Ygby5UeXBlKSB7XG4gICAgICAgICAgICBhc3QudmlzaXRUeXBlKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkRvbid0IGtub3cgaG93IHRvIHByaW50IGRlYnVnIGluZm8gZm9yIFwiICsgYXN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjdHgudG9Tb3VyY2UoKTtcbn1cbmV4cG9ydHMuZGVidWdPdXRwdXRBc3RBc0RhcnQgPSBkZWJ1Z091dHB1dEFzdEFzRGFydDtcbnZhciBEYXJ0RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGFydEVtaXR0ZXIoX2ltcG9ydEdlbmVyYXRvcikge1xuICAgICAgICB0aGlzLl9pbXBvcnRHZW5lcmF0b3IgPSBfaW1wb3J0R2VuZXJhdG9yO1xuICAgIH1cbiAgICBEYXJ0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHMgPSBmdW5jdGlvbiAobW9kdWxlVXJsLCBzdG10cywgZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzcmNQYXJ0cyA9IFtdO1xuICAgICAgICAvLyBOb3RlOiBXZSBhcmUgbm90IGNyZWF0aW5nIGEgbGlicmFyeSBoZXJlIGFzIERhcnQgZG9lcyBub3QgbmVlZCBpdC5cbiAgICAgICAgLy8gRGFydCBhbmFsenllciBtaWdodCBjb21wbGFpbiBhYm91dCBpdCB0aG91Z2guXG4gICAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgX0RhcnRFbWl0dGVyVmlzaXRvcihtb2R1bGVVcmwpO1xuICAgICAgICB2YXIgY3R4ID0gYWJzdHJhY3RfZW1pdHRlcl8xLkVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KGV4cG9ydGVkVmFycyk7XG4gICAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RtdHMsIGN0eCk7XG4gICAgICAgIGNvbnZlcnRlci5pbXBvcnRzV2l0aFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCwgaW1wb3J0ZWRNb2R1bGVVcmwpIHtcbiAgICAgICAgICAgIHNyY1BhcnRzLnB1c2goXCJpbXBvcnQgJ1wiICsgX3RoaXMuX2ltcG9ydEdlbmVyYXRvci5nZXRJbXBvcnRQYXRoKG1vZHVsZVVybCwgaW1wb3J0ZWRNb2R1bGVVcmwpICsgXCInIGFzIFwiICsgcHJlZml4ICsgXCI7XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3JjUGFydHMucHVzaChjdHgudG9Tb3VyY2UoKSk7XG4gICAgICAgIHJldHVybiBzcmNQYXJ0cy5qb2luKCdcXG4nKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXJ0RW1pdHRlcjtcbn0oKSk7XG5leHBvcnRzLkRhcnRFbWl0dGVyID0gRGFydEVtaXR0ZXI7XG52YXIgX0RhcnRFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9EYXJ0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0RhcnRFbWl0dGVyVmlzaXRvcihfbW9kdWxlVXJsKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHRydWUpO1xuICAgICAgICB0aGlzLl9tb2R1bGVVcmwgPSBfbW9kdWxlVXJsO1xuICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIF9EYXJ0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9EYXJ0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKG8uU3RtdE1vZGlmaWVyLkZpbmFsKSkge1xuICAgICAgICAgICAgaWYgKGlzQ29uc3RUeXBlKHN0bXQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoXCJjb25zdCBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoXCJmaW5hbCBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzQmxhbmsoc3RtdC50eXBlKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwidmFyIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdG10LnR5cGUpKSB7XG4gICAgICAgICAgICBzdG10LnR5cGUudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10Lm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9EYXJ0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoXCIgYXMgXCIpO1xuICAgICAgICBhc3QudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfRGFydEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGN0eC5wdXNoQ2xhc3Moc3RtdCk7XG4gICAgICAgIGN0eC5wcmludChcImNsYXNzIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3RtdC5wYXJlbnQpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCIgZXh0ZW5kcyBcIik7XG4gICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHN0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0ZpZWxkKGZpZWxkLCBjdHgpOyB9KTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvcihzdG10LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHN0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzR2V0dGVyKGdldHRlciwgY3R4KTsgfSk7XG4gICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzTWV0aG9kKG1ldGhvZCwgY3R4KTsgfSk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICBjdHgucG9wQ2xhc3MoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfRGFydEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0ZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCBjdHgpIHtcbiAgICAgICAgaWYgKGZpZWxkLmhhc01vZGlmaWVyKG8uU3RtdE1vZGlmaWVyLkZpbmFsKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwiZmluYWwgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc0JsYW5rKGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCJ2YXIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICBmaWVsZC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50KFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihmaWVsZC5uYW1lICsgXCI7XCIpO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZ2V0dGVyLnR5cGUpKSB7XG4gICAgICAgICAgICBnZXR0ZXIudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oXCJnZXQgXCIgKyBnZXR0ZXIubmFtZSArIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgIHZhciBjdG9yU3RtdHMgPSBzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHk7XG4gICAgICAgIHZhciBzdXBlckN0b3JFeHByID0gY3RvclN0bXRzLmxlbmd0aCA+IDAgPyBnZXRTdXBlckNvbnN0cnVjdG9yQ2FsbEV4cHIoY3RvclN0bXRzWzBdKSA6IG51bGw7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN1cGVyQ3RvckV4cHIpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCI6IFwiKTtcbiAgICAgICAgICAgIHN1cGVyQ3RvckV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICBjdG9yU3RtdHMgPSBjdG9yU3RtdHMuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oXCIge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjdG9yU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kLCBjdHgpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWV0aG9kLnR5cGUpKSB7XG4gICAgICAgICAgICBtZXRob2QudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcInZvaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KFwiIFwiICsgbWV0aG9kLm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICB9O1xuICAgIF9EYXJ0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKGFzdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdG10LnR5cGUpKSB7XG4gICAgICAgICAgICBzdG10LnR5cGUudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCJ2b2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChcIiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICcuYWRkQWxsJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdsaXN0ZW4nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5NZXRob2QuYmluZDpcbiAgICAgICAgICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5rbm93biBidWlsdGluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9IGNhdGNoIChcIiArIGFic3RyYWN0X2VtaXR0ZXJfMS5DQVRDSF9FUlJPUl9WQVIubmFtZSArIFwiLCBcIiArIGFic3RyYWN0X2VtaXR0ZXJfMS5DQVRDSF9TVEFDS19WQVIubmFtZSArIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5JZGVudGljYWw6XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KFwiaWRlbnRpY2FsKFwiKTtcbiAgICAgICAgICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KFwiIWlkZW50aWNhbChcIik7XG4gICAgICAgICAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfRGFydEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGlzQ29uc3RUeXBlKGFzdC50eXBlKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwiY29uc3QgXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICB9O1xuICAgIF9EYXJ0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGlzQ29uc3RUeXBlKGFzdC50eXBlKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwiY29uc3QgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFzdC52YWx1ZVR5cGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCI8U3RyaW5nLCBcIik7XG4gICAgICAgICAgICBhc3QudmFsdWVUeXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50KFwiPlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGlzQ29uc3RUeXBlKGFzdC50eXBlKSA/IFwiY29uc3RcIiA6IFwibmV3XCIpO1xuICAgICAgICBjdHgucHJpbnQoJyAnKTtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsIFwiLFwiKTtcbiAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfRGFydEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgdmFyIHR5cGVTdHI7XG4gICAgICAgIHN3aXRjaCAodHlwZS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIG8uQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdib29sJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVHlwZU5hbWUuRHluYW1pYzpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2R5bmFtaWMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbjpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVHlwZU5hbWUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVHlwZU5hbWUuSW50OlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnaW50JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVHlwZU5hbWUuU3RyaW5nOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnU3RyaW5nJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgYnVpbHRpbiB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQodHlwZVN0cik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbFR5cGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhpcy5fdmlzaXRJZGVudGlmaWVyKGFzdC52YWx1ZSwgYXN0LnR5cGVQYXJhbXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX0RhcnRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBcnJheVR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChcIkxpc3Q8XCIpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0eXBlLm9mKSkge1xuICAgICAgICAgICAgdHlwZS5vZi52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcImR5bmFtaWNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KFwiPlwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfRGFydEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1hcFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChcIk1hcDxTdHJpbmcsIFwiKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHlwZS52YWx1ZVR5cGUpKSB7XG4gICAgICAgICAgICB0eXBlLnZhbHVlVHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcImR5bmFtaWNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KFwiPlwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfRGFydEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJhbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLnR5cGUudmlzaXRUeXBlKF90aGlzLCBjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5wcmludCgnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnByaW50KHBhcmFtLm5hbWUpO1xuICAgICAgICB9LCBwYXJhbXMsIGN0eCwgJywnKTtcbiAgICB9O1xuICAgIF9EYXJ0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdElkZW50aWZpZXIgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGVQYXJhbXMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkludGVybmFsIGVycm9yOiB1bmtub3duIGlkZW50aWZpZXIgXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFsdWUubW9kdWxlVXJsKSAmJiB2YWx1ZS5tb2R1bGVVcmwgIT0gdGhpcy5fbW9kdWxlVXJsKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLmdldCh2YWx1ZS5tb2R1bGVVcmwpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcImltcG9ydFwiICsgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNldCh2YWx1ZS5tb2R1bGVVcmwsIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQocHJlZml4ICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludCh2YWx1ZS5uYW1lKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHlwZVBhcmFtcykgJiYgdHlwZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCI8XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUudmlzaXRUeXBlKF90aGlzLCBjdHgpOyB9LCB0eXBlUGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCI+XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX0RhcnRFbWl0dGVyVmlzaXRvcjtcbn0oYWJzdHJhY3RfZW1pdHRlcl8xLkFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcbmZ1bmN0aW9uIGdldFN1cGVyQ29uc3RydWN0b3JDYWxsRXhwcihzdG10KSB7XG4gICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBvLkV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBzdG10LmV4cHI7XG4gICAgICAgIGlmIChleHByIGluc3RhbmNlb2Ygby5JbnZva2VGdW5jdGlvbkV4cHIpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGV4cHIuZm47XG4gICAgICAgICAgICBpZiAoZm4gaW5zdGFuY2VvZiBvLlJlYWRWYXJFeHByKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuLmJ1aWx0aW4gPT09IG8uQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0NvbnN0VHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodHlwZSkgJiYgdHlwZS5oYXNNb2RpZmllcihvLlR5cGVNb2RpZmllci5Db25zdCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXJ0X2VtaXR0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uLy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIEludGVycHJldGl2ZUFwcFZpZXdJbnN0YW5jZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVycHJldGl2ZUFwcFZpZXdJbnN0YW5jZUZhY3RvcnkoKSB7XG4gICAgfVxuICAgIEludGVycHJldGl2ZUFwcFZpZXdJbnN0YW5jZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHN1cGVyQ2xhc3MsIGNsYXp6LCBhcmdzLCBwcm9wcywgZ2V0dGVycywgbWV0aG9kcykge1xuICAgICAgICBpZiAoc3VwZXJDbGFzcyA9PT0gY29yZV9wcml2YXRlXzEuQXBwVmlldykge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGFsd2F5cyB1c2luZyBEZWJ1Z0FwcFZpZXcgYXMgcGFyZW50LlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgaW4gcHJvZCBtb2RlIHdlIGdlbmVyYXRlIGEgY29uc3RydWN0b3IgY2FsbCB0aGF0IGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBoYXZlIHRoZSBhcmd1bWVudCBmb3IgdGhlIGRlYnVnTm9kZUluZm9zLlxuICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtudWxsXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9JbnRlcnByZXRpdmVBcHBWaWV3KGFyZ3MsIHByb3BzLCBnZXR0ZXJzLCBtZXRob2RzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdXBlckNsYXNzID09PSBjb3JlX3ByaXZhdGVfMS5EZWJ1Z0FwcFZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX0ludGVycHJldGl2ZUFwcFZpZXcoYXJncywgcHJvcHMsIGdldHRlcnMsIG1ldGhvZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbid0IGluc3RhbnRpYXRlIGNsYXNzIFwiICsgc3VwZXJDbGFzcyArIFwiIGluIGludGVycHJldGF0aXZlIG1vZGVcIik7XG4gICAgfTtcbiAgICByZXR1cm4gSW50ZXJwcmV0aXZlQXBwVmlld0luc3RhbmNlRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLkludGVycHJldGl2ZUFwcFZpZXdJbnN0YW5jZUZhY3RvcnkgPSBJbnRlcnByZXRpdmVBcHBWaWV3SW5zdGFuY2VGYWN0b3J5O1xudmFyIF9JbnRlcnByZXRpdmVBcHBWaWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX0ludGVycHJldGl2ZUFwcFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0ludGVycHJldGl2ZUFwcFZpZXcoYXJncywgcHJvcHMsIGdldHRlcnMsIG1ldGhvZHMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSwgYXJnc1s3XSk7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5nZXR0ZXJzID0gZ2V0dGVycztcbiAgICAgICAgdGhpcy5tZXRob2RzID0gbWV0aG9kcztcbiAgICB9XG4gICAgX0ludGVycHJldGl2ZUFwcFZpZXcucHJvdG90eXBlLmNyZWF0ZUludGVybmFsID0gZnVuY3Rpb24gKHJvb3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgbSA9IHRoaXMubWV0aG9kcy5nZXQoJ2NyZWF0ZUludGVybmFsJyk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbShyb290U2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlSW50ZXJuYWwuY2FsbCh0aGlzLCByb290U2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfSW50ZXJwcmV0aXZlQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3JHZXRJbnRlcm5hbCA9IGZ1bmN0aW9uICh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMubWV0aG9kcy5nZXQoJ2luamVjdG9yR2V0SW50ZXJuYWwnKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmluamVjdG9yR2V0LmNhbGwodGhpcywgdG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfSW50ZXJwcmV0aXZlQXBwVmlldy5wcm90b3R5cGUuZGVzdHJveUludGVybmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMubWV0aG9kcy5nZXQoJ2Rlc3Ryb3lJbnRlcm5hbCcpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3lJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfSW50ZXJwcmV0aXZlQXBwVmlldy5wcm90b3R5cGUuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5tZXRob2RzLmdldCgnZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwnKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfSW50ZXJwcmV0aXZlQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0ludGVybmFsID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1ldGhvZHMuZ2V0KCdkZXRlY3RDaGFuZ2VzSW50ZXJuYWwnKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtKHRocm93T25DaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0ludGVybmFsLmNhbGwodGhpcywgdGhyb3dPbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfSW50ZXJwcmV0aXZlQXBwVmlldztcbn0oY29yZV9wcml2YXRlXzEuRGVidWdBcHBWaWV3KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnByZXRpdmVfdmlldy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xuLy8vLyBUeXBlc1xuKGZ1bmN0aW9uIChUeXBlTW9kaWZpZXIpIHtcbiAgICBUeXBlTW9kaWZpZXJbVHlwZU1vZGlmaWVyW1wiQ29uc3RcIl0gPSAwXSA9IFwiQ29uc3RcIjtcbn0pKGV4cG9ydHMuVHlwZU1vZGlmaWVyIHx8IChleHBvcnRzLlR5cGVNb2RpZmllciA9IHt9KSk7XG52YXIgVHlwZU1vZGlmaWVyID0gZXhwb3J0cy5UeXBlTW9kaWZpZXI7XG52YXIgVHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZShtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtb2RpZmllcnMpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFR5cGUucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIFR5cGU7XG59KCkpO1xuZXhwb3J0cy5UeXBlID0gVHlwZTtcbihmdW5jdGlvbiAoQnVpbHRpblR5cGVOYW1lKSB7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkR5bmFtaWNcIl0gPSAwXSA9IFwiRHluYW1pY1wiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJCb29sXCJdID0gMV0gPSBcIkJvb2xcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiU3RyaW5nXCJdID0gMl0gPSBcIlN0cmluZ1wiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJJbnRcIl0gPSAzXSA9IFwiSW50XCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIk51bWJlclwiXSA9IDRdID0gXCJOdW1iZXJcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRnVuY3Rpb25cIl0gPSA1XSA9IFwiRnVuY3Rpb25cIjtcbn0pKGV4cG9ydHMuQnVpbHRpblR5cGVOYW1lIHx8IChleHBvcnRzLkJ1aWx0aW5UeXBlTmFtZSA9IHt9KSk7XG52YXIgQnVpbHRpblR5cGVOYW1lID0gZXhwb3J0cy5CdWlsdGluVHlwZU5hbWU7XG52YXIgQnVpbHRpblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWlsdGluVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWlsdGluVHlwZShuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgQnVpbHRpblR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QnVpbHRpbnRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJ1aWx0aW5UeXBlO1xufShUeXBlKSk7XG5leHBvcnRzLkJ1aWx0aW5UeXBlID0gQnVpbHRpblR5cGU7XG52YXIgRXh0ZXJuYWxUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXh0ZXJuYWxUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4dGVybmFsVHlwZSh2YWx1ZSwgdHlwZVBhcmFtcywgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgIH1cbiAgICBFeHRlcm5hbFR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXh0ZXJuYWxUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVybmFsVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5FeHRlcm5hbFR5cGUgPSBFeHRlcm5hbFR5cGU7XG52YXIgQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5VHlwZShvZiwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMub2YgPSBvZjtcbiAgICB9XG4gICAgQXJyYXlUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFycmF5VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheVR5cGU7XG59KFR5cGUpKTtcbmV4cG9ydHMuQXJyYXlUeXBlID0gQXJyYXlUeXBlO1xudmFyIE1hcFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFR5cGUodmFsdWVUeXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGU7XG4gICAgfVxuICAgIE1hcFR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0TWFwVHlwZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gTWFwVHlwZTtcbn0oVHlwZSkpO1xuZXhwb3J0cy5NYXBUeXBlID0gTWFwVHlwZTtcbmV4cG9ydHMuRFlOQU1JQ19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljKTtcbmV4cG9ydHMuQk9PTF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Cb29sKTtcbmV4cG9ydHMuSU5UX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkludCk7XG5leHBvcnRzLk5VTUJFUl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXIpO1xuZXhwb3J0cy5TVFJJTkdfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuU3RyaW5nKTtcbmV4cG9ydHMuRlVOQ1RJT05fVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb24pO1xuLy8vLy8gRXhwcmVzc2lvbnNcbihmdW5jdGlvbiAoQmluYXJ5T3BlcmF0b3IpIHtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkVxdWFsc1wiXSA9IDBdID0gXCJFcXVhbHNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk5vdEVxdWFsc1wiXSA9IDFdID0gXCJOb3RFcXVhbHNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIklkZW50aWNhbFwiXSA9IDJdID0gXCJJZGVudGljYWxcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk5vdElkZW50aWNhbFwiXSA9IDNdID0gXCJOb3RJZGVudGljYWxcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk1pbnVzXCJdID0gNF0gPSBcIk1pbnVzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJQbHVzXCJdID0gNV0gPSBcIlBsdXNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkRpdmlkZVwiXSA9IDZdID0gXCJEaXZpZGVcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk11bHRpcGx5XCJdID0gN10gPSBcIk11bHRpcGx5XCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNb2R1bG9cIl0gPSA4XSA9IFwiTW9kdWxvXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJBbmRcIl0gPSA5XSA9IFwiQW5kXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJPclwiXSA9IDEwXSA9IFwiT3JcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyXCJdID0gMTFdID0gXCJMb3dlclwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTG93ZXJFcXVhbHNcIl0gPSAxMl0gPSBcIkxvd2VyRXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaWdnZXJcIl0gPSAxM10gPSBcIkJpZ2dlclwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQmlnZ2VyRXF1YWxzXCJdID0gMTRdID0gXCJCaWdnZXJFcXVhbHNcIjtcbn0pKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IgfHwgKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IgPSB7fSkpO1xudmFyIEJpbmFyeU9wZXJhdG9yID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvcjtcbnZhciBFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uKHR5cGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUpOyB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIChpbmRleCwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIodGhpcywgaW5kZXgsIHR5cGUpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VNZXRob2RFeHByKHRoaXMsIG5hbWUsIHBhcmFtcyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsRm4gPSBmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIHBhcmFtcyk7IH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocGFyYW1zLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50aWF0ZUV4cHIodGhpcywgcGFyYW1zLCB0eXBlKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKHRydWVDYXNlLCBmYWxzZUNhc2UpIHtcbiAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIodGhpcywgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaWRlbnRpY2FsID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5JZGVudGljYWwsIHRoaXMsIHJocyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RJZGVudGljYWwgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnBsdXMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLlBsdXMsIHRoaXMsIHJocyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTW9kdWxvLCB0aGlzLCByaHMpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuT3IsIHRoaXMsIHJocyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5sb3dlciA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXIsIHRoaXMsIHJocyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5sb3dlckVxdWFscyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocyk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXIgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlciwgdGhpcywgcmhzKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlckVxdWFscyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzLCB0aGlzLCByaHMpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaXNCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTm90ZTogV2UgdXNlIGVxdWFscyBieSBwdXJwb3NlIGhlcmUgdG8gY29tcGFyZSB0byBudWxsIGFuZCB1bmRlZmluZWQgaW4gSlMuXG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhleHBvcnRzLk5VTExfRVhQUik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIG5ldyBDYXN0RXhwcih0aGlzLCB0eXBlKTsgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS50b1N0bXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzKTsgfTtcbiAgICByZXR1cm4gRXhwcmVzc2lvbjtcbn0oKSk7XG5leHBvcnRzLkV4cHJlc3Npb24gPSBFeHByZXNzaW9uO1xuKGZ1bmN0aW9uIChCdWlsdGluVmFyKSB7XG4gICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiVGhpc1wiXSA9IDBdID0gXCJUaGlzXCI7XG4gICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiU3VwZXJcIl0gPSAxXSA9IFwiU3VwZXJcIjtcbiAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJDYXRjaEVycm9yXCJdID0gMl0gPSBcIkNhdGNoRXJyb3JcIjtcbiAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJDYXRjaFN0YWNrXCJdID0gM10gPSBcIkNhdGNoU3RhY2tcIjtcbn0pKGV4cG9ydHMuQnVpbHRpblZhciB8fCAoZXhwb3J0cy5CdWlsdGluVmFyID0ge30pKTtcbnZhciBCdWlsdGluVmFyID0gZXhwb3J0cy5CdWlsdGluVmFyO1xudmFyIFJlYWRWYXJFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZFZhckV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhZFZhckV4cHIobmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICBpZiAobGFuZ18xLmlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlKTsgfTtcbiAgICByZXR1cm4gUmVhZFZhckV4cHI7XG59KEV4cHJlc3Npb24pKTtcbmV4cG9ydHMuUmVhZFZhckV4cHIgPSBSZWFkVmFyRXhwcjtcbnZhciBXcml0ZVZhckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZVZhckV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JpdGVWYXJFeHByKG5hbWUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbGFuZ18xLmlzUHJlc2VudCh0eXBlKSA/IHR5cGUgOiB2YWx1ZS50eXBlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlVmFyRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xuZXhwb3J0cy5Xcml0ZVZhckV4cHIgPSBXcml0ZVZhckV4cHI7XG52YXIgV3JpdGVLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JpdGVLZXlFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdyaXRlS2V5RXhwcihyZWNlaXZlciwgaW5kZXgsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbGFuZ18xLmlzUHJlc2VudCh0eXBlKSA/IHR5cGUgOiB2YWx1ZS50eXBlKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZUtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbmV4cG9ydHMuV3JpdGVLZXlFeHByID0gV3JpdGVLZXlFeHByO1xudmFyIFdyaXRlUHJvcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZVByb3BFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdyaXRlUHJvcEV4cHIocmVjZWl2ZXIsIG5hbWUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbGFuZ18xLmlzUHJlc2VudCh0eXBlKSA/IHR5cGUgOiB2YWx1ZS50eXBlKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIFdyaXRlUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZVByb3BFeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLldyaXRlUHJvcEV4cHIgPSBXcml0ZVByb3BFeHByO1xuKGZ1bmN0aW9uIChCdWlsdGluTWV0aG9kKSB7XG4gICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQ29uY2F0QXJyYXlcIl0gPSAwXSA9IFwiQ29uY2F0QXJyYXlcIjtcbiAgICBCdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2RbXCJTdWJzY3JpYmVPYnNlcnZhYmxlXCJdID0gMV0gPSBcIlN1YnNjcmliZU9ic2VydmFibGVcIjtcbiAgICBCdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2RbXCJiaW5kXCJdID0gMl0gPSBcImJpbmRcIjtcbn0pKGV4cG9ydHMuQnVpbHRpbk1ldGhvZCB8fCAoZXhwb3J0cy5CdWlsdGluTWV0aG9kID0ge30pKTtcbnZhciBCdWlsdGluTWV0aG9kID0gZXhwb3J0cy5CdWlsdGluTWV0aG9kO1xudmFyIEludm9rZU1ldGhvZEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZva2VNZXRob2RFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludm9rZU1ldGhvZEV4cHIocmVjZWl2ZXIsIG1ldGhvZCwgYXJncywgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmcobWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbWV0aG9kO1xuICAgICAgICAgICAgdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBtZXRob2Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW52b2tlTWV0aG9kRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VNZXRob2RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludm9rZU1ldGhvZEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbmV4cG9ydHMuSW52b2tlTWV0aG9kRXhwciA9IEludm9rZU1ldGhvZEV4cHI7XG52YXIgSW52b2tlRnVuY3Rpb25FeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52b2tlRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludm9rZUZ1bmN0aW9uRXhwcihmbiwgYXJncywgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIEludm9rZUZ1bmN0aW9uRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW52b2tlRnVuY3Rpb25FeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLkludm9rZUZ1bmN0aW9uRXhwciA9IEludm9rZUZ1bmN0aW9uRXhwcjtcbnZhciBJbnN0YW50aWF0ZUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnN0YW50aWF0ZUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5zdGFudGlhdGVFeHByKGNsYXNzRXhwciwgYXJncywgdHlwZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgdGhpcy5jbGFzc0V4cHIgPSBjbGFzc0V4cHI7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIEluc3RhbnRpYXRlRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnN0YW50aWF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zdGFudGlhdGVFeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLkluc3RhbnRpYXRlRXhwciA9IEluc3RhbnRpYXRlRXhwcjtcbnZhciBMaXRlcmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpdGVyYWxFeHByKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgTGl0ZXJhbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbmV4cG9ydHMuTGl0ZXJhbEV4cHIgPSBMaXRlcmFsRXhwcjtcbnZhciBFeHRlcm5hbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlcm5hbEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxFeHByKHZhbHVlLCB0eXBlLCB0eXBlUGFyYW1zKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgIH1cbiAgICBFeHRlcm5hbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXh0ZXJuYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVybmFsRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xuZXhwb3J0cy5FeHRlcm5hbEV4cHIgPSBFeHRlcm5hbEV4cHI7XG52YXIgQ29uZGl0aW9uYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uZGl0aW9uYWxFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcihjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UsIHR5cGUpIHtcbiAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBsYW5nXzEuaXNQcmVzZW50KHR5cGUpID8gdHlwZSA6IHRydWVDYXNlLnR5cGUpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgIHRoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICB9XG4gICAgQ29uZGl0aW9uYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25kaXRpb25hbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByID0gQ29uZGl0aW9uYWxFeHByO1xudmFyIE5vdEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vdEV4cHIoY29uZGl0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGV4cG9ydHMuQk9PTF9UWVBFKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIE5vdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Tm90RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOb3RFeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLk5vdEV4cHIgPSBOb3RFeHByO1xudmFyIENhc3RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FzdEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FzdEV4cHIodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgQ2FzdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2FzdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FzdEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbmV4cG9ydHMuQ2FzdEV4cHIgPSBDYXN0RXhwcjtcbnZhciBGblBhcmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGblBhcmFtKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gRm5QYXJhbTtcbn0oKSk7XG5leHBvcnRzLkZuUGFyYW0gPSBGblBhcmFtO1xudmFyIEZ1bmN0aW9uRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHIocGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgIH1cbiAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMuc3RhdGVtZW50cywgdGhpcy50eXBlLCBtb2RpZmllcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xuZXhwb3J0cy5GdW5jdGlvbkV4cHIgPSBGdW5jdGlvbkV4cHI7XG52YXIgQmluYXJ5T3BlcmF0b3JFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmluYXJ5T3BlcmF0b3JFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBsYW5nXzEuaXNQcmVzZW50KHR5cGUpID8gdHlwZSA6IGxocy50eXBlKTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgfVxuICAgIEJpbmFyeU9wZXJhdG9yRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluYXJ5T3BlcmF0b3JFeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLkJpbmFyeU9wZXJhdG9yRXhwciA9IEJpbmFyeU9wZXJhdG9yRXhwcjtcbnZhciBSZWFkUHJvcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkUHJvcEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhZFByb3BFeHByKHJlY2VpdmVyLCBuYW1lLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVQcm9wRXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLm5hbWUsIHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkUHJvcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbmV4cG9ydHMuUmVhZFByb3BFeHByID0gUmVhZFByb3BFeHByO1xudmFyIFJlYWRLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZEtleUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhZEtleUV4cHIocmVjZWl2ZXIsIGluZGV4LCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZUtleUV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5pbmRleCwgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRLZXlFeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLlJlYWRLZXlFeHByID0gUmVhZEtleUV4cHI7XG52YXIgTGl0ZXJhbEFycmF5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxBcnJheUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5RXhwcihlbnRyaWVzLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgfVxuICAgIExpdGVyYWxBcnJheUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsQXJyYXlFeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLkxpdGVyYWxBcnJheUV4cHIgPSBMaXRlcmFsQXJyYXlFeHByO1xudmFyIExpdGVyYWxNYXBFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbE1hcEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbE1hcEV4cHIoZW50cmllcywgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHR5cGUudmFsdWVUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIExpdGVyYWxNYXBFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXBFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxNYXBFeHByO1xufShFeHByZXNzaW9uKSk7XG5leHBvcnRzLkxpdGVyYWxNYXBFeHByID0gTGl0ZXJhbE1hcEV4cHI7XG5leHBvcnRzLlRISVNfRVhQUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLlRoaXMpO1xuZXhwb3J0cy5TVVBFUl9FWFBSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuU3VwZXIpO1xuZXhwb3J0cy5DQVRDSF9FUlJPUl9WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaEVycm9yKTtcbmV4cG9ydHMuQ0FUQ0hfU1RBQ0tfVkFSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjayk7XG5leHBvcnRzLk5VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBudWxsKTtcbi8vLy8gU3RhdGVtZW50c1xuKGZ1bmN0aW9uIChTdG10TW9kaWZpZXIpIHtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiRmluYWxcIl0gPSAwXSA9IFwiRmluYWxcIjtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiUHJpdmF0ZVwiXSA9IDFdID0gXCJQcml2YXRlXCI7XG59KShleHBvcnRzLlN0bXRNb2RpZmllciB8fCAoZXhwb3J0cy5TdG10TW9kaWZpZXIgPSB7fSkpO1xudmFyIFN0bXRNb2RpZmllciA9IGV4cG9ydHMuU3RtdE1vZGlmaWVyO1xudmFyIFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVtZW50KG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG1vZGlmaWVycykpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RhdGVtZW50LnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgIHJldHVybiBTdGF0ZW1lbnQ7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZW1lbnQgPSBTdGF0ZW1lbnQ7XG52YXIgRGVjbGFyZVZhclN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWNsYXJlVmFyU3RtdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWNsYXJlVmFyU3RtdChuYW1lLCB2YWx1ZSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSBsYW5nXzEuaXNQcmVzZW50KHR5cGUpID8gdHlwZSA6IHZhbHVlLnR5cGU7XG4gICAgfVxuICAgIERlY2xhcmVWYXJTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZVZhclN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjbGFyZVZhclN0bXQ7XG59KFN0YXRlbWVudCkpO1xuZXhwb3J0cy5EZWNsYXJlVmFyU3RtdCA9IERlY2xhcmVWYXJTdG10O1xudmFyIERlY2xhcmVGdW5jdGlvblN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWNsYXJlRnVuY3Rpb25TdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgcGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgRGVjbGFyZUZ1bmN0aW9uU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjbGFyZUZ1bmN0aW9uU3RtdDtcbn0oU3RhdGVtZW50KSk7XG5leHBvcnRzLkRlY2xhcmVGdW5jdGlvblN0bXQgPSBEZWNsYXJlRnVuY3Rpb25TdG10O1xudmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHByZXNzaW9uU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICB9XG4gICAgRXhwcmVzc2lvblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG59KFN0YXRlbWVudCkpO1xuZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gRXhwcmVzc2lvblN0YXRlbWVudDtcbnZhciBSZXR1cm5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXR1cm5TdGF0ZW1lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIFJldHVyblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJldHVyblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xufShTdGF0ZW1lbnQpKTtcbmV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gUmV0dXJuU3RhdGVtZW50O1xudmFyIEFic3RyYWN0Q2xhc3NQYXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENsYXNzUGFydCh0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG1vZGlmaWVycykpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWJzdHJhY3RDbGFzc1BhcnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIEFic3RyYWN0Q2xhc3NQYXJ0O1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RDbGFzc1BhcnQgPSBBYnN0cmFjdENsYXNzUGFydDtcbnZhciBDbGFzc0ZpZWxkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NGaWVsZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbGFzc0ZpZWxkKG5hbWUsIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBDbGFzc0ZpZWxkO1xufShBYnN0cmFjdENsYXNzUGFydCkpO1xuZXhwb3J0cy5DbGFzc0ZpZWxkID0gQ2xhc3NGaWVsZDtcbnZhciBDbGFzc01ldGhvZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzTWV0aG9kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsYXNzTWV0aG9kKG5hbWUsIHBhcmFtcywgYm9keSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIHJldHVybiBDbGFzc01ldGhvZDtcbn0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbmV4cG9ydHMuQ2xhc3NNZXRob2QgPSBDbGFzc01ldGhvZDtcbnZhciBDbGFzc0dldHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzR2V0dGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsYXNzR2V0dGVyKG5hbWUsIGJvZHksIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIHJldHVybiBDbGFzc0dldHRlcjtcbn0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbmV4cG9ydHMuQ2xhc3NHZXR0ZXIgPSBDbGFzc0dldHRlcjtcbnZhciBDbGFzc1N0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc1N0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xhc3NTdG10KG5hbWUsIHBhcmVudCwgZmllbGRzLCBnZXR0ZXJzLCBjb25zdHJ1Y3Rvck1ldGhvZCwgbWV0aG9kcywgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5nZXR0ZXJzID0gZ2V0dGVycztcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvck1ldGhvZCA9IGNvbnN0cnVjdG9yTWV0aG9kO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBtZXRob2RzO1xuICAgIH1cbiAgICBDbGFzc1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlQ2xhc3NTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzU3RtdDtcbn0oU3RhdGVtZW50KSk7XG5leHBvcnRzLkNsYXNzU3RtdCA9IENsYXNzU3RtdDtcbnZhciBJZlN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJZlN0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSWZTdG10KGNvbmRpdGlvbiwgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSkge1xuICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gW107IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIHRoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgIH1cbiAgICBJZlN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJZlN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSWZTdG10O1xufShTdGF0ZW1lbnQpKTtcbmV4cG9ydHMuSWZTdG10ID0gSWZTdG10O1xudmFyIENvbW1lbnRTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWVudFN0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tbWVudFN0bXQoY29tbWVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbiAgICB9XG4gICAgQ29tbWVudFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tZW50U3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tZW50U3RtdDtcbn0oU3RhdGVtZW50KSk7XG5leHBvcnRzLkNvbW1lbnRTdG10ID0gQ29tbWVudFN0bXQ7XG52YXIgVHJ5Q2F0Y2hTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJ5Q2F0Y2hTdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyeUNhdGNoU3RtdChib2R5U3RtdHMsIGNhdGNoU3RtdHMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYm9keVN0bXRzID0gYm9keVN0bXRzO1xuICAgICAgICB0aGlzLmNhdGNoU3RtdHMgPSBjYXRjaFN0bXRzO1xuICAgIH1cbiAgICBUcnlDYXRjaFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcnlDYXRjaFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJ5Q2F0Y2hTdG10O1xufShTdGF0ZW1lbnQpKTtcbmV4cG9ydHMuVHJ5Q2F0Y2hTdG10ID0gVHJ5Q2F0Y2hTdG10O1xudmFyIFRocm93U3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRocm93U3RtdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvd1N0bXQoZXJyb3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgVGhyb3dTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGhyb3dTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFRocm93U3RtdDtcbn0oU3RhdGVtZW50KSk7XG5leHBvcnRzLlRocm93U3RtdCA9IFRocm93U3RtdDtcbnZhciBFeHByZXNzaW9uVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25UcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcihleHByLm5hbWUsIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlS2V5RXhwcihleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVByb3BFeHByKGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLm5hbWUsIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gbGFuZ18xLmlzUHJlc2VudChhc3QuYnVpbHRpbikgPyBhc3QuYnVpbHRpbiA6IGFzdC5uYW1lO1xuICAgICAgICByZXR1cm4gbmV3IEludm9rZU1ldGhvZEV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgbWV0aG9kLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEludm9rZUZ1bmN0aW9uRXhwcihhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnRpYXRlRXhwcihhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vdEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENhc3RFeHByKGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGNvbnRleHQpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGFzdC5vcGVyYXRvciwgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRQcm9wRXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QubmFtZSwgYXN0LnR5cGUpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRLZXlFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KSk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIoYXN0LmVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gW2VudHJ5WzBdLCBlbnRyeVsxXS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpXTsgfSkpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQudHlwZSwgc3RtdC5tb2RpZmllcnMpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudChzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXR1cm5TdGF0ZW1lbnQoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IElmU3RtdChzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCkpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJ5Q2F0Y2hTdG10KHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KSk7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaHJvd1N0bXQoc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgIH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIHN0bXQ7IH07XG4gICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbn0oKSk7XG5leHBvcnRzLkV4cHJlc3Npb25UcmFuc2Zvcm1lciA9IEV4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbnZhciBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IoKSB7XG4gICAgfVxuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5WzFdLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIHN0bXQ7IH07XG4gICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdG10cywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdG10cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3I7XG59KCkpO1xuZXhwb3J0cy5SZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvciA9IFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yO1xuZnVuY3Rpb24gcmVwbGFjZVZhckluRXhwcmVzc2lvbih2YXJOYW1lLCBuZXdWYWx1ZSwgZXhwcmVzc2lvbikge1xuICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIodmFyTmFtZSwgbmV3VmFsdWUpO1xuICAgIHJldHVybiBleHByZXNzaW9uLnZpc2l0RXhwcmVzc2lvbih0cmFuc2Zvcm1lciwgbnVsbCk7XG59XG5leHBvcnRzLnJlcGxhY2VWYXJJbkV4cHJlc3Npb24gPSByZXBsYWNlVmFySW5FeHByZXNzaW9uO1xudmFyIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIoX3Zhck5hbWUsIF9uZXdWYWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdmFyTmFtZSA9IF92YXJOYW1lO1xuICAgICAgICB0aGlzLl9uZXdWYWx1ZSA9IF9uZXdWYWx1ZTtcbiAgICB9XG4gICAgX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0Lm5hbWUgPT0gdGhpcy5fdmFyTmFtZSA/IHRoaXMuX25ld1ZhbHVlIDogYXN0O1xuICAgIH07XG4gICAgcmV0dXJuIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lcjtcbn0oRXhwcmVzc2lvblRyYW5zZm9ybWVyKSk7XG5mdW5jdGlvbiBmaW5kUmVhZFZhck5hbWVzKHN0bXRzKSB7XG4gICAgdmFyIGZpbmRlciA9IG5ldyBfVmFyaWFibGVGaW5kZXIoKTtcbiAgICBmaW5kZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICByZXR1cm4gZmluZGVyLnZhck5hbWVzO1xufVxuZXhwb3J0cy5maW5kUmVhZFZhck5hbWVzID0gZmluZFJlYWRWYXJOYW1lcztcbnZhciBfVmFyaWFibGVGaW5kZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfVmFyaWFibGVGaW5kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1ZhcmlhYmxlRmluZGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YXJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgX1ZhcmlhYmxlRmluZGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZhck5hbWVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIF9WYXJpYWJsZUZpbmRlcjtcbn0oUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IpKTtcbmZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcihuYW1lLCB0eXBlKTtcbn1cbmV4cG9ydHMudmFyaWFibGUgPSB2YXJpYWJsZTtcbmZ1bmN0aW9uIGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMpIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBFeHRlcm5hbEV4cHIoaWQsIG51bGwsIHR5cGVQYXJhbXMpO1xufVxuZXhwb3J0cy5pbXBvcnRFeHByID0gaW1wb3J0RXhwcjtcbmZ1bmN0aW9uIGltcG9ydFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVNb2RpZmllcnMgPT09IHZvaWQgMCkgeyB0eXBlTW9kaWZpZXJzID0gbnVsbDsgfVxuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGlkKSA/IG5ldyBFeHRlcm5hbFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbn1cbmV4cG9ydHMuaW1wb3J0VHlwZSA9IGltcG9ydFR5cGU7XG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUpO1xufVxuZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbDtcbmZ1bmN0aW9uIGxpdGVyYWxBcnIodmFsdWVzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUpO1xufVxuZXhwb3J0cy5saXRlcmFsQXJyID0gbGl0ZXJhbEFycjtcbmZ1bmN0aW9uIGxpdGVyYWxNYXAodmFsdWVzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIodmFsdWVzLCB0eXBlKTtcbn1cbmV4cG9ydHMubGl0ZXJhbE1hcCA9IGxpdGVyYWxNYXA7XG5mdW5jdGlvbiBub3QoZXhwcikge1xuICAgIHJldHVybiBuZXcgTm90RXhwcihleHByKTtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuZnVuY3Rpb24gZm4ocGFyYW1zLCBib2R5LCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByKHBhcmFtcywgYm9keSwgdHlwZSk7XG59XG5leHBvcnRzLmZuID0gZm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXRwdXRfYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9hc3luYycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIG8gPSByZXF1aXJlKCcuL291dHB1dF9hc3QnKTtcbnZhciBkYXJ0X2VtaXR0ZXJfMSA9IHJlcXVpcmUoJy4vZGFydF9lbWl0dGVyJyk7XG52YXIgdHNfZW1pdHRlcl8xID0gcmVxdWlyZSgnLi90c19lbWl0dGVyJyk7XG5mdW5jdGlvbiBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIHJlc3VsdFZhciwgaW5zdGFuY2VGYWN0b3J5KSB7XG4gICAgdmFyIHN0bXRzV2l0aFJldHVybiA9IHN0YXRlbWVudHMuY29uY2F0KFtuZXcgby5SZXR1cm5TdGF0ZW1lbnQoby52YXJpYWJsZShyZXN1bHRWYXIpKV0pO1xuICAgIHZhciBjdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbmV3IE1hcCgpLCBuZXcgTWFwKCksIG5ldyBNYXAoKSwgbmV3IE1hcCgpLCBpbnN0YW5jZUZhY3RvcnkpO1xuICAgIHZhciB2aXNpdG9yID0gbmV3IFN0YXRlbWVudEludGVycHJldGVyKCk7XG4gICAgdmFyIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzV2l0aFJldHVybiwgY3R4KTtcbiAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXN1bHQpID8gcmVzdWx0LnZhbHVlIDogbnVsbDtcbn1cbmV4cG9ydHMuaW50ZXJwcmV0U3RhdGVtZW50cyA9IGludGVycHJldFN0YXRlbWVudHM7XG52YXIgRHluYW1pY0luc3RhbmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEeW5hbWljSW5zdGFuY2UoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEeW5hbWljSW5zdGFuY2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHluYW1pY0luc3RhbmNlLnByb3RvdHlwZSwgXCJnZXR0ZXJzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHluYW1pY0luc3RhbmNlLnByb3RvdHlwZSwgXCJtZXRob2RzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHluYW1pY0luc3RhbmNlLnByb3RvdHlwZSwgXCJjbGF6elwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIER5bmFtaWNJbnN0YW5jZTtcbn0oKSk7XG5leHBvcnRzLkR5bmFtaWNJbnN0YW5jZSA9IER5bmFtaWNJbnN0YW5jZTtcbmZ1bmN0aW9uIGlzRHluYW1pY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgaWYgKGxhbmdfMS5JU19EQVJUKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZSBpbnN0YW5jZW9mIER5bmFtaWNJbnN0YW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGluc3RhbmNlKSAmJiBsYW5nXzEuaXNQcmVzZW50KGluc3RhbmNlLnByb3BzKSAmJiBsYW5nXzEuaXNQcmVzZW50KGluc3RhbmNlLmdldHRlcnMpICYmXG4gICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KGluc3RhbmNlLm1ldGhvZHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCB2YXJWYWx1ZXMsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcikge1xuICAgIHZhciBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KHZhck5hbWVzW2ldLCB2YXJWYWx1ZXNbaV0pO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY2hpbGRDdHgpO1xuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHJlc3VsdCkgPyByZXN1bHQudmFsdWUgOiBudWxsO1xufVxudmFyIF9FeGVjdXRpb25Db250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfRXhlY3V0aW9uQ29udGV4dChwYXJlbnQsIHN1cGVyQ2xhc3MsIHN1cGVySW5zdGFuY2UsIGNsYXNzTmFtZSwgdmFycywgcHJvcHMsIGdldHRlcnMsIG1ldGhvZHMsIGluc3RhbmNlRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcbiAgICAgICAgdGhpcy5zdXBlckluc3RhbmNlID0gc3VwZXJJbnN0YW5jZTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5nZXR0ZXJzID0gZ2V0dGVycztcbiAgICAgICAgdGhpcy5tZXRob2RzID0gbWV0aG9kcztcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XG4gICAgfVxuICAgIF9FeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0V4ZWN1dGlvbkNvbnRleHQodGhpcywgdGhpcy5zdXBlckNsYXNzLCB0aGlzLnN1cGVySW5zdGFuY2UsIHRoaXMuY2xhc3NOYW1lLCBuZXcgTWFwKCksIHRoaXMucHJvcHMsIHRoaXMuZ2V0dGVycywgdGhpcy5tZXRob2RzLCB0aGlzLmluc3RhbmNlRmFjdG9yeSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0V4ZWN1dGlvbkNvbnRleHQ7XG59KCkpO1xudmFyIFJldHVyblZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBSZXR1cm5WYWx1ZTtcbn0oKSk7XG52YXIgX0R5bmFtaWNDbGFzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0R5bmFtaWNDbGFzcyhfY2xhc3NTdG10LCBfY3R4LCBfdmlzaXRvcikge1xuICAgICAgICB0aGlzLl9jbGFzc1N0bXQgPSBfY2xhc3NTdG10O1xuICAgICAgICB0aGlzLl9jdHggPSBfY3R4O1xuICAgICAgICB0aGlzLl92aXNpdG9yID0gX3Zpc2l0b3I7XG4gICAgfVxuICAgIF9EeW5hbWljQ2xhc3MucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZ2V0dGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG1ldGhvZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBzdXBlckNsYXNzID0gdGhpcy5fY2xhc3NTdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcy5fdmlzaXRvciwgdGhpcy5fY3R4KTtcbiAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KHRoaXMuX2N0eCwgc3VwZXJDbGFzcywgbnVsbCwgdGhpcy5fY2xhc3NTdG10Lm5hbWUsIHRoaXMuX2N0eC52YXJzLCBwcm9wcywgZ2V0dGVycywgbWV0aG9kcywgdGhpcy5fY3R4Lmluc3RhbmNlRmFjdG9yeSk7XG4gICAgICAgIHRoaXMuX2NsYXNzU3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcHJvcHMuc2V0KGZpZWxkLm5hbWUsIG51bGwpOyB9KTtcbiAgICAgICAgdGhpcy5fY2xhc3NTdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICBnZXR0ZXJzLnNldChnZXR0ZXIubmFtZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoW10sIFtdLCBnZXR0ZXIuYm9keSwgaW5zdGFuY2VDdHgsIF90aGlzLl92aXNpdG9yKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jbGFzc1N0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbU5hbWVzID0gbWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgICAgIG1ldGhvZHMuc2V0KG1ldGhvZC5uYW1lLCBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIG1ldGhvZC5ib2R5LCBpbnN0YW5jZUN0eCwgX3RoaXMuX3Zpc2l0b3IpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdG9yUGFyYW1OYW1lcyA9IHRoaXMuX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKGN0b3JQYXJhbU5hbWVzLCBhcmdzLCB0aGlzLl9jbGFzc1N0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgaW5zdGFuY2VDdHgsIHRoaXMuX3Zpc2l0b3IpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VDdHguc3VwZXJJbnN0YW5jZTtcbiAgICB9O1xuICAgIF9EeW5hbWljQ2xhc3MucHJvdG90eXBlLmRlYnVnQXN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlzaXRvci5kZWJ1Z0FzdCh0aGlzLl9jbGFzc1N0bXQpOyB9O1xuICAgIHJldHVybiBfRHluYW1pY0NsYXNzO1xufSgpKTtcbnZhciBTdGF0ZW1lbnRJbnRlcnByZXRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVtZW50SW50ZXJwcmV0ZXIoKSB7XG4gICAgfVxuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS5kZWJ1Z0FzdCA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5JU19EQVJUID8gZGFydF9lbWl0dGVyXzEuZGVidWdPdXRwdXRBc3RBc0RhcnQoYXN0KSA6IHRzX2VtaXR0ZXJfMS5kZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIGN1cnJDdHggPSBjdHg7XG4gICAgICAgIHdoaWxlIChjdXJyQ3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdXJyQ3R4LnZhcnMuaGFzKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyQ3R4LnZhcnMuc2V0KGV4cHIubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyBleHByLm5hbWUpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIHZhck5hbWUgPSBhc3QubmFtZTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXN0LmJ1aWx0aW4pKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzdC5idWlsdGluKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5WYXIuVGhpczpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5zdXBlckluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVmFyLkNhdGNoRXJyb3I6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9FUlJPUl9WQVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVmFyLkNhdGNoU3RhY2s6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9TVEFDS19WQVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyckN0eCA9IGN0eDtcbiAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXModmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyckN0eC52YXJzLmdldCh2YXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyB2YXJOYW1lKTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIGluZGV4ID0gZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmVjZWl2ZXJbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmIChpc0R5bmFtaWNJbnN0YW5jZShyZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHZhciBkaSA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgaWYgKGRpLnByb3BzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZGkucHJvcHMuc2V0KGV4cHIubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29yZV8xLnJlZmxlY3Rvci5zZXR0ZXIoZXhwci5uYW1lKShyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29yZV8xLnJlZmxlY3Rvci5zZXR0ZXIoZXhwci5uYW1lKShyZWNlaXZlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4KTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZXhwci5idWlsdGluKSkge1xuICAgICAgICAgICAgc3dpdGNoIChleHByLmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIG8uQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbmNhdChyZWNlaXZlciwgYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzeW5jXzEuT2JzZXJ2YWJsZVdyYXBwZXIuc3Vic2NyaWJlKHJlY2VpdmVyLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5NZXRob2QuYmluZDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5JU19EQVJUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmJpbmQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVW5rbm93biBidWlsdGluIG1ldGhvZCBcIiArIGV4cHIuYnVpbHRpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEeW5hbWljSW5zdGFuY2UocmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICB2YXIgZGkgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGlmIChkaS5tZXRob2RzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFuZ18xLkZ1bmN0aW9uV3JhcHBlci5hcHBseShkaS5tZXRob2RzLmdldChleHByLm5hbWUpLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvcmVfMS5yZWZsZWN0b3IubWV0aG9kKGV4cHIubmFtZSkocmVjZWl2ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29yZV8xLnJlZmxlY3Rvci5tZXRob2QoZXhwci5uYW1lKShyZWNlaXZlciwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoc3RtdC5hcmdzLCBjdHgpO1xuICAgICAgICB2YXIgZm5FeHByID0gc3RtdC5mbjtcbiAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIG8uUmVhZFZhckV4cHIgJiYgZm5FeHByLmJ1aWx0aW4gPT09IG8uQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgY3R4LnN1cGVySW5zdGFuY2UgPSBjdHguaW5zdGFuY2VGYWN0b3J5LmNyZWF0ZUluc3RhbmNlKGN0eC5zdXBlckNsYXNzLCBjdHguY2xhc3NOYW1lLCBhcmdzLCBjdHgucHJvcHMsIGN0eC5nZXR0ZXJzLCBjdHgubWV0aG9kcyk7XG4gICAgICAgICAgICBjdHgucGFyZW50LnN1cGVySW5zdGFuY2UgPSBjdHguc3VwZXJJbnN0YW5jZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZuID0gc3RtdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuRnVuY3Rpb25XcmFwcGVyLmFwcGx5KGZuLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXR1cm5WYWx1ZShzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBjbGF6eiA9IG5ldyBfRHluYW1pY0NsYXNzKHN0bXQsIGN0eCwgdGhpcyk7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIGNsYXp6KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KHN0bXQuZmFsc2VDYXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICAgICAgICBjaGlsZEN0eC52YXJzLnNldChDQVRDSF9FUlJPUl9WQVIsIGUpO1xuICAgICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQoQ0FUQ0hfU1RBQ0tfVkFSLCBlLnN0YWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNoaWxkQ3R4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB0aHJvdyBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciBjbGF6eiA9IGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmIChjbGF6eiBpbnN0YW5jZW9mIF9EeW5hbWljQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGF6ei5pbnN0YW50aWF0ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuRnVuY3Rpb25XcmFwcGVyLmFwcGx5KGNvcmVfMS5yZWZsZWN0b3IuZmFjdG9yeShjbGF6eiksIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gYXN0LnZhbHVlOyB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gYXN0LnZhbHVlLnJ1bnRpbWU7IH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXN0LmZhbHNlQ2FzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gIWFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBwYXJhbU5hbWVzID0gYXN0LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgcmV0dXJuIF9kZWNsYXJlRm4ocGFyYW1OYW1lcywgYXN0LnN0YXRlbWVudHMsIGN0eCwgdGhpcyk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgcGFyYW1OYW1lcyA9IHN0bXQucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIHN0bXQuc3RhdGVtZW50cywgY3R4LCB0aGlzKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsaHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfTtcbiAgICAgICAgdmFyIHJocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAhPSByaHMoKTtcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICYmIHJocygpO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLk9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSB8fCByaHMoKTtcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSArIHJocygpO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAtIHJocygpO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLkRpdmlkZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgLyByaHMoKTtcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgKiByaHMoKTtcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICUgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuTG93ZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIDwgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIG8uQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIDw9IHJocygpO1xuICAgICAgICAgICAgY2FzZSBvLkJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPiByaHMoKTtcbiAgICAgICAgICAgIGNhc2Ugby5CaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID49IHJocygpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbmtub3duIG9wZXJhdG9yIFwiICsgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKGlzRHluYW1pY0luc3RhbmNlKHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgdmFyIGRpID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICBpZiAoZGkucHJvcHMuaGFzKGFzdC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRpLnByb3BzLmdldChhc3QubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaS5nZXR0ZXJzLmhhcyhhc3QubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkaS5nZXR0ZXJzLmdldChhc3QubmFtZSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpLm1ldGhvZHMuaGFzKGFzdC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRpLm1ldGhvZHMuZ2V0KGFzdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvcmVfMS5yZWZsZWN0b3IuZ2V0dGVyKGFzdC5uYW1lKShyZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb3JlXzEucmVmbGVjdG9yLmdldHRlcihhc3QubmFtZSkocmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciBwcm9wID0gYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXJbcHJvcF07XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGN0eCk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiByZXN1bHRbZW50cnlbMF1dID1cbiAgICAgICAgICAgIGVudHJ5WzFdLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0bXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVtZW50SW50ZXJwcmV0ZXI7XG59KCkpO1xuZnVuY3Rpb24gX2RlY2xhcmVGbih2YXJOYW1lcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgc3dpdGNoICh2YXJOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCBbXSwgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKTsgfTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkMCkgeyByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIFtkMF0sIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcik7IH07XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZDAsIGQxKSB7IHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgW2QwLCBkMV0sIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcik7IH07XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZDAsIGQxLCBkMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgW2QwLCBkMSwgZDJdLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkMCwgZDEsIGQyLCBkMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgW2QwLCBkMSwgZDIsIGQzXSwgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZDAsIGQxLCBkMiwgZDMsIGQ0KSB7IHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgW2QwLCBkMSwgZDIsIGQzLCBkNF0sIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcik7IH07XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSkgeyByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIFtkMCwgZDEsIGQyLCBkMywgZDQsIGQ1XSwgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKTsgfTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNikgeyByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIFtkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNl0sIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcik7IH07XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3KSB7IHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgW2QwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkN10sIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcik7IH07XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCkgeyByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIFtkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4XSwgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKTsgfTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDkpIHsgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCBbZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3LCBkOCwgZDldLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpOyB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdEZWNsYXJpbmcgZnVuY3Rpb25zIHdpdGggbW9yZSB0aGFuIDEwIGFyZ3VtZW50cyBpcyBub3Qgc3VwcG9ydGVkIHJpZ2h0IG5vdycpO1xuICAgIH1cbn1cbnZhciBDQVRDSF9FUlJPUl9WQVIgPSAnZXJyb3InO1xudmFyIENBVENIX1NUQUNLX1ZBUiA9ICdzdGFjayc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXRwdXRfaW50ZXJwcmV0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBhYnN0cmFjdF9lbWl0dGVyXzEgPSByZXF1aXJlKCcuL2Fic3RyYWN0X2VtaXR0ZXInKTtcbnZhciBhYnN0cmFjdF9qc19lbWl0dGVyXzEgPSByZXF1aXJlKCcuL2Fic3RyYWN0X2pzX2VtaXR0ZXInKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5mdW5jdGlvbiBqaXRTdGF0ZW1lbnRzKHNvdXJjZVVybCwgc3RhdGVtZW50cywgcmVzdWx0VmFyKSB7XG4gICAgdmFyIGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcigpO1xuICAgIHZhciBjdHggPSBhYnN0cmFjdF9lbWl0dGVyXzEuRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoW3Jlc3VsdFZhcl0pO1xuICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICByZXR1cm4gbGFuZ18xLmV2YWxFeHByZXNzaW9uKHNvdXJjZVVybCwgcmVzdWx0VmFyLCBjdHgudG9Tb3VyY2UoKSwgY29udmVydGVyLmdldEFyZ3MoKSk7XG59XG5leHBvcnRzLmppdFN0YXRlbWVudHMgPSBqaXRTdGF0ZW1lbnRzO1xudmFyIEppdEVtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSml0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSml0RW1pdHRlclZpc2l0b3IoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZXZhbEFyZ1ZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2YWxBcmdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W3RoaXMuX2V2YWxBcmdOYW1lc1tpXV0gPSB0aGlzLl9ldmFsQXJnVmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlLnJ1bnRpbWU7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIGlmIChpZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9ldmFsQXJnVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBsYW5nXzEuaXNQcmVzZW50KGFzdC52YWx1ZS5uYW1lKSA/IHV0aWxfMS5zYW5pdGl6ZUlkZW50aWZpZXIoYXN0LnZhbHVlLm5hbWUpIDogJ3ZhbCc7XG4gICAgICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMucHVzaCh1dGlsXzEuc2FuaXRpemVJZGVudGlmaWVyKFwiaml0X1wiICsgbmFtZSArIGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KHRoaXMuX2V2YWxBcmdOYW1lc1tpZF0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBKaXRFbWl0dGVyVmlzaXRvcjtcbn0oYWJzdHJhY3RfanNfZW1pdHRlcl8xLkFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3V0cHV0X2ppdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbi8vIGFzc2V0OjxwYWNrYWdlLW5hbWU+LzxyZWFsbT4vPHBhdGgtdG8tbW9kdWxlPlxudmFyIF9BU1NFVF9VUkxfUkUgPSAvYXNzZXQ6KFteXFwvXSspXFwvKFteXFwvXSspXFwvKC4rKS9nO1xuLyoqXG4gKiBJbnRlcmZhY2UgdGhhdCBkZWZpbmVzIGhvdyBpbXBvcnQgc3RhdGVtZW50cyBzaG91bGQgYmUgZ2VuZXJhdGVkLlxuICovXG52YXIgSW1wb3J0R2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbXBvcnRHZW5lcmF0b3IoKSB7XG4gICAgfVxuICAgIEltcG9ydEdlbmVyYXRvci5wYXJzZUFzc2V0VXJsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gQXNzZXRVcmwucGFyc2UodXJsKTsgfTtcbiAgICByZXR1cm4gSW1wb3J0R2VuZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuSW1wb3J0R2VuZXJhdG9yID0gSW1wb3J0R2VuZXJhdG9yO1xudmFyIEFzc2V0VXJsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3NldFVybChwYWNrYWdlTmFtZSwgZmlyc3RMZXZlbERpciwgbW9kdWxlUGF0aCkge1xuICAgICAgICB0aGlzLnBhY2thZ2VOYW1lID0gcGFja2FnZU5hbWU7XG4gICAgICAgIHRoaXMuZmlyc3RMZXZlbERpciA9IGZpcnN0TGV2ZWxEaXI7XG4gICAgICAgIHRoaXMubW9kdWxlUGF0aCA9IG1vZHVsZVBhdGg7XG4gICAgfVxuICAgIEFzc2V0VXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCwgYWxsb3dOb25NYXRjaGluZykge1xuICAgICAgICBpZiAoYWxsb3dOb25NYXRjaGluZyA9PT0gdm9pZCAwKSB7IGFsbG93Tm9uTWF0Y2hpbmcgPSB0cnVlOyB9XG4gICAgICAgIHZhciBtYXRjaCA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goX0FTU0VUX1VSTF9SRSwgdXJsKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFzc2V0VXJsKG1hdGNoWzFdLCBtYXRjaFsyXSwgbWF0Y2hbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd05vbk1hdGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVcmwgXCIgKyB1cmwgKyBcIiBpcyBub3QgYSB2YWxpZCBhc3NldDogdXJsXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIEFzc2V0VXJsO1xufSgpKTtcbmV4cG9ydHMuQXNzZXRVcmwgPSBBc3NldFVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG8gPSByZXF1aXJlKCcuL291dHB1dF9hc3QnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBhYnN0cmFjdF9lbWl0dGVyXzEgPSByZXF1aXJlKCcuL2Fic3RyYWN0X2VtaXR0ZXInKTtcbnZhciBfZGVidWdNb2R1bGVVcmwgPSAnYXNzZXQ6Ly9kZWJ1Zy9saWInO1xuZnVuY3Rpb24gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQoYXN0KSB7XG4gICAgdmFyIGNvbnZlcnRlciA9IG5ldyBfVHNFbWl0dGVyVmlzaXRvcihfZGVidWdNb2R1bGVVcmwpO1xuICAgIHZhciBjdHggPSBhYnN0cmFjdF9lbWl0dGVyXzEuRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoW10pO1xuICAgIHZhciBhc3RzO1xuICAgIGlmIChsYW5nXzEuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIGFzdHMgPSBhc3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3RzID0gW2FzdF07XG4gICAgfVxuICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBvLlN0YXRlbWVudCkge1xuICAgICAgICAgICAgYXN0LnZpc2l0U3RhdGVtZW50KGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBvLkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGFzdC52aXNpdEV4cHJlc3Npb24oY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIG8uVHlwZSkge1xuICAgICAgICAgICAgYXN0LnZpc2l0VHlwZShjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJEb24ndCBrbm93IGhvdyB0byBwcmludCBkZWJ1ZyBpbmZvIGZvciBcIiArIGFzdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3R4LnRvU291cmNlKCk7XG59XG5leHBvcnRzLmRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0ID0gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQ7XG52YXIgVHlwZVNjcmlwdEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVTY3JpcHRFbWl0dGVyKF9pbXBvcnRHZW5lcmF0b3IpIHtcbiAgICAgICAgdGhpcy5faW1wb3J0R2VuZXJhdG9yID0gX2ltcG9ydEdlbmVyYXRvcjtcbiAgICB9XG4gICAgVHlwZVNjcmlwdEVtaXR0ZXIucHJvdG90eXBlLmVtaXRTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVVybCwgc3RtdHMsIGV4cG9ydGVkVmFycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IF9Uc0VtaXR0ZXJWaXNpdG9yKG1vZHVsZVVybCk7XG4gICAgICAgIHZhciBjdHggPSBhYnN0cmFjdF9lbWl0dGVyXzEuRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoZXhwb3J0ZWRWYXJzKTtcbiAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY3R4KTtcbiAgICAgICAgdmFyIHNyY1BhcnRzID0gW107XG4gICAgICAgIGNvbnZlcnRlci5pbXBvcnRzV2l0aFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCwgaW1wb3J0ZWRNb2R1bGVVcmwpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGNhbid0IHdyaXRlIHRoZSByZWFsIHdvcmQgZm9yIGltcG9ydCBhcyBpdCBzY3Jld3MgdXAgc3lzdGVtLmpzIGF1dG8gZGV0ZWN0aW9uLi4uXG4gICAgICAgICAgICBzcmNQYXJ0cy5wdXNoKFwiaW1wXCIgK1xuICAgICAgICAgICAgICAgIChcIm9ydCAqIGFzIFwiICsgcHJlZml4ICsgXCIgZnJvbSAnXCIgKyBfdGhpcy5faW1wb3J0R2VuZXJhdG9yLmdldEltcG9ydFBhdGgobW9kdWxlVXJsLCBpbXBvcnRlZE1vZHVsZVVybCkgKyBcIic7XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNyY1BhcnRzLnB1c2goY3R4LnRvU291cmNlKCkpO1xuICAgICAgICByZXR1cm4gc3JjUGFydHMuam9pbignXFxuJyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHlwZVNjcmlwdEVtaXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5UeXBlU2NyaXB0RW1pdHRlciA9IFR5cGVTY3JpcHRFbWl0dGVyO1xudmFyIF9Uc0VtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX1RzRW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1RzRW1pdHRlclZpc2l0b3IoX21vZHVsZVVybCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX21vZHVsZVVybCA9IF9tb2R1bGVVcmw7XG4gICAgICAgIHRoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihvLlN0bXRNb2RpZmllci5GaW5hbCkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcImNvbnN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50KFwidmFyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChcIiBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN0bXQudHlwZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcIjpcIik7XG4gICAgICAgICAgICBzdG10LnR5cGUudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KFwiID0gXCIpO1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KFwiKDxcIik7XG4gICAgICAgIGFzdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoXCI+XCIpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcImV4cG9ydCBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KFwiY2xhc3MgXCIgKyBzdG10Lm5hbWUpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdG10LnBhcmVudCkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcIiBleHRlbmRzIFwiKTtcbiAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgc3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzRmllbGQoZmllbGQsIGN0eCk7IH0pO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2QobWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0ZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCBjdHgpIHtcbiAgICAgICAgaWYgKGZpZWxkLmhhc01vZGlmaWVyKG8uU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoZmllbGQubmFtZSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCI6XCIpO1xuICAgICAgICAgICAgZmllbGQudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcIjogYW55XCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKFwiO1wiKTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0dldHRlciA9IGZ1bmN0aW9uIChnZXR0ZXIsIGN0eCkge1xuICAgICAgICBpZiAoZ2V0dGVyLmhhc01vZGlmaWVyKG8uU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoXCJnZXQgXCIgKyBnZXR0ZXIubmFtZSArIFwiKClcIik7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGdldHRlci50eXBlKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwiOlwiKTtcbiAgICAgICAgICAgIGdldHRlci50eXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChcImNvbnN0cnVjdG9yKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kLCBjdHgpIHtcbiAgICAgICAgaWYgKG1ldGhvZC5oYXNNb2RpZmllcihvLlN0bXRNb2RpZmllci5Qcml2YXRlKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwicHJpdmF0ZSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KG1ldGhvZC5uYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoXCIpOlwiKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWV0aG9kLnR5cGUpKSB7XG4gICAgICAgICAgICBtZXRob2QudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcInZvaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oXCIge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhtZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KFwiKTpcIik7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFzdC50eXBlKSkge1xuICAgICAgICAgICAgYXN0LnR5cGUudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCJ2b2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKFwiID0+IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChcIik6XCIpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdG10LnR5cGUpKSB7XG4gICAgICAgICAgICBzdG10LnR5cGUudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCJ2b2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9IGNhdGNoIChcIiArIGFic3RyYWN0X2VtaXR0ZXJfMS5DQVRDSF9FUlJPUl9WQVIubmFtZSArIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHZhciBjYXRjaFN0bXRzID0gW1xuICAgICAgICAgICAgYWJzdHJhY3RfZW1pdHRlcl8xLkNBVENIX1NUQUNLX1ZBUi5zZXQoYWJzdHJhY3RfZW1pdHRlcl8xLkNBVENIX0VSUk9SX1ZBUi5wcm9wKCdzdGFjaycpKVxuICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtvLlN0bXRNb2RpZmllci5GaW5hbF0pXG4gICAgICAgIF0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgdmFyIHR5cGVTdHI7XG4gICAgICAgIHN3aXRjaCAodHlwZS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIG8uQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdib29sZWFuJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugby5CdWlsdGluVHlwZU5hbWUuRHluYW1pYzpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2FueSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG8uQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnRnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5UeXBlTmFtZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5UeXBlTmFtZS5JbnQ6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5UeXBlTmFtZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBidWlsdGluIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludCh0eXBlU3RyKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbFR5cGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhpcy5fdmlzaXRJZGVudGlmaWVyKGFzdC52YWx1ZSwgYXN0LnR5cGVQYXJhbXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXJyYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0eXBlLm9mKSkge1xuICAgICAgICAgICAgdHlwZS5vZi52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChcImFueVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoXCJbXVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNYXBUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoXCJ7W2tleTogc3RyaW5nXTpcIik7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGUudmFsdWVUeXBlKSkge1xuICAgICAgICAgICAgdHlwZS52YWx1ZVR5cGUudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCJhbnlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdjb25jYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvLkJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG8uQnVpbHRpbk1ldGhvZC5iaW5kOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJhbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChcIjpcIik7XG4gICAgICAgICAgICAgICAgcGFyYW0udHlwZS52aXNpdFR5cGUoX3RoaXMsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdElkZW50aWZpZXIgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGVQYXJhbXMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkludGVybmFsIGVycm9yOiB1bmtub3duIGlkZW50aWZpZXIgXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFsdWUubW9kdWxlVXJsKSAmJiB2YWx1ZS5tb2R1bGVVcmwgIT0gdGhpcy5fbW9kdWxlVXJsKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLmdldCh2YWx1ZS5tb2R1bGVVcmwpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcImltcG9ydFwiICsgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNldCh2YWx1ZS5tb2R1bGVVcmwsIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQocHJlZml4ICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludCh2YWx1ZS5uYW1lKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHlwZVBhcmFtcykgJiYgdHlwZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCI8XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUudmlzaXRUeXBlKF90aGlzLCBjdHgpOyB9LCB0eXBlUGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICAgICAgICBjdHgucHJpbnQoXCI+XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1RzRW1pdHRlclZpc2l0b3I7XG59KGFic3RyYWN0X2VtaXR0ZXJfMS5BYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10c19lbWl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFBhcnNlTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlTG9jYXRpb24oZmlsZSwgb2Zmc2V0LCBsaW5lLCBjb2wpIHtcbiAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sID0gY29sO1xuICAgIH1cbiAgICBQYXJzZUxvY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZmlsZS51cmwgKyBcIkBcIiArIHRoaXMubGluZSArIFwiOlwiICsgdGhpcy5jb2w7IH07XG4gICAgcmV0dXJuIFBhcnNlTG9jYXRpb247XG59KCkpO1xuZXhwb3J0cy5QYXJzZUxvY2F0aW9uID0gUGFyc2VMb2NhdGlvbjtcbnZhciBQYXJzZVNvdXJjZUZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlU291cmNlRmlsZShjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZVNvdXJjZUZpbGU7XG59KCkpO1xuZXhwb3J0cy5QYXJzZVNvdXJjZUZpbGUgPSBQYXJzZVNvdXJjZUZpbGU7XG52YXIgUGFyc2VTb3VyY2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICBQYXJzZVNvdXJjZVNwYW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5maWxlLmNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuc3RhcnQub2Zmc2V0LCB0aGlzLmVuZC5vZmZzZXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlU291cmNlU3Bhbjtcbn0oKSk7XG5leHBvcnRzLlBhcnNlU291cmNlU3BhbiA9IFBhcnNlU291cmNlU3BhbjtcbihmdW5jdGlvbiAoUGFyc2VFcnJvckxldmVsKSB7XG4gICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIldBUk5JTkdcIl0gPSAwXSA9IFwiV0FSTklOR1wiO1xuICAgIFBhcnNlRXJyb3JMZXZlbFtQYXJzZUVycm9yTGV2ZWxbXCJGQVRBTFwiXSA9IDFdID0gXCJGQVRBTFwiO1xufSkoZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwgfHwgKGV4cG9ydHMuUGFyc2VFcnJvckxldmVsID0ge30pKTtcbnZhciBQYXJzZUVycm9yTGV2ZWwgPSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbDtcbnZhciBQYXJzZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZUVycm9yKHNwYW4sIG1zZywgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBQYXJzZUVycm9yTGV2ZWwuRkFUQUw7IH1cbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNwYW4uc3RhcnQuZmlsZS5jb250ZW50O1xuICAgICAgICB2YXIgY3R4U3RhcnQgPSB0aGlzLnNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICBpZiAoY3R4U3RhcnQgPiBzb3VyY2UubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY3R4U3RhcnQgPSBzb3VyY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3R4RW5kID0gY3R4U3RhcnQ7XG4gICAgICAgIHZhciBjdHhMZW4gPSAwO1xuICAgICAgICB2YXIgY3R4TGluZXMgPSAwO1xuICAgICAgICB3aGlsZSAoY3R4TGVuIDwgMTAwICYmIGN0eFN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgY3R4U3RhcnQtLTtcbiAgICAgICAgICAgIGN0eExlbisrO1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtjdHhTdGFydF0gPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eExlbiA9IDA7XG4gICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgd2hpbGUgKGN0eExlbiA8IDEwMCAmJiBjdHhFbmQgPCBzb3VyY2UubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY3R4RW5kKys7XG4gICAgICAgICAgICBjdHhMZW4rKztcbiAgICAgICAgICAgIGlmIChzb3VyY2VbY3R4RW5kXSA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKGN0eFN0YXJ0LCB0aGlzLnNwYW4uc3RhcnQub2Zmc2V0KSArICdbRVJST1IgLT5dJyArXG4gICAgICAgICAgICBzb3VyY2Uuc3Vic3RyaW5nKHRoaXMuc3Bhbi5zdGFydC5vZmZzZXQsIGN0eEVuZCArIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cgKyBcIiAoXFxcIlwiICsgY29udGV4dCArIFwiXFxcIik6IFwiICsgdGhpcy5zcGFuLnN0YXJ0O1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KCkpO1xuZXhwb3J0cy5QYXJzZUVycm9yID0gUGFyc2VFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlX3V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvcmVfcHJpdmF0ZV8xID0gcmVxdWlyZSgnLi4vY29yZV9wcml2YXRlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG5mdW5jdGlvbiBfaXNQaXBlTWV0YWRhdGEodHlwZSkge1xuICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgY29yZV8xLlBpcGVNZXRhZGF0YTtcbn1cbnZhciBQaXBlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBpcGVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KF9yZWZsZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gY29yZV8xLnJlZmxlY3RvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4ge0BsaW5rIFBpcGVNZXRhZGF0YX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAqL1xuICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBtZXRhcyA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhjb3JlXzEucmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtZXRhcykpIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gbWV0YXMuZmluZChfaXNQaXBlTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJObyBQaXBlIGRlY29yYXRvciBmb3VuZCBvbiBcIiArIGxhbmdfMS5zdHJpbmdpZnkodHlwZSkpO1xuICAgIH07XG4gICAgUGlwZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIFBpcGVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlX3ByaXZhdGVfMS5SZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gUGlwZVJlc29sdmVyO1xufSgpKTtcbmV4cG9ydHMuUGlwZVJlc29sdmVyID0gUGlwZVJlc29sdmVyO1xuZXhwb3J0cy5DT0RFR0VOX1BJUEVfUkVTT0xWRVIgPSBuZXcgUGlwZVJlc29sdmVyKGNvcmVfMS5yZWZsZWN0b3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZV9yZXNvbHZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIHRlbXBsYXRlX2FzdF8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9hc3QnKTtcbnZhciBjb21waWxlX21ldGFkYXRhXzEgPSByZXF1aXJlKCcuL2NvbXBpbGVfbWV0YWRhdGEnKTtcbnZhciBpZGVudGlmaWVyc18xID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xudmFyIHBhcnNlX3V0aWxfMSA9IHJlcXVpcmUoJy4vcGFyc2VfdXRpbCcpO1xudmFyIFByb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyRXJyb3IobWVzc2FnZSwgc3Bhbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb3ZpZGVyRXJyb3I7XG59KHBhcnNlX3V0aWxfMS5QYXJzZUVycm9yKSk7XG5leHBvcnRzLlByb3ZpZGVyRXJyb3IgPSBQcm92aWRlckVycm9yO1xudmFyIFByb3ZpZGVyVmlld0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyVmlld0NvbnRleHQoY29tcG9uZW50LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdRdWVyaWVzID0gX2dldFZpZXdRdWVyaWVzKGNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMudmlld1Byb3ZpZGVycyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRva2VuTWFwKCk7XG4gICAgICAgIF9ub3JtYWxpemVQcm92aWRlcnMoY29tcG9uZW50LnZpZXdQcm92aWRlcnMsIHNvdXJjZVNwYW4sIHRoaXMuZXJyb3JzKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoX3RoaXMudmlld1Byb3ZpZGVycy5nZXQocHJvdmlkZXIudG9rZW4pKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXdQcm92aWRlcnMuYWRkKHByb3ZpZGVyLnRva2VuLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm92aWRlclZpZXdDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuUHJvdmlkZXJWaWV3Q29udGV4dCA9IFByb3ZpZGVyVmlld0NvbnRleHQ7XG52YXIgUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJFbGVtZW50Q29udGV4dChfdmlld0NvbnRleHQsIF9wYXJlbnQsIF9pc1ZpZXdSb290LCBfZGlyZWN0aXZlQXN0cywgYXR0cnMsIHJlZnMsIF9zb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250ZXh0ID0gX3ZpZXdDb250ZXh0O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLl9pc1ZpZXdSb290ID0gX2lzVmlld1Jvb3Q7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUFzdHMgPSBfZGlyZWN0aXZlQXN0cztcbiAgICAgICAgdGhpcy5fc291cmNlU3BhbiA9IF9zb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRva2VuTWFwKCk7XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVUb2tlbk1hcCgpO1xuICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIF90aGlzLl9hdHRyc1thdHRyQXN0Lm5hbWVdID0gYXR0ckFzdC52YWx1ZTsgfSk7XG4gICAgICAgIHZhciBkaXJlY3RpdmVzTWV0YSA9IF9kaXJlY3RpdmVBc3RzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID1cbiAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzRnJvbURpcmVjdGl2ZXMoZGlyZWN0aXZlc01ldGEsIF9zb3VyY2VTcGFuLCBfdmlld0NvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgdGhpcy5fY29udGVudFF1ZXJpZXMgPSBfZ2V0Q29udGVudFF1ZXJpZXMoZGlyZWN0aXZlc01ldGEpO1xuICAgICAgICB2YXIgcXVlcmllZFRva2VucyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRva2VuTWFwKCk7XG4gICAgICAgIHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikgeyBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKHByb3ZpZGVyLnRva2VuLCBxdWVyaWVkVG9rZW5zKTsgfSk7XG4gICAgICAgIHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmQXN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogcmVmQXN0Lm5hbWUgfSksIHF1ZXJpZWRUb2tlbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocXVlcmllZFRva2Vucy5nZXQoaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgdGhlIHByb3ZpZGVycyB0aGF0IHdlIGtub3cgYXJlIGVhZ2VyIGZpcnN0XG4gICAgICAgIHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIGVhZ2VyID0gcHJvdmlkZXIuZWFnZXIgfHwgbGFuZ18xLmlzUHJlc2VudChxdWVyaWVkVG9rZW5zLmdldChwcm92aWRlci50b2tlbikpO1xuICAgICAgICAgICAgaWYgKGVhZ2VyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci5wcm92aWRlclR5cGUsIHByb3ZpZGVyLnRva2VuLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLmFmdGVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY29sbGVjdCBsYXp5IHByb3ZpZGVyc1xuICAgICAgICB0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnZhbHVlcygpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc29ydGVkUHJvdmlkZXJUeXBlcyA9IHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnZhbHVlcygpLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXI7IH0pO1xuICAgICAgICAgICAgdmFyIHNvcnRlZERpcmVjdGl2ZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY2xvbmUodGhpcy5fZGlyZWN0aXZlQXN0cyk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuc29ydChzb3J0ZWREaXJlY3RpdmVzLCBmdW5jdGlvbiAoZGlyMSwgZGlyMikgeyByZXR1cm4gc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjEuZGlyZWN0aXZlLnR5cGUpIC1cbiAgICAgICAgICAgICAgICBzb3J0ZWRQcm92aWRlclR5cGVzLmluZGV4T2YoZGlyMi5kaXJlY3RpdmUudHlwZSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZERpcmVjdGl2ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1ZpZXdDb250YWluZXI7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9hZGRRdWVyeVJlYWRzVG8gPSBmdW5jdGlvbiAodG9rZW4sIHF1ZXJ5UmVhZFRva2Vucykge1xuICAgICAgICB0aGlzLl9nZXRRdWVyaWVzRm9yKHRva2VuKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5UmVhZFRva2VuID0gbGFuZ18xLmlzUHJlc2VudChxdWVyeS5yZWFkKSA/IHF1ZXJ5LnJlYWQgOiB0b2tlbjtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhxdWVyeVJlYWRUb2tlbnMuZ2V0KHF1ZXJ5UmVhZFRva2VuKSkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVJlYWRUb2tlbnMuYWRkKHF1ZXJ5UmVhZFRva2VuLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0UXVlcmllc0ZvciA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICB2YXIgcXVlcmllcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRFbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcXVlcmllcyA9IGN1cnJlbnRFbC5fY29udGVudFF1ZXJpZXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmFkZEFsbChyZXN1bHQsIHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkuZGVzY2VuZGFudHMgfHwgZGlzdGFuY2UgPD0gMTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlQXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXMgPSB0aGlzLl92aWV3Q29udGV4dC52aWV3UXVlcmllcy5nZXQodG9rZW4pO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChxdWVyaWVzKSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmFkZEFsbChyZXN1bHQsIHF1ZXJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIHRva2VuLCBlYWdlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlciA9IHRoaXMuX2FsbFByb3ZpZGVycy5nZXQodG9rZW4pO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzb2x2ZWRQcm92aWRlcikgfHxcbiAgICAgICAgICAgICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gdGVtcGxhdGVfYXN0XzEuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHx8XG4gICAgICAgICAgICAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm92aWRlckFzdFR5cGUuQnVpbHRpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHJhbnNmb3JtZWRQcm92aWRlckFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3NlZW5Qcm92aWRlcnMuZ2V0KHRva2VuKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuLm5hbWUsIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuYWRkKHRva2VuLCB0cnVlKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkUHJvdmlkZXJzID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBwcm92aWRlci51c2VWYWx1ZTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gcHJvdmlkZXIudXNlRXhpc3Rpbmc7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWREZXBzO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXIudXNlRXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfSksIGVhZ2VyKTtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChleGlzdGluZ0RpRGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gZXhpc3RpbmdEaURlcC50b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLmRlcHMpID8gcHJvdmlkZXIuZGVwcyA6IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gbGFuZ18xLmlzUHJlc2VudChwcm92aWRlci5kZXBzKSA/IHByb3ZpZGVyLmRlcHMgOiBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdHJhbnNmb3JtZWRVc2VWYWx1ZSxcbiAgICAgICAgICAgICAgICBkZXBzOiB0cmFuc2Zvcm1lZERlcHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9XG4gICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLmFkZCh0b2tlbiwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgIH07XG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICBpZiAoZGVwLmlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbZGVwLnRva2VuLnZhbHVlXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBsYW5nXzEubm9ybWFsaXplQmxhbmsoYXR0clZhbHVlKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkZXAucXVlcnkpIHx8IGxhbmdfMS5pc1ByZXNlbnQoZGVwLnZpZXdRdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGVwLnRva2VuKSkge1xuICAgICAgICAgICAgLy8gYWNjZXNzIGJ1aWx0aW50c1xuICAgICAgICAgICAgaWYgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gdGVtcGxhdGVfYXN0XzEuUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLmVxdWFsc1RvKGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuUmVuZGVyZXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICBkZXAudG9rZW4uZXF1YWxzVG8oaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5FbGVtZW50UmVmKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLmVxdWFsc1RvKGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYpKSB8fFxuICAgICAgICAgICAgICAgICAgICBkZXAudG9rZW4uZXF1YWxzVG8oaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXAudG9rZW4uZXF1YWxzVG8oaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzVmlld0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWNjZXNzIHRoZSBpbmplY3RvclxuICAgICAgICAgICAgaWYgKGRlcC50b2tlbi5lcXVhbHNUbyhpZGVudGlmaWVyc18xLmlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkluamVjdG9yKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWNjZXNzIHByb3ZpZGVyc1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcC50b2tlbiwgZWFnZXIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICB2YXIgY3VyckVsZW1lbnQgPSB0aGlzO1xuICAgICAgICB2YXIgY3VyckVhZ2VyID0gZWFnZXI7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbERlcGVuZGVuY3kocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcC5pc1NlbGYpIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZXN1bHQpICYmIGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhcmVudCBlbGVtZW50c1xuICAgICAgICAgICAgd2hpbGUgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkgJiYgbGFuZ18xLmlzUHJlc2VudChjdXJyRWxlbWVudC5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2RWxlbWVudCA9IGN1cnJFbGVtZW50O1xuICAgICAgICAgICAgICAgIGN1cnJFbGVtZW50ID0gY3VyckVsZW1lbnQuX3BhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkVsZW1lbnQuX2lzVmlld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyckVhZ2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJFbGVtZW50Ll9nZXRMb2NhbERlcGVuZGVuY3kodGVtcGxhdGVfYXN0XzEuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGRlcCwgY3VyckVhZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIEBIb3N0IHJlc3RyaWN0aW9uXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGlmICghZGVwLmlzSG9zdCB8fCB0aGlzLl92aWV3Q29udGV4dC5jb21wb25lbnQudHlwZS5pc0hvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4odGhpcy5fdmlld0NvbnRleHQuY29tcG9uZW50LnR5cGUpLmVxdWFsc1RvKGRlcC50b2tlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl92aWV3Q29udGV4dC52aWV3UHJvdmlkZXJzLmdldChkZXAudG9rZW4pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXAuaXNPcHRpb25hbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGV4dC5lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk5vIHByb3ZpZGVyIGZvciBcIiArIGRlcC50b2tlbi5uYW1lLCB0aGlzLl9zb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBQcm92aWRlckVsZW1lbnRDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IFByb3ZpZGVyRWxlbWVudENvbnRleHQ7XG5mdW5jdGlvbiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIF9hKSB7XG4gICAgdmFyIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIGRlcHMgPSBfYS5kZXBzO1xuICAgIHJldHVybiBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgdG9rZW46IHByb3ZpZGVyLnRva2VuLFxuICAgICAgICB1c2VDbGFzczogcHJvdmlkZXIudXNlQ2xhc3MsXG4gICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcbiAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZXIudXNlRmFjdG9yeSxcbiAgICAgICAgdXNlVmFsdWU6IHVzZVZhbHVlLFxuICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlckFzdChwcm92aWRlciwgX2EpIHtcbiAgICB2YXIgZWFnZXIgPSBfYS5lYWdlciwgcHJvdmlkZXJzID0gX2EucHJvdmlkZXJzO1xuICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIsIHByb3ZpZGVyLmVhZ2VyIHx8IGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIuc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCB0YXJnZXRQcm92aWRlcnMpIHtcbiAgICBpZiAodGFyZ2V0UHJvdmlkZXJzID09PSB2b2lkIDApIHsgdGFyZ2V0UHJvdmlkZXJzID0gbnVsbDsgfVxuICAgIGlmIChsYW5nXzEuaXNCbGFuayh0YXJnZXRQcm92aWRlcnMpKSB7XG4gICAgICAgIHRhcmdldFByb3ZpZGVycyA9IFtdO1xuICAgIH1cbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcm92aWRlcnMpKSB7XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0FycmF5KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplUHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVR5cGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVQcm92aWRlciA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoeyB0b2tlbjogbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlVG9rZW5NZXRhZGF0YSh7IGlkZW50aWZpZXI6IHByb3ZpZGVyIH0pLCB1c2VDbGFzczogcHJvdmlkZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIlVua25vd24gcHJvdmlkZXIgdHlwZSBcIiArIHByb3ZpZGVyLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG5vcm1hbGl6ZVByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcm92aWRlcnMucHVzaChub3JtYWxpemVQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFByb3ZpZGVycztcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlUHJvdmlkZXJzRnJvbURpcmVjdGl2ZXMoZGlyZWN0aXZlcywgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzKSB7XG4gICAgdmFyIHByb3ZpZGVyc0J5VG9rZW4gPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVUb2tlbk1hcCgpO1xuICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciBkaXJQcm92aWRlciA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoeyB0b2tlbjogbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlVG9rZW5NZXRhZGF0YSh7IGlkZW50aWZpZXI6IGRpcmVjdGl2ZS50eXBlIH0pLCB1c2VDbGFzczogZGlyZWN0aXZlLnR5cGUgfSk7XG4gICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtkaXJQcm92aWRlcl0sIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/IHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQgOiB0ZW1wbGF0ZV9hc3RfMS5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlLCB0cnVlLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHByb3ZpZGVyc0J5VG9rZW4pO1xuICAgIH0pO1xuICAgIC8vIE5vdGU6IGRpcmVjdGl2ZXMgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJ3cml0ZSBwcm92aWRlcnMgb2YgYSBjb21wb25lbnQhXG4gICAgdmFyIGRpcmVjdGl2ZXNXaXRoQ29tcG9uZW50Rmlyc3QgPSBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBkaXIuaXNDb21wb25lbnQ7IH0pLmNvbmNhdChkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAhZGlyLmlzQ29tcG9uZW50OyB9KSk7XG4gICAgZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdC5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoX25vcm1hbGl6ZVByb3ZpZGVycyhkaXJlY3RpdmUucHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpLCB0ZW1wbGF0ZV9hc3RfMS5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKF9ub3JtYWxpemVQcm92aWRlcnMoZGlyZWN0aXZlLnZpZXdQcm92aWRlcnMsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycyksIHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyc0J5VG9rZW47XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVycyhwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgZWFnZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbikge1xuICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlciA9IHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uZ2V0KHByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmVzb2x2ZWRQcm92aWRlcikgJiYgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyICE9PSBwcm92aWRlci5tdWx0aSkge1xuICAgICAgICAgICAgdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJNaXhpbmcgbXVsdGkgYW5kIG5vbiBtdWx0aSBwcm92aWRlciBpcyBub3QgcG9zc2libGUgZm9yIHRva2VuIFwiICsgcmVzb2x2ZWRQcm92aWRlci50b2tlbi5uYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlc29sdmVkUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5tdWx0aSwgZWFnZXIsIFtwcm92aWRlcl0sIHByb3ZpZGVyVHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB0YXJnZXRQcm92aWRlcnNCeVRva2VuLmFkZChwcm92aWRlci50b2tlbiwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsZWFyKHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KSB7XG4gICAgdmFyIHZpZXdRdWVyaWVzID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlVG9rZW5NYXAoKTtcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wb25lbnQudmlld1F1ZXJpZXMpKSB7XG4gICAgICAgIGNvbXBvbmVudC52aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgcXVlcnkpOyB9KTtcbiAgICB9XG4gICAgY29tcG9uZW50LnR5cGUuZGlEZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkZXAudmlld1F1ZXJ5KSkge1xuICAgICAgICAgICAgX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgZGVwLnZpZXdRdWVyeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmlld1F1ZXJpZXM7XG59XG5mdW5jdGlvbiBfZ2V0Q29udGVudFF1ZXJpZXMoZGlyZWN0aXZlcykge1xuICAgIHZhciBjb250ZW50UXVlcmllcyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRva2VuTWFwKCk7XG4gICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGlyZWN0aXZlLnF1ZXJpZXMpKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmUucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcChjb250ZW50UXVlcmllcywgcXVlcnkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBkaXJlY3RpdmUudHlwZS5kaURlcHMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkZXAucXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgX2FkZFF1ZXJ5VG9Ub2tlbk1hcChjb250ZW50UXVlcmllcywgZGVwLnF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnRRdWVyaWVzO1xufVxuZnVuY3Rpb24gX2FkZFF1ZXJ5VG9Ub2tlbk1hcChtYXAsIHF1ZXJ5KSB7XG4gICAgcXVlcnkuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG1hcC5nZXQodG9rZW4pO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoZW50cnkpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtdO1xuICAgICAgICAgICAgbWFwLmFkZCh0b2tlbiwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJfcGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9hc3luYycpO1xudmFyIGNvbXBpbGVfbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vY29tcGlsZV9tZXRhZGF0YScpO1xudmFyIHN0eWxlX2NvbXBpbGVyXzEgPSByZXF1aXJlKCcuL3N0eWxlX2NvbXBpbGVyJyk7XG52YXIgdmlld19jb21waWxlcl8xID0gcmVxdWlyZSgnLi92aWV3X2NvbXBpbGVyL3ZpZXdfY29tcGlsZXInKTtcbnZhciB0ZW1wbGF0ZV9wYXJzZXJfMSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVfcGFyc2VyJyk7XG52YXIgZGlyZWN0aXZlX25vcm1hbGl6ZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlX25vcm1hbGl6ZXInKTtcbnZhciBtZXRhZGF0YV9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9tZXRhZGF0YV9yZXNvbHZlcicpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciBpciA9IHJlcXVpcmUoJy4vb3V0cHV0L291dHB1dF9hc3QnKTtcbnZhciBvdXRwdXRfaml0XzEgPSByZXF1aXJlKCcuL291dHB1dC9vdXRwdXRfaml0Jyk7XG52YXIgb3V0cHV0X2ludGVycHJldGVyXzEgPSByZXF1aXJlKCcuL291dHB1dC9vdXRwdXRfaW50ZXJwcmV0ZXInKTtcbnZhciBpbnRlcnByZXRpdmVfdmlld18xID0gcmVxdWlyZSgnLi9vdXRwdXQvaW50ZXJwcmV0aXZlX3ZpZXcnKTtcbnZhciB4aHJfMSA9IHJlcXVpcmUoJy4veGhyJyk7XG52YXIgUnVudGltZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSdW50aW1lQ29tcGlsZXIoX21ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZU5vcm1hbGl6ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF94aHIsIF9nZW5Db25maWcpIHtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciA9IF9tZXRhZGF0YVJlc29sdmVyO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIgPSBfdGVtcGxhdGVOb3JtYWxpemVyO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZVBhcnNlciA9IF90ZW1wbGF0ZVBhcnNlcjtcbiAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xuICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICB0aGlzLl94aHIgPSBfeGhyO1xuICAgICAgICB0aGlzLl9nZW5Db25maWcgPSBfZ2VuQ29uZmlnO1xuICAgICAgICB0aGlzLl9zdHlsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ob3N0Q2FjaGVLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVEb25lID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLnJlc29sdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgICB2YXIgY29tcE1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICB2YXIgaG9zdENhY2hlS2V5ID0gdGhpcy5faG9zdENhY2hlS2V5cy5nZXQoY29tcG9uZW50VHlwZSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhob3N0Q2FjaGVLZXkpKSB7XG4gICAgICAgICAgICBob3N0Q2FjaGVLZXkgPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Q2FjaGVLZXlzLnNldChjb21wb25lbnRUeXBlLCBob3N0Q2FjaGVLZXkpO1xuICAgICAgICAgICAgYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIHZhciBob3N0TWV0YSA9IGNvbXBpbGVfbWV0YWRhdGFfMS5jcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YS50eXBlLCBjb21wTWV0YS5zZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLl9sb2FkQW5kQ29tcGlsZUNvbXBvbmVudChob3N0Q2FjaGVLZXksIGhvc3RNZXRhLCBbY29tcE1ldGFdLCBbXSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlZFRlbXBsYXRlRG9uZS5nZXQoaG9zdENhY2hlS2V5KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbXBpbGVkVGVtcGxhdGUpIHsgcmV0dXJuIG5ldyBjb3JlXzEuQ29tcG9uZW50RmFjdG9yeShjb21wTWV0YS5zZWxlY3RvciwgY29tcGlsZWRUZW1wbGF0ZS52aWV3RmFjdG9yeSwgY29tcG9uZW50VHlwZSk7IH0pO1xuICAgIH07XG4gICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdHlsZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlRG9uZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9ob3N0Q2FjaGVLZXlzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9sb2FkQW5kQ29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjYWNoZUtleSwgY29tcE1ldGEsIHZpZXdEaXJlY3RpdmVzLCBwaXBlcywgY29tcGlsaW5nQ29tcG9uZW50c1BhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgdmFyIGRvbmUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlRG9uZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcGlsZWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjYWNoZUtleSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgICAgICBkb25lID1cbiAgICAgICAgICAgICAgICBhc3luY18xLlByb21pc2VXcmFwcGVyLmFsbChbdGhpcy5fY29tcGlsZUNvbXBvbmVudFN0eWxlcyhjb21wTWV0YSldLmNvbmNhdCh2aWV3RGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpck1ldGEpIHsgcmV0dXJuIF90aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIubm9ybWFsaXplRGlyZWN0aXZlKGRpck1ldGEpOyB9KSkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdHlsZXNBbmROb3JtYWxpemVkVmlld0Rpck1ldGFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmlld0Rpck1ldGFzID0gc3R5bGVzQW5kTm9ybWFsaXplZFZpZXdEaXJNZXRhcy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHN0eWxlc0FuZE5vcm1hbGl6ZWRWaWV3RGlyTWV0YXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRUZW1wbGF0ZSA9IF90aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIG5vcm1hbGl6ZWRWaWV3RGlyTWV0YXMsIHBpcGVzLCBjb21wTWV0YS50eXBlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlZFRlbXBsYXRlLmluaXQoX3RoaXMuX2NvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCBzdHlsZXMsIHBpcGVzLCBjb21waWxpbmdDb21wb25lbnRzUGF0aCwgY2hpbGRQcm9taXNlcykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5hbGwoY2hpbGRQcm9taXNlcykudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlRG9uZS5zZXQoY2FjaGVLZXksIGRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xuICAgIH07XG4gICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wTWV0YSwgcGFyc2VkVGVtcGxhdGUsIHN0eWxlcywgcGlwZXMsIGNvbXBpbGluZ0NvbXBvbmVudHNQYXRoLCBjaGlsZFByb21pc2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCBuZXcgaXIuRXh0ZXJuYWxFeHByKG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IHJ1bnRpbWU6IHN0eWxlcyB9KSksIHBpcGVzKTtcbiAgICAgICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb21waWxpbmdDb21wb25lbnRzUGF0aCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jbG9uZShjb21waWxpbmdDb21wb25lbnRzUGF0aCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRDYWNoZUtleSA9IGRlcC5jb21wLnR5cGUucnVudGltZTtcbiAgICAgICAgICAgIHZhciBjaGlsZFZpZXdEaXJlY3RpdmVzID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0Vmlld0RpcmVjdGl2ZXNNZXRhZGF0YShkZXAuY29tcC50eXBlLnJ1bnRpbWUpO1xuICAgICAgICAgICAgdmFyIGNoaWxkVmlld1BpcGVzID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0Vmlld1BpcGVzTWV0YWRhdGEoZGVwLmNvbXAudHlwZS5ydW50aW1lKTtcbiAgICAgICAgICAgIHZhciBjaGlsZElzUmVjdXJzaXZlID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbnRhaW5zKGNoaWxkQ29tcGlsaW5nQ29tcG9uZW50c1BhdGgsIGNoaWxkQ2FjaGVLZXkpO1xuICAgICAgICAgICAgY2hpbGRDb21waWxpbmdDb21wb25lbnRzUGF0aC5wdXNoKGNoaWxkQ2FjaGVLZXkpO1xuICAgICAgICAgICAgdmFyIGNoaWxkQ29tcCA9IF90aGlzLl9sb2FkQW5kQ29tcGlsZUNvbXBvbmVudChkZXAuY29tcC50eXBlLnJ1bnRpbWUsIGRlcC5jb21wLCBjaGlsZFZpZXdEaXJlY3RpdmVzLCBjaGlsZFZpZXdQaXBlcywgY2hpbGRDb21waWxpbmdDb21wb25lbnRzUGF0aCk7XG4gICAgICAgICAgICBkZXAuZmFjdG9yeVBsYWNlaG9sZGVyLnJ1bnRpbWUgPSBjaGlsZENvbXAucHJveHlWaWV3RmFjdG9yeTtcbiAgICAgICAgICAgIGRlcC5mYWN0b3J5UGxhY2Vob2xkZXIubmFtZSA9IFwidmlld0ZhY3RvcnlfXCIgKyBkZXAuY29tcC50eXBlLm5hbWU7XG4gICAgICAgICAgICBpZiAoIWNoaWxkSXNSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHdhaXQgZm9yIGEgY2hpbGQgaWYgaXQgaXMgbm90IGEgY3ljbGVcbiAgICAgICAgICAgICAgICBjaGlsZFByb21pc2VzLnB1c2goX3RoaXMuX2NvbXBpbGVkVGVtcGxhdGVEb25lLmdldChjaGlsZENhY2hlS2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZmFjdG9yeTtcbiAgICAgICAgaWYgKGxhbmdfMS5JU19EQVJUIHx8ICF0aGlzLl9nZW5Db25maWcudXNlSml0KSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gb3V0cHV0X2ludGVycHJldGVyXzEuaW50ZXJwcmV0U3RhdGVtZW50cyhjb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIGNvbXBpbGVSZXN1bHQudmlld0ZhY3RvcnlWYXIsIG5ldyBpbnRlcnByZXRpdmVfdmlld18xLkludGVycHJldGl2ZUFwcFZpZXdJbnN0YW5jZUZhY3RvcnkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gb3V0cHV0X2ppdF8xLmppdFN0YXRlbWVudHMoY29tcE1ldGEudHlwZS5uYW1lICsgXCIudGVtcGxhdGUuanNcIiwgY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzLCBjb21waWxlUmVzdWx0LnZpZXdGYWN0b3J5VmFyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9O1xuICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRTdHlsZXMgPSBmdW5jdGlvbiAoY29tcE1ldGEpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVSZXN1bHQgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQoY29tcE1ldGEudHlwZS5uYW1lLCBjb21waWxlUmVzdWx0KTtcbiAgICB9O1xuICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0ID0gZnVuY3Rpb24gKHNvdXJjZVVybCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IHJlc3VsdC5kZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9sb2FkU3R5bGVzaGVldERlcChkZXApOyB9KTtcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXIuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNzc1RleHRzKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkQ29tcGlsZVJlc3VsdFByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5kZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwID0gcmVzdWx0LmRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgY3NzVGV4dCA9IGNzc1RleHRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRDb21waWxlUmVzdWx0ID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZVN0eWxlc2hlZXQoZGVwLm1vZHVsZVVybCwgY3NzVGV4dCwgZGVwLmlzU2hpbW1lZCk7XG4gICAgICAgICAgICAgICAgbmVzdGVkQ29tcGlsZVJlc3VsdFByb21pc2VzLnB1c2goX3RoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KGRlcC5tb2R1bGVVcmwsIG5lc3RlZENvbXBpbGVSZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhc3luY18xLlByb21pc2VXcmFwcGVyLmFsbChuZXN0ZWRDb21waWxlUmVzdWx0UHJvbWlzZXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG5lc3RlZFN0eWxlc0Fycikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcCA9IHJlc3VsdC5kZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIucnVudGltZSA9IG5lc3RlZFN0eWxlc0FycltpXTtcbiAgICAgICAgICAgICAgICBkZXAudmFsdWVQbGFjZWhvbGRlci5uYW1lID0gXCJpbXBvcnRlZFN0eWxlc1wiICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYW5nXzEuSVNfREFSVCB8fCAhX3RoaXMuX2dlbkNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0X2ludGVycHJldGVyXzEuaW50ZXJwcmV0U3RhdGVtZW50cyhyZXN1bHQuc3RhdGVtZW50cywgcmVzdWx0LnN0eWxlc1ZhciwgbmV3IGludGVycHJldGl2ZV92aWV3XzEuSW50ZXJwcmV0aXZlQXBwVmlld0luc3RhbmNlRmFjdG9yeSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRfaml0XzEuaml0U3RhdGVtZW50cyhzb3VyY2VVcmwgKyBcIi5jc3MuanNcIiwgcmVzdWx0LnN0YXRlbWVudHMsIHJlc3VsdC5zdHlsZXNWYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2xvYWRTdHlsZXNoZWV0RGVwID0gZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBcIlwiICsgZGVwLm1vZHVsZVVybCArIChkZXAuaXNTaGltbWVkID8gJy5zaGltJyA6ICcnKTtcbiAgICAgICAgdmFyIGNzc1RleHRQcm9taXNlID0gdGhpcy5fc3R5bGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY3NzVGV4dFByb21pc2UpKSB7XG4gICAgICAgICAgICBjc3NUZXh0UHJvbWlzZSA9IHRoaXMuX3hoci5nZXQoZGVwLm1vZHVsZVVybCk7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZUNhY2hlLnNldChjYWNoZUtleSwgY3NzVGV4dFByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3NUZXh0UHJvbWlzZTtcbiAgICB9O1xuICAgIFJ1bnRpbWVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBSdW50aW1lQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogbWV0YWRhdGFfcmVzb2x2ZXJfMS5Db21waWxlTWV0YWRhdGFSZXNvbHZlciwgfSxcbiAgICAgICAgeyB0eXBlOiBkaXJlY3RpdmVfbm9ybWFsaXplcl8xLkRpcmVjdGl2ZU5vcm1hbGl6ZXIsIH0sXG4gICAgICAgIHsgdHlwZTogdGVtcGxhdGVfcGFyc2VyXzEuVGVtcGxhdGVQYXJzZXIsIH0sXG4gICAgICAgIHsgdHlwZTogc3R5bGVfY29tcGlsZXJfMS5TdHlsZUNvbXBpbGVyLCB9LFxuICAgICAgICB7IHR5cGU6IHZpZXdfY29tcGlsZXJfMS5WaWV3Q29tcGlsZXIsIH0sXG4gICAgICAgIHsgdHlwZTogeGhyXzEuWEhSLCB9LFxuICAgICAgICB7IHR5cGU6IGNvbmZpZ18xLkNvbXBpbGVyQ29uZmlnLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIFJ1bnRpbWVDb21waWxlcjtcbn0oKSk7XG5leHBvcnRzLlJ1bnRpbWVDb21waWxlciA9IFJ1bnRpbWVDb21waWxlcjtcbnZhciBDb21waWxlZFRlbXBsYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlZFRlbXBsYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXdGYWN0b3J5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm94eVZpZXdGYWN0b3J5ID0gZnVuY3Rpb24gKHZpZXdVdGlscywgY2hpbGRJbmplY3RvciwgY29udGV4dEVsKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudmlld0ZhY3Rvcnkodmlld1V0aWxzLCBjaGlsZEluamVjdG9yLCBjb250ZXh0RWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBDb21waWxlZFRlbXBsYXRlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHZpZXdGYWN0b3J5KSB7IHRoaXMudmlld0ZhY3RvcnkgPSB2aWV3RmFjdG9yeTsgfTtcbiAgICByZXR1cm4gQ29tcGlsZWRUZW1wbGF0ZTtcbn0oKSk7XG5mdW5jdGlvbiBhc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgIGlmICghbWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBtZXRhLnR5cGUubmFtZSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVudGltZV9jb21waWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uLy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBlbGVtZW50X3NjaGVtYV9yZWdpc3RyeV8xID0gcmVxdWlyZSgnLi9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeScpO1xudmFyIEVWRU5UID0gJ2V2ZW50JztcbnZhciBCT09MRUFOID0gJ2Jvb2xlYW4nO1xudmFyIE5VTUJFUiA9ICdudW1iZXInO1xudmFyIFNUUklORyA9ICdzdHJpbmcnO1xudmFyIE9CSkVDVCA9ICdvYmplY3QnO1xuLyoqXG4gKiBUaGlzIGFycmF5IHJlcHJlc2VudHMgdGhlIERPTSBzY2hlbWEuIEl0IGVuY29kZXMgaW5oZXJpdGFuY2UsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gKlxuICogIyMgT3ZlcnZpZXdcbiAqXG4gKiBFYWNoIGxpbmUgcmVwcmVzZW50cyBvbmUga2luZCBvZiBlbGVtZW50LiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGFuZCBwcm9wZXJ0aWVzIGFyZSBqb2luZWRcbiAqIHVzaW5nIGBlbGVtZW50X2luaGVyaXRhbmNlfHByZXBlcnRpZXNgIHN5bnRheC5cbiAqXG4gKiAjIyBFbGVtZW50IEluaGVyaXRhbmNlXG4gKlxuICogVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBjYW4gYmUgZnVydGhlciBzdWJkaXZpZGVkIGFzIGBlbGVtZW50MSxlbGVtZW50MiwuLi5ecGFyZW50RWxlbWVudGAuXG4gKiBIZXJlIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFdmVyeSBlbGVtZW50IGluIHRoZSBsaXN0XG4gKiBoYXMgaWRlbnRpY2FsIHByb3BlcnRpZXMuXG4gKlxuICogQW4gYGVsZW1lbnRgIG1heSBpbmhlcml0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIGBwYXJlbnRFbGVtZW50YCBJZiBubyBgXnBhcmVudEVsZW1lbnRgIGlzXG4gKiBzcGVjaWZpZWQgdGhlbiBgXCJcImAgKGJsYW5rKSBlbGVtZW50IGlzIGFzc3VtZWQuXG4gKlxuICogTk9URTogVGhlIGJsYW5rIGVsZW1lbnQgaW5oZXJpdHMgZnJvbSByb290IGAqYCBlbGVtZW50LCB0aGUgc3VwZXIgZWxlbWVudCBvZiBhbGwgZWxlbWVudHMuXG4gKlxuICogTk9URSBhbiBlbGVtZW50IHByZWZpeCBzdWNoIGFzIGBAc3ZnOmAgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyB0byB0aGUgc2NoZW1hLlxuICpcbiAqICMjIFByb3BlcnRpZXNcbiAqXG4gKiBFYWNoIGVsZW1lbnQgaGFzIGEgc2V0IG9mIHByb3BlcnRpZXMgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRWFjaCBwcm9wZXJ0eSBjYW4gYmUgcHJlZml4ZWRcbiAqIGJ5IGEgc3BlY2lhbCBjaGFyYWN0ZXIgZGVzaWduYXRpbmcgaXRzIHR5cGU6XG4gKlxuICogLSAobm8gcHJlZml4KTogcHJvcGVydHkgaXMgYSBzdHJpbmcuXG4gKiAtIGAqYDogcHJvcGVydHkgcmVwcmVzZW50cyBhbiBldmVudC5cbiAqIC0gYCFgOiBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4uXG4gKiAtIGAjYDogcHJvcGVydHkgaXMgYSBudW1iZXIuXG4gKiAtIGAlYDogcHJvcGVydHkgaXMgYW4gb2JqZWN0LlxuICpcbiAqICMjIFF1ZXJ5XG4gKlxuICogVGhlIGNsYXNzIGNyZWF0ZXMgYW4gaW50ZXJuYWwgc3F1YXMgcmVwcmVzZW50YWlubyB3aGljaCBhbGxvd3MgdG8gZWFzaWx5IGFuc3dlciB0aGUgcXVlcnkgb2ZcbiAqIGlmIGEgZ2l2ZW4gcHJvcGVydHkgZXhpc3Qgb24gYSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIE5PVEU6IFdlIGRvbid0IHlldCBzdXBwb3J0IHF1ZXJ5aW5nIGZvciB0eXBlcyBvciBldmVudHMuXG4gKiBOT1RFOiBUaGlzIHNjaGVtYSBpcyBhdXRvIGV4dHJhY3RlZCBmcm9tIGBzY2hlbWFfZXh0cmFjdG9yLnRzYCBsb2NhdGVkIGluIHRoZSB0ZXN0IGZvbGRlci5cbiAqL1xudmFyIFNDSEVNQSA9IFxuLypAdHMyZGFydF9jb25zdCovIChbXG4gICAgJyp8JWNsYXNzTGlzdCxjbGFzc05hbWUsaWQsaW5uZXJIVE1MLCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpjb3B5LCpjdXQsKnBhc3RlLCpzZWFyY2gsKnNlbGVjdHN0YXJ0LCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVySFRNTCwjc2Nyb2xsTGVmdCwjc2Nyb2xsVG9wJyxcbiAgICAnXip8YWNjZXNzS2V5LGNvbnRlbnRFZGl0YWJsZSxkaXIsIWRyYWdnYWJsZSwhaGlkZGVuLGlubmVyVGV4dCxsYW5nLCphYm9ydCwqYXV0b2NvbXBsZXRlLCphdXRvY29tcGxldGVlcnJvciwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjb3B5LCpjdWVjaGFuZ2UsKmN1dCwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbWVzc2FnZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKm1vemZ1bGxzY3JlZW5jaGFuZ2UsKm1vemZ1bGxzY3JlZW5lcnJvciwqbW96cG9pbnRlcmxvY2tjaGFuZ2UsKm1venBvaW50ZXJsb2NrZXJyb3IsKnBhc3RlLCpwYXVzZSwqcGxheSwqcGxheWluZywqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2VhcmNoLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2VsZWN0c3RhcnQsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsKndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IsKndlYmdsY29udGV4dGxvc3QsKndlYmdsY29udGV4dHJlc3RvcmVkLCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVyVGV4dCwhc3BlbGxjaGVjaywlc3R5bGUsI3RhYkluZGV4LHRpdGxlLCF0cmFuc2xhdGUnLFxuICAgICdtZWRpYXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjcm9zc09yaWdpbiwjY3VycmVudFRpbWUsIWRlZmF1bHRNdXRlZCwjZGVmYXVsdFBsYXliYWNrUmF0ZSwhZGlzYWJsZVJlbW90ZVBsYXliYWNrLCFsb29wLCFtdXRlZCwqZW5jcnlwdGVkLCNwbGF5YmFja1JhdGUscHJlbG9hZCxzcmMsI3ZvbHVtZScsXG4gICAgJ0Bzdmc6Xip8KmFib3J0LCphdXRvY29tcGxldGUsKmF1dG9jb21wbGV0ZWVycm9yLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywlc3R5bGUsI3RhYkluZGV4JyxcbiAgICAnQHN2ZzpncmFwaGljc15Ac3ZnOnwnLFxuICAgICdAc3ZnOmFuaW1hdGlvbl5Ac3ZnOnwqYmVnaW4sKmVuZCwqcmVwZWF0JyxcbiAgICAnQHN2ZzpnZW9tZXRyeV5Ac3ZnOnwnLFxuICAgICdAc3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25eQHN2Zzp8JyxcbiAgICAnQHN2ZzpncmFkaWVudF5Ac3ZnOnwnLFxuICAgICdAc3ZnOnRleHRDb250ZW50XkBzdmc6Z3JhcGhpY3N8JyxcbiAgICAnQHN2Zzp0ZXh0UG9zaXRpb25pbmdeQHN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICdhfGNoYXJzZXQsY29vcmRzLGRvd25sb2FkLGhhc2gsaG9zdCxob3N0bmFtZSxocmVmLGhyZWZsYW5nLG5hbWUscGFzc3dvcmQscGF0aG5hbWUscGluZyxwb3J0LHByb3RvY29sLHJlbCxyZXYsc2VhcmNoLHNoYXBlLHRhcmdldCx0ZXh0LHR5cGUsdXNlcm5hbWUnLFxuICAgICdhcmVhfGFsdCxjb29yZHMsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wsc2VhcmNoLHNoYXBlLHRhcmdldCx1c2VybmFtZScsXG4gICAgJ2F1ZGlvXm1lZGlhfCcsXG4gICAgJ2JyfGNsZWFyJyxcbiAgICAnYmFzZXxocmVmLHRhcmdldCcsXG4gICAgJ2JvZHl8YUxpbmssYmFja2dyb3VuZCxiZ0NvbG9yLGxpbmssKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQsdGV4dCx2TGluaycsXG4gICAgJ2J1dHRvbnwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAnY2FudmFzfCNoZWlnaHQsI3dpZHRoJyxcbiAgICAnY29udGVudHxzZWxlY3QnLFxuICAgICdkbHwhY29tcGFjdCcsXG4gICAgJ2RhdGFsaXN0fCcsXG4gICAgJ2RldGFpbHN8IW9wZW4nLFxuICAgICdkaWFsb2d8IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICdkaXJ8IWNvbXBhY3QnLFxuICAgICdkaXZ8YWxpZ24nLFxuICAgICdlbWJlZHxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgJ2ZpZWxkc2V0fCFkaXNhYmxlZCxuYW1lJyxcbiAgICAnZm9udHxjb2xvcixmYWNlLHNpemUnLFxuICAgICdmb3JtfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgJ2ZyYW1lfGZyYW1lQm9yZGVyLGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLCFub1Jlc2l6ZSxzY3JvbGxpbmcsc3JjJyxcbiAgICAnZnJhbWVzZXR8Y29scywqYmVmb3JldW5sb2FkLCpibHVyLCplcnJvciwqZm9jdXMsKmhhc2hjaGFuZ2UsKmxhbmd1YWdlY2hhbmdlLCpsb2FkLCptZXNzYWdlLCpvZmZsaW5lLCpvbmxpbmUsKnBhZ2VoaWRlLCpwYWdlc2hvdywqcG9wc3RhdGUsKnJlamVjdGlvbmhhbmRsZWQsKnJlc2l6ZSwqc2Nyb2xsLCpzdG9yYWdlLCp1bmhhbmRsZWRyZWplY3Rpb24sKnVubG9hZCxyb3dzJyxcbiAgICAnaHJ8YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgJ2hlYWR8JyxcbiAgICAnaDEsaDIsaDMsaDQsaDUsaDZ8YWxpZ24nLFxuICAgICdodG1sfHZlcnNpb24nLFxuICAgICdpZnJhbWV8YWxpZ24sIWFsbG93RnVsbHNjcmVlbixmcmFtZUJvcmRlcixoZWlnaHQsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUsJXNhbmRib3gsc2Nyb2xsaW5nLHNyYyxzcmNkb2Msd2lkdGgnLFxuICAgICdpbWd8YWxpZ24sYWx0LGJvcmRlciwlY3Jvc3NPcmlnaW4sI2hlaWdodCwjaHNwYWNlLCFpc01hcCxsb25nRGVzYyxsb3dzcmMsbmFtZSxzaXplcyxzcmMsc3Jjc2V0LHVzZU1hcCwjdnNwYWNlLCN3aWR0aCcsXG4gICAgJ2lucHV0fGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgJ2tleWdlbnwhYXV0b2ZvY3VzLGNoYWxsZW5nZSwhZGlzYWJsZWQsa2V5dHlwZSxuYW1lJyxcbiAgICAnbGl8dHlwZSwjdmFsdWUnLFxuICAgICdsYWJlbHxodG1sRm9yJyxcbiAgICAnbGVnZW5kfGFsaWduJyxcbiAgICAnbGlua3xhcyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGlzYWJsZWQsaHJlZixocmVmbGFuZyxpbnRlZ3JpdHksbWVkaWEscmVsLCVyZWxMaXN0LHJldiwlc2l6ZXMsdGFyZ2V0LHR5cGUnLFxuICAgICdtYXB8bmFtZScsXG4gICAgJ21hcnF1ZWV8YmVoYXZpb3IsYmdDb2xvcixkaXJlY3Rpb24saGVpZ2h0LCNoc3BhY2UsI2xvb3AsI3Njcm9sbEFtb3VudCwjc2Nyb2xsRGVsYXksIXRydWVTcGVlZCwjdnNwYWNlLHdpZHRoJyxcbiAgICAnbWVudXwhY29tcGFjdCcsXG4gICAgJ21ldGF8Y29udGVudCxodHRwRXF1aXYsbmFtZSxzY2hlbWUnLFxuICAgICdtZXRlcnwjaGlnaCwjbG93LCNtYXgsI21pbiwjb3B0aW11bSwjdmFsdWUnLFxuICAgICdpbnMsZGVsfGNpdGUsZGF0ZVRpbWUnLFxuICAgICdvbHwhY29tcGFjdCwhcmV2ZXJzZWQsI3N0YXJ0LHR5cGUnLFxuICAgICdvYmplY3R8YWxpZ24sYXJjaGl2ZSxib3JkZXIsY29kZSxjb2RlQmFzZSxjb2RlVHlwZSxkYXRhLCFkZWNsYXJlLGhlaWdodCwjaHNwYWNlLG5hbWUsc3RhbmRieSx0eXBlLHVzZU1hcCwjdnNwYWNlLHdpZHRoJyxcbiAgICAnb3B0Z3JvdXB8IWRpc2FibGVkLGxhYmVsJyxcbiAgICAnb3B0aW9ufCFkZWZhdWx0U2VsZWN0ZWQsIWRpc2FibGVkLGxhYmVsLCFzZWxlY3RlZCx0ZXh0LHZhbHVlJyxcbiAgICAnb3V0cHV0fGRlZmF1bHRWYWx1ZSwlaHRtbEZvcixuYW1lLHZhbHVlJyxcbiAgICAncHxhbGlnbicsXG4gICAgJ3BhcmFtfG5hbWUsdHlwZSx2YWx1ZSx2YWx1ZVR5cGUnLFxuICAgICdwaWN0dXJlfCcsXG4gICAgJ3ByZXwjd2lkdGgnLFxuICAgICdwcm9ncmVzc3wjbWF4LCN2YWx1ZScsXG4gICAgJ3EsYmxvY2txdW90ZSxjaXRlfCcsXG4gICAgJ3NjcmlwdHwhYXN5bmMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRlZmVyLGV2ZW50LGh0bWxGb3IsaW50ZWdyaXR5LHNyYyx0ZXh0LHR5cGUnLFxuICAgICdzZWxlY3R8IWF1dG9mb2N1cywhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICdzaGFkb3d8JyxcbiAgICAnc291cmNlfG1lZGlhLHNpemVzLHNyYyxzcmNzZXQsdHlwZScsXG4gICAgJ3NwYW58JyxcbiAgICAnc3R5bGV8IWRpc2FibGVkLG1lZGlhLHR5cGUnLFxuICAgICdjYXB0aW9ufGFsaWduJyxcbiAgICAndGgsdGR8YWJicixhbGlnbixheGlzLGJnQ29sb3IsY2gsY2hPZmYsI2NvbFNwYW4saGVhZGVycyxoZWlnaHQsIW5vV3JhcCwjcm93U3BhbixzY29wZSx2QWxpZ24sd2lkdGgnLFxuICAgICdjb2wsY29sZ3JvdXB8YWxpZ24sY2gsY2hPZmYsI3NwYW4sdkFsaWduLHdpZHRoJyxcbiAgICAndGFibGV8YWxpZ24sYmdDb2xvcixib3JkZXIsJWNhcHRpb24sY2VsbFBhZGRpbmcsY2VsbFNwYWNpbmcsZnJhbWUscnVsZXMsc3VtbWFyeSwldEZvb3QsJXRIZWFkLHdpZHRoJyxcbiAgICAndHJ8YWxpZ24sYmdDb2xvcixjaCxjaE9mZix2QWxpZ24nLFxuICAgICd0Zm9vdCx0aGVhZCx0Ym9keXxhbGlnbixjaCxjaE9mZix2QWxpZ24nLFxuICAgICd0ZW1wbGF0ZXwnLFxuICAgICd0ZXh0YXJlYXxhdXRvY2FwaXRhbGl6ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAndGl0bGV8dGV4dCcsXG4gICAgJ3RyYWNrfCFkZWZhdWx0LGtpbmQsbGFiZWwsc3JjLHNyY2xhbmcnLFxuICAgICd1bHwhY29tcGFjdCx0eXBlJyxcbiAgICAndW5rbm93bnwnLFxuICAgICd2aWRlb15tZWRpYXwjaGVpZ2h0LHBvc3Rlciwjd2lkdGgnLFxuICAgICdAc3ZnOmFeQHN2ZzpncmFwaGljc3wnLFxuICAgICdAc3ZnOmFuaW1hdGVeQHN2ZzphbmltYXRpb258JyxcbiAgICAnQHN2ZzphbmltYXRlTW90aW9uXkBzdmc6YW5pbWF0aW9ufCcsXG4gICAgJ0Bzdmc6YW5pbWF0ZVRyYW5zZm9ybV5Ac3ZnOmFuaW1hdGlvbnwnLFxuICAgICdAc3ZnOmNpcmNsZV5Ac3ZnOmdlb21ldHJ5fCcsXG4gICAgJ0Bzdmc6Y2xpcFBhdGheQHN2ZzpncmFwaGljc3wnLFxuICAgICdAc3ZnOmN1cnNvcl5Ac3ZnOnwnLFxuICAgICdAc3ZnOmRlZnNeQHN2ZzpncmFwaGljc3wnLFxuICAgICdAc3ZnOmRlc2NeQHN2Zzp8JyxcbiAgICAnQHN2ZzpkaXNjYXJkXkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZWxsaXBzZV5Ac3ZnOmdlb21ldHJ5fCcsXG4gICAgJ0Bzdmc6ZmVCbGVuZF5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZlQ29sb3JNYXRyaXheQHN2Zzp8JyxcbiAgICAnQHN2ZzpmZUNvbXBvbmVudFRyYW5zZmVyXkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZmVDb21wb3NpdGVeQHN2Zzp8JyxcbiAgICAnQHN2ZzpmZUNvbnZvbHZlTWF0cml4XkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZmVEaWZmdXNlTGlnaHRpbmdeQHN2Zzp8JyxcbiAgICAnQHN2ZzpmZURpc3BsYWNlbWVudE1hcF5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZlRGlzdGFudExpZ2h0XkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZmVEcm9wU2hhZG93XkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZmVGbG9vZF5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZlRnVuY0FeQHN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJ0Bzdmc6ZmVGdW5jQl5Ac3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnQHN2ZzpmZUZ1bmNHXkBzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICdAc3ZnOmZlRnVuY1JeQHN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJ0Bzdmc6ZmVHYXVzc2lhbkJsdXJeQHN2Zzp8JyxcbiAgICAnQHN2ZzpmZUltYWdlXkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZmVNZXJnZV5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZlTWVyZ2VOb2RlXkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZmVNb3JwaG9sb2d5XkBzdmc6fCcsXG4gICAgJ0Bzdmc6ZmVPZmZzZXReQHN2Zzp8JyxcbiAgICAnQHN2ZzpmZVBvaW50TGlnaHReQHN2Zzp8JyxcbiAgICAnQHN2ZzpmZVNwZWN1bGFyTGlnaHRpbmdeQHN2Zzp8JyxcbiAgICAnQHN2ZzpmZVNwb3RMaWdodF5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZlVGlsZV5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZlVHVyYnVsZW5jZV5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZpbHRlcl5Ac3ZnOnwnLFxuICAgICdAc3ZnOmZvcmVpZ25PYmplY3ReQHN2ZzpncmFwaGljc3wnLFxuICAgICdAc3ZnOmdeQHN2ZzpncmFwaGljc3wnLFxuICAgICdAc3ZnOmltYWdlXkBzdmc6Z3JhcGhpY3N8JyxcbiAgICAnQHN2ZzpsaW5lXkBzdmc6Z2VvbWV0cnl8JyxcbiAgICAnQHN2ZzpsaW5lYXJHcmFkaWVudF5Ac3ZnOmdyYWRpZW50fCcsXG4gICAgJ0Bzdmc6bXBhdGheQHN2Zzp8JyxcbiAgICAnQHN2ZzptYXJrZXJeQHN2Zzp8JyxcbiAgICAnQHN2ZzptYXNrXkBzdmc6fCcsXG4gICAgJ0Bzdmc6bWV0YWRhdGFeQHN2Zzp8JyxcbiAgICAnQHN2ZzpwYXRoXkBzdmc6Z2VvbWV0cnl8JyxcbiAgICAnQHN2ZzpwYXR0ZXJuXkBzdmc6fCcsXG4gICAgJ0Bzdmc6cG9seWdvbl5Ac3ZnOmdlb21ldHJ5fCcsXG4gICAgJ0Bzdmc6cG9seWxpbmVeQHN2ZzpnZW9tZXRyeXwnLFxuICAgICdAc3ZnOnJhZGlhbEdyYWRpZW50XkBzdmc6Z3JhZGllbnR8JyxcbiAgICAnQHN2ZzpyZWN0XkBzdmc6Z2VvbWV0cnl8JyxcbiAgICAnQHN2ZzpzdmdeQHN2ZzpncmFwaGljc3wjY3VycmVudFNjYWxlLCN6b29tQW5kUGFuJyxcbiAgICAnQHN2ZzpzY3JpcHReQHN2Zzp8dHlwZScsXG4gICAgJ0Bzdmc6c2V0XkBzdmc6YW5pbWF0aW9ufCcsXG4gICAgJ0Bzdmc6c3RvcF5Ac3ZnOnwnLFxuICAgICdAc3ZnOnN0eWxlXkBzdmc6fCFkaXNhYmxlZCxtZWRpYSx0aXRsZSx0eXBlJyxcbiAgICAnQHN2Zzpzd2l0Y2heQHN2ZzpncmFwaGljc3wnLFxuICAgICdAc3ZnOnN5bWJvbF5Ac3ZnOnwnLFxuICAgICdAc3ZnOnRzcGFuXkBzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJ0Bzdmc6dGV4dF5Ac3ZnOnRleHRQb3NpdGlvbmluZ3wnLFxuICAgICdAc3ZnOnRleHRQYXRoXkBzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAnQHN2Zzp0aXRsZV5Ac3ZnOnwnLFxuICAgICdAc3ZnOnVzZV5Ac3ZnOmdyYXBoaWNzfCcsXG4gICAgJ0Bzdmc6dmlld15Ac3ZnOnwjem9vbUFuZFBhbidcbl0pO1xudmFyIGF0dHJUb1Byb3BNYXAgPSB7XG4gICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4J1xufTtcbnZhciBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSB7fTtcbiAgICAgICAgU0NIRU1BLmZvckVhY2goZnVuY3Rpb24gKGVuY29kZWRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBlbmNvZGVkVHlwZS5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBwYXJ0c1sxXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgdmFyIHR5cGVQYXJ0cyA9IChwYXJ0c1swXSArICdeJykuc3BsaXQoJ14nKTtcbiAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IHR5cGVQYXJ0c1swXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0ge307XG4gICAgICAgICAgICB0eXBlTmFtZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gX3RoaXMuc2NoZW1hW3RhZ10gPSB0eXBlOyB9KTtcbiAgICAgICAgICAgIHZhciBzdXBlclR5cGUgPSBfdGhpcy5zY2hlbWFbdHlwZVBhcnRzWzFdXTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHN1cGVyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHN1cGVyVHlwZSwgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHR5cGVba10gPSB2OyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgPT0gJycpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkuc3RhcnRzV2l0aCgnKicpKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5LnN0YXJ0c1dpdGgoJyEnKSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBCT09MRUFOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eS5zdGFydHNXaXRoKCclJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gT0JKRUNUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eV0gPSBTVFJJTkc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lKSB7XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGNhbid0IHRlbGwgbm93IGFzIHdlIGRvbid0IGtub3cgd2hpY2ggcHJvcGVydGllcyBhIGN1c3RvbSBlbGVtZW50IHdpbGwgZ2V0XG4gICAgICAgICAgICAvLyBvbmNlIGl0IGlzIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLnNjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKCFsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnRQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRQcm9wZXJ0aWVzID0gdGhpcy5zY2hlbWFbJ3Vua25vd24nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KGVsZW1lbnRQcm9wZXJ0aWVzW3Byb3BOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNlY3VyaXR5Q29udGV4dCByZXR1cm5zIHRoZSBzZWN1cml0eSBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGdpdmVuIERPTSB0YWcuXG4gICAgICpcbiAgICAgKiBUYWcgYW5kIHByb3BlcnR5IG5hbWUgYXJlIHN0YXRpY2FsbHkga25vd24gYW5kIGNhbm5vdCBjaGFuZ2UgYXQgcnVudGltZSwgaS5lLiBpdCBpcyBub3RcbiAgICAgKiBwb3NzaWJsZSB0byBiaW5kIGEgdmFsdWUgaW50byBhIGNoYW5naW5nIGF0dHJpYnV0ZSBvciB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSBmaWx0ZXJpbmcgaXMgd2hpdGUgbGlzdCBiYXNlZC4gQWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHNjaGVtYSBhYm92ZSBhcmUgYXNzdW1lZCB0byBoYXZlIHRoZVxuICAgICAqICdOT05FJyBzZWN1cml0eSBjb250ZXh0LCBpLmUuIHRoYXQgdGhleSBhcmUgc2FmZSBpbmVydCBzdHJpbmcgdmFsdWVzLiBPbmx5IHNwZWNpZmljIHdlbGwga25vd25cbiAgICAgKiBhdHRhY2sgdmVjdG9ycyBhcmUgYXNzaWduZWQgdGhlaXIgYXBwcm9wcmlhdGUgY29udGV4dC5cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSkge1xuICAgICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IEZpbGwgaW4gbWlzc2luZyBwcm9wZXJ0aWVzLlxuICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdzdHlsZScpXG4gICAgICAgICAgICByZXR1cm4gY29yZV9wcml2YXRlXzEuU2VjdXJpdHlDb250ZXh0LlNUWUxFO1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ2EnICYmIHByb3BOYW1lID09PSAnaHJlZicpXG4gICAgICAgICAgICByZXR1cm4gY29yZV9wcml2YXRlXzEuU2VjdXJpdHlDb250ZXh0LlVSTDtcbiAgICAgICAgaWYgKHByb3BOYW1lID09PSAnaW5uZXJIVE1MJylcbiAgICAgICAgICAgIHJldHVybiBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuSFRNTDtcbiAgICAgICAgcmV0dXJuIGNvcmVfcHJpdmF0ZV8xLlNlY3VyaXR5Q29udGV4dC5OT05FO1xuICAgIH07XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRNYXBwZWRQcm9wTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICB2YXIgbWFwcGVkUHJvcE5hbWUgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQoYXR0clRvUHJvcE1hcCwgcHJvcE5hbWUpO1xuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChtYXBwZWRQcm9wTmFtZSkgPyBtYXBwZWRQcm9wTmFtZSA6IHByb3BOYW1lO1xuICAgIH07XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgIHJldHVybiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XG59KGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KSk7XG5leHBvcnRzLkRvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbn0oKSk7XG5leHBvcnRzLkVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIF9FTVBUWV9BVFRSX1ZBTFVFID0gJyc7XG4vLyBUT0RPOiBDYW4ndCB1c2UgYGNvbnN0YCBoZXJlIGFzXG4vLyBpbiBEYXJ0IHRoaXMgaXMgbm90IHRyYW5zcGlsZWQgaW50byBgZmluYWxgIHlldC4uLlxudmFyIF9TRUxFQ1RPUl9SRUdFWFAgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJyhcXFxcOm5vdFxcXFwoKXwnICtcbiAgICAnKFstXFxcXHddKyl8JyArXG4gICAgJyg/OlxcXFwuKFstXFxcXHddKykpfCcgK1xuICAgICcoPzpcXFxcWyhbLVxcXFx3Kl0rKSg/Oj0oW15cXFxcXV0qKSk/XFxcXF0pfCcgK1xuICAgICcoXFxcXCkpfCcgK1xuICAgICcoXFxcXHMqLFxcXFxzKiknKTsgLy8gXCIsXCJcbi8qKlxuICogQSBjc3Mgc2VsZWN0b3IgY29udGFpbnMgYW4gZWxlbWVudCBuYW1lLFxuICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAqL1xudmFyIENzc1NlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgQ3NzU2VsZWN0b3IucGFyc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIF9hZGRSZXN1bHQgPSBmdW5jdGlvbiAocmVzLCBjc3NTZWwpIHtcbiAgICAgICAgICAgIGlmIChjc3NTZWwubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgbGFuZ18xLmlzQmxhbmsoY3NzU2VsLmVsZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmlzRW1wdHkoY3NzU2VsLmNsYXNzTmFtZXMpICYmIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5pc0VtcHR5KGNzc1NlbC5hdHRycykpIHtcbiAgICAgICAgICAgICAgICBjc3NTZWwuZWxlbWVudCA9IFwiKlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICAgIHZhciBtYXRjaGVyID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIubWF0Y2hlcihfU0VMRUNUT1JfUkVHRVhQLCBzZWxlY3Rvcik7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgdmFyIGluTm90ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoID0gbGFuZ18xLlJlZ0V4cE1hdGNoZXJXcmFwcGVyLm5leHQobWF0Y2hlcikpKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdOZXN0aW5nIDpub3QgaXMgbm90IGFsbG93ZWQgaW4gYSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbk5vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWF0Y2hbMl0pKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXRFbGVtZW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKG1hdGNoWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKG1hdGNoWzRdLCBtYXRjaFs1XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChtYXRjaFs2XSkpIHtcbiAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG1hdGNoWzddKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5pc0VsZW1lbnRTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5lbGVtZW50KSAmJiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eSh0aGlzLmNsYXNzTmFtZXMpICYmXG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaXNFbXB0eSh0aGlzLmF0dHJzKSAmJiB0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHsgZWxlbWVudCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IGxhbmdfMS5pc1ByZXNlbnQodGhpcy5lbGVtZW50KSA/IHRoaXMuZWxlbWVudCA6ICdkaXYnO1xuICAgICAgICB2YXIgY2xhc3NBdHRyID0gdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDAgPyBcIiBjbGFzcz1cXFwiXCIgKyB0aGlzLmNsYXNzTmFtZXMuam9pbignICcpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgdmFyIGF0dHJzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdGhpcy5hdHRyc1tpXTtcbiAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBcIj1cXFwiXCIgKyB0aGlzLmF0dHJzW2kgKyAxXSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiPjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gX0VNUFRZX0FUVFJfVkFMVUU7IH1cbiAgICAgICAgdGhpcy5hdHRycy5wdXNoKG5hbWUpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gX0VNUFRZX0FUVFJfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRycy5wdXNoKHZhbHVlKTtcbiAgICB9O1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5hZGRDbGFzc05hbWUgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLmNsYXNzTmFtZXMucHVzaChuYW1lLnRvTG93ZXJDYXNlKCkpOyB9O1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9ICcnO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXMgKz0gdGhpcy5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuY2xhc3NOYW1lcykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9ICcuJyArIHRoaXMuY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmF0dHJzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB0aGlzLmF0dHJzW2krK107XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IHRoaXMuYXR0cnNbaSsrXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gJ1snICsgYXR0ck5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSAnPScgKyBhdHRyVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyArPSAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAobm90U2VsZWN0b3IpIHsgcmV0dXJuIHJlcyArPSBcIjpub3QoXCIgKyBub3RTZWxlY3RvciArIFwiKVwiOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBDc3NTZWxlY3Rvcjtcbn0oKSk7XG5leHBvcnRzLkNzc1NlbGVjdG9yID0gQ3NzU2VsZWN0b3I7XG4vKipcbiAqIFJlYWRzIGEgbGlzdCBvZiBDc3NTZWxlY3RvcnMgYW5kIGFsbG93cyB0byBjYWxjdWxhdGUgd2hpY2ggb25lc1xuICogYXJlIGNvbnRhaW5lZCBpbiBhIGdpdmVuIENzc1NlbGVjdG9yLlxuICovXG52YXIgU2VsZWN0b3JNYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rvck1hdGNoZXIoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRNYXAgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xuICAgICAgICB0aGlzLl9lbGVtZW50UGFydGlhbE1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcbiAgICAgICAgdGhpcy5fY2xhc3NQYXJ0aWFsTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIHRoaXMuX2xpc3RDb250ZXh0cyA9IFtdO1xuICAgIH1cbiAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIG5vdE1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIG5vdE1hdGNoZXIuYWRkU2VsZWN0YWJsZXMobm90U2VsZWN0b3JzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5vdE1hdGNoZXI7XG4gICAgfTtcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgIHZhciBsaXN0Q29udGV4dCA9IG51bGw7XG4gICAgICAgIGlmIChjc3NTZWxlY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGlzdENvbnRleHQgPSBuZXcgU2VsZWN0b3JMaXN0Q29udGV4dChjc3NTZWxlY3RvcnMpO1xuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzLnB1c2gobGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTZWxlY3RhYmxlKGNzc1NlbGVjdG9yc1tpXSwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvYmplY3QgdGhhdCBjYW4gYmUgZm91bmQgbGF0ZXIgb24gYnkgY2FsbGluZyBgbWF0Y2hgLlxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgdmFyIHNlbGVjdGFibGUgPSBuZXcgU2VsZWN0b3JDb250ZXh0KGNzc1NlbGVjdG9yLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjbGFzc05hbWVzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgaW5kZXggPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwobWF0Y2hlci5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChtYXRjaGVyLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGF0dHJzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUZXJtaW5hbCA9IGluZGV4ID09PSBhdHRycy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh0ZXJtaW5hbFZhbHVlc01hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsVmFsdWVzTWFwID0gbmV3IGNvbGxlY3Rpb25fMS5NYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTWFwLnNldChhdHRyTmFtZSwgdGVybWluYWxWYWx1ZXNNYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCBhdHRyVmFsdWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnR0aWFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlUGFydGlhbE1hcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0dGlhbE1hcC5nZXQoYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGFydGlhbFZhbHVlc01hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxWYWx1ZXNNYXAgPSBuZXcgY29sbGVjdGlvbl8xLk1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHRpYWxNYXAuc2V0KGF0dHJOYW1lLCBwYXJ0aWFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkVGVybWluYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBzZWxlY3RhYmxlKSB7XG4gICAgICAgIHZhciB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodGVybWluYWxMaXN0KSkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfTtcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhtYXRjaGVyKSkge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiB3aG9zZSBjc3Mgc2VsZWN0b3IgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiBjc3Mgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIG1hdGNoZWRDYWxsYmFjayBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBoYW5kZWQgaW50byBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZSBpZiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgIHZhciBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzW2ldLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9lbGVtZW50TWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2xhc3NOYW1lcykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjbGFzc05hbWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRoaXMuX2NsYXNzTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXR0cnMpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYXR0cnMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVNYXAuZ2V0KGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhhdHRyVmFsdWUsIF9FTVBUWV9BVFRSX1ZBTFVFKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCBfRU1QVFlfQVRUUl9WQUxVRSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgYXR0clZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwLmdldChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoYXR0clZhbHVlLCBfRU1QVFlfQVRUUl9WQUxVRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsIF9FTVBUWV9BVFRSX1ZBTFVFLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgYXR0clZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWFwKSB8fCBsYW5nXzEuaXNCbGFuayhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIHZhciBzdGFyU2VsZWN0YWJsZXMgPSBtYXAuZ2V0KFwiKlwiKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoc3RhclNlbGVjdGFibGVzKSkge1xuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoc2VsZWN0YWJsZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGFibGU7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHNlbGVjdGFibGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2luZGV4XTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGVjdGFibGUuZmluYWxpemUoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjayAvKjogKGM6IENzc1NlbGVjdG9yLCBhOiBhbnkpID0+IHZvaWQqLykge1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobWFwKSB8fCBsYW5nXzEuaXNCbGFuayhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXN0ZWRTZWxlY3RvciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhuZXN0ZWRTZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKHBlcmYpOiBnZXQgcmlkIG9mIHJlY3Vyc2lvbiBhbmQgbWVhc3VyZSBhZ2FpblxuICAgICAgICAvLyBUT0RPKHBlcmYpOiBkb24ndCBwYXNzIHRoZSB3aG9sZSBzZWxlY3RvciBpbnRvIHRoZSByZWN1cnNpb24sXG4gICAgICAgIC8vIGJ1dCBvbmx5IHRoZSBub3QgcHJvY2Vzc2VkIHBhcnRzXG4gICAgICAgIHJldHVybiBuZXN0ZWRTZWxlY3Rvci5tYXRjaChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3Rvck1hdGNoZXI7XG59KCkpO1xuZXhwb3J0cy5TZWxlY3Rvck1hdGNoZXIgPSBTZWxlY3Rvck1hdGNoZXI7XG52YXIgU2VsZWN0b3JMaXN0Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0b3JMaXN0Q29udGV4dChzZWxlY3RvcnMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgIHRoaXMuYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdG9yTGlzdENvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5TZWxlY3Rvckxpc3RDb250ZXh0ID0gU2VsZWN0b3JMaXN0Q29udGV4dDtcbi8vIFN0b3JlIGNvbnRleHQgdG8gcGFzcyBiYWNrIHNlbGVjdG9yIGFuZCBjb250ZXh0IHdoZW4gYSBzZWxlY3RvciBpcyBtYXRjaGVkXG52YXIgU2VsZWN0b3JDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RvckNvbnRleHQoc2VsZWN0b3IsIGNiQ29udGV4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNiQ29udGV4dCA9IGNiQ29udGV4dDtcbiAgICAgICAgdGhpcy5saXN0Q29udGV4dCA9IGxpc3RDb250ZXh0O1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycztcbiAgICB9XG4gICAgU2VsZWN0b3JDb250ZXh0LnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAobGFuZ18xLmlzQmxhbmsodGhpcy5saXN0Q29udGV4dCkgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICB2YXIgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGxhbmdfMS5pc1ByZXNlbnQoY2FsbGJhY2spICYmXG4gICAgICAgICAgICAobGFuZ18xLmlzQmxhbmsodGhpcy5saXN0Q29udGV4dCkgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmxpc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5zZWxlY3RvciwgdGhpcy5jYkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0b3JDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuU2VsZWN0b3JDb250ZXh0ID0gU2VsZWN0b3JDb250ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG4vKipcbiAqIFRoaXMgZmlsZSBpcyBhIHBvcnQgb2Ygc2hhZG93Q1NTIGZyb20gd2ViY29tcG9uZW50cy5qcyB0byBUeXBlU2NyaXB0LlxuICpcbiAqIFBsZWFzZSBtYWtlIHN1cmUgdG8ga2VlcCB0byBlZGl0cyBpbiBzeW5jIHdpdGggdGhlIHNvdXJjZSBmaWxlLlxuICpcbiAqIFNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iLzRlZmVjZDdlMGUvc3JjL1NoYWRvd0NTUy9TaGFkb3dDU1MuanNcbiAqXG4gKiBUaGUgb3JpZ2luYWwgZmlsZSBsZXZlbCBjb21tZW50IGlzIHJlcHJvZHVjZWQgYmVsb3dcbiAqL1xuLypcbiAgVGhpcyBpcyBhIGxpbWl0ZWQgc2hpbSBmb3IgU2hhZG93RE9NIGNzcyBzdHlsaW5nLlxuICBodHRwczovL2R2Y3MudzMub3JnL2hnL3dlYmNvbXBvbmVudHMvcmF3LWZpbGUvdGlwL3NwZWMvc2hhZG93L2luZGV4Lmh0bWwjc3R5bGVzXG5cbiAgVGhlIGludGVudGlvbiBoZXJlIGlzIHRvIHN1cHBvcnQgb25seSB0aGUgc3R5bGluZyBmZWF0dXJlcyB3aGljaCBjYW4gYmVcbiAgcmVsYXRpdmVseSBzaW1wbHkgaW1wbGVtZW50ZWQuIFRoZSBnb2FsIGlzIHRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIHRoZVxuICBtb3N0IG9idmlvdXMgcGl0ZmFsbHMgYW5kIGRvIHNvIHdpdGhvdXQgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHNpZ25pZmljYW50bHkuXG4gIEZvciBTaGFkb3dET00gc3R5bGluZyB0aGF0J3Mgbm90IGNvdmVyZWQgaGVyZSwgYSBzZXQgb2YgYmVzdCBwcmFjdGljZXNcbiAgY2FuIGJlIHByb3ZpZGVkIHRoYXQgc2hvdWxkIGFsbG93IHVzZXJzIHRvIGFjY29tcGxpc2ggbW9yZSBjb21wbGV4IHN0eWxpbmcuXG5cbiAgVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2Ygc3BlY2lmaWMgU2hhZG93RE9NIHN0eWxpbmcgZmVhdHVyZXMgYW5kIGEgYnJpZWZcbiAgZGlzY3Vzc2lvbiBvZiB0aGUgYXBwcm9hY2ggdXNlZCB0byBzaGltLlxuXG4gIFNoaW1tZWQgZmVhdHVyZXM6XG5cbiAgKiA6aG9zdCwgOmhvc3QtY29udGV4dDogU2hhZG93RE9NIGFsbG93cyBzdHlsaW5nIG9mIHRoZSBzaGFkb3dSb290J3MgaG9zdFxuICBlbGVtZW50IHVzaW5nIHRoZSA6aG9zdCBydWxlLiBUbyBzaGltIHRoaXMgZmVhdHVyZSwgdGhlIDpob3N0IHN0eWxlcyBhcmVcbiAgcmVmb3JtYXR0ZWQgYW5kIHByZWZpeGVkIHdpdGggYSBnaXZlbiBzY29wZSBuYW1lIGFuZCBwcm9tb3RlZCB0byBhXG4gIGRvY3VtZW50IGxldmVsIHN0eWxlc2hlZXQuXG4gIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgLmZvbywgYSBydWxlIGxpa2UgdGhpczpcblxuICAgIDpob3N0IHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuICAgIH1cblxuICBiZWNvbWVzOlxuXG4gICAgLmZvbyB7XG4gICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgfVxuXG4gICogZW5jYXBzdWx0aW9uOiBTdHlsZXMgZGVmaW5lZCB3aXRoaW4gU2hhZG93RE9NLCBhcHBseSBvbmx5IHRvXG4gIGRvbSBpbnNpZGUgdGhlIFNoYWRvd0RPTS4gUG9seW1lciB1c2VzIG9uZSBvZiB0d28gdGVjaG5pcXVlcyB0byBpbXBsZW1lbnRcbiAgdGhpcyBmZWF0dXJlLlxuXG4gIEJ5IGRlZmF1bHQsIHJ1bGVzIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWVcbiAgYXMgYSBkZXNjZW5kYW50IHNlbGVjdG9yLiBUaGlzIGVuc3VyZXMgc3R5bGluZyBkb2VzIG5vdCBsZWFrIG91dCBvZiB0aGUgJ3RvcCdcbiAgb2YgdGhlIGVsZW1lbnQncyBTaGFkb3dET00uIEZvciBleGFtcGxlLFxuXG4gIGRpdiB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgYmVjb21lczpcblxuICB4LWZvbyBkaXYge1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gIGJlY29tZXM6XG5cblxuICBBbHRlcm5hdGl2ZWx5LCBpZiBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5zdHJpY3RTdHlsaW5nIGlzIHNldCB0byB0cnVlIHRoZW5cbiAgc2VsZWN0b3JzIGFyZSBzY29wZWQgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciBzdWZmaXggdG8gZWFjaFxuICBzaW1wbGUgc2VsZWN0b3IgdGhhdCBjb250YWlucyB0aGUgaG9zdCBlbGVtZW50IHRhZyBuYW1lLiBFYWNoIGVsZW1lbnRcbiAgaW4gdGhlIGVsZW1lbnQncyBTaGFkb3dET00gdGVtcGxhdGUgaXMgYWxzbyBnaXZlbiB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICBUaHVzLCB0aGVzZSBydWxlcyBtYXRjaCBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICBGb3IgZXhhbXBsZSwgZ2l2ZW4gYSBzY29wZSBuYW1lIG9mIHgtZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxuXG4gICAgZGl2IHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICBiZWNvbWVzOlxuXG4gICAgZGl2W3gtZm9vXSB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgTm90ZSB0aGF0IGVsZW1lbnRzIHRoYXQgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHRvIGEgc2NvcGUgbXVzdCBoYXZlIHRoZSBzY29wZVxuICBzZWxlY3RvciBhZGRlZCB0byB0aGVtIG1hbnVhbGx5LlxuXG4gICogdXBwZXIvbG93ZXIgYm91bmQgZW5jYXBzdWxhdGlvbjogU3R5bGVzIHdoaWNoIGFyZSBkZWZpbmVkIG91dHNpZGUgYVxuICBzaGFkb3dSb290IHNob3VsZCBub3QgY3Jvc3MgdGhlIFNoYWRvd0RPTSBib3VuZGFyeSBhbmQgc2hvdWxkIG5vdCBhcHBseVxuICBpbnNpZGUgYSBzaGFkb3dSb290LlxuXG4gIFRoaXMgc3R5bGluZyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIFNvbWUgcG9zc2libGUgd2F5cyB0byBkbyB0aGlzIHRoYXRcbiAgd2VyZSByZWplY3RlZCBkdWUgdG8gY29tcGxleGl0eSBhbmQvb3IgcGVyZm9ybWFuY2UgY29uY2VybnMgaW5jbHVkZTogKDEpIHJlc2V0XG4gIGV2ZXJ5IHBvc3NpYmxlIHByb3BlcnR5IGZvciBldmVyeSBwb3NzaWJsZSBzZWxlY3RvciBmb3IgYSBnaXZlbiBzY29wZSBuYW1lO1xuICAoMikgcmUtaW1wbGVtZW50IGNzcyBpbiBqYXZhc2NyaXB0LlxuXG4gIEFzIGFuIGFsdGVybmF0aXZlLCB1c2VycyBzaG91bGQgbWFrZSBzdXJlIHRvIHVzZSBzZWxlY3RvcnNcbiAgc3BlY2lmaWMgdG8gdGhlIHNjb3BlIGluIHdoaWNoIHRoZXkgYXJlIHdvcmtpbmcuXG5cbiAgKiA6OmRpc3RyaWJ1dGVkOiBUaGlzIGJlaGF2aW9yIGlzIG5vdCBlbXVsYXRlZC4gSXQncyBvZnRlbiBub3QgbmVjZXNzYXJ5XG4gIHRvIHN0eWxlIHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIGluc2VydGlvbiBwb2ludCBhbmQgaW5zdGVhZCwgZGVzY2VuZGFudHNcbiAgb2YgdGhlIGhvc3QgZWxlbWVudCBjYW4gYmUgc3R5bGVkIHNlbGVjdGl2ZWx5LiBVc2VycyBjYW4gYWxzbyBjcmVhdGUgYW5cbiAgZXh0cmEgbm9kZSBhcm91bmQgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBzdHlsZSB0aGF0IG5vZGUncyBjb250ZW50c1xuICB2aWEgZGVzY2VuZGVudCBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCB3aXRoIGEgc2hhZG93Um9vdCBsaWtlIHRoaXM6XG5cbiAgICA8c3R5bGU+XG4gICAgICA6OmNvbnRlbnQoZGl2KSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxjb250ZW50PjwvY29udGVudD5cblxuICBjb3VsZCBiZWNvbWU6XG5cbiAgICA8c3R5bGU+XG4gICAgICAvICpAcG9seWZpbGwgLmNvbnRlbnQtY29udGFpbmVyIGRpdiAqIC9cbiAgICAgIDo6Y29udGVudChkaXYpIHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRlbnQtY29udGFpbmVyXCI+XG4gICAgICA8Y29udGVudD48L2NvbnRlbnQ+XG4gICAgPC9kaXY+XG5cbiAgTm90ZSB0aGUgdXNlIG9mIEBwb2x5ZmlsbCBpbiB0aGUgY29tbWVudCBhYm92ZSBhIFNoYWRvd0RPTSBzcGVjaWZpYyBzdHlsZVxuICBkZWNsYXJhdGlvbi4gVGhpcyBpcyBhIGRpcmVjdGl2ZSB0byB0aGUgc3R5bGluZyBzaGltIHRvIHVzZSB0aGUgc2VsZWN0b3JcbiAgaW4gY29tbWVudHMgaW4gbGlldSBvZiB0aGUgbmV4dCBzZWxlY3RvciB3aGVuIHJ1bm5pbmcgdW5kZXIgcG9seWZpbGwuXG4qL1xudmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93Q3NzKCkge1xuICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvKlxuICAgICogU2hpbSBzb21lIGNzc1RleHQgd2l0aCB0aGUgZ2l2ZW4gc2VsZWN0b3IuIFJldHVybnMgY3NzVGV4dCB0aGF0IGNhblxuICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXG4gICAgKlxuICAgICogV2hlbiBzdHJpY3RTdHlsaW5nIGlzIHRydWU6XG4gICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcbiAgICAqIC0gaG9zdFNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gdGhlIGhvc3QgaXRzZWxmLlxuICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5zaGltQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChob3N0U2VsZWN0b3IgPT09IHZvaWQgMCkgeyBob3N0U2VsZWN0b3IgPSAnJzsgfVxuICAgICAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydERpcmVjdGl2ZXMoY3NzVGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZUNzc1RleHQoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfTtcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsRGlyZWN0aXZlc0luQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGNvbnZlcnQgbmF0aXZlIFNoYWRvd0RPTSBydWxlcyB0aGF0IHdpbGwgdHJpcFxuICAgICAqIHVwIHRoZSBjc3MgcGFyc2VyOyB3ZSByZWx5IG9uIGRlY29yYXRpbmcgdGhlIHN0eWxlc2hlZXQgd2l0aCBpbmVydCBydWxlcy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgKlxuICAgICAqIHBvbHlmaWxsLW5leHQtc2VsZWN0b3IgeyBjb250ZW50OiAnOmhvc3QgbWVudS1pdGVtJzsgfVxuICAgICAqIDo6Y29udGVudCBtZW51LWl0ZW0ge1xuICAgICAqXG4gICAgICogdG8gdGhpczpcbiAgICAgKlxuICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0ge1xuICAgICAqXG4gICAgKiovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzQ29udGVudE5leHRTZWxlY3RvclJlLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbVsxXSArICd7JzsgfSk7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICpcbiAgICAgKiBwb2x5ZmlsbC1ydWxlIHtcbiAgICAgKiAgIGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nO1xuICAgICAqIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBzY29wZU5hbWUgbWVudS1pdGVtIHsuLi59XG4gICAgICpcbiAgICAqKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzQ29udGVudFJ1bGVSZSwgZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBydWxlID0gbVswXTtcbiAgICAgICAgICAgIHJ1bGUgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHJ1bGUsIG1bMV0sICcnKTtcbiAgICAgICAgICAgIHJ1bGUgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHJ1bGUsIG1bMl0sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBtWzNdICsgcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiBFbnN1cmUgc3R5bGVzIGFyZSBzY29wZWQuIFBzZXVkby1zY29waW5nIHRha2VzIGEgcnVsZSBsaWtlOlxuICAgICAqXG4gICAgICogIC5mb28gey4uLiB9XG4gICAgICpcbiAgICAgKiAgYW5kIGNvbnZlcnRzIHRoaXMgdG9cbiAgICAgKlxuICAgICAqICBzY29wZU5hbWUgLmZvbyB7IC4uLiB9XG4gICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciB1bnNjb3BlZCA9IHRoaXMuX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX3Njb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQgKyAnXFxuJyArIHVuc2NvcGVkO1xuICAgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICogYW5kIGRvIG5vdCBwcm9jZXNzIHZpYSBDU1NPTS4gKENTU09NIGlzIGRlc3RydWN0aXZlIHRvIHJ1bGVzIG9uIHJhcmVcbiAgICAgKiBvY2Nhc2lvbnMsIGUuZy4gLXdlYmtpdC1jYWxjIG9uIFNhZmFyaS4pXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAqXG4gICAgICogQHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUge1xuICAgICAqICAgY29udGVudDogJ21lbnUtaXRlbSc7XG4gICAgICogLi4uIH1cbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBtZW51LWl0ZW0gey4uLn1cbiAgICAgKlxuICAgICoqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHZhciByID0gJycsIG07XG4gICAgICAgIHZhciBtYXRjaGVyID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIubWF0Y2hlcihfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLCBjc3NUZXh0KTtcbiAgICAgICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQobSA9IGxhbmdfMS5SZWdFeHBNYXRjaGVyV3JhcHBlci5uZXh0KG1hdGNoZXIpKSkge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBtWzBdO1xuICAgICAgICAgICAgcnVsZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2UocnVsZSwgbVsyXSwgJycpO1xuICAgICAgICAgICAgcnVsZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2UocnVsZSwgbVsxXSwgbVszXSk7XG4gICAgICAgICAgICByICs9IHJ1bGUgKyAnXFxuXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8qXG4gICAgICogY29udmVydCBhIHJ1bGUgbGlrZSA6aG9zdCguZm9vKSA+IC5iYXIgeyB9XG4gICAgICpcbiAgICAgKiB0b1xuICAgICAqXG4gICAgICogc2NvcGVOYW1lLmZvbyA+IC5iYXJcbiAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3QgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0UmUsIHRoaXMuX2NvbG9uSG9zdFBhcnRSZXBsYWNlcik7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QtY29udGV4dCguZm9vKSA+IC5iYXIgeyB9XG4gICAgICpcbiAgICAgKiB0b1xuICAgICAqXG4gICAgICogc2NvcGVOYW1lLmZvbyA+IC5iYXIsIC5mb28gc2NvcGVOYW1lID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIGFuZFxuICAgICAqXG4gICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxuICAgICAqXG4gICAgICogdG9cbiAgICAgKlxuICAgICAqIHNjb3BlTmFtZS5mb28gLmJhciB7IC4uLiB9XG4gICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUsIHRoaXMuX2NvbG9uSG9zdENvbnRleHRQYXJ0UmVwbGFjZXIpO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uUnVsZSA9IGZ1bmN0aW9uIChjc3NUZXh0LCByZWdFeHAsIHBhcnRSZXBsYWNlcikge1xuICAgICAgICAvLyBwMSA9IDpob3N0LCBwMiA9IGNvbnRlbnRzIG9mICgpLCBwMyByZXN0IG9mIHJ1bGVcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoY3NzVGV4dCwgcmVnRXhwLCBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobVsyXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBtWzJdLnNwbGl0KCcsJyksIHIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHIucHVzaChwYXJ0UmVwbGFjZXIoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciwgcCwgbVszXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gci5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29sb25Ib3N0Q29udGV4dFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmNvbnRhaW5zKHBhcnQsIF9wb2x5ZmlsbEhvc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKGhvc3QsIHBhcnQsIHN1ZmZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQgKyBzdWZmaXggKyAnLCAnICsgcGFydCArICcgJyArIGhvc3QgKyBzdWZmaXg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QgKyBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHBhcnQsIF9wb2x5ZmlsbEhvc3QsICcnKSArIHN1ZmZpeDtcbiAgICB9O1xuICAgIC8qXG4gICAgICogQ29udmVydCBjb21iaW5hdG9ycyBsaWtlIDo6c2hhZG93IGFuZCBwc2V1ZG8tZWxlbWVudHMgbGlrZSA6OmNvbnRlbnRcbiAgICAgKiBieSByZXBsYWNpbmcgd2l0aCBzcGFjZS5cbiAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zaGFkb3dET01TZWxlY3RvcnNSZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NzVGV4dCA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoY3NzVGV4dCwgX3NoYWRvd0RPTVNlbGVjdG9yc1JlW2ldLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3NUZXh0O1xuICAgIH07XG4gICAgLy8gY2hhbmdlIGEgc2VsZWN0b3IgbGlrZSAnZGl2JyB0byAnbmFtZSBkaXYnXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yWzBdICE9ICdAJyB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BwYWdlJykpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY29wZVNlbGVjdG9yKHJ1bGUuc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3RvciwgX3RoaXMuc3RyaWN0U3R5bGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF90aGlzLl9zY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvciwgc3RyaWN0KSB7XG4gICAgICAgIHZhciByID0gW10sIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoJywnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBwYXJ0c1tpXS50cmltKCk7XG4gICAgICAgICAgICB2YXIgZGVlcFBhcnRzID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3BsaXQocCwgX3NoYWRvd0RlZXBTZWxlY3RvcnMpO1xuICAgICAgICAgICAgdmFyIHNoYWxsb3dQYXJ0ID0gZGVlcFBhcnRzWzBdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGRlZXBQYXJ0c1swXSA9IHN0cmljdCAmJiAhbGFuZ18xLlN0cmluZ1dyYXBwZXIuY29udGFpbnMoc2hhbGxvd1BhcnQsIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgL2RlZXAvIHdpdGggYSBzcGFjZSBmb3IgY2hpbGQgc2VsZWN0b3JzXG4gICAgICAgICAgICByLnB1c2goZGVlcFBhcnRzLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIuam9pbignLCAnKTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3NlbGVjdG9yTmVlZHNTY29waW5nID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIHZhciByZSA9IHRoaXMuX21ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiAhbGFuZ18xLmlzUHJlc2VudChsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKHJlLCBzZWxlY3RvcikpO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fbWFrZVNjb3BlTWF0Y2hlciA9IGZ1bmN0aW9uIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBscmUgPSAvXFxbL2c7XG4gICAgICAgIHZhciBycmUgPSAvXFxdL2c7XG4gICAgICAgIHNjb3BlU2VsZWN0b3IgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHNjb3BlU2VsZWN0b3IsIGxyZSwgJ1xcXFxbJyk7XG4gICAgICAgIHNjb3BlU2VsZWN0b3IgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHNjb3BlU2VsZWN0b3IsIHJyZSwgJ1xcXFxdJyk7XG4gICAgICAgIHJldHVybiBsYW5nXzEuUmVnRXhwV3JhcHBlci5jcmVhdGUoJ14oJyArIHNjb3BlU2VsZWN0b3IgKyAnKScgKyBfc2VsZWN0b3JSZVN1ZmZpeCwgJ20nKTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2UgZnJvbSB3ZWJjb21wb25lbnRzanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvLyBzY29wZSB2aWEgbmFtZSBhbmQgW2lzPW5hbWVdXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChfcG9seWZpbGxIb3N0UmUsIHNlbGVjdG9yKSkpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlQnkgPSB0aGlzLnN0cmljdFN0eWxpbmcgPyBcIltcIiArIGhvc3RTZWxlY3RvciArIFwiXVwiIDogc2NvcGVTZWxlY3RvcjtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZShzZWxlY3RvciwgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciwgcmVwbGFjZUJ5KTtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHNlbGVjdG9yLCBfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeSArICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcbiAgICAvLyBlLmcuIC5mb28uYmFyID4gLnpvdCBiZWNvbWVzIC5mb29bbmFtZV0uYmFyW25hbWVdID4gLnpvdFtuYW1lXSAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoc2NvcGVTZWxlY3RvciwgaXNSZSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1bMV07IH0pO1xuICAgICAgICB2YXIgc3BsaXRzID0gWycgJywgJz4nLCAnKycsICd+J10sIHNjb3BlZCA9IHNlbGVjdG9yLCBhdHRyTmFtZSA9ICdbJyArIHNjb3BlU2VsZWN0b3IgKyAnXSc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VwID0gc3BsaXRzW2ldO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gc2NvcGVkLnNwbGl0KHNlcCk7XG4gICAgICAgICAgICBzY29wZWQgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgOmhvc3Qgc2luY2UgaXQgc2hvdWxkIGJlIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKHAudHJpbSgpLCBfcG9seWZpbGxIb3N0UmUsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPiAwICYmICFjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29udGFpbnMoc3BsaXRzLCB0KSAmJlxuICAgICAgICAgICAgICAgICAgICAhbGFuZ18xLlN0cmluZ1dyYXBwZXIuY29udGFpbnModCwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZSA9IC8oW146XSopKDoqKSguKikvZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKHJlLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBtWzFdICsgYXR0ck5hbWUgKyBtWzJdICsgbVszXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oc2VwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVkO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxIb3N0SW5Dc3NUZXh0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHNlbGVjdG9yID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzZWxlY3RvciwgX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpO1xuICAgICAgICBzZWxlY3RvciA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoc2VsZWN0b3IsIF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9O1xuICAgIHJldHVybiBTaGFkb3dDc3M7XG59KCkpO1xuZXhwb3J0cy5TaGFkb3dDc3MgPSBTaGFkb3dDc3M7XG52YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj9bJ1wiXSguKj8pWydcIl1bO1xcc10qfShbXntdKj8pey9naW07XG52YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSpbJ1wiXSguKj8pWydcIl0pWztcXHNdKltefV0qfS9naW07XG52YXIgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKlsnXCJdKC4qPylbJ1wiXSlbO1xcc10qW159XSp9L2dpbTtcbnZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0Jztcbi8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXG52YXIgX3BvbHlmaWxsSG9zdENvbnRleHQgPSAnLXNoYWRvd2Nzc2NvbnRleHQnO1xudmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXG4gICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXG4gICAgJylcXFxcKSk/KFteLHtdKiknO1xudmFyIF9jc3NDb2xvbkhvc3RSZSA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnKCcgKyBfcG9seWZpbGxIb3N0ICsgX3BhcmVuU3VmZml4LCAnaW0nKTtcbnZhciBfY3NzQ29sb25Ib3N0Q29udGV4dFJlID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnaW0nKTtcbnZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArICctbm8tY29tYmluYXRvcic7XG52YXIgX3NoYWRvd0RPTVNlbGVjdG9yc1JlID0gW1xuICAgIC86OnNoYWRvdy9nLFxuICAgIC86OmNvbnRlbnQvZyxcbiAgICAvLyBEZXByZWNhdGVkIHNlbGVjdG9yc1xuICAgIC8vIFRPRE8odmljYik6IHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9jbGFuZy1mb3JtYXQvaXNzdWVzLzE2XG4gICAgLy8gY2xhbmctZm9ybWF0IG9mZlxuICAgIC9cXC9zaGFkb3ctZGVlcFxcLy9nLFxuICAgIC9cXC9zaGFkb3dcXC8vZyxcbl07XG52YXIgX3NoYWRvd0RlZXBTZWxlY3RvcnMgPSAvKD86Pj4+KXwoPzpcXC9kZWVwXFwvKS9nO1xudmFyIF9zZWxlY3RvclJlU3VmZml4ID0gJyhbPlxcXFxzfitcXFsuLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xudmFyIF9wb2x5ZmlsbEhvc3RSZSA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZShfcG9seWZpbGxIb3N0LCAnaW0nKTtcbnZhciBfY29sb25Ib3N0UmUgPSAvOmhvc3QvZ2ltO1xudmFyIF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XG52YXIgX2NvbW1lbnRSZSA9IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXQsIF9jb21tZW50UmUsIGZ1bmN0aW9uIChfKSB7IHJldHVybiAnJzsgfSk7XG59XG52YXIgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG52YXIgX2N1cmx5UmUgPSAvKFt7fV0pL2c7XG52YXIgT1BFTl9DVVJMWSA9ICd7JztcbnZhciBDTE9TRV9DVVJMWSA9ICd9JztcbnZhciBCTE9DS19QTEFDRUhPTERFUiA9ICclQkxPQ0slJztcbnZhciBDc3NSdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIENzc1J1bGU7XG59KCkpO1xuZXhwb3J0cy5Dc3NSdWxlID0gQ3NzUnVsZTtcbmZ1bmN0aW9uIHByb2Nlc3NSdWxlcyhpbnB1dCwgcnVsZUNhbGxiYWNrKSB7XG4gICAgdmFyIGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xuICAgIHZhciBuZXh0QmxvY2tJbmRleCA9IDA7XG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLCBfcnVsZVJlLCBmdW5jdGlvbiAobSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBtWzJdO1xuICAgICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgICB2YXIgc3VmZml4ID0gbVs0XTtcbiAgICAgICAgdmFyIGNvbnRlbnRQcmVmaXggPSAnJztcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobVs0XSkgJiYgbVs0XS5zdGFydHNXaXRoKCd7JyArIEJMT0NLX1BMQUNFSE9MREVSKSkge1xuICAgICAgICAgICAgY29udGVudCA9IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MuYmxvY2tzW25leHRCbG9ja0luZGV4KytdO1xuICAgICAgICAgICAgc3VmZml4ID0gbVs0XS5zdWJzdHJpbmcoQkxPQ0tfUExBQ0VIT0xERVIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBjb250ZW50UHJlZml4ID0gJ3snO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlID0gcnVsZUNhbGxiYWNrKG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSk7XG4gICAgICAgIHJldHVybiBcIlwiICsgbVsxXSArIHJ1bGUuc2VsZWN0b3IgKyBtWzNdICsgY29udGVudFByZWZpeCArIHJ1bGUuY29udGVudCArIHN1ZmZpeDtcbiAgICB9KTtcbn1cbmV4cG9ydHMucHJvY2Vzc1J1bGVzID0gcHJvY2Vzc1J1bGVzO1xudmFyIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcyhlc2NhcGVkU3RyaW5nLCBibG9ja3MpIHtcbiAgICAgICAgdGhpcy5lc2NhcGVkU3RyaW5nID0gZXNjYXBlZFN0cmluZztcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcztcbn0oKSk7XG5mdW5jdGlvbiBlc2NhcGVCbG9ja3MoaW5wdXQpIHtcbiAgICB2YXIgaW5wdXRQYXJ0cyA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KGlucHV0LCBfY3VybHlSZSk7XG4gICAgdmFyIHJlc3VsdFBhcnRzID0gW107XG4gICAgdmFyIGVzY2FwZWRCbG9ja3MgPSBbXTtcbiAgICB2YXIgYnJhY2tldENvdW50ID0gMDtcbiAgICB2YXIgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcbiAgICBmb3IgKHZhciBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBpbnB1dFBhcnRzLmxlbmd0aDsgcGFydEluZGV4KyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgIGlmIChwYXJ0ID09IENMT1NFX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhY2tldENvdW50ID4gMCkge1xuICAgICAgICAgICAgY3VycmVudEJsb2NrUGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydCA9PSBPUEVOX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyhyZXN1bHRQYXJ0cy5qb2luKCcnKSwgZXNjYXBlZEJsb2Nrcyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkb3dfY3NzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb21waWxlX21ldGFkYXRhXzEgPSByZXF1aXJlKCcuL2NvbXBpbGVfbWV0YWRhdGEnKTtcbnZhciBvID0gcmVxdWlyZSgnLi9vdXRwdXQvb3V0cHV0X2FzdCcpO1xudmFyIHNoYWRvd19jc3NfMSA9IHJlcXVpcmUoJy4vc2hhZG93X2NzcycpO1xudmFyIHVybF9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi91cmxfcmVzb2x2ZXInKTtcbnZhciBzdHlsZV91cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vc3R5bGVfdXJsX3Jlc29sdmVyJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgQ09NUE9ORU5UX1ZBUklBQkxFID0gJyVDT01QJSc7XG52YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xudmFyIENPTlRFTlRfQVRUUiA9IFwiX25nY29udGVudC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbnZhciBTdHlsZXNDb21waWxlRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVzQ29tcGlsZURlcGVuZGVuY3kobW9kdWxlVXJsLCBpc1NoaW1tZWQsIHZhbHVlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgIHRoaXMuaXNTaGltbWVkID0gaXNTaGltbWVkO1xuICAgICAgICB0aGlzLnZhbHVlUGxhY2Vob2xkZXIgPSB2YWx1ZVBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICByZXR1cm4gU3R5bGVzQ29tcGlsZURlcGVuZGVuY3k7XG59KCkpO1xuZXhwb3J0cy5TdHlsZXNDb21waWxlRGVwZW5kZW5jeSA9IFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xudmFyIFN0eWxlc0NvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlc0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy5zdHlsZXNWYXIgPSBzdHlsZXNWYXI7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICByZXR1cm4gU3R5bGVzQ29tcGlsZVJlc3VsdDtcbn0oKSk7XG5leHBvcnRzLlN0eWxlc0NvbXBpbGVSZXN1bHQgPSBTdHlsZXNDb21waWxlUmVzdWx0O1xudmFyIFN0eWxlQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlQ29tcGlsZXIoX3VybFJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xuICAgICAgICB0aGlzLl9zaGFkb3dDc3MgPSBuZXcgc2hhZG93X2Nzc18xLlNoYWRvd0NzcygpO1xuICAgIH1cbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgdmFyIHNoaW0gPSBjb21wLnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24gPT09IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVTdHlsZXMoZ2V0U3R5bGVzVmFyTmFtZShjb21wKSwgY29tcC50ZW1wbGF0ZS5zdHlsZXMsIGNvbXAudGVtcGxhdGUuc3R5bGVVcmxzLCBzaGltKTtcbiAgICB9O1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKHN0eWxlc2hlZXRVcmwsIGNzc1RleHQsIGlzU2hpbW1lZCkge1xuICAgICAgICB2YXIgc3R5bGVXaXRoSW1wb3J0cyA9IHN0eWxlX3VybF9yZXNvbHZlcl8xLmV4dHJhY3RTdHlsZVVybHModGhpcy5fdXJsUmVzb2x2ZXIsIHN0eWxlc2hlZXRVcmwsIGNzc1RleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVN0eWxlcyhnZXRTdHlsZXNWYXJOYW1lKG51bGwpLCBbc3R5bGVXaXRoSW1wb3J0cy5zdHlsZV0sIHN0eWxlV2l0aEltcG9ydHMuc3R5bGVVcmxzLCBpc1NoaW1tZWQpO1xuICAgIH07XG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzVmFyLCBwbGFpblN0eWxlcywgYWJzVXJscywgc2hpbSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGVFeHByZXNzaW9ucyA9IHBsYWluU3R5bGVzLm1hcChmdW5jdGlvbiAocGxhaW5TdHlsZSkgeyByZXR1cm4gby5saXRlcmFsKF90aGlzLl9zaGltSWZOZWVkZWQocGxhaW5TdHlsZSwgc2hpbSkpOyB9KTtcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFic1VybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZ2V0U3R5bGVzVmFyTmFtZShudWxsKSB9KTtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG5ldyBTdHlsZXNDb21waWxlRGVwZW5kZW5jeShhYnNVcmxzW2ldLCBzaGltLCBpZGVudGlmaWVyKSk7XG4gICAgICAgICAgICBzdHlsZUV4cHJlc3Npb25zLnB1c2gobmV3IG8uRXh0ZXJuYWxFeHByKGlkZW50aWZpZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHlsZXMgdmFyaWFibGUgY29udGFpbnMgcGxhaW4gc3RyaW5ncyBhbmQgYXJyYXlzIG9mIG90aGVyIHN0eWxlcyBhcnJheXMgKHJlY3Vyc2l2ZSksXG4gICAgICAgIC8vIHNvIHdlIHNldCBpdHMgdHlwZSB0byBkeW5hbWljLlxuICAgICAgICB2YXIgc3RtdCA9IG8udmFyaWFibGUoc3R5bGVzVmFyKVxuICAgICAgICAgICAgLnNldChvLmxpdGVyYWxBcnIoc3R5bGVFeHByZXNzaW9ucywgbmV3IG8uQXJyYXlUeXBlKG8uRFlOQU1JQ19UWVBFLCBbby5UeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbby5TdG10TW9kaWZpZXIuRmluYWxdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHlsZXNDb21waWxlUmVzdWx0KFtzdG10XSwgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMpO1xuICAgIH07XG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX3NoaW1JZk5lZWRlZCA9IGZ1bmN0aW9uIChzdHlsZSwgc2hpbSkge1xuICAgICAgICByZXR1cm4gc2hpbSA/IHRoaXMuX3NoYWRvd0Nzcy5zaGltQ3NzVGV4dChzdHlsZSwgQ09OVEVOVF9BVFRSLCBIT1NUX0FUVFIpIDogc3R5bGU7XG4gICAgfTtcbiAgICBTdHlsZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIFN0eWxlQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogdXJsX3Jlc29sdmVyXzEuVXJsUmVzb2x2ZXIsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gU3R5bGVDb21waWxlcjtcbn0oKSk7XG5leHBvcnRzLlN0eWxlQ29tcGlsZXIgPSBTdHlsZUNvbXBpbGVyO1xuZnVuY3Rpb24gZ2V0U3R5bGVzVmFyTmFtZShjb21wb25lbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJzdHlsZXNcIjtcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wb25lbnQpKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIl9cIiArIGNvbXBvbmVudC50eXBlLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZV9jb21waWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIFNvbWUgb2YgdGhlIGNvZGUgY29tZXMgZnJvbSBXZWJDb21wb25lbnRzLkpTXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi9tYXN0ZXIvc3JjL0hUTUxJbXBvcnRzL3BhdGguanNcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBTdHlsZVdpdGhJbXBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlLCBzdHlsZVVybHMpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IHN0eWxlVXJscztcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlV2l0aEltcG9ydHM7XG59KCkpO1xuZXhwb3J0cy5TdHlsZVdpdGhJbXBvcnRzID0gU3R5bGVXaXRoSW1wb3J0cztcbmZ1bmN0aW9uIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkge1xuICAgIGlmIChsYW5nXzEuaXNCbGFuayh1cmwpIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzY2hlbWVNYXRjaCA9IGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goX3VybFdpdGhTY2hlbWFSZSwgdXJsKTtcbiAgICByZXR1cm4gbGFuZ18xLmlzQmxhbmsoc2NoZW1lTWF0Y2gpIHx8IHNjaGVtZU1hdGNoWzFdID09ICdwYWNrYWdlJyB8fCBzY2hlbWVNYXRjaFsxXSA9PSAnYXNzZXQnO1xufVxuZXhwb3J0cy5pc1N0eWxlVXJsUmVzb2x2YWJsZSA9IGlzU3R5bGVVcmxSZXNvbHZhYmxlO1xuLyoqXG4gKiBSZXdyaXRlcyBzdHlsZXNoZWV0cyBieSByZXNvbHZpbmcgYW5kIHJlbW92aW5nIHRoZSBAaW1wb3J0IHVybHMgdGhhdFxuICogYXJlIGVpdGhlciByZWxhdGl2ZSBvciBkb24ndCBoYXZlIGEgYHBhY2thZ2U6YCBzY2hlbWVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFN0eWxlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCkge1xuICAgIHZhciBmb3VuZFVybHMgPSBbXTtcbiAgICB2YXIgbW9kaWZpZWRDc3NUZXh0ID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzSW1wb3J0UmUsIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHZhciB1cmwgPSBsYW5nXzEuaXNQcmVzZW50KG1bMV0pID8gbVsxXSA6IG1bMl07XG4gICAgICAgIGlmICghaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJIHNjaGVtZVxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICAgIH1cbiAgICAgICAgZm91bmRVcmxzLnB1c2gocmVzb2x2ZXIucmVzb2x2ZShiYXNlVXJsLCB1cmwpKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU3R5bGVXaXRoSW1wb3J0cyhtb2RpZmllZENzc1RleHQsIGZvdW5kVXJscyk7XG59XG5leHBvcnRzLmV4dHJhY3RTdHlsZVVybHMgPSBleHRyYWN0U3R5bGVVcmxzO1xudmFyIF9jc3NJbXBvcnRSZSA9IC9AaW1wb3J0XFxzKyg/OnVybFxcKCk/XFxzKig/Oig/OlsnXCJdKFteJ1wiXSopKXwoW147XFwpXFxzXSopKVteO10qOz8vZztcbi8vIFRPRE86IGNhbid0IHVzZSAvXlteOi8/Iy5dKzovZyBkdWUgdG8gY2xhbmctZm9ybWF0IGJ1Zzpcbi8vICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzQ1OTZcbnZhciBfdXJsV2l0aFNjaGVtYVJlID0gL14oW2EtekEtWlxcLVxcK1xcLl0rKTovZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlX3VybF9yZXNvbHZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbi8qKlxuICogQSBzZWdtZW50IG9mIHRleHQgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAqL1xudmFyIFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBUZXh0QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGV4dEFzdDtcbn0oKSk7XG5leHBvcnRzLlRleHRBc3QgPSBUZXh0QXN0O1xuLyoqXG4gKiBBIGJvdW5kIGV4cHJlc3Npb24gd2l0aGluIHRoZSB0ZXh0IG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBCb3VuZFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kVGV4dEFzdCh2YWx1ZSwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIEJvdW5kVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJvdW5kVGV4dCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZFRleHRBc3Q7XG59KCkpO1xuZXhwb3J0cy5Cb3VuZFRleHRBc3QgPSBCb3VuZFRleHRBc3Q7XG4vKipcbiAqIEEgcGxhaW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQuXG4gKi9cbnZhciBBdHRyQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgQXR0ckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEF0dHJBc3Q7XG59KCkpO1xuZXhwb3J0cy5BdHRyQXN0ID0gQXR0ckFzdDtcbi8qKlxuICogQSBiaW5kaW5nIGZvciBhbiBlbGVtZW50IHByb3BlcnR5IChlLmcuIGBbcHJvcGVydHldPVwiZXhwcmVzc2lvblwiYCkuXG4gKi9cbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRFbGVtZW50UHJvcGVydHlBc3QobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlY3VyaXR5Q29udGV4dCA9IHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnRQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcbn0oKSk7XG5leHBvcnRzLkJvdW5kRWxlbWVudFByb3BlcnR5QXN0ID0gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XG4vKipcbiAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBldmVudCAoZS5nLiBgKGV2ZW50KT1cImhhbmRsZXIoKVwiYCkuXG4gKi9cbnZhciBCb3VuZEV2ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3VuZEV2ZW50QXN0KG5hbWUsIHRhcmdldCwgaGFuZGxlciwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgQm91bmRFdmVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLCBcImZ1bGxOYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQgKyBcIjpcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBCb3VuZEV2ZW50QXN0O1xufSgpKTtcbmV4cG9ydHMuQm91bmRFdmVudEFzdCA9IEJvdW5kRXZlbnRBc3Q7XG4vKipcbiAqIEEgcmVmZXJlbmNlIGRlY2xhcmF0aW9uIG9uIGFuIGVsZW1lbnQgKGUuZy4gYGxldCBzb21lTmFtZT1cImV4cHJlc3Npb25cImApLlxuICovXG52YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZlcmVuY2VBc3QobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xufSgpKTtcbmV4cG9ydHMuUmVmZXJlbmNlQXN0ID0gUmVmZXJlbmNlQXN0O1xuLyoqXG4gKiBBIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG9uIGEgPHRlbXBsYXRlPiAoZS5nLiBgdmFyLXNvbWVOYW1lPVwic29tZUxvY2FsTmFtZVwiYCkuXG4gKi9cbnZhciBWYXJpYWJsZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFyaWFibGVBc3QobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBWYXJpYWJsZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFZhcmlhYmxlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFZhcmlhYmxlQXN0O1xufSgpKTtcbmV4cG9ydHMuVmFyaWFibGVBc3QgPSBWYXJpYWJsZUFzdDtcbi8qKlxuICogQW4gZWxlbWVudCBkZWNsYXJhdGlvbiBpbiBhIHRlbXBsYXRlLlxuICovXG52YXIgRWxlbWVudEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudEFzdChuYW1lLCBhdHRycywgaW5wdXRzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCBkaXJlY3RpdmVzLCBwcm92aWRlcnMsIGhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRBc3Q7XG59KCkpO1xuZXhwb3J0cy5FbGVtZW50QXN0ID0gRWxlbWVudEFzdDtcbi8qKlxuICogQSBgPHRlbXBsYXRlPmAgZWxlbWVudCBpbmNsdWRlZCBpbiBhbiBBbmd1bGFyIHRlbXBsYXRlLlxuICovXG52YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW1iZWRkZWRUZW1wbGF0ZUFzdChhdHRycywgb3V0cHV0cywgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBkaXJlY3RpdmVzLCBwcm92aWRlcnMsIGhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIEVtYmVkZGVkVGVtcGxhdGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbWJlZGRlZFRlbXBsYXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEVtYmVkZGVkVGVtcGxhdGVBc3Q7XG59KCkpO1xuZXhwb3J0cy5FbWJlZGRlZFRlbXBsYXRlQXN0ID0gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbi8qKlxuICogQSBkaXJlY3RpdmUgcHJvcGVydHkgd2l0aCBhIGJvdW5kIHZhbHVlIChlLmcuIGAqbmdJZj1cImNvbmRpdGlvblwiKS5cbiAqL1xudmFyIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyZWN0aXZlTmFtZSwgdGVtcGxhdGVOYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdDtcbn0oKSk7XG5leHBvcnRzLkJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSBkZWNsYXJlZCBvbiBhbiBlbGVtZW50LlxuICovXG52YXIgRGlyZWN0aXZlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmhvc3RFdmVudHMgPSBob3N0RXZlbnRzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBEaXJlY3RpdmVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREaXJlY3RpdmUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZWN0aXZlQXN0O1xufSgpKTtcbmV4cG9ydHMuRGlyZWN0aXZlQXN0ID0gRGlyZWN0aXZlQXN0O1xuLyoqXG4gKiBBIHByb3ZpZGVyIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnRcbiAqL1xudmFyIFByb3ZpZGVyQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm92aWRlckFzdCh0b2tlbiwgbXVsdGlQcm92aWRlciwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXJUeXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgdGhpcy5lYWdlciA9IGVhZ2VyO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5wcm92aWRlclR5cGUgPSBwcm92aWRlclR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIFByb3ZpZGVyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIE5vIHZpc2l0IG1ldGhvZCBpbiB0aGUgdmlzaXRvciBmb3Igbm93Li4uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyQXN0O1xufSgpKTtcbmV4cG9ydHMuUHJvdmlkZXJBc3QgPSBQcm92aWRlckFzdDtcbihmdW5jdGlvbiAoUHJvdmlkZXJBc3RUeXBlKSB7XG4gICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlB1YmxpY1NlcnZpY2VcIl0gPSAwXSA9IFwiUHVibGljU2VydmljZVwiO1xuICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJQcml2YXRlU2VydmljZVwiXSA9IDFdID0gXCJQcml2YXRlU2VydmljZVwiO1xuICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJDb21wb25lbnRcIl0gPSAyXSA9IFwiQ29tcG9uZW50XCI7XG4gICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIkRpcmVjdGl2ZVwiXSA9IDNdID0gXCJEaXJlY3RpdmVcIjtcbiAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiQnVpbHRpblwiXSA9IDRdID0gXCJCdWlsdGluXCI7XG59KShleHBvcnRzLlByb3ZpZGVyQXN0VHlwZSB8fCAoZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUgPSB7fSkpO1xudmFyIFByb3ZpZGVyQXN0VHlwZSA9IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlO1xuLyoqXG4gKiBQb3NpdGlvbiB3aGVyZSBjb250ZW50IGlzIHRvIGJlIHByb2plY3RlZCAoaW5zdGFuY2Ugb2YgYDxuZy1jb250ZW50PmAgaW4gYSB0ZW1wbGF0ZSkuXG4gKi9cbnZhciBOZ0NvbnRlbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nQ29udGVudEFzdChpbmRleCwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5nQ29udGVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XG59KCkpO1xuZXhwb3J0cy5OZ0NvbnRlbnRBc3QgPSBOZ0NvbnRlbnRBc3Q7XG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHR5cGVzIG9mIHByb3BlcnR5IGJpbmRpbmdzLlxuICovXG4oZnVuY3Rpb24gKFByb3BlcnR5QmluZGluZ1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIG5vcm1hbCBiaW5kaW5nIHRvIGEgcHJvcGVydHkgKGUuZy4gYFtwcm9wZXJ0eV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJQcm9wZXJ0eVwiXSA9IDBdID0gXCJQcm9wZXJ0eVwiO1xuICAgIC8qKlxuICAgICAqIEEgYmluZGluZyB0byBhbiBlbGVtZW50IGF0dHJpYnV0ZSAoZS5nLiBgW2F0dHIubmFtZV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJBdHRyaWJ1dGVcIl0gPSAxXSA9IFwiQXR0cmlidXRlXCI7XG4gICAgLyoqXG4gICAgICogQSBiaW5kaW5nIHRvIGEgQ1NTIGNsYXNzIChlLmcuIGBbY2xhc3MubmFtZV09XCJjb25kaXRpb25cImApLlxuICAgICAqL1xuICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIkNsYXNzXCJdID0gMl0gPSBcIkNsYXNzXCI7XG4gICAgLyoqXG4gICAgICogQSBiaW5kaW5nIHRvIGEgc3R5bGUgcnVsZSAoZS5nLiBgW3N0eWxlLnJ1bGVdPVwiZXhwcmVzc2lvblwiYCkuXG4gICAgICovXG4gICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiU3R5bGVcIl0gPSAzXSA9IFwiU3R5bGVcIjtcbn0pKGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZSB8fCAoZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlID0ge30pKTtcbnZhciBQcm9wZXJ0eUJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlO1xuLyoqXG4gKiBWaXNpdCBldmVyeSBub2RlIGluIGEgbGlzdCBvZiB7QGxpbmsgVGVtcGxhdGVBc3R9cyB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgVGVtcGxhdGVBc3RWaXNpdG9yfS5cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVWaXNpdEFsbCh2aXNpdG9yLCBhc3RzLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgYXN0UmVzdWx0ID0gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhc3RSZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudGVtcGxhdGVWaXNpdEFsbCA9IHRlbXBsYXRlVmlzaXRBbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9hc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgY29yZV9wcml2YXRlXzEgPSByZXF1aXJlKCcuLi9jb3JlX3ByaXZhdGUnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBhc3RfMSA9IHJlcXVpcmUoJy4vZXhwcmVzc2lvbl9wYXJzZXIvYXN0Jyk7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKCcuL2V4cHJlc3Npb25fcGFyc2VyL3BhcnNlcicpO1xudmFyIGh0bWxfcGFyc2VyXzEgPSByZXF1aXJlKCcuL2h0bWxfcGFyc2VyJyk7XG52YXIgaHRtbF90YWdzXzEgPSByZXF1aXJlKCcuL2h0bWxfdGFncycpO1xudmFyIHBhcnNlX3V0aWxfMSA9IHJlcXVpcmUoJy4vcGFyc2VfdXRpbCcpO1xudmFyIHRlbXBsYXRlX2FzdF8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9hc3QnKTtcbnZhciBzZWxlY3Rvcl8xID0gcmVxdWlyZSgnLi9zZWxlY3RvcicpO1xudmFyIGVsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5XzEgPSByZXF1aXJlKCcuL3NjaGVtYS9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeScpO1xudmFyIHRlbXBsYXRlX3ByZXBhcnNlcl8xID0gcmVxdWlyZSgnLi90ZW1wbGF0ZV9wcmVwYXJzZXInKTtcbnZhciBzdHlsZV91cmxfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vc3R5bGVfdXJsX3Jlc29sdmVyJyk7XG52YXIgaHRtbF9hc3RfMSA9IHJlcXVpcmUoJy4vaHRtbF9hc3QnKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBpZGVudGlmaWVyc18xID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xudmFyIHByb3ZpZGVyX3BhcnNlcl8xID0gcmVxdWlyZSgnLi9wcm92aWRlcl9wYXJzZXInKTtcbi8vIEdyb3VwIDEgPSBcImJpbmQtXCJcbi8vIEdyb3VwIDIgPSBcInZhci1cIlxuLy8gR3JvdXAgMyA9IFwibGV0LVwiXG4vLyBHcm91cCA0ID0gXCJyZWYtLyNcIlxuLy8gR3JvdXAgNSA9IFwib24tXCJcbi8vIEdyb3VwIDYgPSBcImJpbmRvbi1cIlxuLy8gR3JvdXAgNyA9IHRoZSBpZGVudGlmaWVyIGFmdGVyIFwiYmluZC1cIiwgXCJ2YXItLyNcIiwgb3IgXCJvbi1cIlxuLy8gR3JvdXAgOCA9IGlkZW50aWZpZXIgaW5zaWRlIFsoKV1cbi8vIEdyb3VwIDkgPSBpZGVudGlmaWVyIGluc2lkZSBbXVxuLy8gR3JvdXAgMTAgPSBpZGVudGlmaWVyIGluc2lkZSAoKVxudmFyIEJJTkRfTkFNRV9SRUdFWFAgPSAvXig/Oig/Oig/OihiaW5kLSl8KHZhci0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSkpKC4rKSl8XFxbXFwoKFteXFwpXSspXFwpXFxdfFxcWyhbXlxcXV0rKVxcXXxcXCgoW15cXCldKylcXCkpJC9nO1xudmFyIFRFTVBMQVRFX0VMRU1FTlQgPSAndGVtcGxhdGUnO1xudmFyIFRFTVBMQVRFX0FUVFIgPSAndGVtcGxhdGUnO1xudmFyIFRFTVBMQVRFX0FUVFJfUFJFRklYID0gJyonO1xudmFyIENMQVNTX0FUVFIgPSAnY2xhc3MnO1xudmFyIFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUiA9ICcuJztcbnZhciBBVFRSSUJVVEVfUFJFRklYID0gJ2F0dHInO1xudmFyIENMQVNTX1BSRUZJWCA9ICdjbGFzcyc7XG52YXIgU1RZTEVfUFJFRklYID0gJ3N0eWxlJztcbnZhciBURVhUX0NTU19TRUxFQ1RPUiA9IHNlbGVjdG9yXzEuQ3NzU2VsZWN0b3IucGFyc2UoJyonKVswXTtcbi8qKlxuICogUHJvdmlkZXMgYW4gYXJyYXkgb2Yge0BsaW5rIFRlbXBsYXRlQXN0VmlzaXRvcn1zIHdoaWNoIHdpbGwgYmUgdXNlZCB0byB0cmFuc2Zvcm1cbiAqIHBhcnNlZCB0ZW1wbGF0ZXMgYmVmb3JlIGNvbXBpbGF0aW9uIGlzIGludm9rZWQsIGFsbG93aW5nIGN1c3RvbSBleHByZXNzaW9uIHN5bnRheFxuICogYW5kIG90aGVyIGFkdmFuY2VkIHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBUaGlzIGlzIGN1cnJlbnRseSBhbiBpbnRlcm5hbC1vbmx5IGZlYXR1cmUgYW5kIG5vdCBtZWFudCBmb3IgZ2VuZXJhbCB1c2UuXG4gKi9cbmV4cG9ydHMuVEVNUExBVEVfVFJBTlNGT1JNUyA9IG5ldyBjb3JlXzEuT3BhcXVlVG9rZW4oJ1RlbXBsYXRlVHJhbnNmb3JtcycpO1xudmFyIFRlbXBsYXRlUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlbXBsYXRlUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlRXJyb3IobWVzc2FnZSwgc3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSwgbGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZUVycm9yO1xufShwYXJzZV91dGlsXzEuUGFyc2VFcnJvcikpO1xuZXhwb3J0cy5UZW1wbGF0ZVBhcnNlRXJyb3IgPSBUZW1wbGF0ZVBhcnNlRXJyb3I7XG52YXIgVGVtcGxhdGVQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZVJlc3VsdCh0ZW1wbGF0ZUFzdCwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVBc3QgPSB0ZW1wbGF0ZUFzdDtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuVGVtcGxhdGVQYXJzZVJlc3VsdCA9IFRlbXBsYXRlUGFyc2VSZXN1bHQ7XG52YXIgVGVtcGxhdGVQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VyKF9leHByUGFyc2VyLCBfc2NoZW1hUmVnaXN0cnksIF9odG1sUGFyc2VyLCBfY29uc29sZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcbiAgICB9XG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50cnlQYXJzZShjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgdGVtcGxhdGVVcmwpO1xuICAgICAgICB2YXIgd2FybmluZ3MgPSByZXN1bHQuZXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yLmxldmVsID09PSBwYXJzZV91dGlsXzEuUGFyc2VFcnJvckxldmVsLldBUk5JTkc7IH0pO1xuICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gcGFyc2VfdXRpbF8xLlBhcnNlRXJyb3JMZXZlbC5GQVRBTDsgfSk7XG4gICAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oXCJUZW1wbGF0ZSBwYXJzZSB3YXJuaW5nczpcXG5cIiArIHdhcm5pbmdzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRlbXBsYXRlQXN0O1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnRyeVBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICB2YXIgaHRtbEFzdFdpdGhFcnJvcnMgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCk7XG4gICAgICAgIHZhciBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHVuaXFEaXJlY3RpdmVzID0gcmVtb3ZlRHVwbGljYXRlcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHZhciB1bmlxUGlwZXMgPSByZW1vdmVEdXBsaWNhdGVzKHBpcGVzKTtcbiAgICAgICAgICAgIHZhciBwcm92aWRlclZpZXdDb250ZXh0ID0gbmV3IHByb3ZpZGVyX3BhcnNlcl8xLlByb3ZpZGVyVmlld0NvbnRleHQoY29tcG9uZW50LCBodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXNbMF0uc291cmNlU3Bhbik7XG4gICAgICAgICAgICB2YXIgcGFyc2VWaXNpdG9yID0gbmV3IFRlbXBsYXRlUGFyc2VWaXNpdG9yKHByb3ZpZGVyVmlld0NvbnRleHQsIHVuaXFEaXJlY3RpdmVzLCB1bmlxUGlwZXMsIHRoaXMuX2V4cHJQYXJzZXIsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHBhcnNlVmlzaXRvciwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLCBFTVBUWV9FTEVNRU5UX0NPTlRFWFQpO1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChwYXJzZVZpc2l0b3IuZXJyb3JzKS5jb25jYXQocHJvdmlkZXJWaWV3Q29udGV4dC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMudHJhbnNmb3JtcykpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHsgcmVzdWx0ID0gdGVtcGxhdGVfYXN0XzEudGVtcGxhdGVWaXNpdEFsbCh0cmFuc2Zvcm0sIHJlc3VsdCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJzZVJlc3VsdChyZXN1bHQsIGVycm9ycyk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBUZW1wbGF0ZVBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBwYXJzZXJfMS5QYXJzZXIsIH0sXG4gICAgICAgIHsgdHlwZTogZWxlbWVudF9zY2hlbWFfcmVnaXN0cnlfMS5FbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgICAgIHsgdHlwZTogaHRtbF9wYXJzZXJfMS5IdG1sUGFyc2VyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfcHJpdmF0ZV8xLkNvbnNvbGUsIH0sXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuT3B0aW9uYWwgfSwgeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbZXhwb3J0cy5URU1QTEFURV9UUkFOU0ZPUk1TLF0gfSxdIH0sXG4gICAgXTtcbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZXI7XG59KCkpO1xuZXhwb3J0cy5UZW1wbGF0ZVBhcnNlciA9IFRlbXBsYXRlUGFyc2VyO1xudmFyIFRlbXBsYXRlUGFyc2VWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlVmlzaXRvcihwcm92aWRlclZpZXdDb250ZXh0LCBkaXJlY3RpdmVzLCBwaXBlcywgX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQgPSBwcm92aWRlclZpZXdDb250ZXh0O1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JNYXRjaGVyID0gbmV3IHNlbGVjdG9yXzEuU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4KGRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXJlY3RpdmUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3Rvcl8xLkNzc1NlbGVjdG9yLnBhcnNlKGRpcmVjdGl2ZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVzSW5kZXguc2V0KGRpcmVjdGl2ZSwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5waXBlc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgcGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMucGlwZXNCeU5hbWUuc2V0KHBpcGUubmFtZSwgcGlwZSk7IH0pO1xuICAgIH1cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gcGFyc2VfdXRpbF8xLlBhcnNlRXJyb3JMZXZlbC5GQVRBTDsgfVxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBUZW1wbGF0ZVBhcnNlRXJyb3IobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwpKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFzdCkgJiZcbiAgICAgICAgICAgICAgICBhc3QuYXN0LmV4cHJlc3Npb25zLmxlbmd0aCA+IGNvcmVfcHJpdmF0ZV8xLk1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIk9ubHkgc3VwcG9ydCBhdCBtb3N0IFwiICsgY29yZV9wcml2YXRlXzEuTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTICsgXCIgaW50ZXJwb2xhdGlvbiB2YWx1ZXMhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgc291cmNlSW5mbyk7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQaXBlcyhhc3QsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzUmVzdWx0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3ModmFsdWUsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZGluZy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQaXBlcyhiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykgeyBfdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgcGFyc2VfdXRpbF8xLlBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NoZWNrUGlwZXMgPSBmdW5jdGlvbiAoYXN0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFzdCkpIHtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0b3IgPSBuZXcgUGlwZUNvbGxlY3RvcigpO1xuICAgICAgICAgICAgYXN0LnZpc2l0KGNvbGxlY3Rvcik7XG4gICAgICAgICAgICBjb2xsZWN0b3IucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnBpcGVzQnlOYW1lLmhhcyhwaXBlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlIHBpcGUgJ1wiICsgcGlwZU5hbWUgKyBcIicgY291bGQgbm90IGJlIGZvdW5kXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUik7XG4gICAgICAgIHZhciBleHByID0gdGhpcy5fcGFyc2VJbnRlcnBvbGF0aW9uKGFzdC52YWx1ZSwgYXN0LnNvdXJjZVNwYW4pO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChleHByKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5Cb3VuZFRleHRBc3QoZXhwciwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuVGV4dEFzdChhc3QudmFsdWUsIG5nQ29udGVudEluZGV4LCBhc3Quc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5BdHRyQXN0KGFzdC5uYW1lLCBhc3QudmFsdWUsIGFzdC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubmFtZTtcbiAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5wcmVwYXJzZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgJiZcbiAgICAgICAgICAgIHN0eWxlX3VybF9yZXNvbHZlcl8xLmlzU3R5bGVVcmxSZXNvbHZhYmxlKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyBzdHlsZXNoZWV0cyB3aXRoIGVpdGhlciByZWxhdGl2ZSB1cmxzIG9yIHBhY2thZ2Ugc2NoZW1lIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAvLyB0aGVtIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVSZWZzID0gW107XG4gICAgICAgIHZhciBlbGVtZW50VmFycyA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgIHZhciB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzID0gW107XG4gICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRWYXJzID0gW107XG4gICAgICAgIHZhciBoYXNJbmxpbmVUZW1wbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGF0dHJzID0gW107XG4gICAgICAgIHZhciBsY0VsTmFtZSA9IGh0bWxfdGFnc18xLnNwbGl0TnNOYW1lKG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpWzFdO1xuICAgICAgICB2YXIgaXNUZW1wbGF0ZUVsZW1lbnQgPSBsY0VsTmFtZSA9PSBURU1QTEFURV9FTEVNRU5UO1xuICAgICAgICBlbGVtZW50LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBoYXNCaW5kaW5nID0gX3RoaXMuX3BhcnNlQXR0cihpc1RlbXBsYXRlRWxlbWVudCwgYXR0ciwgbWF0Y2hhYmxlQXR0cnMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBldmVudHMsIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMsIGVsZW1lbnRWYXJzKTtcbiAgICAgICAgICAgIHZhciBoYXNUZW1wbGF0ZUJpbmRpbmcgPSBfdGhpcy5fcGFyc2VJbmxpbmVUZW1wbGF0ZUJpbmRpbmcoYXR0ciwgdGVtcGxhdGVNYXRjaGFibGVBdHRycywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgdGVtcGxhdGVFbGVtZW50VmFycyk7XG4gICAgICAgICAgICBpZiAoIWhhc0JpbmRpbmcgJiYgIWhhc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgdGhlIGJpbmRpbmdzIGFzIGF0dHJpYnV0ZXMgYXMgd2VsbCBpbiB0aGUgQVNUXG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHIoYXR0ciwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIG1hdGNoYWJsZUF0dHJzLnB1c2goW2F0dHIubmFtZSwgYXR0ci52YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIGhhc0lubGluZVRlbXBsYXRlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZWxlbWVudENzc1NlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKG5vZGVOYW1lLCBtYXRjaGFibGVBdHRycyk7XG4gICAgICAgIHZhciBkaXJlY3RpdmVNZXRhcyA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKGlzVGVtcGxhdGVFbGVtZW50LCBlbGVtZW50Lm5hbWUsIGRpcmVjdGl2ZU1ldGFzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudC5zb3VyY2VTcGFuLCByZWZlcmVuY2VzKTtcbiAgICAgICAgdmFyIGVsZW1lbnRQcm9wcyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMoZWxlbWVudC5uYW1lLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZGlyZWN0aXZlQXN0cyk7XG4gICAgICAgIHZhciBpc1ZpZXdSb290ID0gcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50IHx8IGhhc0lubGluZVRlbXBsYXRlcztcbiAgICAgICAgdmFyIHByb3ZpZGVyQ29udGV4dCA9IG5ldyBwcm92aWRlcl9wYXJzZXJfMS5Qcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgaXNWaWV3Um9vdCwgZGlyZWN0aXZlQXN0cywgYXR0cnMsIHJlZmVyZW5jZXMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGh0bWxfYXN0XzEuaHRtbFZpc2l0QWxsKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUgPyBOT05fQklOREFCTEVfVklTSVRPUiA6IHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIEVsZW1lbnRDb250ZXh0LmNyZWF0ZShpc1RlbXBsYXRlRWxlbWVudCwgZGlyZWN0aXZlQXN0cywgaXNUZW1wbGF0ZUVsZW1lbnQgPyBwYXJlbnQucHJvdmlkZXJDb250ZXh0IDogcHJvdmlkZXJDb250ZXh0KSk7XG4gICAgICAgIHByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGFjdHVhbCBzZWxlY3RvciB3aGVuIHRoZSBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZSBpcyBwcm92aWRlZFxuICAgICAgICB2YXIgcHJvamVjdGlvblNlbGVjdG9yID0gbGFuZ18xLmlzUHJlc2VudChwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcykgP1xuICAgICAgICAgICAgc2VsZWN0b3JfMS5Dc3NTZWxlY3Rvci5wYXJzZShwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcylbMF0gOlxuICAgICAgICAgICAgZWxlbWVudENzc1NlbGVjdG9yO1xuICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KHByb2plY3Rpb25TZWxlY3Rvcik7XG4gICAgICAgIHZhciBwYXJzZWRFbGVtZW50O1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChlbGVtZW50LmNoaWxkcmVuKSAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIjxuZy1jb250ZW50PiBlbGVtZW50IGNhbm5vdCBoYXZlIGNvbnRlbnQuIDxuZy1jb250ZW50PiBtdXN0IGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IDwvbmctY29udGVudD5cIiwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgdGVtcGxhdGVfYXN0XzEuTmdDb250ZW50QXN0KHRoaXMubmdDb250ZW50Q291bnQrKywgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMoZGlyZWN0aXZlQXN0cywgZXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUoZGlyZWN0aXZlQXN0cywgZWxlbWVudFByb3BzLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyB0ZW1wbGF0ZV9hc3RfMS5FbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBldmVudHMsIHJlZmVyZW5jZXMsIGVsZW1lbnRWYXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0T25seU9uZUNvbXBvbmVudChkaXJlY3RpdmVBc3RzLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4XzEgPSBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyB0ZW1wbGF0ZV9hc3RfMS5FbGVtZW50QXN0KG5vZGVOYW1lLCBhdHRycywgZWxlbWVudFByb3BzLCBldmVudHMsIHJlZmVyZW5jZXMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXhfMSwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzSW5saW5lVGVtcGxhdGVzKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVDc3NTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihURU1QTEFURV9FTEVNRU5ULCB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZURpcmVjdGl2ZU1ldGFzID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCB0ZW1wbGF0ZUNzc1NlbGVjdG9yKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKHRydWUsIGVsZW1lbnQubmFtZSwgdGVtcGxhdGVEaXJlY3RpdmVNZXRhcywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgW10sIGVsZW1lbnQuc291cmNlU3BhbiwgW10pO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRGlyZWN0aXZlQXN0cyk7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVFbGVtZW50UHJvcHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVQcm92aWRlckNvbnRleHQgPSBuZXcgcHJvdmlkZXJfcGFyc2VyXzEuUHJvdmlkZXJFbGVtZW50Q29udGV4dCh0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQsIHBhcmVudC5wcm92aWRlckNvbnRleHQsIHBhcmVudC5pc1RlbXBsYXRlRWxlbWVudCwgdGVtcGxhdGVEaXJlY3RpdmVBc3RzLCBbXSwgW10sIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgdGVtcGxhdGVfYXN0XzEuRW1iZWRkZWRUZW1wbGF0ZUFzdChbXSwgW10sIFtdLCB0ZW1wbGF0ZUVsZW1lbnRWYXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBbcGFyc2VkRWxlbWVudF0sIG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBudWxsO1xuICAgICAgICBpZiAoYXR0ci5uYW1lID09IFRFTVBMQVRFX0FUVFIpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGF0dHIubmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKTsgLy8gcmVtb3ZlIHRoZSBzdGFyXG4gICAgICAgICAgICB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlID0gKGF0dHIudmFsdWUubGVuZ3RoID09IDApID8ga2V5IDoga2V5ICsgJyAnICsgYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0ZW1wbGF0ZUJpbmRpbmdzU291cmNlKSkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRlbXBsYXRlQmluZGluZ3NTb3VyY2UsIGF0dHIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5rZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IHRlbXBsYXRlX2FzdF8xLlZhcmlhYmxlQXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLm5hbWUsIGF0dHIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRpbmcuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChiaW5kaW5nLmtleSwgYmluZGluZy5leHByZXNzaW9uLCBhdHRyLnNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtiaW5kaW5nLmtleSwgJyddKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VMaXRlcmFsQXR0cihiaW5kaW5nLmtleSwgbnVsbCwgYXR0ci5zb3VyY2VTcGFuLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUF0dHIgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0RXZlbnRzLCB0YXJnZXRSZWZzLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgIHZhciBhdHRyTmFtZSA9IHRoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKTtcbiAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgIHZhciBiaW5kUGFydHMgPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKEJJTkRfTkFNRV9SRUdFWFAsIGF0dHJOYW1lKTtcbiAgICAgICAgdmFyIGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzKSkge1xuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eShiaW5kUGFydHNbN10sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbMl0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbN107XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcInZhci1cXFwiIG9uIDx0ZW1wbGF0ZT4gZWxlbWVudHMgaXMgZGVwcmVjYXRlZC4gVXNlIFxcXCJsZXQtXFxcIiBpbnN0ZWFkIVwiLCBhdHRyLnNvdXJjZVNwYW4sIHBhcnNlX3V0aWxfMS5QYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZVNwYW4sIHRhcmdldFZhcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwidmFyLVxcXCIgb24gbm9uIDx0ZW1wbGF0ZT4gZWxlbWVudHMgaXMgZGVwcmVjYXRlZC4gVXNlIFxcXCJyZWYtXFxcIiBpbnN0ZWFkIVwiLCBhdHRyLnNvdXJjZVNwYW4sIHBhcnNlX3V0aWxfMS5QYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCB0YXJnZXRSZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGJpbmRQYXJ0c1szXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbN107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZVNwYW4sIHRhcmdldFZhcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwibGV0LVxcXCIgaXMgb25seSBzdXBwb3J0ZWQgb24gdGVtcGxhdGUgZWxlbWVudHMuXCIsIGF0dHIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbNF0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbN107XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VSZWZlcmVuY2UoaWRlbnRpZmllciwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZVNwYW4sIHRhcmdldFJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChiaW5kUGFydHNbNV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFdmVudChiaW5kUGFydHNbN10sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzZdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHkoYmluZFBhcnRzWzddLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbN10sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzhdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHkoYmluZFBhcnRzWzhdLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbOF0sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzldKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHkoYmluZFBhcnRzWzldLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmluZFBhcnRzWzEwXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50KGJpbmRQYXJ0c1sxMF0sIGF0dHJWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLl9wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihhdHRyTmFtZSwgYXR0clZhbHVlLCBhdHRyLnNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUxpdGVyYWxBdHRyKGF0dHJOYW1lLCBhdHRyVmFsdWUsIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNCaW5kaW5nO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIHJldHVybiBhdHRyTmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2RhdGEtJykgPyBhdHRyTmFtZS5zdWJzdHJpbmcoNSkgOiBhdHRyTmFtZTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VWYXJpYWJsZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0VmFycykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gdmFyaWFibGUgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyB0ZW1wbGF0ZV9hc3RfMS5WYXJpYWJsZUFzdChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0UmVmcykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gcmVmZXJlbmNlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFJlZnMucHVzaChuZXcgRWxlbWVudE9yRGlyZWN0aXZlUmVmKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciBleHByID0gdGhpcy5fcGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZXhwcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kRWxlbWVudE9yRGlyZWN0aXZlUHJvcGVydHkobmFtZSwgYXN0LCBmYWxzZSwgc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUFzc2lnbm1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICAvLyBsb25nIGZvcm1hdDogJ3RhcmdldDogZXZlbnROYW1lJ1xuICAgICAgICB2YXIgcGFydHMgPSB1dGlsXzEuc3BsaXRBdENvbG9uKG5hbWUsIFtudWxsLCBuYW1lXSk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwYXJ0c1swXTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgdGFyZ2V0RXZlbnRzLnB1c2gobmV3IHRlbXBsYXRlX2FzdF8xLkJvdW5kRXZlbnRBc3QoZXZlbnROYW1lLCB0YXJnZXQsIGFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAvLyBEb24ndCBkZXRlY3QgZGlyZWN0aXZlcyBmb3IgZXZlbnQgbmFtZXMgZm9yIG5vdyxcbiAgICAgICAgLy8gc28gZG9uJ3QgYWRkIHRoZSBldmVudCBuYW1lIHRvIHRoZSBtYXRjaGFibGVBdHRyc1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUxpdGVyYWxBdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRQcm9wcykge1xuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5KG5hbWUsIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUodmFsdWUsICcnKSwgdHJ1ZSwgc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTmVlZCB0byBzb3J0IHRoZSBkaXJlY3RpdmVzIHNvIHRoYXQgd2UgZ2V0IGNvbnNpc3RlbnQgcmVzdWx0cyB0aHJvdWdob3V0LFxuICAgICAgICAvLyBhcyBzZWxlY3Rvck1hdGNoZXIgdXNlcyBNYXBzIGluc2lkZS5cbiAgICAgICAgLy8gQWxzbyBkZWR1cGUgZGlyZWN0aXZlcyBhcyB0aGV5IG1pZ2h0IG1hdGNoIG1vcmUgdGhhbiBvbmUgdGltZSFcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHRoaXMuZGlyZWN0aXZlc0luZGV4LnNpemUpO1xuICAgICAgICBzZWxlY3Rvck1hdGNoZXIubWF0Y2goZWxlbWVudENzc1NlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgZGlyZWN0aXZlc1tfdGhpcy5kaXJlY3RpdmVzSW5kZXguZ2V0KGRpcmVjdGl2ZSldID0gZGlyZWN0aXZlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQoZGlyKTsgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUFzdHMgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnROYW1lLCBkaXJlY3RpdmVzLCBwcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgc291cmNlU3BhbiwgdGFyZ2V0UmVmZXJlbmNlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWF0Y2hlZFJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBudWxsO1xuICAgICAgICB2YXIgZGlyZWN0aXZlQXN0cyA9IGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaG9zdFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBob3N0RXZlbnRzID0gW107XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMoZWxlbWVudE5hbWUsIGRpcmVjdGl2ZS5ob3N0UHJvcGVydGllcywgc291cmNlU3BhbiwgaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLmhvc3RMaXN0ZW5lcnMsIHNvdXJjZVNwYW4sIGhvc3RFdmVudHMpO1xuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyhkaXJlY3RpdmUuaW5wdXRzLCBwcm9wcywgZGlyZWN0aXZlUHJvcGVydGllcyk7XG4gICAgICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGVsT3JEaXJSZWYudmFsdWUubGVuZ3RoID09PSAwICYmIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGRpcmVjdGl2ZS5leHBvcnRBcyA9PSBlbE9yRGlyUmVmLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IHRlbXBsYXRlX2FzdF8xLlJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGRpcmVjdGl2ZS50eXBlKSwgZWxPckRpclJlZi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRSZWZlcmVuY2VzLmFkZChlbE9yRGlyUmVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5EaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBkaXJlY3RpdmVQcm9wZXJ0aWVzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgIGlmIChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhtYXRjaGVkUmVmZXJlbmNlcywgZWxPckRpclJlZi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGVyZSBpcyBubyBkaXJlY3RpdmUgd2l0aCBcXFwiZXhwb3J0QXNcXFwiIHNldCB0byBcXFwiXCIgKyBlbE9yRGlyUmVmLnZhbHVlICsgXCJcXFwiXCIsIGVsT3JEaXJSZWYuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWZUb2tlbiA9IGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IHRlbXBsYXRlX2FzdF8xLlJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIHJlZlRva2VuLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nIGlzc3VlOiBgXG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVBc3RzO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBob3N0UHJvcHMsIHNvdXJjZVNwYW4sIHRhcmdldFByb3BlcnR5QXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChob3N0UHJvcHMpKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGhvc3RQcm9wcywgZnVuY3Rpb24gKGV4cHJlc3Npb24sIHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJBc3QgPSBfdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIHRhcmdldFByb3BlcnR5QXN0cy5wdXNoKF90aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QoZWxlbWVudE5hbWUsIHByb3BOYW1lLCBleHByQXN0LCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVIb3N0RXZlbnRBc3RzID0gZnVuY3Rpb24gKGhvc3RMaXN0ZW5lcnMsIHNvdXJjZVNwYW4sIHRhcmdldEV2ZW50QXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChob3N0TGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChob3N0TGlzdGVuZXJzLCBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFyc2VFdmVudChwcm9wTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgW10sIHRhcmdldEV2ZW50QXN0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUHJvcGVydGllcywgYm91bmRQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcykge1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkaXJlY3RpdmVQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgdmFyIGJvdW5kUHJvcHNCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBib3VuZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBib3VuZFByb3BzQnlOYW1lLmdldChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHByZXZWYWx1ZSkgfHwgcHJldlZhbHVlLmlzTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gYT1cImJcIiBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWUuc2V0KGJvdW5kUHJvcC5uYW1lLCBib3VuZFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChkaXJlY3RpdmVQcm9wZXJ0aWVzLCBmdW5jdGlvbiAoZWxQcm9wLCBkaXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvcCA9IGJvdW5kUHJvcHNCeU5hbWUuZ2V0KGVsUHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gQmluZGluZ3MgYXJlIG9wdGlvbmFsLCBzbyB0aGlzIGJpbmRpbmcgb25seSBuZWVkcyB0byBiZSBzZXQgdXAgaWYgYW4gZXhwcmVzc2lvbiBpcyBnaXZlbi5cbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChib3VuZFByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcHMucHVzaChuZXcgdGVtcGxhdGVfYXN0XzEuQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdChkaXJQcm9wLCBib3VuZFByb3AubmFtZSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIGJvdW5kUHJvcC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcHMsIGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGJvdW5kRWxlbWVudFByb3BzID0gW107XG4gICAgICAgIHZhciBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmUuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXguc2V0KHByb3AudGVtcGxhdGVOYW1lLCBwcm9wKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wLmlzTGl0ZXJhbCAmJiBsYW5nXzEuaXNCbGFuayhib3VuZERpcmVjdGl2ZVByb3BzSW5kZXguZ2V0KHByb3AubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgYm91bmRFbGVtZW50UHJvcHMucHVzaChfdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGVsZW1lbnROYW1lLCBwcm9wLm5hbWUsIHByb3AuZXhwcmVzc2lvbiwgcHJvcC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm91bmRFbGVtZW50UHJvcHM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgbmFtZSwgYXN0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciB1bml0ID0gbnVsbDtcbiAgICAgICAgdmFyIGJpbmRpbmdUeXBlO1xuICAgICAgICB2YXIgYm91bmRQcm9wZXJ0eU5hbWU7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SKTtcbiAgICAgICAgdmFyIHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShwYXJ0c1swXSk7XG4gICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5zZWN1cml0eUNvbnRleHQoZWxlbWVudE5hbWUsIGJvdW5kUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gdGVtcGxhdGVfYXN0XzEuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzUHJvcGVydHkoZWxlbWVudE5hbWUsIGJvdW5kUHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQ2FuJ3QgYmluZCB0byAnXCIgKyBib3VuZFByb3BlcnR5TmFtZSArIFwiJyBzaW5jZSBpdCBpc24ndCBhIGtub3duIG5hdGl2ZSBwcm9wZXJ0eVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PSBBVFRSSUJVVEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQcm9wZXJ0eU5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKChcIkJpbmRpbmcgdG8gZXZlbnQgYXR0cmlidXRlICdcIiArIGJvdW5kUHJvcGVydHlOYW1lICsgXCInIGlzIGRpc2FsbG93ZWQgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImZvciBzZWN1cml0eSByZWFzb25zLCBwbGVhc2UgdXNlIChcIiArIGJvdW5kUHJvcGVydHlOYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5COiBGb3Igc2VjdXJpdHkgcHVycG9zZXMsIHVzZSB0aGUgbWFwcGVkIHByb3BlcnR5IG5hbWUsIG5vdCB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0ID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShib3VuZFByb3BlcnR5TmFtZSkpO1xuICAgICAgICAgICAgICAgIHZhciBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnMgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMCwgbnNTZXBhcmF0b3JJZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKG5zU2VwYXJhdG9ySWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gaHRtbF90YWdzXzEubWVyZ2VOc0FuZE5hbWUobnMsIG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gdGVtcGxhdGVfYXN0XzEuUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gdGVtcGxhdGVfYXN0XzEuUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzcztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuTk9ORTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSB0ZW1wbGF0ZV9hc3RfMS5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dCA9IGNvcmVfcHJpdmF0ZV8xLlNlY3VyaXR5Q29udGV4dC5TVFlMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lICdcIiArIG5hbWUgKyBcIidcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5Cb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3BlcnR5TmFtZSwgYmluZGluZ1R5cGUsIHNlY3VyaXR5Q29udGV4dCwgYXN0LCB1bml0LCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVOYW1lcyA9IFtdO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gZGlyZWN0aXZlLmRpcmVjdGl2ZS50eXBlLm5hbWU7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGVOYW1lcy5wdXNoKHR5cGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRUeXBlTmFtZXM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiTW9yZSB0aGFuIG9uZSBjb21wb25lbnQ6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBlbGVtZW50UHJvcHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVOYW1lcyA9IHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVOYW1lcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkNvbXBvbmVudHMgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGU6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlByb3BlcnR5IGJpbmRpbmcgXCIgKyBwcm9wLm5hbWUgKyBcIiBub3QgdXNlZCBieSBhbnkgZGlyZWN0aXZlIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0QWxsRXZlbnRzUHVibGlzaGVkQnlEaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGV2ZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWxsRGlyZWN0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChkaXJlY3RpdmUuZGlyZWN0aXZlLm91dHB1dHMsIGZ1bmN0aW9uIChldmVudE5hbWUsIF8pIHsgYWxsRGlyZWN0aXZlRXZlbnRzLmFkZChldmVudE5hbWUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZXZlbnQudGFyZ2V0KSB8fCAhY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKGFsbERpcmVjdGl2ZUV2ZW50cywgZXZlbnQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJFdmVudCBiaW5kaW5nIFwiICsgZXZlbnQuZnVsbE5hbWUgKyBcIiBub3QgZW1pdHRlZCBieSBhbnkgZGlyZWN0aXZlIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlXCIsIGV2ZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlVmlzaXRvcjtcbn0oKSk7XG52YXIgTm9uQmluZGFibGVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb25CaW5kYWJsZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gdGVtcGxhdGVfcHJlcGFyc2VyXzEucHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IHRlbXBsYXRlX3ByZXBhcnNlcl8xLlByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSB0ZW1wbGF0ZV9wcmVwYXJzZXJfMS5QcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIFthdHRyQXN0Lm5hbWUsIGF0dHJBc3QudmFsdWVdOyB9KTtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGFzdC5uYW1lLCBhdHRyTmFtZUFuZFZhbHVlcyk7XG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoc2VsZWN0b3IpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBodG1sX2FzdF8xLmh0bWxWaXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCk7XG4gICAgICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuRWxlbWVudEFzdChhc3QubmFtZSwgaHRtbF9hc3RfMS5odG1sVmlzaXRBbGwodGhpcywgYXN0LmF0dHJzKSwgW10sIFtdLCBbXSwgW10sIFtdLCBmYWxzZSwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBhc3Quc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGVtcGxhdGVfYXN0XzEuQXR0ckFzdChhc3QubmFtZSwgYXN0LnZhbHVlLCBhc3Quc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0ZW1wbGF0ZV9hc3RfMS5UZXh0QXN0KGFzdC52YWx1ZSwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgcmV0dXJuIE5vbkJpbmRhYmxlVmlzaXRvcjtcbn0oKSk7XG52YXIgQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eShuYW1lLCBleHByZXNzaW9uLCBpc0xpdGVyYWwsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5pc0xpdGVyYWwgPSBpc0xpdGVyYWw7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHJldHVybiBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5O1xufSgpKTtcbnZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRPckRpcmVjdGl2ZVJlZihuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHJldHVybiBFbGVtZW50T3JEaXJlY3RpdmVSZWY7XG59KCkpO1xuZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzQXR0clZhbHVlKSB7XG4gICAgcmV0dXJuIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnNwbGl0KGNsYXNzQXR0clZhbHVlLnRyaW0oKSwgL1xccysvZyk7XG59XG5leHBvcnRzLnNwbGl0Q2xhc3NlcyA9IHNwbGl0Q2xhc3NlcztcbnZhciBFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIF9uZ0NvbnRlbnRJbmRleE1hdGNoZXIsIF93aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pc1RlbXBsYXRlRWxlbWVudCA9IGlzVGVtcGxhdGVFbGVtZW50O1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIgPSBfbmdDb250ZW50SW5kZXhNYXRjaGVyO1xuICAgICAgICB0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4ID0gX3dpbGRjYXJkTmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMucHJvdmlkZXJDb250ZXh0ID0gcHJvdmlkZXJDb250ZXh0O1xuICAgIH1cbiAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBzZWxlY3Rvcl8xLlNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICB2YXIgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IG51bGw7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHZhciBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBjb21wb25lbnQuZGlyZWN0aXZlLnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gbmdDb250ZW50U2VsZWN0b3JzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoc2VsZWN0b3IsICcqJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyLmFkZFNlbGVjdGFibGVzKHNlbGVjdG9yXzEuQ3NzU2VsZWN0b3IucGFyc2UobmdDb250ZW50U2VsZWN0b3JzW2ldKSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIG1hdGNoZXIsIHdpbGRjYXJkTmdDb250ZW50SW5kZXgsIHByb3ZpZGVyQ29udGV4dCk7XG4gICAgfTtcbiAgICBFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuZmluZE5nQ29udGVudEluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRpY2VzID0gW107XG4gICAgICAgIHRoaXMuX25nQ29udGVudEluZGV4TWF0Y2hlci5tYXRjaChzZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBuZ0NvbnRlbnRJbmRleCkgeyBuZ0NvbnRlbnRJbmRpY2VzLnB1c2gobmdDb250ZW50SW5kZXgpOyB9KTtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnNvcnQobmdDb250ZW50SW5kaWNlcyk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnB1c2godGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5nQ29udGVudEluZGljZXMubGVuZ3RoID4gMCA/IG5nQ29udGVudEluZGljZXNbMF0gOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRDb250ZXh0O1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgbWF0Y2hhYmxlQXR0cnMpIHtcbiAgICB2YXIgY3NzU2VsZWN0b3IgPSBuZXcgc2VsZWN0b3JfMS5Dc3NTZWxlY3RvcigpO1xuICAgIHZhciBlbE5hbWVOb05zID0gaHRtbF90YWdzXzEuc3BsaXROc05hbWUoZWxlbWVudE5hbWUpWzFdO1xuICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxOYW1lTm9Ocyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGFibGVBdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0ck5hbWUgPSBtYXRjaGFibGVBdHRyc1tpXVswXTtcbiAgICAgICAgdmFyIGF0dHJOYW1lTm9OcyA9IGh0bWxfdGFnc18xLnNwbGl0TnNOYW1lKGF0dHJOYW1lKVsxXTtcbiAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IG1hdGNoYWJsZUF0dHJzW2ldWzFdO1xuICAgICAgICBjc3NTZWxlY3Rvci5hZGRBdHRyaWJ1dGUoYXR0ck5hbWVOb05zLCBhdHRyVmFsdWUpO1xuICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PSBDTEFTU19BVFRSKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNwbGl0Q2xhc3NlcyhhdHRyVmFsdWUpO1xuICAgICAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIGNzc1NlbGVjdG9yLmFkZENsYXNzTmFtZShjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3NzU2VsZWN0b3I7XG59XG52YXIgRU1QVFlfRUxFTUVOVF9DT05URVhUID0gbmV3IEVsZW1lbnRDb250ZXh0KHRydWUsIG5ldyBzZWxlY3Rvcl8xLlNlbGVjdG9yTWF0Y2hlcigpLCBudWxsLCBudWxsKTtcbnZhciBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcbnZhciBQaXBlQ29sbGVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGlwZUNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaXBlQ29sbGVjdG9yKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5waXBlcyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgUGlwZUNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnBpcGVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQaXBlQ29sbGVjdG9yO1xufShhc3RfMS5SZWN1cnNpdmVBc3RWaXNpdG9yKSk7XG5leHBvcnRzLlBpcGVDb2xsZWN0b3IgPSBQaXBlQ29sbGVjdG9yO1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhpdGVtcykge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBoYXNNYXRjaCA9IHJlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudHlwZS5uYW1lID09IGl0ZW0udHlwZS5uYW1lICYmIHIudHlwZS5tb2R1bGVVcmwgPT0gaXRlbS50eXBlLm1vZHVsZVVybCAmJlxuICAgICAgICAgICAgci50eXBlLnJ1bnRpbWUgPT0gaXRlbS50eXBlLnJ1bnRpbWU7IH0pXG4gICAgICAgICAgICAubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGVfcGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGh0bWxfdGFnc18xID0gcmVxdWlyZSgnLi9odG1sX3RhZ3MnKTtcbnZhciBOR19DT05URU5UX1NFTEVDVF9BVFRSID0gJ3NlbGVjdCc7XG52YXIgTkdfQ09OVEVOVF9FTEVNRU5UID0gJ25nLWNvbnRlbnQnO1xudmFyIExJTktfRUxFTUVOVCA9ICdsaW5rJztcbnZhciBMSU5LX1NUWUxFX1JFTF9BVFRSID0gJ3JlbCc7XG52YXIgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XG52YXIgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XG52YXIgU1RZTEVfRUxFTUVOVCA9ICdzdHlsZSc7XG52YXIgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcbnZhciBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbnZhciBOR19QUk9KRUNUX0FTID0gJ25nUHJvamVjdEFzJztcbmZ1bmN0aW9uIHByZXBhcnNlRWxlbWVudChhc3QpIHtcbiAgICB2YXIgc2VsZWN0QXR0ciA9IG51bGw7XG4gICAgdmFyIGhyZWZBdHRyID0gbnVsbDtcbiAgICB2YXIgcmVsQXR0ciA9IG51bGw7XG4gICAgdmFyIG5vbkJpbmRhYmxlID0gZmFsc2U7XG4gICAgdmFyIHByb2plY3RBcyA9IG51bGw7XG4gICAgYXN0LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgdmFyIGxjQXR0ck5hbWUgPSBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxjQXR0ck5hbWUgPT0gTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUikge1xuICAgICAgICAgICAgc2VsZWN0QXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX0hSRUZfQVRUUikge1xuICAgICAgICAgICAgaHJlZkF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9SRUxfQVRUUikge1xuICAgICAgICAgICAgcmVsQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IE5HX05PTl9CSU5EQUJMRV9BVFRSKSB7XG4gICAgICAgICAgICBub25CaW5kYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IE5HX1BST0pFQ1RfQVMpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0QXMgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2VsZWN0QXR0ciA9IG5vcm1hbGl6ZU5nQ29udGVudFNlbGVjdChzZWxlY3RBdHRyKTtcbiAgICB2YXIgbm9kZU5hbWUgPSBhc3QubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVI7XG4gICAgaWYgKGh0bWxfdGFnc18xLnNwbGl0TnNOYW1lKG5vZGVOYW1lKVsxXSA9PSBOR19DT05URU5UX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNUWUxFX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTQ1JJUFRfRUxFTUVOVCkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBMSU5LX0VMRU1FTlQgJiYgcmVsQXR0ciA9PSBMSU5LX1NUWUxFX1JFTF9WQUxVRSkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKTtcbn1cbmV4cG9ydHMucHJlcGFyc2VFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50O1xuKGZ1bmN0aW9uIChQcmVwYXJzZWRFbGVtZW50VHlwZSkge1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiTkdfQ09OVEVOVFwiXSA9IDBdID0gXCJOR19DT05URU5UXCI7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVwiXSA9IDFdID0gXCJTVFlMRVwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVTSEVFVFwiXSA9IDJdID0gXCJTVFlMRVNIRUVUXCI7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJPVEhFUlwiXSA9IDRdID0gXCJPVEhFUlwiO1xufSkoZXhwb3J0cy5QcmVwYXJzZWRFbGVtZW50VHlwZSB8fCAoZXhwb3J0cy5QcmVwYXJzZWRFbGVtZW50VHlwZSA9IHt9KSk7XG52YXIgUHJlcGFyc2VkRWxlbWVudFR5cGUgPSBleHBvcnRzLlByZXBhcnNlZEVsZW1lbnRUeXBlO1xudmFyIFByZXBhcnNlZEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlLCBwcm9qZWN0QXMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWxlY3RBdHRyID0gc2VsZWN0QXR0cjtcbiAgICAgICAgdGhpcy5ocmVmQXR0ciA9IGhyZWZBdHRyO1xuICAgICAgICB0aGlzLm5vbkJpbmRhYmxlID0gbm9uQmluZGFibGU7XG4gICAgICAgIHRoaXMucHJvamVjdEFzID0gcHJvamVjdEFzO1xuICAgIH1cbiAgICByZXR1cm4gUHJlcGFyc2VkRWxlbWVudDtcbn0oKSk7XG5leHBvcnRzLlByZXBhcnNlZEVsZW1lbnQgPSBQcmVwYXJzZWRFbGVtZW50O1xuZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoc2VsZWN0QXR0cikgfHwgc2VsZWN0QXR0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcqJztcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdEF0dHI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9wcmVwYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIF9BU1NFVF9TQ0hFTUUgPSAnYXNzZXQ6Jztcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIFVybFJlc29sdmVyfSB3aXRoIG5vIHBhY2thZ2UgcHJlZml4LlxuICovXG5mdW5jdGlvbiBjcmVhdGVVcmxSZXNvbHZlcldpdGhvdXRQYWNrYWdlUHJlZml4KCkge1xuICAgIHJldHVybiBuZXcgVXJsUmVzb2x2ZXIoKTtcbn1cbmV4cG9ydHMuY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeCA9IGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXg7XG5mdW5jdGlvbiBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyKCkge1xuICAgIHJldHVybiBuZXcgVXJsUmVzb2x2ZXIoX0FTU0VUX1NDSEVNRSk7XG59XG5leHBvcnRzLmNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIgPSBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyO1xuLyoqXG4gKiBBIGRlZmF1bHQgcHJvdmlkZXIgZm9yIHtAbGluayBQQUNLQUdFX1JPT1RfVVJMfSB0aGF0IG1hcHMgdG8gJy8nLlxuICovXG5leHBvcnRzLkRFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIgPSB7XG4gICAgcHJvdmlkZTogY29yZV8xLlBBQ0tBR0VfUk9PVF9VUkwsXG4gICAgdXNlVmFsdWU6IFwiL1wiXG59O1xudmFyIFVybFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxSZXNvbHZlcihfcGFja2FnZVByZWZpeCkge1xuICAgICAgICBpZiAoX3BhY2thZ2VQcmVmaXggPT09IHZvaWQgMCkgeyBfcGFja2FnZVByZWZpeCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fcGFja2FnZVByZWZpeCA9IF9wYWNrYWdlUHJlZml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgYHVybGAgZ2l2ZW4gdGhlIGBiYXNlVXJsYDpcbiAgICAgKiAtIHdoZW4gdGhlIGB1cmxgIGlzIG51bGwsIHRoZSBgYmFzZVVybGAgaXMgcmV0dXJuZWQsXG4gICAgICogLSBpZiBgdXJsYCBpcyByZWxhdGl2ZSAoJ3BhdGgvdG8vaGVyZScsICcuL3BhdGgvdG8vaGVyZScpLCB0aGUgcmVzb2x2ZWQgdXJsIGlzIGEgY29tYmluYXRpb24gb2ZcbiAgICAgKiBgYmFzZVVybGAgYW5kIGB1cmxgLFxuICAgICAqIC0gaWYgYHVybGAgaXMgYWJzb2x1dGUgKGl0IGhhcyBhIHNjaGVtZTogJ2h0dHA6Ly8nLCAnaHR0cHM6Ly8nIG9yIHN0YXJ0IHdpdGggJy8nKSwgdGhlIGB1cmxgIGlzXG4gICAgICogcmV0dXJuZWQgYXMgaXMgKGlnbm9yaW5nIHRoZSBgYmFzZVVybGApXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgcmVzb2x2ZWQgVVJMXG4gICAgICovXG4gICAgVXJsUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoYmFzZVVybCwgdXJsKSB7XG4gICAgICAgIHZhciByZXNvbHZlZFVybCA9IHVybDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYmFzZVVybCkgJiYgYmFzZVVybC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXNvbHZlZFVybCA9IF9yZXNvbHZlVXJsKGJhc2VVcmwsIHJlc29sdmVkVXJsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb2x2ZWRQYXJ0cyA9IF9zcGxpdChyZXNvbHZlZFVybCk7XG4gICAgICAgIHZhciBwcmVmaXggPSB0aGlzLl9wYWNrYWdlUHJlZml4O1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcmVmaXgpICYmIGxhbmdfMS5pc1ByZXNlbnQocmVzb2x2ZWRQYXJ0cykgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gXCJwYWNrYWdlXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFja2FnZVByZWZpeCA9PT0gX0FTU0VUX1NDSEVNRSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoU2VnZW1lbnRzID0gcGF0aC5zcGxpdCgvXFwvLyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBcImFzc2V0OlwiICsgcGF0aFNlZ2VtZW50c1swXSArIFwiL2xpYi9cIiArIHBhdGhTZWdlbWVudHMuc2xpY2UoMSkuam9pbignLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gbGFuZ18xLlN0cmluZ1dyYXBwZXIuc3RyaXBSaWdodChwcmVmaXgsICcvJyk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnN0cmlwTGVmdChwYXRoLCAnLycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIi9cIiArIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkVXJsO1xuICAgIH07XG4gICAgVXJsUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgVXJsUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbY29yZV8xLlBBQ0tBR0VfUk9PVF9VUkwsXSB9LF0gfSxcbiAgICBdO1xuICAgIHJldHVybiBVcmxSZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLlVybFJlc29sdmVyID0gVXJsUmVzb2x2ZXI7XG4vKipcbiAqIEV4dHJhY3QgdGhlIHNjaGVtZSBvZiBhIFVSTC5cbiAqL1xuZnVuY3Rpb24gZ2V0VXJsU2NoZW1lKHVybCkge1xuICAgIHZhciBtYXRjaCA9IF9zcGxpdCh1cmwpO1xuICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2hbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0pIHx8IFwiXCI7XG59XG5leHBvcnRzLmdldFVybFNjaGVtZSA9IGdldFVybFNjaGVtZTtcbi8vIFRoZSBjb2RlIGJlbG93IGlzIGFkYXB0ZWQgZnJvbSBUcmFjZXVyOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS90cmFjZXVyLWNvbXBpbGVyL2Jsb2IvOTUxMWMxZGFmYTk3MmJmMGRlMTIwMmE4YTg2M2JhZDAyZjBmOTVhOC9zcmMvcnVudGltZS91cmwuanNcbi8qKlxuICogQnVpbGRzIGEgVVJJIHN0cmluZyBmcm9tIGFscmVhZHktZW5jb2RlZCBwYXJ0cy5cbiAqXG4gKiBObyBlbmNvZGluZyBpcyBwZXJmb3JtZWQuICBBbnkgY29tcG9uZW50IG1heSBiZSBvbWl0dGVkIGFzIGVpdGhlciBudWxsIG9yXG4gKiB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nPX0gb3B0X3NjaGVtZSBUaGUgc2NoZW1lIHN1Y2ggYXMgJ2h0dHAnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0gb3B0X3VzZXJJbmZvIFRoZSB1c2VyIG5hbWUgYmVmb3JlIHRoZSAnQCcuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfZG9tYWluIFRoZSBkb21haW4gc3VjaCBhcyAnd3d3Lmdvb2dsZS5jb20nLCBhbHJlYWR5XG4gKiAgICAgVVJJLWVuY29kZWQuXG4gKiBAcGFyYW0geyhzdHJpbmd8bnVsbCk9fSBvcHRfcG9ydCBUaGUgcG9ydCBudW1iZXIuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfcGF0aCBUaGUgcGF0aCwgYWxyZWFkeSBVUkktZW5jb2RlZC4gIElmIGl0IGlzIG5vdFxuICogICAgIGVtcHR5LCBpdCBtdXN0IGJlZ2luIHdpdGggYSBzbGFzaC5cbiAqIEBwYXJhbSB7P3N0cmluZz19IG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBmdWxseSBjb21iaW5lZCBVUkkuXG4gKi9cbmZ1bmN0aW9uIF9idWlsZEZyb21FbmNvZGVkUGFydHMob3B0X3NjaGVtZSwgb3B0X3VzZXJJbmZvLCBvcHRfZG9tYWluLCBvcHRfcG9ydCwgb3B0X3BhdGgsIG9wdF9xdWVyeURhdGEsIG9wdF9mcmFnbWVudCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcHRfc2NoZW1lKSkge1xuICAgICAgICBvdXQucHVzaChvcHRfc2NoZW1lICsgJzonKTtcbiAgICB9XG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob3B0X2RvbWFpbikpIHtcbiAgICAgICAgb3V0LnB1c2goJy8vJyk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF91c2VySW5mbykpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbyArICdAJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gob3B0X2RvbWFpbik7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9wb3J0KSkge1xuICAgICAgICAgICAgb3V0LnB1c2goJzonICsgb3B0X3BvcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9wYXRoKSkge1xuICAgICAgICBvdXQucHVzaChvcHRfcGF0aCk7XG4gICAgfVxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG9wdF9xdWVyeURhdGEpKSB7XG4gICAgICAgIG91dC5wdXNoKCc/JyArIG9wdF9xdWVyeURhdGEpO1xuICAgIH1cbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChvcHRfZnJhZ21lbnQpKSB7XG4gICAgICAgIG91dC5wdXNoKCcjJyArIG9wdF9mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbignJyk7XG59XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gKlxuICoge0BsaW5rIGh0dHA6Ly93d3cuZ2Jpdi5jb20vcHJvdG9jb2xzL3VyaS9yZmMvcmZjMzk4Ni5odG1sI1JGQzIyMzR9IHNheXNcbiAqIEFzIHRoZSBcImZpcnN0LW1hdGNoLXdpbnNcIiBhbGdvcml0aG0gaXMgaWRlbnRpY2FsIHRvIHRoZSBcImdyZWVkeVwiXG4gKiBkaXNhbWJpZ3VhdGlvbiBtZXRob2QgdXNlZCBieSBQT1NJWCByZWd1bGFyIGV4cHJlc3Npb25zLCBpdCBpcyBuYXR1cmFsIGFuZFxuICogY29tbW9ucGxhY2UgdG8gdXNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBwYXJzaW5nIHRoZSBwb3RlbnRpYWwgZml2ZVxuICogY29tcG9uZW50cyBvZiBhIFVSSSByZWZlcmVuY2UuXG4gKlxuICogVGhlIGZvbGxvd2luZyBsaW5lIGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nLWRvd24gYVxuICogd2VsbC1mb3JtZWQgVVJJIHJlZmVyZW5jZSBpbnRvIGl0cyBjb21wb25lbnRzLlxuICpcbiAqIDxwcmU+XG4gKiBeKChbXjovPyNdKyk6KT8oLy8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/XG4gKiAgMTIgICAgICAgICAgICAzICA0ICAgICAgICAgIDUgICAgICAgNiAgNyAgICAgICAgOCA5XG4gKiA8L3ByZT5cbiAqXG4gKiBUaGUgbnVtYmVycyBpbiB0aGUgc2Vjb25kIGxpbmUgYWJvdmUgYXJlIG9ubHkgdG8gYXNzaXN0IHJlYWRhYmlsaXR5OyB0aGV5XG4gKiBpbmRpY2F0ZSB0aGUgcmVmZXJlbmNlIHBvaW50cyBmb3IgZWFjaCBzdWJleHByZXNzaW9uIChpLmUuLCBlYWNoIHBhaXJlZFxuICogcGFyZW50aGVzaXMpLiBXZSByZWZlciB0byB0aGUgdmFsdWUgbWF0Y2hlZCBmb3Igc3ViZXhwcmVzc2lvbiA8bj4gYXMgJDxuPi5cbiAqIEZvciBleGFtcGxlLCBtYXRjaGluZyB0aGUgYWJvdmUgZXhwcmVzc2lvbiB0b1xuICogPHByZT5cbiAqICAgICBodHRwOi8vd3d3Lmljcy51Y2kuZWR1L3B1Yi9pZXRmL3VyaS8jUmVsYXRlZFxuICogPC9wcmU+XG4gKiByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgc3ViZXhwcmVzc2lvbiBtYXRjaGVzOlxuICogPHByZT5cbiAqICAgICQxID0gaHR0cDpcbiAqICAgICQyID0gaHR0cFxuICogICAgJDMgPSAvL3d3dy5pY3MudWNpLmVkdVxuICogICAgJDQgPSB3d3cuaWNzLnVjaS5lZHVcbiAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS9cbiAqICAgICQ2ID0gPHVuZGVmaW5lZD5cbiAqICAgICQ3ID0gPHVuZGVmaW5lZD5cbiAqICAgICQ4ID0gI1JlbGF0ZWRcbiAqICAgICQ5ID0gUmVsYXRlZFxuICogPC9wcmU+XG4gKiB3aGVyZSA8dW5kZWZpbmVkPiBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tcG9uZW50IGlzIG5vdCBwcmVzZW50LCBhcyBpcyB0aGVcbiAqIGNhc2UgZm9yIHRoZSBxdWVyeSBjb21wb25lbnQgaW4gdGhlIGFib3ZlIGV4YW1wbGUuIFRoZXJlZm9yZSwgd2UgY2FuXG4gKiBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBmaXZlIGNvbXBvbmVudHMgYXNcbiAqIDxwcmU+XG4gKiAgICBzY2hlbWUgICAgPSAkMlxuICogICAgYXV0aG9yaXR5ID0gJDRcbiAqICAgIHBhdGggICAgICA9ICQ1XG4gKiAgICBxdWVyeSAgICAgPSAkN1xuICogICAgZnJhZ21lbnQgID0gJDlcbiAqIDwvcHJlPlxuICpcbiAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gaGFzIGJlZW4gbW9kaWZpZWQgc2xpZ2h0bHkgdG8gZXhwb3NlIHRoZVxuICogdXNlckluZm8sIGRvbWFpbiwgYW5kIHBvcnQgc2VwYXJhdGVseSBmcm9tIHRoZSBhdXRob3JpdHkuXG4gKiBUaGUgbW9kaWZpZWQgdmVyc2lvbiB5aWVsZHNcbiAqIDxwcmU+XG4gKiAgICAkMSA9IGh0dHAgICAgICAgICAgICAgIHNjaGVtZVxuICogICAgJDIgPSA8dW5kZWZpbmVkPiAgICAgICB1c2VySW5mbyAtXFxcbiAqICAgICQzID0gd3d3Lmljcy51Y2kuZWR1ICAgZG9tYWluICAgICB8IGF1dGhvcml0eVxuICogICAgJDQgPSA8dW5kZWZpbmVkPiAgICAgICBwb3J0ICAgICAtL1xuICogICAgJDUgPSAvcHViL2lldGYvdXJpLyAgICBwYXRoXG4gKiAgICAkNiA9IDx1bmRlZmluZWQ+ICAgICAgIHF1ZXJ5IHdpdGhvdXQgP1xuICogICAgJDcgPSBSZWxhdGVkICAgICAgICAgICBmcmFnbWVudCB3aXRob3V0ICNcbiAqIDwvcHJlPlxuICogQHR5cGUgeyFSZWdFeHB9XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIF9zcGxpdFJlID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuY3JlYXRlKCdeJyArXG4gICAgJyg/OicgK1xuICAgICcoW146Lz8jLl0rKScgK1xuICAgIC8vIHVzZWQgYnkgb3RoZXIgVVJMIHBhcnRzIHN1Y2ggYXMgOixcbiAgICAvLyA/LCAvLCAjLCBhbmQgLlxuICAgICc6KT8nICtcbiAgICAnKD86Ly8nICtcbiAgICAnKD86KFteLz8jXSopQCk/JyArXG4gICAgJyhbXFxcXHdcXFxcZFxcXFwtXFxcXHUwMTAwLVxcXFx1ZmZmZi4lXSopJyArXG4gICAgLy8gZGlnaXRzLCBkYXNoZXMsIGRvdHMsIHBlcmNlbnRcbiAgICAvLyBlc2NhcGVzLCBhbmQgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICcoPzo6KFswLTldKykpPycgK1xuICAgICcpPycgK1xuICAgICcoW14/I10rKT8nICtcbiAgICAnKD86XFxcXD8oW14jXSopKT8nICtcbiAgICAnKD86IyguKikpPycgK1xuICAgICckJyk7XG4vKipcbiAqIFRoZSBpbmRleCBvZiBlYWNoIFVSSSBjb21wb25lbnQgaW4gdGhlIHJldHVybiB2YWx1ZSBvZiBnb29nLnVyaS51dGlscy5zcGxpdC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbnZhciBfQ29tcG9uZW50SW5kZXg7XG4oZnVuY3Rpb24gKF9Db21wb25lbnRJbmRleCkge1xuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJTY2hlbWVcIl0gPSAxXSA9IFwiU2NoZW1lXCI7XG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlVzZXJJbmZvXCJdID0gMl0gPSBcIlVzZXJJbmZvXCI7XG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIkRvbWFpblwiXSA9IDNdID0gXCJEb21haW5cIjtcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUG9ydFwiXSA9IDRdID0gXCJQb3J0XCI7XG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlBhdGhcIl0gPSA1XSA9IFwiUGF0aFwiO1xuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJRdWVyeURhdGFcIl0gPSA2XSA9IFwiUXVlcnlEYXRhXCI7XG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIkZyYWdtZW50XCJdID0gN10gPSBcIkZyYWdtZW50XCI7XG59KShfQ29tcG9uZW50SW5kZXggfHwgKF9Db21wb25lbnRJbmRleCA9IHt9KSk7XG4vKipcbiAqIFNwbGl0cyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gKlxuICogRWFjaCBjb21wb25lbnQgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgY29tcG9uZW50IGluZGljZXM7IGZvciBleGFtcGxlOlxuICogPHByZT5cbiAqIGdvb2cudXJpLnV0aWxzLnNwbGl0KHNvbWVTdHIpW2dvb2cudXJpLnV0aWxzLkNvbXBvbnRlbnRJbmRleC5RVUVSWV9EQVRBXTtcbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgVGhlIFVSSSBzdHJpbmcgdG8gZXhhbWluZS5cbiAqIEByZXR1cm4geyFBcnJheS48c3RyaW5nfHVuZGVmaW5lZD59IEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxuICogICAgIEVhY2ggY29tcG9uZW50IHRoYXQgaXMgcHJlc2VudCB3aWxsIGNvbnRhaW4gdGhlIGVuY29kZWQgdmFsdWUsIHdoZXJlYXNcbiAqICAgICBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVzZW50IHdpbGwgYmUgdW5kZWZpbmVkIG9yIGVtcHR5LCBkZXBlbmRpbmdcbiAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXG4gKiAgICAgYXJiaXRyYXJ5IHN0cmluZ3MgbWF5IHN0aWxsIGxvb2sgbGlrZSBwYXRoIG5hbWVzLlxuICovXG5mdW5jdGlvbiBfc3BsaXQodXJpKSB7XG4gICAgcmV0dXJuIGxhbmdfMS5SZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2goX3NwbGl0UmUsIHVyaSk7XG59XG4vKipcbiAgKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXG4gICogUkZDIDM5ODYsIHNlY3Rpb24gNS4yLjQuXG4gICpcbiAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBBIG5vbi1lbXB0eSBwYXRoIGNvbXBvbmVudC5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IFBhdGggY29tcG9uZW50IHdpdGggcmVtb3ZlZCBkb3Qgc2VnbWVudHMuXG4gICovXG5mdW5jdGlvbiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCkge1xuICAgIGlmIChwYXRoID09ICcvJylcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB2YXIgbGVhZGluZ1NsYXNoID0gcGF0aFswXSA9PSAnLycgPyAnLycgOiAnJztcbiAgICB2YXIgdHJhaWxpbmdTbGFzaCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgdXAgPSAwO1xuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1twb3NdO1xuICAgICAgICBzd2l0Y2ggKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy4uJzpcbiAgICAgICAgICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXArKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsZWFkaW5nU2xhc2ggPT0gJycpIHtcbiAgICAgICAgd2hpbGUgKHVwLS0gPiAwKSB7XG4gICAgICAgICAgICBvdXQudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIG91dC5wdXNoKCcuJyk7XG4gICAgfVxuICAgIHJldHVybiBsZWFkaW5nU2xhc2ggKyBvdXQuam9pbignLycpICsgdHJhaWxpbmdTbGFzaDtcbn1cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgdGhlIHBhcnRzIGZyb20gc3BsaXQgYW5kIGNhbm9uaWNhbGl6ZXMgdGhlIHBhdGggcGFydFxuICogYW5kIHRoZW4gam9pbnMgYWxsIHRoZSBwYXJ0cy5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz8+fSBwYXJ0c1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpIHtcbiAgICB2YXIgcGF0aCA9IHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBwYXRoID0gbGFuZ18xLmlzQmxhbmsocGF0aCkgPyAnJyA6IF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKTtcbiAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xuICAgIHJldHVybiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguVXNlckluZm9dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRG9tYWluXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlBvcnRdLCBwYXRoLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSk7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgVGhlIFVSTCBhY3RpbmcgYXMgdGhlIGJhc2UgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvIFRoZSBVUkwgdG8gcmVzb2x2ZS5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgdmFyIHBhcnRzID0gX3NwbGl0KGVuY29kZVVSSSh1cmwpKTtcbiAgICB2YXIgYmFzZVBhcnRzID0gX3NwbGl0KGJhc2UpO1xuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdKSkge1xuICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gX0NvbXBvbmVudEluZGV4LlNjaGVtZTsgaSA8PSBfQ29tcG9uZW50SW5kZXguUG9ydDsgaSsrKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgIHBhcnRzW2ldID0gYmFzZVBhcnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF1bMF0gPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IGJhc2VQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhdGgpKVxuICAgICAgICBwYXRoID0gJy8nO1xuICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKSArIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xuICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsX3Jlc29sdmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4vZmFjYWRlL2xhbmcnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG5leHBvcnRzLk1PRFVMRV9TVUZGSVggPSBsYW5nXzEuSVNfREFSVCA/ICcuZGFydCcgOiAnJztcbnZhciBDQU1FTF9DQVNFX1JFR0VYUCA9IC8oW0EtWl0pL2c7XG52YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKFthLXpdKS9nO1xuZnVuY3Rpb24gY2FtZWxDYXNlVG9EYXNoQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGlucHV0LCBDQU1FTF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuICctJyArIG1bMV0udG9Mb3dlckNhc2UoKTsgfSk7XG59XG5leHBvcnRzLmNhbWVsQ2FzZVRvRGFzaENhc2UgPSBjYW1lbENhc2VUb0Rhc2hDYXNlO1xuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGlucHV0LCBEQVNIX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpOyB9KTtcbn1cbmV4cG9ydHMuZGFzaENhc2VUb0NhbWVsQ2FzZSA9IGRhc2hDYXNlVG9DYW1lbENhc2U7XG5mdW5jdGlvbiBzcGxpdEF0Q29sb24oaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICB2YXIgcGFydHMgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5zcGxpdChpbnB1dC50cmltKCksIC9cXHMqOlxccyovZyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5zcGxpdEF0Q29sb24gPSBzcGxpdEF0Q29sb247XG5mdW5jdGlvbiBzYW5pdGl6ZUlkZW50aWZpZXIobmFtZSkge1xuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKG5hbWUsIC9cXFcvZywgJ18nKTtcbn1cbmV4cG9ydHMuc2FuaXRpemVJZGVudGlmaWVyID0gc2FuaXRpemVJZGVudGlmaWVyO1xuZnVuY3Rpb24gdmlzaXRWYWx1ZSh2YWx1ZSwgdmlzaXRvciwgY29udGV4dCkge1xuICAgIGlmIChsYW5nXzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheSh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxhbmdfMS5pc1N0cmljdFN0cmluZ01hcCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdNYXAodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsYW5nXzEuaXNCbGFuayh2YWx1ZSkgfHwgbGFuZ18xLmlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByaW1pdGl2ZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE90aGVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLnZpc2l0VmFsdWUgPSB2aXNpdFZhbHVlO1xudmFyIFZhbHVlVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbHVlVHJhbnNmb3JtZXIoKSB7XG4gICAgfVxuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2gobWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkgeyByZXN1bHRba2V5XSA9IHZpc2l0VmFsdWUodmFsdWUsIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgcmV0dXJuIFZhbHVlVHJhbnNmb3JtZXI7XG59KCkpO1xuZXhwb3J0cy5WYWx1ZVRyYW5zZm9ybWVyID0gVmFsdWVUcmFuc2Zvcm1lcjtcbmZ1bmN0aW9uIGFzc2V0VXJsKHBrZywgcGF0aCwgdHlwZSkge1xuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSAnc3JjJzsgfVxuICAgIGlmIChsYW5nXzEuSVNfREFSVCkge1xuICAgICAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhc3NldDphbmd1bGFyMi9cIiArIHBrZyArIFwiL1wiICsgcGtnICsgXCIuZGFydFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiYXNzZXQ6YW5ndWxhcjIvbGliL1wiICsgcGtnICsgXCIvc3JjL1wiICsgcGF0aCArIFwiLmRhcnRcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYXNzZXQ6QGFuZ3VsYXIvbGliL1wiICsgcGtnICsgXCIvaW5kZXhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcImFzc2V0OkBhbmd1bGFyL2xpYi9cIiArIHBrZyArIFwiL3NyYy9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmFzc2V0VXJsID0gYXNzZXRVcmw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIENvbXBpbGVCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlQmluZGluZyhub2RlLCBzb3VyY2VBc3QpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5zb3VyY2VBc3QgPSBzb3VyY2VBc3Q7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQmluZGluZztcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVCaW5kaW5nID0gQ29tcGlsZUJpbmRpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlX2JpbmRpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbyA9IHJlcXVpcmUoJy4uL291dHB1dC9vdXRwdXRfYXN0Jyk7XG52YXIgaWRlbnRpZmllcnNfMSA9IHJlcXVpcmUoJy4uL2lkZW50aWZpZXJzJyk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIHRlbXBsYXRlX2FzdF8xID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVfYXN0Jyk7XG52YXIgY29tcGlsZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi4vY29tcGlsZV9tZXRhZGF0YScpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGNvbXBpbGVfcXVlcnlfMSA9IHJlcXVpcmUoJy4vY29tcGlsZV9xdWVyeScpO1xudmFyIGNvbXBpbGVfbWV0aG9kXzEgPSByZXF1aXJlKCcuL2NvbXBpbGVfbWV0aG9kJyk7XG52YXIgdXRpbF8yID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIENvbXBpbGVOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlTm9kZShwYXJlbnQsIHZpZXcsIG5vZGVJbmRleCwgcmVuZGVyTm9kZSwgc291cmNlQXN0KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm5vZGVJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gcmVuZGVyTm9kZTtcbiAgICAgICAgdGhpcy5zb3VyY2VBc3QgPSBzb3VyY2VBc3Q7XG4gICAgfVxuICAgIENvbXBpbGVOb2RlLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNCbGFuayh0aGlzLnJlbmRlck5vZGUpOyB9O1xuICAgIENvbXBpbGVOb2RlLnByb3RvdHlwZS5pc1Jvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52aWV3ICE9IHRoaXMucGFyZW50LnZpZXc7IH07XG4gICAgcmV0dXJuIENvbXBpbGVOb2RlO1xufSgpKTtcbmV4cG9ydHMuQ29tcGlsZU5vZGUgPSBDb21waWxlTm9kZTtcbnZhciBDb21waWxlRWxlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBpbGVFbGVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBpbGVFbGVtZW50KHBhcmVudCwgdmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBzb3VyY2VBc3QsIGNvbXBvbmVudCwgX2RpcmVjdGl2ZXMsIF9yZXNvbHZlZFByb3ZpZGVyc0FycmF5LCBoYXNWaWV3Q29udGFpbmVyLCBoYXNFbWJlZGRlZFZpZXcsIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcGFyZW50LCB2aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIHNvdXJjZUFzdCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVzID0gX2RpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXkgPSBfcmVzb2x2ZWRQcm92aWRlcnNBcnJheTtcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5oYXNFbWJlZGRlZFZpZXcgPSBoYXNFbWJlZGRlZFZpZXc7XG4gICAgICAgIHRoaXMuX2NvbXBWaWV3RXhwciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlcyA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRva2VuTWFwKCk7XG4gICAgICAgIHRoaXMuX3F1ZXJ5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLl9xdWVyaWVzID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlVG9rZW5NYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZVRva2VucyA9IHt9O1xuICAgICAgICByZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gX3RoaXMucmVmZXJlbmNlVG9rZW5zW3JlZi5uYW1lXSA9IHJlZi52YWx1ZTsgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IG8uaW1wb3J0RXhwcihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkVsZW1lbnRSZWYpLmluc3RhbnRpYXRlKFt0aGlzLnJlbmRlck5vZGVdKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzLmFkZChpZGVudGlmaWVyc18xLmlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkVsZW1lbnRSZWYpLCB0aGlzLmVsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gby5USElTX0VYUFIuY2FsbE1ldGhvZCgnaW5qZWN0b3InLCBbby5saXRlcmFsKHRoaXMubm9kZUluZGV4KV0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXMuYWRkKGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuSW5qZWN0b3IpLCB0aGlzLmluamVjdG9yKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzLmFkZChpZGVudGlmaWVyc18xLmlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLlJlbmRlcmVyKSwgby5USElTX0VYUFIucHJvcCgncmVuZGVyZXInKSk7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZpZXdDb250YWluZXIgfHwgdGhpcy5oYXNFbWJlZGRlZFZpZXcgfHwgbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUFwcEVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21waWxlRWxlbWVudC5jcmVhdGVOdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVFbGVtZW50KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFtdLCBbXSwgZmFsc2UsIGZhbHNlLCBbXSk7XG4gICAgfTtcbiAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZUFwcEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl9hcHBFbF9cIiArIHRoaXMubm9kZUluZGV4O1xuICAgICAgICB2YXIgcGFyZW50Tm9kZUluZGV4ID0gdGhpcy5pc1Jvb3RFbGVtZW50KCkgPyBudWxsIDogdGhpcy5wYXJlbnQubm9kZUluZGV4O1xuICAgICAgICAvLyBwcml2YXRlIGlzIGZpbmUgaGVyZSBhcyBubyBjaGlsZCB2aWV3IHdpbGwgcmVmZXJlbmNlIGFuIEFwcEVsZW1lbnRcbiAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBvLkNsYXNzRmllbGQoZmllbGROYW1lLCBvLmltcG9ydFR5cGUoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5BcHBFbGVtZW50KSwgW28uU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQgPSBvLlRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgIC5zZXQoby5pbXBvcnRFeHByKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuQXBwRWxlbWVudClcbiAgICAgICAgICAgIC5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICBvLmxpdGVyYWwodGhpcy5ub2RlSW5kZXgpLFxuICAgICAgICAgICAgby5saXRlcmFsKHBhcmVudE5vZGVJbmRleCksXG4gICAgICAgICAgICBvLlRISVNfRVhQUixcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZVxuICAgICAgICBdKSlcbiAgICAgICAgICAgIC50b1N0bXQoKTtcbiAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KHN0YXRlbWVudCk7XG4gICAgICAgIHRoaXMuYXBwRWxlbWVudCA9IG8uVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzLmFkZChpZGVudGlmaWVyc18xLmlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkFwcEVsZW1lbnQpLCB0aGlzLmFwcEVsZW1lbnQpO1xuICAgIH07XG4gICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLnNldENvbXBvbmVudFZpZXcgPSBmdW5jdGlvbiAoY29tcFZpZXdFeHByKSB7XG4gICAgICAgIHRoaXMuX2NvbXBWaWV3RXhwciA9IGNvbXBWaWV3RXhwcjtcbiAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4ID1cbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUodGhpcy5jb21wb25lbnQudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXhbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLnNldEVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uIChlbWJlZGRlZFZpZXcpIHtcbiAgICAgICAgdGhpcy5lbWJlZGRlZFZpZXcgPSBlbWJlZGRlZFZpZXc7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGVtYmVkZGVkVmlldykpIHtcbiAgICAgICAgICAgIHZhciBjcmVhdGVUZW1wbGF0ZVJlZkV4cHIgPSBvLmltcG9ydEV4cHIoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5UZW1wbGF0ZVJlZl8pXG4gICAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKFt0aGlzLmFwcEVsZW1lbnQsIHRoaXMuZW1iZWRkZWRWaWV3LnZpZXdGYWN0b3J5XSk7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVQcm92aWRlck1ldGFkYXRhKHsgdG9rZW46IGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpLCB1c2VWYWx1ZTogY3JlYXRlVGVtcGxhdGVSZWZFeHByIH0pO1xuICAgICAgICAgICAgLy8gQWRkIFRlbXBsYXRlUmVmIGFzIGZpcnN0IHByb3ZpZGVyIGFzIGl0IGRvZXMgbm90IGhhdmUgZGVwcyBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXkudW5zaGlmdChuZXcgdGVtcGxhdGVfYXN0XzEuUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIGZhbHNlLCB0cnVlLCBbcHJvdmlkZXJdLCB0ZW1wbGF0ZV9hc3RfMS5Qcm92aWRlckFzdFR5cGUuQnVpbHRpbiwgdGhpcy5zb3VyY2VBc3Quc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlcy5hZGQoaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSwgdGhpcy5hcHBFbGVtZW50LnByb3AoJ3ZjUmVmJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlVG9rZW5NYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZXNvbHZlZFByb3ZpZGVycy5hZGQocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNyZWF0ZSBhbGwgdGhlIHByb3ZpZGVyIGluc3RhbmNlcywgc29tZSBpbiB0aGUgdmlldyBjb25zdHJ1Y3RvcixcbiAgICAgICAgLy8gc29tZSBhcyBnZXR0ZXJzLiBXZSByZWx5IG9uIHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgYWxyZWFkeSBzb3J0ZWQgdG9wb2xvZ2ljYWxseS5cbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMudmFsdWVzKCkuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLmRlcHMpID8gcHJvdmlkZXIuZGVwcyA6IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvLmltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcHNFeHByKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLmRlcHMpID8gcHJvdmlkZXIuZGVwcyA6IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHNFeHByID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5pbXBvcnRFeHByKHByb3ZpZGVyLnVzZUNsYXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKGRlcHNFeHByLCBvLmltcG9ydFR5cGUocHJvdmlkZXIudXNlQ2xhc3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udmVydFZhbHVlVG9PdXRwdXRBc3QocHJvdmlkZXIudXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfXCIgKyByZXNvbHZlZFByb3ZpZGVyLnRva2VuLm5hbWUgKyBcIl9cIiArIF90aGlzLm5vZGVJbmRleCArIFwiX1wiICsgX3RoaXMuX2luc3RhbmNlcy5zaXplO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlUHJvdmlkZXJQcm9wZXJ0eShwcm9wTmFtZSwgcmVzb2x2ZWRQcm92aWRlciwgcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zLCByZXNvbHZlZFByb3ZpZGVyLm11bHRpUHJvdmlkZXIsIHJlc29sdmVkUHJvdmlkZXIuZWFnZXIsIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLl9pbnN0YW5jZXMuYWRkKHJlc29sdmVkUHJvdmlkZXIudG9rZW4sIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlSW5zdGFuY2VzID1cbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIF90aGlzLl9pbnN0YW5jZXMuZ2V0KGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGRpcmVjdGl2ZS50eXBlKSk7IH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyZWN0aXZlSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSB0aGlzLmRpcmVjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSB0aGlzLl9kaXJlY3RpdmVzW2ldO1xuICAgICAgICAgICAgZGlyZWN0aXZlLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlNZXRhKSB7IF90aGlzLl9hZGRRdWVyeShxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJpZXNXaXRoUmVhZHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMudmFsdWVzKCkuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIHF1ZXJpZXNGb3JQcm92aWRlciA9IF90aGlzLl9nZXRRdWVyaWVzRm9yKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmFkZEFsbChxdWVyaWVzV2l0aFJlYWRzLCBxdWVyaWVzRm9yUHJvdmlkZXIubWFwKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gbmV3IF9RdWVyeVdpdGhSZWFkKHF1ZXJ5LCByZXNvbHZlZFByb3ZpZGVyLnRva2VuKTsgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCh0aGlzLnJlZmVyZW5jZVRva2VucywgZnVuY3Rpb24gKF8sIHZhck5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IF90aGlzLnJlZmVyZW5jZVRva2Vuc1t2YXJOYW1lXTtcbiAgICAgICAgICAgIHZhciB2YXJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHZhclZhbHVlID0gX3RoaXMuX2luc3RhbmNlcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5yZW5kZXJOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMudmlldy5sb2NhbHMuc2V0KHZhck5hbWUsIHZhclZhbHVlKTtcbiAgICAgICAgICAgIHZhciB2YXJUb2tlbiA9IG5ldyBjb21waWxlX21ldGFkYXRhXzEuQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogdmFyTmFtZSB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5hZGRBbGwocXVlcmllc1dpdGhSZWFkcywgX3RoaXMuX2dldFF1ZXJpZXNGb3IodmFyVG9rZW4pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIG5ldyBfUXVlcnlXaXRoUmVhZChxdWVyeSwgdmFyVG9rZW4pOyB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBxdWVyaWVzV2l0aFJlYWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5V2l0aFJlYWQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHF1ZXJ5V2l0aFJlYWQucmVhZC5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IGZvciBhbiBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5faW5zdGFuY2VzLmdldChxdWVyeVdpdGhSZWFkLnJlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcXVlcnkgZm9yIGEgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gX3RoaXMucmVmZXJlbmNlVG9rZW5zW3F1ZXJ5V2l0aFJlYWQucmVhZC52YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuX2luc3RhbmNlcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5lbGVtZW50UmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5V2l0aFJlYWQucXVlcnkuYWRkVmFsdWUodmFsdWUsIF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0ID0gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmNvbXBvbmVudCkgPyBvLmxpdGVyYWxBcnIodGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cykgOlxuICAgICAgICAgICAgICAgIG8uTlVMTF9FWFBSO1xuICAgICAgICAgICAgdmFyIGNvbXBFeHByID0gbGFuZ18xLmlzUHJlc2VudCh0aGlzLmdldENvbXBvbmVudCgpKSA/IHRoaXMuZ2V0Q29tcG9uZW50KCkgOiBvLk5VTExfRVhQUjtcbiAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdCh0aGlzLmFwcEVsZW1lbnQuY2FsbE1ldGhvZCgnaW5pdENvbXBvbmVudCcsIFtjb21wRXhwciwgY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0LCB0aGlzLl9jb21wVmlld0V4cHJdKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5hZnRlckNoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkTm9kZUNvdW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzLnZhbHVlcygpLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGFmdGVyQ2hpbGRyZW4gaXMgY2FsbGVkIGFmdGVyIHJlY3Vyc2luZyBpbnRvIGNoaWxkcmVuLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBnb29kIHNvIHRoYXQgYW4gaW5qZWN0b3IgbWF0Y2ggaW4gYW4gZWxlbWVudCB0aGF0IGlzIGNsb3NlciB0byBhIHJlcXVlc3RpbmcgZWxlbWVudFxuICAgICAgICAgICAgLy8gbWF0Y2hlcyBmaXJzdC5cbiAgICAgICAgICAgIHZhciBwcm92aWRlckV4cHIgPSBfdGhpcy5faW5zdGFuY2VzLmdldChyZXNvbHZlZFByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHZpZXcgcHJvdmlkZXJzIGFyZSBvbmx5IHZpc2libGUgb24gdGhlIGluamVjdG9yIG9mIHRoYXQgZWxlbWVudC5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYXMgdGhlIHJ1bGVzIGR1cmluZyBjb2RlZ2VuIGRvbid0IGFsbG93IGEgZGlyZWN0aXZlXG4gICAgICAgICAgICAvLyB0byBnZXQgaG9sZCBvZiBhIHZpZXcgcHJvdmRpZXIgb24gdGhlIHNhbWUgZWxlbWVudC4gV2Ugc3RpbGwgZG8gdGhpcyBzZW1hbnRpY1xuICAgICAgICAgICAgLy8gYXMgaXQgc2ltcGxpZmllcyBvdXIgbW9kZWwgdG8gaGF2aW5nIG9ubHkgb25lIHJ1bnRpbWUgaW5qZWN0b3IgcGVyIGVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgcHJvdmlkZXJDaGlsZE5vZGVDb3VudCA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSB0ZW1wbGF0ZV9hc3RfMS5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgPyAwIDogY2hpbGROb2RlQ291bnQ7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmluamVjdG9yR2V0TWV0aG9kLmFkZFN0bXQoY3JlYXRlSW5qZWN0SW50ZXJuYWxDb25kaXRpb24oX3RoaXMubm9kZUluZGV4LCBwcm92aWRlckNoaWxkTm9kZUNvdW50LCByZXNvbHZlZFByb3ZpZGVyLCBwcm92aWRlckV4cHIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXJpZXMudmFsdWVzKCkuZm9yRWFjaChmdW5jdGlvbiAocXVlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIHF1ZXJ5LmFmdGVyQ2hpbGRyZW4oX3RoaXMudmlldy51cGRhdGVDb250ZW50UXVlcmllc01ldGhvZCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5hZGRDb250ZW50Tm9kZSA9IGZ1bmN0aW9uIChuZ0NvbnRlbnRJbmRleCwgbm9kZUV4cHIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4W25nQ29udGVudEluZGV4XS5wdXNoKG5vZGVFeHByKTtcbiAgICB9O1xuICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuY29tcG9uZW50KSA/IHRoaXMuX2luc3RhbmNlcy5nZXQoaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4odGhpcy5jb21wb25lbnQudHlwZSkpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuZ2V0UHJvdmlkZXJUb2tlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZFByb3ZpZGVycy52YWx1ZXMoKS5tYXAoZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHsgcmV0dXJuIHV0aWxfMS5jcmVhdGVEaVRva2VuRXhwcmVzc2lvbihyZXNvbHZlZFByb3ZpZGVyLnRva2VuKTsgfSk7XG4gICAgfTtcbiAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcztcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIHF1ZXJpZXM7XG4gICAgICAgIHdoaWxlICghY3VycmVudEVsLmlzTnVsbCgpKSB7XG4gICAgICAgICAgICBxdWVyaWVzID0gY3VycmVudEVsLl9xdWVyaWVzLmdldCh0b2tlbik7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChxdWVyaWVzKSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5hZGRBbGwocmVzdWx0LCBxdWVyaWVzLmZpbHRlcihmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIHF1ZXJ5Lm1ldGEuZGVzY2VuZGFudHMgfHwgZGlzdGFuY2UgPD0gMTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcmllcyA9IHRoaXMudmlldy5jb21wb25lbnRWaWV3LnZpZXdRdWVyaWVzLmdldCh0b2tlbik7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuYWRkQWxsKHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fYWRkUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBcIl9xdWVyeV9cIiArIHF1ZXJ5TWV0YS5zZWxlY3RvcnNbMF0ubmFtZSArIFwiX1wiICsgdGhpcy5ub2RlSW5kZXggKyBcIl9cIiArIHRoaXMuX3F1ZXJ5Q291bnQrKztcbiAgICAgICAgdmFyIHF1ZXJ5TGlzdCA9IGNvbXBpbGVfcXVlcnlfMS5jcmVhdGVRdWVyeUxpc3QocXVlcnlNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgcHJvcE5hbWUsIHRoaXMudmlldyk7XG4gICAgICAgIHZhciBxdWVyeSA9IG5ldyBjb21waWxlX3F1ZXJ5XzEuQ29tcGlsZVF1ZXJ5KHF1ZXJ5TWV0YSwgcXVlcnlMaXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgdGhpcy52aWV3KTtcbiAgICAgICAgY29tcGlsZV9xdWVyeV8xLmFkZFF1ZXJ5VG9Ub2tlbk1hcCh0aGlzLl9xdWVyaWVzLCBxdWVyeSk7XG4gICAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9O1xuICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fZ2V0TG9jYWxEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgLy8gY29uc3RydWN0b3IgY29udGVudCBxdWVyeVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSAmJiBsYW5nXzEuaXNQcmVzZW50KGRlcC5xdWVyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2FkZFF1ZXJ5KGRlcC5xdWVyeSwgbnVsbCkucXVlcnlMaXN0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnN0cnVjdG9yIHZpZXcgcXVlcnlcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkgJiYgbGFuZ18xLmlzUHJlc2VudChkZXAudmlld1F1ZXJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tcGlsZV9xdWVyeV8xLmNyZWF0ZVF1ZXJ5TGlzdChkZXAudmlld1F1ZXJ5LCBudWxsLCBcIl92aWV3UXVlcnlfXCIgKyBkZXAudmlld1F1ZXJ5LnNlbGVjdG9yc1swXS5uYW1lICsgXCJfXCIgKyB0aGlzLm5vZGVJbmRleCArIFwiX1wiICsgdGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cy5sZW5ndGgsIHRoaXMudmlldyk7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyeUxpc3RzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkZXAudG9rZW4pKSB7XG4gICAgICAgICAgICAvLyBhY2Nlc3MgYnVpbHRpbnMgd2l0aCBzcGVjaWFsIHZpc2liaWxpdHlcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcC50b2tlbi5lcXVhbHNUbyhpZGVudGlmaWVyc18xLmlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wVmlld0V4cHIucHJvcCgncmVmJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmdldFByb3BlcnR5SW5WaWV3KG8uVEhJU19FWFBSLnByb3AoJ3JlZicpLCB0aGlzLnZpZXcsIHRoaXMudmlldy5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VzcyByZWd1bGFyIHByb3ZpZGVycyBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9pbnN0YW5jZXMuZ2V0KGRlcC50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXApIHtcbiAgICAgICAgdmFyIGN1cnJFbGVtZW50ID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmIChkZXAuaXNWYWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gby5saXRlcmFsKGRlcC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkgJiYgIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbERlcGVuZGVuY3kocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBwYXJlbnQgZWxlbWVudHNcbiAgICAgICAgd2hpbGUgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkgJiYgIWN1cnJFbGVtZW50LnBhcmVudC5pc051bGwoKSkge1xuICAgICAgICAgICAgY3VyckVsZW1lbnQgPSBjdXJyRWxlbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSBjdXJyRWxlbWVudC5fZ2V0TG9jYWxEZXBlbmRlbmN5KHRlbXBsYXRlX2FzdF8xLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBkZXAudG9rZW4gfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB1dGlsXzEuaW5qZWN0RnJvbVZpZXdQYXJlbnRJbmplY3RvcihkZXAudG9rZW4sIGRlcC5pc09wdGlvbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gby5OVUxMX0VYUFI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRQcm9wZXJ0eUluVmlldyhyZXN1bHQsIHRoaXMudmlldywgY3VyckVsZW1lbnQudmlldyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZUVsZW1lbnQ7XG59KENvbXBpbGVOb2RlKSk7XG5leHBvcnRzLkNvbXBpbGVFbGVtZW50ID0gQ29tcGlsZUVsZW1lbnQ7XG5mdW5jdGlvbiBjcmVhdGVJbmplY3RJbnRlcm5hbENvbmRpdGlvbihub2RlSW5kZXgsIGNoaWxkTm9kZUNvdW50LCBwcm92aWRlciwgcHJvdmlkZXJFeHByKSB7XG4gICAgdmFyIGluZGV4Q29uZGl0aW9uO1xuICAgIGlmIChjaGlsZE5vZGVDb3VudCA+IDApIHtcbiAgICAgICAgaW5kZXhDb25kaXRpb24gPSBvLmxpdGVyYWwobm9kZUluZGV4KVxuICAgICAgICAgICAgLmxvd2VyRXF1YWxzKGNvbnN0YW50c18xLkluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleClcbiAgICAgICAgICAgIC5hbmQoY29uc3RhbnRzXzEuSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4Lmxvd2VyRXF1YWxzKG8ubGl0ZXJhbChub2RlSW5kZXggKyBjaGlsZE5vZGVDb3VudCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluZGV4Q29uZGl0aW9uID0gby5saXRlcmFsKG5vZGVJbmRleCkuaWRlbnRpY2FsKGNvbnN0YW50c18xLkluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgby5JZlN0bXQoY29uc3RhbnRzXzEuSW5qZWN0TWV0aG9kVmFycy50b2tlbi5pZGVudGljYWwodXRpbF8xLmNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHByb3ZpZGVyLnRva2VuKSkuYW5kKGluZGV4Q29uZGl0aW9uKSwgW25ldyBvLlJldHVyblN0YXRlbWVudChwcm92aWRlckV4cHIpXSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlclByb3BlcnR5KHByb3BOYW1lLCBwcm92aWRlciwgcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zLCBpc011bHRpLCBpc0VhZ2VyLCBjb21waWxlRWxlbWVudCkge1xuICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICB2YXIgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcjtcbiAgICB2YXIgdHlwZTtcbiAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gby5saXRlcmFsQXJyKHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyk7XG4gICAgICAgIHR5cGUgPSBuZXcgby5BcnJheVR5cGUoby5EWU5BTUlDX1RZUEUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwciA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXTtcbiAgICAgICAgdHlwZSA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXS50eXBlO1xuICAgIH1cbiAgICBpZiAobGFuZ18xLmlzQmxhbmsodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IG8uRFlOQU1JQ19UWVBFO1xuICAgIH1cbiAgICBpZiAoaXNFYWdlcikge1xuICAgICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBvLkNsYXNzRmllbGQocHJvcE5hbWUsIHR5cGUpKTtcbiAgICAgICAgdmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChvLlRISVNfRVhQUi5wcm9wKHByb3BOYW1lKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGludGVybmFsRmllbGQgPSBcIl9cIiArIHByb3BOYW1lO1xuICAgICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBvLkNsYXNzRmllbGQoaW50ZXJuYWxGaWVsZCwgdHlwZSkpO1xuICAgICAgICB2YXIgZ2V0dGVyID0gbmV3IGNvbXBpbGVfbWV0aG9kXzEuQ29tcGlsZU1ldGhvZCh2aWV3KTtcbiAgICAgICAgZ2V0dGVyLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgICAgLy8gTm90ZTogRXF1YWxzIGlzIGltcG9ydGFudCBmb3IgSlMgc28gdGhhdCBpdCBhbHNvIGNoZWNrcyB0aGUgdW5kZWZpbmVkIGNhc2UhXG4gICAgICAgIGdldHRlci5hZGRTdG10KG5ldyBvLklmU3RtdChvLlRISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpLmlzQmxhbmsoKSwgW28uVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpXSkpO1xuICAgICAgICBnZXR0ZXIuYWRkU3RtdChuZXcgby5SZXR1cm5TdGF0ZW1lbnQoby5USElTX0VYUFIucHJvcChpbnRlcm5hbEZpZWxkKSkpO1xuICAgICAgICB2aWV3LmdldHRlcnMucHVzaChuZXcgby5DbGFzc0dldHRlcihwcm9wTmFtZSwgZ2V0dGVyLmZpbmlzaCgpLCB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiBvLlRISVNfRVhQUi5wcm9wKHByb3BOYW1lKTtcbn1cbnZhciBfUXVlcnlXaXRoUmVhZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1F1ZXJ5V2l0aFJlYWQocXVlcnksIG1hdGNoKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5yZWFkID0gbGFuZ18xLmlzUHJlc2VudChxdWVyeS5tZXRhLnJlYWQpID8gcXVlcnkubWV0YS5yZWFkIDogbWF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBfUXVlcnlXaXRoUmVhZDtcbn0oKSk7XG5mdW5jdGlvbiBfY29udmVydFZhbHVlVG9PdXRwdXRBc3QodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbF8yLnZpc2l0VmFsdWUodmFsdWUsIG5ldyBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcigpLCBudWxsKTtcbn1cbnZhciBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvLmxpdGVyYWxBcnIoYXJyLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHV0aWxfMi52aXNpdFZhbHVlKHZhbHVlLCBfdGhpcywgY29udGV4dCk7IH0pKTtcbiAgICB9O1xuICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChtYXAsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IGVudHJpZXMucHVzaChba2V5LCB1dGlsXzIudmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIGNvbnRleHQpXSk7IH0pO1xuICAgICAgICByZXR1cm4gby5saXRlcmFsTWFwKGVudHJpZXMpO1xuICAgIH07XG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiBvLmxpdGVyYWwodmFsdWUpOyB9O1xuICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gby5pbXBvcnRFeHByKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIG8uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5CYXNlRXhjZXB0aW9uKFwiSWxsZWdhbCBzdGF0ZTogRG9uJ3Qgbm93IGhvdyB0byBjb21waWxlIHZhbHVlIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXI7XG59KHV0aWxfMi5WYWx1ZVRyYW5zZm9ybWVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlX2VsZW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbyA9IHJlcXVpcmUoJy4uL291dHB1dC9vdXRwdXRfYXN0Jyk7XG52YXIgX0RlYnVnU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9EZWJ1Z1N0YXRlKG5vZGVJbmRleCwgc291cmNlQXN0KSB7XG4gICAgICAgIHRoaXMubm9kZUluZGV4ID0gbm9kZUluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZUFzdCA9IHNvdXJjZUFzdDtcbiAgICB9XG4gICAgcmV0dXJuIF9EZWJ1Z1N0YXRlO1xufSgpKTtcbnZhciBOVUxMX0RFQlVHX1NUQVRFID0gbmV3IF9EZWJ1Z1N0YXRlKG51bGwsIG51bGwpO1xudmFyIENvbXBpbGVNZXRob2QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVNZXRob2QoX3ZpZXcpIHtcbiAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICB0aGlzLl9uZXdTdGF0ZSA9IE5VTExfREVCVUdfU1RBVEU7XG4gICAgICAgIHRoaXMuX2N1cnJTdGF0ZSA9IE5VTExfREVCVUdfU1RBVEU7XG4gICAgICAgIHRoaXMuX2JvZHlTdGF0ZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuX2RlYnVnRW5hYmxlZCA9IHRoaXMuX3ZpZXcuZ2VuQ29uZmlnLmdlbkRlYnVnSW5mbztcbiAgICB9XG4gICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuX3VwZGF0ZURlYnVnQ29udGV4dElmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbmV3U3RhdGUubm9kZUluZGV4ICE9PSB0aGlzLl9jdXJyU3RhdGUubm9kZUluZGV4IHx8XG4gICAgICAgICAgICB0aGlzLl9uZXdTdGF0ZS5zb3VyY2VBc3QgIT09IHRoaXMuX2N1cnJTdGF0ZS5zb3VyY2VBc3QpIHtcbiAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5fdXBkYXRlRGVidWdDb250ZXh0KHRoaXMuX25ld1N0YXRlKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keVN0YXRlbWVudHMucHVzaChleHByLnRvU3RtdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuX3VwZGF0ZURlYnVnQ29udGV4dCA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9jdXJyU3RhdGUgPSB0aGlzLl9uZXdTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBpZiAodGhpcy5fZGVidWdFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlTG9jYXRpb24gPSBsYW5nXzEuaXNQcmVzZW50KG5ld1N0YXRlLnNvdXJjZUFzdCkgPyBuZXdTdGF0ZS5zb3VyY2VBc3Quc291cmNlU3Bhbi5zdGFydCA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gby5USElTX0VYUFIuY2FsbE1ldGhvZCgnZGVidWcnLCBbXG4gICAgICAgICAgICAgICAgby5saXRlcmFsKG5ld1N0YXRlLm5vZGVJbmRleCksXG4gICAgICAgICAgICAgICAgbGFuZ18xLmlzUHJlc2VudChzb3VyY2VMb2NhdGlvbikgPyBvLmxpdGVyYWwoc291cmNlTG9jYXRpb24ubGluZSkgOiBvLk5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBsYW5nXzEuaXNQcmVzZW50KHNvdXJjZUxvY2F0aW9uKSA/IG8ubGl0ZXJhbChzb3VyY2VMb2NhdGlvbi5jb2wpIDogby5OVUxMX0VYUFJcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLnJlc2V0RGVidWdJbmZvRXhwciA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIHRlbXBsYXRlQXN0KSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHQobmV3IF9EZWJ1Z1N0YXRlKG5vZGVJbmRleCwgdGVtcGxhdGVBc3QpKTtcbiAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQocmVzKSA/IHJlcyA6IG8uTlVMTF9FWFBSO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUucmVzZXREZWJ1Z0luZm8gPSBmdW5jdGlvbiAobm9kZUluZGV4LCB0ZW1wbGF0ZUFzdCkge1xuICAgICAgICB0aGlzLl9uZXdTdGF0ZSA9IG5ldyBfRGVidWdTdGF0ZShub2RlSW5kZXgsIHRlbXBsYXRlQXN0KTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLmFkZFN0bXQgPSBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHRJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl9ib2R5U3RhdGVtZW50cy5wdXNoKHN0bXQpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuYWRkU3RtdHMgPSBmdW5jdGlvbiAoc3RtdHMpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGVidWdDb250ZXh0SWZOZWVkZWQoKTtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmFkZEFsbCh0aGlzLl9ib2R5U3RhdGVtZW50cywgc3RtdHMpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYm9keVN0YXRlbWVudHM7IH07XG4gICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2JvZHlTdGF0ZW1lbnRzLmxlbmd0aCA9PT0gMDsgfTtcbiAgICByZXR1cm4gQ29tcGlsZU1ldGhvZDtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVNZXRob2QgPSBDb21waWxlTWV0aG9kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZV9tZXRob2QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIG8gPSByZXF1aXJlKCcuLi9vdXRwdXQvb3V0cHV0X2FzdCcpO1xudmFyIGlkZW50aWZpZXJzXzEgPSByZXF1aXJlKCcuLi9pZGVudGlmaWVycycpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIF9QdXJlUGlwZVByb3h5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfUHVyZVBpcGVQcm94eSh2aWV3LCBpbnN0YW5jZSwgYXJnQ291bnQpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB0aGlzLmFyZ0NvdW50ID0gYXJnQ291bnQ7XG4gICAgfVxuICAgIHJldHVybiBfUHVyZVBpcGVQcm94eTtcbn0oKSk7XG52YXIgQ29tcGlsZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVQaXBlKHZpZXcsIG1ldGEpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgICAgdGhpcy5fcHVyZVBpcGVQcm94aWVzID0gW107XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBvLlRISVNfRVhQUi5wcm9wKFwiX3BpcGVfXCIgKyBtZXRhLm5hbWUgKyBcIl9cIiArIHZpZXcucGlwZUNvdW50KyspO1xuICAgIH1cbiAgICBDb21waWxlUGlwZS5jYWxsID0gZnVuY3Rpb24gKHZpZXcsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNvbXBWaWV3ID0gdmlldy5jb21wb25lbnRWaWV3O1xuICAgICAgICB2YXIgbWV0YSA9IF9maW5kUGlwZU1ldGEoY29tcFZpZXcsIG5hbWUpO1xuICAgICAgICB2YXIgcGlwZTtcbiAgICAgICAgaWYgKG1ldGEucHVyZSkge1xuICAgICAgICAgICAgLy8gcHVyZSBwaXBlcyBsaXZlIG9uIHRoZSBjb21wb25lbnQgdmlld1xuICAgICAgICAgICAgcGlwZSA9IGNvbXBWaWV3LnB1cmVQaXBlcy5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocGlwZSkpIHtcbiAgICAgICAgICAgICAgICBwaXBlID0gbmV3IENvbXBpbGVQaXBlKGNvbXBWaWV3LCBtZXRhKTtcbiAgICAgICAgICAgICAgICBjb21wVmlldy5wdXJlUGlwZXMuc2V0KG5hbWUsIHBpcGUpO1xuICAgICAgICAgICAgICAgIGNvbXBWaWV3LnBpcGVzLnB1c2gocGlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb24gcHVyZSBwaXBlcyBsaXZlIG9uIHRoZSB2aWV3IHRoYXQgY2FsbGVkIGl0XG4gICAgICAgICAgICBwaXBlID0gbmV3IENvbXBpbGVQaXBlKHZpZXcsIG1ldGEpO1xuICAgICAgICAgICAgdmlldy5waXBlcy5wdXNoKHBpcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlLl9jYWxsKHZpZXcsIGFyZ3MpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVQaXBlLnByb3RvdHlwZSwgXCJwdXJlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1ldGEucHVyZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29tcGlsZVBpcGUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRlcHMgPSB0aGlzLm1ldGEudHlwZS5kaURlcHMubWFwKGZ1bmN0aW9uIChkaURlcCkge1xuICAgICAgICAgICAgaWYgKGRpRGVwLnRva2VuLmVxdWFsc1RvKGlkZW50aWZpZXJzXzEuaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZ2V0UHJvcGVydHlJblZpZXcoby5USElTX0VYUFIucHJvcCgncmVmJyksIF90aGlzLnZpZXcsIF90aGlzLnZpZXcuY29tcG9uZW50Vmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IoZGlEZXAudG9rZW4sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgby5DbGFzc0ZpZWxkKHRoaXMuaW5zdGFuY2UubmFtZSwgby5pbXBvcnRUeXBlKHRoaXMubWV0YS50eXBlKSkpO1xuICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvKG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoby5USElTX0VYUFIucHJvcCh0aGlzLmluc3RhbmNlLm5hbWUpXG4gICAgICAgICAgICAuc2V0KG8uaW1wb3J0RXhwcih0aGlzLm1ldGEudHlwZSkuaW5zdGFudGlhdGUoZGVwcykpXG4gICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICB0aGlzLl9wdXJlUGlwZVByb3hpZXMuZm9yRWFjaChmdW5jdGlvbiAocHVyZVBpcGVQcm94eSkge1xuICAgICAgICAgICAgdmFyIHBpcGVJbnN0YW5jZVNlZW5Gcm9tUHVyZVByb3h5ID0gdXRpbF8xLmdldFByb3BlcnR5SW5WaWV3KF90aGlzLmluc3RhbmNlLCBwdXJlUGlwZVByb3h5LnZpZXcsIF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgdXRpbF8xLmNyZWF0ZVB1cmVQcm94eShwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eS5wcm9wKCd0cmFuc2Zvcm0nKVxuICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKG8uQnVpbHRpbk1ldGhvZC5iaW5kLCBbcGlwZUluc3RhbmNlU2VlbkZyb21QdXJlUHJveHldKSwgcHVyZVBpcGVQcm94eS5hcmdDb3VudCwgcHVyZVBpcGVQcm94eS5pbnN0YW5jZSwgcHVyZVBpcGVQcm94eS52aWV3KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21waWxlUGlwZS5wcm90b3R5cGUuX2NhbGwgPSBmdW5jdGlvbiAoY2FsbGluZ1ZpZXcsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWV0YS5wdXJlKSB7XG4gICAgICAgICAgICAvLyBQdXJlUGlwZVByb3hpZXMgbGl2ZSBvbiB0aGUgdmlldyB0aGF0IGNhbGxlZCB0aGVtLlxuICAgICAgICAgICAgdmFyIHB1cmVQaXBlUHJveHkgPSBuZXcgX1B1cmVQaXBlUHJveHkoY2FsbGluZ1ZpZXcsIG8uVEhJU19FWFBSLnByb3AodGhpcy5pbnN0YW5jZS5uYW1lICsgXCJfXCIgKyB0aGlzLl9wdXJlUGlwZVByb3hpZXMubGVuZ3RoKSwgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5fcHVyZVBpcGVQcm94aWVzLnB1c2gocHVyZVBpcGVQcm94eSk7XG4gICAgICAgICAgICByZXR1cm4gby5pbXBvcnRFeHByKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuY2FzdEJ5VmFsdWUpXG4gICAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgcHVyZVBpcGVQcm94eS5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICB1dGlsXzEuZ2V0UHJvcGVydHlJblZpZXcodGhpcy5pbnN0YW5jZS5wcm9wKCd0cmFuc2Zvcm0nKSwgY2FsbGluZ1ZpZXcsIHRoaXMudmlldylcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLmNhbGxGbihhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZ2V0UHJvcGVydHlJblZpZXcodGhpcy5pbnN0YW5jZSwgY2FsbGluZ1ZpZXcsIHRoaXMudmlldykuY2FsbE1ldGhvZCgndHJhbnNmb3JtJywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlUGlwZTtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVQaXBlID0gQ29tcGlsZVBpcGU7XG5mdW5jdGlvbiBfZmluZFBpcGVNZXRhKHZpZXcsIG5hbWUpIHtcbiAgICB2YXIgcGlwZU1ldGEgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSB2aWV3LnBpcGVNZXRhcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbG9jYWxQaXBlTWV0YSA9IHZpZXcucGlwZU1ldGFzW2ldO1xuICAgICAgICBpZiAobG9jYWxQaXBlTWV0YS5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgIHBpcGVNZXRhID0gbG9jYWxQaXBlTWV0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChsYW5nXzEuaXNCbGFuayhwaXBlTWV0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiSWxsZWdhbCBzdGF0ZTogQ291bGQgbm90IGZpbmQgcGlwZSBcIiArIG5hbWUgKyBcIiBhbHRob3VnaCB0aGUgcGFyc2VyIHNob3VsZCBoYXZlIGRldGVjdGVkIHRoaXMgZXJyb3IhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZU1ldGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlX3BpcGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbyA9IHJlcXVpcmUoJy4uL291dHB1dC9vdXRwdXRfYXN0Jyk7XG52YXIgaWRlbnRpZmllcnNfMSA9IHJlcXVpcmUoJy4uL2lkZW50aWZpZXJzJyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgVmlld1F1ZXJ5VmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3UXVlcnlWYWx1ZXModmlldywgdmFsdWVzKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gVmlld1F1ZXJ5VmFsdWVzO1xufSgpKTtcbnZhciBDb21waWxlUXVlcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVRdWVyeShtZXRhLCBxdWVyeUxpc3QsIG93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbiwgdmlldykge1xuICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICB0aGlzLnF1ZXJ5TGlzdCA9IHF1ZXJ5TGlzdDtcbiAgICAgICAgdGhpcy5vd25lckRpcmVjdGl2ZUV4cHJlc3Npb24gPSBvd25lckRpcmVjdGl2ZUV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBWaWV3UXVlcnlWYWx1ZXModmlldywgW10pO1xuICAgIH1cbiAgICBDb21waWxlUXVlcnkucHJvdG90eXBlLmFkZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCB2aWV3KSB7XG4gICAgICAgIHZhciBjdXJyZW50VmlldyA9IHZpZXc7XG4gICAgICAgIHZhciBlbFBhdGggPSBbXTtcbiAgICAgICAgd2hpbGUgKGxhbmdfMS5pc1ByZXNlbnQoY3VycmVudFZpZXcpICYmIGN1cnJlbnRWaWV3ICE9PSB0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRFbCA9IGN1cnJlbnRWaWV3LmRlY2xhcmF0aW9uRWxlbWVudDtcbiAgICAgICAgICAgIGVsUGF0aC51bnNoaWZ0KHBhcmVudEVsKTtcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3ID0gcGFyZW50RWwudmlldztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcnlMaXN0Rm9yRGlydHlFeHByID0gdXRpbF8xLmdldFByb3BlcnR5SW5WaWV3KHRoaXMucXVlcnlMaXN0LCB2aWV3LCB0aGlzLnZpZXcpO1xuICAgICAgICB2YXIgdmlld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICAgICAgZWxQYXRoLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHZpZXdWYWx1ZXMudmFsdWVzLmxlbmd0aCA+IDAgPyB2aWV3VmFsdWVzLnZhbHVlc1t2aWV3VmFsdWVzLnZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIFZpZXdRdWVyeVZhbHVlcyAmJiBsYXN0LnZpZXcgPT09IGVsLmVtYmVkZGVkVmlldykge1xuICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMgPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZpZXdWYWx1ZXMgPSBuZXcgVmlld1F1ZXJ5VmFsdWVzKGVsLmVtYmVkZGVkVmlldywgW10pO1xuICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMudmFsdWVzLnB1c2gobmV3Vmlld1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgdmlld1ZhbHVlcyA9IG5ld1ZpZXdWYWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3VmFsdWVzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKGVsUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2aWV3LmRpcnR5UGFyZW50UXVlcmllc01ldGhvZC5hZGRTdG10KHF1ZXJ5TGlzdEZvckRpcnR5RXhwci5jYWxsTWV0aG9kKCdzZXREaXJ0eScsIFtdKS50b1N0bXQoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVRdWVyeS5wcm90b3R5cGUuYWZ0ZXJDaGlsZHJlbiA9IGZ1bmN0aW9uICh0YXJnZXRNZXRob2QpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGNyZWF0ZVF1ZXJ5VmFsdWVzKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHZhciB1cGRhdGVTdG10cyA9IFt0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdyZXNldCcsIFtvLmxpdGVyYWxBcnIodmFsdWVzKV0pLnRvU3RtdCgpXTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5vd25lckRpcmVjdGl2ZUV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVFeHByID0gdGhpcy5tZXRhLmZpcnN0ID8gdGhpcy5xdWVyeUxpc3QucHJvcCgnZmlyc3QnKSA6IHRoaXMucXVlcnlMaXN0O1xuICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbi5wcm9wKHRoaXMubWV0YS5wcm9wZXJ0eU5hbWUpLnNldCh2YWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWV0YS5maXJzdCkge1xuICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdub3RpZnlPbkNoYW5nZXMnLCBbXSkudG9TdG10KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldE1ldGhvZC5hZGRTdG10KG5ldyBvLklmU3RtdCh0aGlzLnF1ZXJ5TGlzdC5wcm9wKCdkaXJ0eScpLCB1cGRhdGVTdG10cykpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVRdWVyeTtcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVRdWVyeSA9IENvbXBpbGVRdWVyeTtcbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5VmFsdWVzKHZpZXdWYWx1ZXMpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZsYXR0ZW4odmlld1ZhbHVlcy52YWx1ZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBOZXN0ZWRWaWV3cyhlbnRyeS52aWV3LmRlY2xhcmF0aW9uRWxlbWVudC5hcHBFbGVtZW50LCBlbnRyeS52aWV3LCBjcmVhdGVRdWVyeVZhbHVlcyhlbnRyeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gbWFwTmVzdGVkVmlld3MoZGVjbGFyYXRpb25BcHBFbGVtZW50LCB2aWV3LCBleHByZXNzaW9ucykge1xuICAgIHZhciBhZGp1c3RlZEV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgIHJldHVybiBvLnJlcGxhY2VWYXJJbkV4cHJlc3Npb24oby5USElTX0VYUFIubmFtZSwgby52YXJpYWJsZSgnbmVzdGVkVmlldycpLCBleHByKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVjbGFyYXRpb25BcHBFbGVtZW50LmNhbGxNZXRob2QoJ21hcE5lc3RlZFZpZXdzJywgW1xuICAgICAgICBvLnZhcmlhYmxlKHZpZXcuY2xhc3NOYW1lKSxcbiAgICAgICAgby5mbihbbmV3IG8uRm5QYXJhbSgnbmVzdGVkVmlldycsIHZpZXcuY2xhc3NUeXBlKV0sIFtuZXcgby5SZXR1cm5TdGF0ZW1lbnQoby5saXRlcmFsQXJyKGFkanVzdGVkRXhwcmVzc2lvbnMpKV0pXG4gICAgXSk7XG59XG5mdW5jdGlvbiBjcmVhdGVRdWVyeUxpc3QocXVlcnksIGRpcmVjdGl2ZUluc3RhbmNlLCBwcm9wZXJ0eU5hbWUsIGNvbXBpbGVWaWV3KSB7XG4gICAgY29tcGlsZVZpZXcuZmllbGRzLnB1c2gobmV3IG8uQ2xhc3NGaWVsZChwcm9wZXJ0eU5hbWUsIG8uaW1wb3J0VHlwZShpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLlF1ZXJ5TGlzdCkpKTtcbiAgICB2YXIgZXhwciA9IG8uVEhJU19FWFBSLnByb3AocHJvcGVydHlOYW1lKTtcbiAgICBjb21waWxlVmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChvLlRISVNfRVhQUi5wcm9wKHByb3BlcnR5TmFtZSlcbiAgICAgICAgLnNldChvLmltcG9ydEV4cHIoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5RdWVyeUxpc3QpLmluc3RhbnRpYXRlKFtdKSlcbiAgICAgICAgLnRvU3RtdCgpKTtcbiAgICByZXR1cm4gZXhwcjtcbn1cbmV4cG9ydHMuY3JlYXRlUXVlcnlMaXN0ID0gY3JlYXRlUXVlcnlMaXN0O1xuZnVuY3Rpb24gYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICBxdWVyeS5tZXRhLnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGVudHJ5KSkge1xuICAgICAgICAgICAgZW50cnkgPSBbXTtcbiAgICAgICAgICAgIG1hcC5hZGQoc2VsZWN0b3IsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5wdXNoKHF1ZXJ5KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWRkUXVlcnlUb1Rva2VuTWFwID0gYWRkUXVlcnlUb1Rva2VuTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZV9xdWVyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uLy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIG8gPSByZXF1aXJlKCcuLi9vdXRwdXQvb3V0cHV0X2FzdCcpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBjb21waWxlX3F1ZXJ5XzEgPSByZXF1aXJlKCcuL2NvbXBpbGVfcXVlcnknKTtcbnZhciBjb21waWxlX21ldGhvZF8xID0gcmVxdWlyZSgnLi9jb21waWxlX21ldGhvZCcpO1xudmFyIGNvbXBpbGVfcGlwZV8xID0gcmVxdWlyZSgnLi9jb21waWxlX3BpcGUnKTtcbnZhciBjb21waWxlX21ldGFkYXRhXzEgPSByZXF1aXJlKCcuLi9jb21waWxlX21ldGFkYXRhJyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaWRlbnRpZmllcnNfMSA9IHJlcXVpcmUoJy4uL2lkZW50aWZpZXJzJyk7XG52YXIgQ29tcGlsZVZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVWaWV3KGNvbXBvbmVudCwgZ2VuQ29uZmlnLCBwaXBlTWV0YXMsIHN0eWxlcywgdmlld0luZGV4LCBkZWNsYXJhdGlvbkVsZW1lbnQsIHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5nZW5Db25maWcgPSBnZW5Db25maWc7XG4gICAgICAgIHRoaXMucGlwZU1ldGFzID0gcGlwZU1ldGFzO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy52aWV3SW5kZXggPSB2aWV3SW5kZXg7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25FbGVtZW50ID0gZGVjbGFyYXRpb25FbGVtZW50O1xuICAgICAgICB0aGlzLnRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncyA9IHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncztcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICAvLyByb290IG5vZGVzIG9yIEFwcEVsZW1lbnRzIGZvciBWaWV3Q29udGFpbmVyc1xuICAgICAgICB0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLmNsYXNzU3RhdGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1ldGhvZHMgPSBbXTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMucHVyZVBpcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBpcGVzID0gW107XG4gICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpdGVyYWxBcnJheUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5saXRlcmFsTWFwQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnBpcGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY3JlYXRlTWV0aG9kID0gbmV3IGNvbXBpbGVfbWV0aG9kXzEuQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbmplY3RvckdldE1ldGhvZCA9IG5ldyBjb21waWxlX21ldGhvZF8xLkNvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QgPSBuZXcgY29tcGlsZV9tZXRob2RfMS5Db21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc01ldGhvZCA9IG5ldyBjb21waWxlX21ldGhvZF8xLkNvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QgPSBuZXcgY29tcGlsZV9tZXRob2RfMS5Db21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICB0aGlzLmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IG5ldyBjb21waWxlX21ldGhvZF8xLkNvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QgPSBuZXcgY29tcGlsZV9tZXRob2RfMS5Db21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICB0aGlzLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZCA9IG5ldyBjb21waWxlX21ldGhvZF8xLkNvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgIHRoaXMuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gbmV3IGNvbXBpbGVfbWV0aG9kXzEuQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95TWV0aG9kID0gbmV3IGNvbXBpbGVfbWV0aG9kXzEuQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgdGhpcy52aWV3VHlwZSA9IGdldFZpZXdUeXBlKGNvbXBvbmVudCwgdmlld0luZGV4KTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIl9WaWV3X1wiICsgY29tcG9uZW50LnR5cGUubmFtZSArIHZpZXdJbmRleDtcbiAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBvLmltcG9ydFR5cGUobmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogdGhpcy5jbGFzc05hbWUgfSkpO1xuICAgICAgICB0aGlzLnZpZXdGYWN0b3J5ID0gby52YXJpYWJsZSh1dGlsXzEuZ2V0Vmlld0ZhY3RvcnlOYW1lKGNvbXBvbmVudCwgdmlld0luZGV4KSk7XG4gICAgICAgIGlmICh0aGlzLnZpZXdUeXBlID09PSBjb3JlX3ByaXZhdGVfMS5WaWV3VHlwZS5DT01QT05FTlQgfHwgdGhpcy52aWV3VHlwZSA9PT0gY29yZV9wcml2YXRlXzEuVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRWaWV3ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IHRoaXMuZGVjbGFyYXRpb25FbGVtZW50LnZpZXcuY29tcG9uZW50VmlldztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRleHQgPVxuICAgICAgICAgICAgdXRpbF8xLmdldFByb3BlcnR5SW5WaWV3KG8uVEhJU19FWFBSLnByb3AoJ2NvbnRleHQnKSwgdGhpcywgdGhpcy5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgdmFyIHZpZXdRdWVyaWVzID0gbmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlVG9rZW5NYXAoKTtcbiAgICAgICAgaWYgKHRoaXMudmlld1R5cGUgPT09IGNvcmVfcHJpdmF0ZV8xLlZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gby5USElTX0VYUFIucHJvcCgnY29udGV4dCcpO1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgodGhpcy5jb21wb25lbnQudmlld1F1ZXJpZXMsIGZ1bmN0aW9uIChxdWVyeU1ldGEsIHF1ZXJ5SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBcIl92aWV3UXVlcnlfXCIgKyBxdWVyeU1ldGEuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHF1ZXJ5SW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5TGlzdCA9IGNvbXBpbGVfcXVlcnlfMS5jcmVhdGVRdWVyeUxpc3QocXVlcnlNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgcHJvcE5hbWUsIF90aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgY29tcGlsZV9xdWVyeV8xLkNvbXBpbGVRdWVyeShxdWVyeU1ldGEsIHF1ZXJ5TGlzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIF90aGlzKTtcbiAgICAgICAgICAgICAgICBjb21waWxlX3F1ZXJ5XzEuYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCBxdWVyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvclZpZXdRdWVyeUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnR5cGUuZGlEZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRlcC52aWV3UXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeUxpc3QgPSBvLlRISVNfRVhQUi5wcm9wKCdkZWNsYXJhdGlvbkFwcEVsZW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2NvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmtleShvLmxpdGVyYWwoY29uc3RydWN0b3JWaWV3UXVlcnlDb3VudCsrKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IG5ldyBjb21waWxlX3F1ZXJ5XzEuQ29tcGlsZVF1ZXJ5KGRlcC52aWV3UXVlcnksIHF1ZXJ5TGlzdCwgbnVsbCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlX3F1ZXJ5XzEuYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IHZpZXdRdWVyaWVzO1xuICAgICAgICB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgX3RoaXMubG9jYWxzLnNldChlbnRyeVsxXSwgby5USElTX0VYUFIucHJvcCgnY29udGV4dCcpLnByb3AoZW50cnlbMF0pKTsgfSk7XG4gICAgICAgIGlmICghdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQuaXNOdWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25FbGVtZW50LnNldEVtYmVkZGVkVmlldyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21waWxlVmlldy5wcm90b3R5cGUuY2FsbFBpcGUgPSBmdW5jdGlvbiAobmFtZSwgaW5wdXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVfcGlwZV8xLkNvbXBpbGVQaXBlLmNhbGwodGhpcywgbmFtZSwgW2lucHV0XS5jb25jYXQoYXJncykpO1xuICAgIH07XG4gICAgQ29tcGlsZVZpZXcucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gY29uc3RhbnRzXzEuRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyclZpZXcgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VyclZpZXcubG9jYWxzLmdldChuYW1lKTtcbiAgICAgICAgd2hpbGUgKGxhbmdfMS5pc0JsYW5rKHJlc3VsdCkgJiYgbGFuZ18xLmlzUHJlc2VudChjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldykpIHtcbiAgICAgICAgICAgIGN1cnJWaWV3ID0gY3VyclZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnZpZXc7XG4gICAgICAgICAgICByZXN1bHQgPSBjdXJyVmlldy5sb2NhbHMuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZ2V0UHJvcGVydHlJblZpZXcocmVzdWx0LCB0aGlzLCBjdXJyVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZVZpZXcucHJvdG90eXBlLmNyZWF0ZUxpdGVyYWxBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvLmltcG9ydEV4cHIoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5FTVBUWV9BUlJBWSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3h5RXhwciA9IG8uVEhJU19FWFBSLnByb3AoXCJfYXJyX1wiICsgdGhpcy5saXRlcmFsQXJyYXlDb3VudCsrKTtcbiAgICAgICAgdmFyIHByb3h5UGFyYW1zID0gW107XG4gICAgICAgIHZhciBwcm94eVJldHVybkVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBcInBcIiArIGk7XG4gICAgICAgICAgICBwcm94eVBhcmFtcy5wdXNoKG5ldyBvLkZuUGFyYW0ocGFyYW1OYW1lKSk7XG4gICAgICAgICAgICBwcm94eVJldHVybkVudHJpZXMucHVzaChvLnZhcmlhYmxlKHBhcmFtTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxfMS5jcmVhdGVQdXJlUHJveHkoby5mbihwcm94eVBhcmFtcywgW25ldyBvLlJldHVyblN0YXRlbWVudChvLmxpdGVyYWxBcnIocHJveHlSZXR1cm5FbnRyaWVzKSldKSwgdmFsdWVzLmxlbmd0aCwgcHJveHlFeHByLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHByb3h5RXhwci5jYWxsRm4odmFsdWVzKTtcbiAgICB9O1xuICAgIENvbXBpbGVWaWV3LnByb3RvdHlwZS5jcmVhdGVMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gby5pbXBvcnRFeHByKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuRU1QVFlfTUFQKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJveHlFeHByID0gby5USElTX0VYUFIucHJvcChcIl9tYXBfXCIgKyB0aGlzLmxpdGVyYWxNYXBDb3VudCsrKTtcbiAgICAgICAgdmFyIHByb3h5UGFyYW1zID0gW107XG4gICAgICAgIHZhciBwcm94eVJldHVybkVudHJpZXMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBcInBcIiArIGk7XG4gICAgICAgICAgICBwcm94eVBhcmFtcy5wdXNoKG5ldyBvLkZuUGFyYW0ocGFyYW1OYW1lKSk7XG4gICAgICAgICAgICBwcm94eVJldHVybkVudHJpZXMucHVzaChbZW50cmllc1tpXVswXSwgby52YXJpYWJsZShwYXJhbU5hbWUpXSk7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChlbnRyaWVzW2ldWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsXzEuY3JlYXRlUHVyZVByb3h5KG8uZm4ocHJveHlQYXJhbXMsIFtuZXcgby5SZXR1cm5TdGF0ZW1lbnQoby5saXRlcmFsTWFwKHByb3h5UmV0dXJuRW50cmllcykpXSksIGVudHJpZXMubGVuZ3RoLCBwcm94eUV4cHIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gcHJveHlFeHByLmNhbGxGbih2YWx1ZXMpO1xuICAgIH07XG4gICAgQ29tcGlsZVZpZXcucHJvdG90eXBlLmFmdGVyTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gcGlwZS5jcmVhdGUoKTsgfSk7XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMudmFsdWVzKCkuZm9yRWFjaChmdW5jdGlvbiAocXVlcmllcykgeyByZXR1cm4gcXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkuYWZ0ZXJDaGlsZHJlbihfdGhpcy51cGRhdGVWaWV3UXVlcmllc01ldGhvZCk7IH0pOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlVmlldztcbn0oKSk7XG5leHBvcnRzLkNvbXBpbGVWaWV3ID0gQ29tcGlsZVZpZXc7XG5mdW5jdGlvbiBnZXRWaWV3VHlwZShjb21wb25lbnQsIGVtYmVkZGVkVGVtcGxhdGVJbmRleCkge1xuICAgIGlmIChlbWJlZGRlZFRlbXBsYXRlSW5kZXggPiAwKSB7XG4gICAgICAgIHJldHVybiBjb3JlX3ByaXZhdGVfMS5WaWV3VHlwZS5FTUJFRERFRDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29tcG9uZW50LnR5cGUuaXNIb3N0KSB7XG4gICAgICAgIHJldHVybiBjb3JlX3ByaXZhdGVfMS5WaWV3VHlwZS5IT1NUO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvcmVfcHJpdmF0ZV8xLlZpZXdUeXBlLkNPTVBPTkVOVDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlX3ZpZXcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvcmVfcHJpdmF0ZV8xID0gcmVxdWlyZSgnLi4vLi4vY29yZV9wcml2YXRlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29tcGlsZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi4vY29tcGlsZV9tZXRhZGF0YScpO1xudmFyIG8gPSByZXF1aXJlKCcuLi9vdXRwdXQvb3V0cHV0X2FzdCcpO1xudmFyIGlkZW50aWZpZXJzXzEgPSByZXF1aXJlKCcuLi9pZGVudGlmaWVycycpO1xuZnVuY3Rpb24gX2VudW1FeHByZXNzaW9uKGNsYXNzSWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsodmFsdWUpKVxuICAgICAgICByZXR1cm4gby5OVUxMX0VYUFI7XG4gICAgdmFyIG5hbWUgPSBsYW5nXzEucmVzb2x2ZUVudW1Ub2tlbihjbGFzc0lkZW50aWZpZXIucnVudGltZSwgdmFsdWUpO1xuICAgIHJldHVybiBvLmltcG9ydEV4cHIobmV3IGNvbXBpbGVfbWV0YWRhdGFfMS5Db21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgbmFtZTogY2xhc3NJZGVudGlmaWVyLm5hbWUgKyBcIi5cIiArIG5hbWUsXG4gICAgICAgIG1vZHVsZVVybDogY2xhc3NJZGVudGlmaWVyLm1vZHVsZVVybCxcbiAgICAgICAgcnVudGltZTogdmFsdWVcbiAgICB9KSk7XG59XG52YXIgVmlld1R5cGVFbnVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3VHlwZUVudW0oKSB7XG4gICAgfVxuICAgIFZpZXdUeXBlRW51bS5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLlZpZXdUeXBlLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBWaWV3VHlwZUVudW0uSE9TVCA9IFZpZXdUeXBlRW51bS5mcm9tVmFsdWUoY29yZV9wcml2YXRlXzEuVmlld1R5cGUuSE9TVCk7XG4gICAgVmlld1R5cGVFbnVtLkNPTVBPTkVOVCA9IFZpZXdUeXBlRW51bS5mcm9tVmFsdWUoY29yZV9wcml2YXRlXzEuVmlld1R5cGUuQ09NUE9ORU5UKTtcbiAgICBWaWV3VHlwZUVudW0uRU1CRURERUQgPSBWaWV3VHlwZUVudW0uZnJvbVZhbHVlKGNvcmVfcHJpdmF0ZV8xLlZpZXdUeXBlLkVNQkVEREVEKTtcbiAgICByZXR1cm4gVmlld1R5cGVFbnVtO1xufSgpKTtcbmV4cG9ydHMuVmlld1R5cGVFbnVtID0gVmlld1R5cGVFbnVtO1xudmFyIFZpZXdFbmNhcHN1bGF0aW9uRW51bSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0VuY2Fwc3VsYXRpb25FbnVtKCkge1xuICAgIH1cbiAgICBWaWV3RW5jYXBzdWxhdGlvbkVudW0uZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfZW51bUV4cHJlc3Npb24oaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5WaWV3RW5jYXBzdWxhdGlvbiwgdmFsdWUpO1xuICAgIH07XG4gICAgVmlld0VuY2Fwc3VsYXRpb25FbnVtLkVtdWxhdGVkID0gVmlld0VuY2Fwc3VsYXRpb25FbnVtLmZyb21WYWx1ZShjb3JlXzEuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpO1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uRW51bS5OYXRpdmUgPSBWaWV3RW5jYXBzdWxhdGlvbkVudW0uZnJvbVZhbHVlKGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUpO1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uRW51bS5Ob25lID0gVmlld0VuY2Fwc3VsYXRpb25FbnVtLmZyb21WYWx1ZShjb3JlXzEuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSk7XG4gICAgcmV0dXJuIFZpZXdFbmNhcHN1bGF0aW9uRW51bTtcbn0oKSk7XG5leHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uRW51bSA9IFZpZXdFbmNhcHN1bGF0aW9uRW51bTtcbnZhciBDaGFuZ2VEZXRlY3RvclN0YXRlRW51bSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0b3JTdGF0ZUVudW0oKSB7XG4gICAgfVxuICAgIENoYW5nZURldGVjdG9yU3RhdGVFbnVtLmZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JTdGF0ZSwgdmFsdWUpO1xuICAgIH07XG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0ZUVudW0uTmV2ZXJDaGVja2VkID0gQ2hhbmdlRGV0ZWN0b3JTdGF0ZUVudW0uZnJvbVZhbHVlKGNvcmVfcHJpdmF0ZV8xLkNoYW5nZURldGVjdG9yU3RhdGUuTmV2ZXJDaGVja2VkKTtcbiAgICBDaGFuZ2VEZXRlY3RvclN0YXRlRW51bS5DaGVja2VkQmVmb3JlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0ZUVudW0uZnJvbVZhbHVlKGNvcmVfcHJpdmF0ZV8xLkNoYW5nZURldGVjdG9yU3RhdGUuQ2hlY2tlZEJlZm9yZSk7XG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0ZUVudW0uRXJyb3JlZCA9IENoYW5nZURldGVjdG9yU3RhdGVFbnVtLmZyb21WYWx1ZShjb3JlX3ByaXZhdGVfMS5DaGFuZ2VEZXRlY3RvclN0YXRlLkVycm9yZWQpO1xuICAgIHJldHVybiBDaGFuZ2VEZXRlY3RvclN0YXRlRW51bTtcbn0oKSk7XG5leHBvcnRzLkNoYW5nZURldGVjdG9yU3RhdGVFbnVtID0gQ2hhbmdlRGV0ZWN0b3JTdGF0ZUVudW07XG52YXIgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneUVudW0oKSB7XG4gICAgfVxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5RW51bS5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneUVudW0uQ2hlY2tPbmNlID0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtLmZyb21WYWx1ZShjb3JlXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tPbmNlKTtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneUVudW0uQ2hlY2tlZCA9IENoYW5nZURldGVjdGlvblN0cmF0ZWd5RW51bS5mcm9tVmFsdWUoY29yZV8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrZWQpO1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5RW51bS5DaGVja0Fsd2F5cyA9IENoYW5nZURldGVjdGlvblN0cmF0ZWd5RW51bS5mcm9tVmFsdWUoY29yZV8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzKTtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneUVudW0uRGV0YWNoZWQgPSBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneUVudW0uZnJvbVZhbHVlKGNvcmVfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZXRhY2hlZCk7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtLk9uUHVzaCA9IENoYW5nZURldGVjdGlvblN0cmF0ZWd5RW51bS5mcm9tVmFsdWUoY29yZV8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCk7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtLkRlZmF1bHQgPSBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneUVudW0uZnJvbVZhbHVlKGNvcmVfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0KTtcbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtO1xufSgpKTtcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtID0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtO1xudmFyIFZpZXdDb25zdHJ1Y3RvclZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdDb25zdHJ1Y3RvclZhcnMoKSB7XG4gICAgfVxuICAgIFZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzID0gby52YXJpYWJsZSgndmlld1V0aWxzJyk7XG4gICAgVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRJbmplY3RvciA9IG8udmFyaWFibGUoJ3BhcmVudEluamVjdG9yJyk7XG4gICAgVmlld0NvbnN0cnVjdG9yVmFycy5kZWNsYXJhdGlvbkVsID0gby52YXJpYWJsZSgnZGVjbGFyYXRpb25FbCcpO1xuICAgIHJldHVybiBWaWV3Q29uc3RydWN0b3JWYXJzO1xufSgpKTtcbmV4cG9ydHMuVmlld0NvbnN0cnVjdG9yVmFycyA9IFZpZXdDb25zdHJ1Y3RvclZhcnM7XG52YXIgVmlld1Byb3BlcnRpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdQcm9wZXJ0aWVzKCkge1xuICAgIH1cbiAgICBWaWV3UHJvcGVydGllcy5yZW5kZXJlciA9IG8uVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJyk7XG4gICAgVmlld1Byb3BlcnRpZXMucHJvamVjdGFibGVOb2RlcyA9IG8uVEhJU19FWFBSLnByb3AoJ3Byb2plY3RhYmxlTm9kZXMnKTtcbiAgICBWaWV3UHJvcGVydGllcy52aWV3VXRpbHMgPSBvLlRISVNfRVhQUi5wcm9wKCd2aWV3VXRpbHMnKTtcbiAgICByZXR1cm4gVmlld1Byb3BlcnRpZXM7XG59KCkpO1xuZXhwb3J0cy5WaWV3UHJvcGVydGllcyA9IFZpZXdQcm9wZXJ0aWVzO1xudmFyIEV2ZW50SGFuZGxlclZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlclZhcnMoKSB7XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQgPSBvLnZhcmlhYmxlKCckZXZlbnQnKTtcbiAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycztcbn0oKSk7XG5leHBvcnRzLkV2ZW50SGFuZGxlclZhcnMgPSBFdmVudEhhbmRsZXJWYXJzO1xudmFyIEluamVjdE1ldGhvZFZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluamVjdE1ldGhvZFZhcnMoKSB7XG4gICAgfVxuICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSBvLnZhcmlhYmxlKCd0b2tlbicpO1xuICAgIEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleCA9IG8udmFyaWFibGUoJ3JlcXVlc3ROb2RlSW5kZXgnKTtcbiAgICBJbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0ID0gby52YXJpYWJsZSgnbm90Rm91bmRSZXN1bHQnKTtcbiAgICByZXR1cm4gSW5qZWN0TWV0aG9kVmFycztcbn0oKSk7XG5leHBvcnRzLkluamVjdE1ldGhvZFZhcnMgPSBJbmplY3RNZXRob2RWYXJzO1xudmFyIERldGVjdENoYW5nZXNWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXRlY3RDaGFuZ2VzVmFycygpIHtcbiAgICB9XG4gICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSA9IG8udmFyaWFibGUoXCJ0aHJvd09uQ2hhbmdlXCIpO1xuICAgIERldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMgPSBvLnZhcmlhYmxlKFwiY2hhbmdlc1wiKTtcbiAgICBEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkID0gby52YXJpYWJsZShcImNoYW5nZWRcIik7XG4gICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyID0gby52YXJpYWJsZShcInZhbFVud3JhcHBlclwiKTtcbiAgICByZXR1cm4gRGV0ZWN0Q2hhbmdlc1ZhcnM7XG59KCkpO1xuZXhwb3J0cy5EZXRlY3RDaGFuZ2VzVmFycyA9IERldGVjdENoYW5nZXNWYXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBvID0gcmVxdWlyZSgnLi4vb3V0cHV0L291dHB1dF9hc3QnKTtcbnZhciBjb21waWxlX21ldGhvZF8xID0gcmVxdWlyZSgnLi9jb21waWxlX21ldGhvZCcpO1xudmFyIGV4cHJlc3Npb25fY29udmVydGVyXzEgPSByZXF1aXJlKCcuL2V4cHJlc3Npb25fY29udmVydGVyJyk7XG52YXIgY29tcGlsZV9iaW5kaW5nXzEgPSByZXF1aXJlKCcuL2NvbXBpbGVfYmluZGluZycpO1xudmFyIENvbXBpbGVFdmVudExpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlRXZlbnRMaXN0ZW5lcihjb21waWxlRWxlbWVudCwgZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgbGlzdGVuZXJJbmRleCkge1xuICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50ID0gY29tcGlsZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuX2hhc0NvbXBvbmVudEhvc3RMaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hY3Rpb25SZXN1bHRFeHBycyA9IFtdO1xuICAgICAgICB0aGlzLl9tZXRob2QgPSBuZXcgY29tcGlsZV9tZXRob2RfMS5Db21waWxlTWV0aG9kKGNvbXBpbGVFbGVtZW50LnZpZXcpO1xuICAgICAgICB0aGlzLl9tZXRob2ROYW1lID1cbiAgICAgICAgICAgIFwiX2hhbmRsZV9cIiArIHNhbnRpdGl6ZUV2ZW50TmFtZShldmVudE5hbWUpICsgXCJfXCIgKyBjb21waWxlRWxlbWVudC5ub2RlSW5kZXggKyBcIl9cIiArIGxpc3RlbmVySW5kZXg7XG4gICAgICAgIHRoaXMuX2V2ZW50UGFyYW0gPVxuICAgICAgICAgICAgbmV3IG8uRm5QYXJhbShjb25zdGFudHNfMS5FdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUsIG8uaW1wb3J0VHlwZSh0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlckV2ZW50KSk7XG4gICAgfVxuICAgIENvbXBpbGVFdmVudExpc3RlbmVyLmdldE9yQ3JlYXRlID0gZnVuY3Rpb24gKGNvbXBpbGVFbGVtZW50LCBldmVudFRhcmdldCwgZXZlbnROYW1lLCB0YXJnZXRFdmVudExpc3RlbmVycykge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0YXJnZXRFdmVudExpc3RlbmVycy5maW5kKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuZXZlbnRUYXJnZXQgPT0gZXZlbnRUYXJnZXQgJiZcbiAgICAgICAgICAgIGxpc3RlbmVyLmV2ZW50TmFtZSA9PSBldmVudE5hbWU7IH0pO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG5ldyBDb21waWxlRXZlbnRMaXN0ZW5lcihjb21waWxlRWxlbWVudCwgZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRhcmdldEV2ZW50TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIENvbXBpbGVFdmVudExpc3RlbmVyLnByb3RvdHlwZS5hZGRBY3Rpb24gPSBmdW5jdGlvbiAoaG9zdEV2ZW50LCBkaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRpcmVjdGl2ZSkgJiYgZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNDb21wb25lbnRIb3N0TGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21ldGhvZC5yZXNldERlYnVnSW5mbyh0aGlzLmNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgaG9zdEV2ZW50KTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBsYW5nXzEuaXNQcmVzZW50KGRpcmVjdGl2ZUluc3RhbmNlKSA/IGRpcmVjdGl2ZUluc3RhbmNlIDpcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5jb21wb25lbnRDb250ZXh0O1xuICAgICAgICB2YXIgYWN0aW9uU3RtdHMgPSBleHByZXNzaW9uX2NvbnZlcnRlcl8xLmNvbnZlcnRDZFN0YXRlbWVudFRvSXIodGhpcy5jb21waWxlRWxlbWVudC52aWV3LCBjb250ZXh0LCBob3N0RXZlbnQuaGFuZGxlcik7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBhY3Rpb25TdG10cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHZhciBsYXN0U3RhdGVtZW50ID0gYWN0aW9uU3RtdHNbbGFzdEluZGV4XTtcbiAgICAgICAgICAgIHZhciByZXR1cm5FeHByID0gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihsYXN0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIHZhciBwcmV2ZW50RGVmYXVsdFZhciA9IG8udmFyaWFibGUoXCJwZF9cIiArIHRoaXMuX2FjdGlvblJlc3VsdEV4cHJzLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25SZXN1bHRFeHBycy5wdXNoKHByZXZlbnREZWZhdWx0VmFyKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHJldHVybkV4cHIpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjYXN0IHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZCBjYWxsIHRvIGR5bmFtaWMsXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQgbWlnaHQgYmUgYSB2b2lkIG1ldGhvZCFcbiAgICAgICAgICAgICAgICBhY3Rpb25TdG10c1tsYXN0SW5kZXhdID1cbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIuc2V0KHJldHVybkV4cHIuY2FzdChvLkRZTkFNSUNfVFlQRSkubm90SWRlbnRpY2FsKG8ubGl0ZXJhbChmYWxzZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW28uU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWV0aG9kLmFkZFN0bXRzKGFjdGlvblN0bXRzKTtcbiAgICB9O1xuICAgIENvbXBpbGVFdmVudExpc3RlbmVyLnByb3RvdHlwZS5maW5pc2hNZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXJrUGF0aFRvUm9vdFN0YXJ0ID0gdGhpcy5faGFzQ29tcG9uZW50SG9zdExpc3RlbmVyID9cbiAgICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQuYXBwRWxlbWVudC5wcm9wKCdjb21wb25lbnRWaWV3JykgOlxuICAgICAgICAgICAgby5USElTX0VYUFI7XG4gICAgICAgIHZhciByZXN1bHRFeHByID0gby5saXRlcmFsKHRydWUpO1xuICAgICAgICB0aGlzLl9hY3Rpb25SZXN1bHRFeHBycy5mb3JFYWNoKGZ1bmN0aW9uIChleHByKSB7IHJlc3VsdEV4cHIgPSByZXN1bHRFeHByLmFuZChleHByKTsgfSk7XG4gICAgICAgIHZhciBzdG10cyA9IFttYXJrUGF0aFRvUm9vdFN0YXJ0LmNhbGxNZXRob2QoJ21hcmtQYXRoVG9Sb290QXNDaGVja09uY2UnLCBbXSkudG9TdG10KCldXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMuX21ldGhvZC5maW5pc2goKSlcbiAgICAgICAgICAgIC5jb25jYXQoW25ldyBvLlJldHVyblN0YXRlbWVudChyZXN1bHRFeHByKV0pO1xuICAgICAgICAvLyBwcml2YXRlIGlzIGZpbmUgaGVyZSBhcyBubyBjaGlsZCB2aWV3IHdpbGwgcmVmZXJlbmNlIHRoZSBldmVudCBoYW5kbGVyLi4uXG4gICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5ldmVudEhhbmRsZXJNZXRob2RzLnB1c2gobmV3IG8uQ2xhc3NNZXRob2QodGhpcy5fbWV0aG9kTmFtZSwgW3RoaXMuX2V2ZW50UGFyYW1dLCBzdG10cywgby5CT09MX1RZUEUsIFtvLlN0bXRNb2RpZmllci5Qcml2YXRlXSkpO1xuICAgIH07XG4gICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmxpc3RlblRvUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaXN0ZW5FeHByO1xuICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IG8uVEhJU19FWFBSLmNhbGxNZXRob2QoJ2V2ZW50SGFuZGxlcicsIFtvLlRISVNfRVhQUi5wcm9wKHRoaXMuX21ldGhvZE5hbWUpLmNhbGxNZXRob2Qoby5CdWlsdGluTWV0aG9kLmJpbmQsIFtvLlRISVNfRVhQUl0pXSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuZXZlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICBsaXN0ZW5FeHByID0gY29uc3RhbnRzXzEuVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnbGlzdGVuR2xvYmFsJywgW28ubGl0ZXJhbCh0aGlzLmV2ZW50VGFyZ2V0KSwgby5saXRlcmFsKHRoaXMuZXZlbnROYW1lKSwgZXZlbnRMaXN0ZW5lcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuRXhwciA9IGNvbnN0YW50c18xLlZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2xpc3RlbicsIFt0aGlzLmNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIG8ubGl0ZXJhbCh0aGlzLmV2ZW50TmFtZSksIGV2ZW50TGlzdGVuZXJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlzcG9zYWJsZSA9IG8udmFyaWFibGUoXCJkaXNwb3NhYmxlX1wiICsgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LmRpc3Bvc2FibGVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5kaXNwb3NhYmxlcy5wdXNoKGRpc3Bvc2FibGUpO1xuICAgICAgICAvLyBwcml2YXRlIGlzIGZpbmUgaGVyZSBhcyBubyBjaGlsZCB2aWV3IHdpbGwgcmVmZXJlbmNlIHRoZSBldmVudCBoYW5kbGVyLi4uXG4gICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChkaXNwb3NhYmxlLnNldChsaXN0ZW5FeHByKS50b0RlY2xTdG10KG8uRlVOQ1RJT05fVFlQRSwgW28uU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgfTtcbiAgICBDb21waWxlRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUubGlzdGVuVG9EaXJlY3RpdmUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlSW5zdGFuY2UsIG9ic2VydmFibGVQcm9wTmFtZSkge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gby52YXJpYWJsZShcInN1YnNjcmlwdGlvbl9cIiArIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5zdWJzY3JpcHRpb25zLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5zdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBvLlRISVNfRVhQUi5jYWxsTWV0aG9kKCdldmVudEhhbmRsZXInLCBbby5USElTX0VYUFIucHJvcCh0aGlzLl9tZXRob2ROYW1lKS5jYWxsTWV0aG9kKG8uQnVpbHRpbk1ldGhvZC5iaW5kLCBbby5USElTX0VYUFJdKV0pO1xuICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoc3Vic2NyaXB0aW9uLnNldChkaXJlY3RpdmVJbnN0YW5jZS5wcm9wKG9ic2VydmFibGVQcm9wTmFtZSlcbiAgICAgICAgICAgIC5jYWxsTWV0aG9kKG8uQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlLCBbZXZlbnRMaXN0ZW5lcl0pKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW28uU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVFdmVudExpc3RlbmVyO1xufSgpKTtcbmV4cG9ydHMuQ29tcGlsZUV2ZW50TGlzdGVuZXIgPSBDb21waWxlRXZlbnRMaXN0ZW5lcjtcbmZ1bmN0aW9uIGNvbGxlY3RFdmVudExpc3RlbmVycyhob3N0RXZlbnRzLCBkaXJzLCBjb21waWxlRWxlbWVudCkge1xuICAgIHZhciBldmVudExpc3RlbmVycyA9IFtdO1xuICAgIGhvc3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdEV2ZW50KSB7XG4gICAgICAgIGNvbXBpbGVFbGVtZW50LnZpZXcuYmluZGluZ3MucHVzaChuZXcgY29tcGlsZV9iaW5kaW5nXzEuQ29tcGlsZUJpbmRpbmcoY29tcGlsZUVsZW1lbnQsIGhvc3RFdmVudCkpO1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBDb21waWxlRXZlbnRMaXN0ZW5lci5nZXRPckNyZWF0ZShjb21waWxlRWxlbWVudCwgaG9zdEV2ZW50LnRhcmdldCwgaG9zdEV2ZW50Lm5hbWUsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgbGlzdGVuZXIuYWRkQWN0aW9uKGhvc3RFdmVudCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoZGlycywgZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCwgaSkge1xuICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVJbnN0YW5jZXNbaV07XG4gICAgICAgIGRpcmVjdGl2ZUFzdC5ob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RFdmVudCkge1xuICAgICAgICAgICAgY29tcGlsZUVsZW1lbnQudmlldy5iaW5kaW5ncy5wdXNoKG5ldyBjb21waWxlX2JpbmRpbmdfMS5Db21waWxlQmluZGluZyhjb21waWxlRWxlbWVudCwgaG9zdEV2ZW50KSk7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBDb21waWxlRXZlbnRMaXN0ZW5lci5nZXRPckNyZWF0ZShjb21waWxlRWxlbWVudCwgaG9zdEV2ZW50LnRhcmdldCwgaG9zdEV2ZW50Lm5hbWUsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmFkZEFjdGlvbihob3N0RXZlbnQsIGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyLmZpbmlzaE1ldGhvZCgpOyB9KTtcbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnM7XG59XG5leHBvcnRzLmNvbGxlY3RFdmVudExpc3RlbmVycyA9IGNvbGxlY3RFdmVudExpc3RlbmVycztcbmZ1bmN0aW9uIGJpbmREaXJlY3RpdmVPdXRwdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLm91dHB1dHMsIGZ1bmN0aW9uIChldmVudE5hbWUsIG9ic2VydmFibGVQcm9wTmFtZSkge1xuICAgICAgICBldmVudExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lci5ldmVudE5hbWUgPT0gZXZlbnROYW1lOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IGxpc3RlbmVyLmxpc3RlblRvRGlyZWN0aXZlKGRpcmVjdGl2ZUluc3RhbmNlLCBvYnNlcnZhYmxlUHJvcE5hbWUpOyB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmluZERpcmVjdGl2ZU91dHB1dHMgPSBiaW5kRGlyZWN0aXZlT3V0cHV0cztcbmZ1bmN0aW9uIGJpbmRSZW5kZXJPdXRwdXRzKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyLmxpc3RlblRvUmVuZGVyZXIoKTsgfSk7XG59XG5leHBvcnRzLmJpbmRSZW5kZXJPdXRwdXRzID0gYmluZFJlbmRlck91dHB1dHM7XG5mdW5jdGlvbiBjb252ZXJ0U3RtdEludG9FeHByZXNzaW9uKHN0bXQpIHtcbiAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIG8uRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gc3RtdC5leHByO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdG10IGluc3RhbmNlb2Ygby5SZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2FudGl0aXplRXZlbnROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChuYW1lLCAvW15hLXpBLVpfXS9nLCAnXycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRfYmluZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIG8gPSByZXF1aXJlKCcuLi9vdXRwdXQvb3V0cHV0X2FzdCcpO1xudmFyIGlkZW50aWZpZXJzXzEgPSByZXF1aXJlKCcuLi9pZGVudGlmaWVycycpO1xudmFyIElNUExJQ0lUX1JFQ0VJVkVSID0gby52YXJpYWJsZSgnI2ltcGxpY2l0Jyk7XG52YXIgRXhwcmVzc2lvbldpdGhXcmFwcGVkVmFsdWVJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uV2l0aFdyYXBwZWRWYWx1ZUluZm8oZXhwcmVzc2lvbiwgbmVlZHNWYWx1ZVVud3JhcHBlcikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLm5lZWRzVmFsdWVVbndyYXBwZXIgPSBuZWVkc1ZhbHVlVW53cmFwcGVyO1xuICAgIH1cbiAgICByZXR1cm4gRXhwcmVzc2lvbldpdGhXcmFwcGVkVmFsdWVJbmZvO1xufSgpKTtcbmV4cG9ydHMuRXhwcmVzc2lvbldpdGhXcmFwcGVkVmFsdWVJbmZvID0gRXhwcmVzc2lvbldpdGhXcmFwcGVkVmFsdWVJbmZvO1xuZnVuY3Rpb24gY29udmVydENkRXhwcmVzc2lvblRvSXIobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBleHByZXNzaW9uLCB2YWx1ZVVud3JhcHBlcikge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihuYW1lUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIHZhbHVlVW53cmFwcGVyKTtcbiAgICB2YXIgaXJBc3QgPSBleHByZXNzaW9uLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbldpdGhXcmFwcGVkVmFsdWVJbmZvKGlyQXN0LCB2aXNpdG9yLm5lZWRzVmFsdWVVbndyYXBwZXIpO1xufVxuZXhwb3J0cy5jb252ZXJ0Q2RFeHByZXNzaW9uVG9JciA9IGNvbnZlcnRDZEV4cHJlc3Npb25Ub0lyO1xuZnVuY3Rpb24gY29udmVydENkU3RhdGVtZW50VG9JcihuYW1lUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIHN0bXQpIHtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBudWxsKTtcbiAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgIGZsYXR0ZW5TdGF0ZW1lbnRzKHN0bXQudmlzaXQodmlzaXRvciwgX01vZGUuU3RhdGVtZW50KSwgc3RhdGVtZW50cyk7XG4gICAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG5leHBvcnRzLmNvbnZlcnRDZFN0YXRlbWVudFRvSXIgPSBjb252ZXJ0Q2RTdGF0ZW1lbnRUb0lyO1xudmFyIF9Nb2RlO1xuKGZ1bmN0aW9uIChfTW9kZSkge1xuICAgIF9Nb2RlW19Nb2RlW1wiU3RhdGVtZW50XCJdID0gMF0gPSBcIlN0YXRlbWVudFwiO1xuICAgIF9Nb2RlW19Nb2RlW1wiRXhwcmVzc2lvblwiXSA9IDFdID0gXCJFeHByZXNzaW9uXCI7XG59KShfTW9kZSB8fCAoX01vZGUgPSB7fSkpO1xuZnVuY3Rpb24gZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuU3RhdGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkV4cGVjdGVkIGEgc3RhdGVtZW50LCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJFeHBlY3RlZCBhbiBleHByZXNzaW9uLCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBleHByKSB7XG4gICAgaWYgKG1vZGUgPT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbnZhciBfQXN0VG9JclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9Bc3RUb0lyVmlzaXRvcihfbmFtZVJlc29sdmVyLCBfaW1wbGljaXRSZWNlaXZlciwgX3ZhbHVlVW53cmFwcGVyKSB7XG4gICAgICAgIHRoaXMuX25hbWVSZXNvbHZlciA9IF9uYW1lUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIgPSBfaW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgdGhpcy5fdmFsdWVVbndyYXBwZXIgPSBfdmFsdWVVbndyYXBwZXI7XG4gICAgICAgIHRoaXMubmVlZHNWYWx1ZVVud3JhcHBlciA9IGZhbHNlO1xuICAgIH1cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgb3A7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgb3AgPSBvLkJpbmFyeU9wZXJhdG9yLlBsdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuTWludXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuRGl2aWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgb3AgPSBvLkJpbmFyeU9wZXJhdG9yLk1vZHVsbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuQW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgICAgICAgIG9wID0gby5CaW5hcnlPcGVyYXRvci5PcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIG9wID0gby5CaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIG9wID0gby5CaW5hcnlPcGVyYXRvci5JZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gby5CaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuTG93ZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuQmlnZ2VyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIG9wID0gby5CaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICBvcCA9IG8uQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIgKyBhc3Qub3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbmV3IG8uQmluYXJ5T3BlcmF0b3JFeHByKG9wLCBhc3QubGVmdC52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKSwgYXN0LnJpZ2h0LnZpc2l0KHRoaXMsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIGVuc3VyZVN0YXRlbWVudE1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBtb2RlKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHZhbHVlLmNvbmRpdGlvbmFsKGFzdC50cnVlRXhwLnZpc2l0KHRoaXMsIF9Nb2RlLkV4cHJlc3Npb24pLCBhc3QuZmFsc2VFeHAudmlzaXQodGhpcywgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgaW5wdXQgPSBhc3QuZXhwLnZpc2l0KHRoaXMsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9uYW1lUmVzb2x2ZXIuY2FsbFBpcGUoYXN0Lm5hbWUsIGlucHV0LCBhcmdzKTtcbiAgICAgICAgdGhpcy5uZWVkc1ZhbHVlVW53cmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMuX3ZhbHVlVW53cmFwcGVyLmNhbGxNZXRob2QoJ3Vud3JhcCcsIFt2YWx1ZV0pKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBhc3QudGFyZ2V0LnZpc2l0KHRoaXMsIF9Nb2RlLkV4cHJlc3Npb24pXG4gICAgICAgICAgICAuY2FsbEZuKHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgcmV0dXJuIElNUExJQ0lUX1JFQ0VJVkVSO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHZhciBhcmdzID0gW28ubGl0ZXJhbChhc3QuZXhwcmVzc2lvbnMubGVuZ3RoKV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goby5saXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICBhcmdzLnB1c2goYXN0LmV4cHJlc3Npb25zW2ldLnZpc2l0KHRoaXMsIF9Nb2RlLkV4cHJlc3Npb24pKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goby5saXRlcmFsKGFzdC5zdHJpbmdzW2FzdC5zdHJpbmdzLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIHJldHVybiBvLmltcG9ydEV4cHIoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5pbnRlcnBvbGF0ZSkuY2FsbEZuKGFyZ3MpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGFzdC5vYmoudmlzaXQodGhpcywgX01vZGUuRXhwcmVzc2lvbikua2V5KGFzdC5rZXkudmlzaXQodGhpcywgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgb2JqID0gYXN0Lm9iai52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIGtleSA9IGFzdC5rZXkudmlzaXQodGhpcywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFzdC52YWx1ZS52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG9iai5rZXkoa2V5KS5zZXQodmFsdWUpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLl9uYW1lUmVzb2x2ZXIuY3JlYXRlTGl0ZXJhbEFycmF5KHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBtb2RlKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdC5rZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFthc3Qua2V5c1tpXSwgYXN0LnZhbHVlc1tpXS52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLl9uYW1lUmVzb2x2ZXIuY3JlYXRlTGl0ZXJhbE1hcChwYXJ0cykpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBvLmxpdGVyYWwoYXN0LnZhbHVlKSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBJTVBMSUNJVF9SRUNFSVZFUikge1xuICAgICAgICAgICAgdmFyIHZhckV4cHIgPSB0aGlzLl9uYW1lUmVzb2x2ZXIuZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodmFyRXhwcikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YXJFeHByLmNhbGxGbihhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY2FsbE1ldGhvZChhc3QubmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgby5ub3QoYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcywgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gSU1QTElDSVRfUkVDRUlWRVIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX25hbWVSZXNvbHZlci5nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIucHJvcChhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IElNUExJQ0lUX1JFQ0VJVkVSKSB7XG4gICAgICAgICAgICB2YXIgdmFyRXhwciA9IHRoaXMuX25hbWVSZXNvbHZlci5nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh2YXJFeHByKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignQ2Fubm90IGFzc2lnbiB0byBhIHJlZmVyZW5jZSBvciB2YXJpYWJsZSEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVjZWl2ZXIucHJvcChhc3QubmFtZSkuc2V0KGFzdC52YWx1ZS52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlY2VpdmVyLmlzQmxhbmsoKS5jb25kaXRpb25hbChvLk5VTExfRVhQUiwgcmVjZWl2ZXIucHJvcChhc3QubmFtZSkpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVjZWl2ZXIuaXNCbGFuaygpLmNvbmRpdGlvbmFsKG8uTlVMTF9FWFBSLCByZWNlaXZlci5jYWxsTWV0aG9kKGFzdC5uYW1lLCBhcmdzKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzLCBtb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIG1vZGUpOyB9KTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdRdW90ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGV2YWx1YXRpb24hJyk7XG4gICAgfTtcbiAgICByZXR1cm4gX0FzdFRvSXJWaXNpdG9yO1xufSgpKTtcbmZ1bmN0aW9uIGZsYXR0ZW5TdGF0ZW1lbnRzKGFyZywgb3V0cHV0KSB7XG4gICAgaWYgKGxhbmdfMS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cHJlc3Npb25fY29udmVydGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfcHJpdmF0ZV8xID0gcmVxdWlyZSgnLi4vLi4vY29yZV9wcml2YXRlJyk7XG52YXIgbyA9IHJlcXVpcmUoJy4uL291dHB1dC9vdXRwdXRfYXN0Jyk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIFNUQVRFX0lTX05FVkVSX0NIRUNLRUQgPSBvLlRISVNfRVhQUi5wcm9wKCdjZFN0YXRlJykuaWRlbnRpY2FsKGNvbnN0YW50c18xLkNoYW5nZURldGVjdG9yU3RhdGVFbnVtLk5ldmVyQ2hlY2tlZCk7XG52YXIgTk9UX1RIUk9XX09OX0NIQU5HRVMgPSBvLm5vdChjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlKTtcbmZ1bmN0aW9uIGJpbmREaXJlY3RpdmVEZXRlY3RDaGFuZ2VzTGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgIHZhciBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QgPSB2aWV3LmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZDtcbiAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLmxpZmVjeWNsZUhvb2tzO1xuICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKGNvcmVfcHJpdmF0ZV8xLkxpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcykgIT09IC0xICYmIGRpcmVjdGl2ZUFzdC5pbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuYWRkU3RtdChuZXcgby5JZlN0bXQoY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5ub3RJZGVudGljYWwoby5OVUxMX0VYUFIpLCBbZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdPbkNoYW5nZXMnLCBbY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlc10pLnRvU3RtdCgpXSkpO1xuICAgIH1cbiAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihjb3JlX3ByaXZhdGVfMS5MaWZlY3ljbGVIb29rcy5PbkluaXQpICE9PSAtMSkge1xuICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuYWRkU3RtdChuZXcgby5JZlN0bXQoU1RBVEVfSVNfTkVWRVJfQ0hFQ0tFRC5hbmQoTk9UX1RIUk9XX09OX0NIQU5HRVMpLCBbZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdPbkluaXQnLCBbXSkudG9TdG10KCldKSk7XG4gICAgfVxuICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKGNvcmVfcHJpdmF0ZV8xLkxpZmVjeWNsZUhvb2tzLkRvQ2hlY2spICE9PSAtMSkge1xuICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuYWRkU3RtdChuZXcgby5JZlN0bXQoTk9UX1RIUk9XX09OX0NIQU5HRVMsIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0RvQ2hlY2snLCBbXSkudG9TdG10KCldKSk7XG4gICAgfVxufVxuZXhwb3J0cy5iaW5kRGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc0xpZmVjeWNsZUNhbGxiYWNrcyA9IGJpbmREaXJlY3RpdmVEZXRlY3RDaGFuZ2VzTGlmZWN5Y2xlQ2FsbGJhY2tzO1xuZnVuY3Rpb24gYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICB2YXIgdmlldyA9IGNvbXBpbGVFbGVtZW50LnZpZXc7XG4gICAgdmFyIGxpZmVjeWNsZUhvb2tzID0gZGlyZWN0aXZlTWV0YS5saWZlY3ljbGVIb29rcztcbiAgICB2YXIgYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gdmlldy5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2Q7XG4gICAgYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihjb3JlX3ByaXZhdGVfMS5MaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0KSAhPT0gLTEpIHtcbiAgICAgICAgYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmFkZFN0bXQobmV3IG8uSWZTdG10KFNUQVRFX0lTX05FVkVSX0NIRUNLRUQsIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudEluaXQnLCBbXSkudG9TdG10KCldKSk7XG4gICAgfVxuICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKGNvcmVfcHJpdmF0ZV8xLkxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQpICE9PSAtMSkge1xuICAgICAgICBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudENoZWNrZWQnLCBbXSkudG9TdG10KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyA9IGJpbmREaXJlY3RpdmVBZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3M7XG5mdW5jdGlvbiBiaW5kRGlyZWN0aXZlQWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCkge1xuICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBkaXJlY3RpdmVNZXRhLmxpZmVjeWNsZUhvb2tzO1xuICAgIHZhciBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QgPSB2aWV3LmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZDtcbiAgICBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKGNvcmVfcHJpdmF0ZV8xLkxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQpICE9PSAtMSkge1xuICAgICAgICBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChuZXcgby5JZlN0bXQoU1RBVEVfSVNfTkVWRVJfQ0hFQ0tFRCwgW2RpcmVjdGl2ZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nQWZ0ZXJWaWV3SW5pdCcsIFtdKS50b1N0bXQoKV0pKTtcbiAgICB9XG4gICAgaWYgKGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoY29yZV9wcml2YXRlXzEuTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZCkgIT09IC0xKSB7XG4gICAgICAgIGFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5hZGRTdG10KGRpcmVjdGl2ZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nQWZ0ZXJWaWV3Q2hlY2tlZCcsIFtdKS50b1N0bXQoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5iaW5kRGlyZWN0aXZlQWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzID0gYmluZERpcmVjdGl2ZUFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcztcbmZ1bmN0aW9uIGJpbmREaXJlY3RpdmVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCkge1xuICAgIHZhciBvbkRlc3Ryb3lNZXRob2QgPSBjb21waWxlRWxlbWVudC52aWV3LmRlc3Ryb3lNZXRob2Q7XG4gICAgb25EZXN0cm95TWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICBpZiAoZGlyZWN0aXZlTWV0YS5saWZlY3ljbGVIb29rcy5pbmRleE9mKGNvcmVfcHJpdmF0ZV8xLkxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgIG9uRGVzdHJveU1ldGhvZC5hZGRTdG10KGRpcmVjdGl2ZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICB9XG59XG5leHBvcnRzLmJpbmREaXJlY3RpdmVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzID0gYmluZERpcmVjdGl2ZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3M7XG5mdW5jdGlvbiBiaW5kUGlwZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocGlwZU1ldGEsIHBpcGVJbnN0YW5jZSwgdmlldykge1xuICAgIHZhciBvbkRlc3Ryb3lNZXRob2QgPSB2aWV3LmRlc3Ryb3lNZXRob2Q7XG4gICAgaWYgKHBpcGVNZXRhLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoY29yZV9wcml2YXRlXzEuTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSAhPT0gLTEpIHtcbiAgICAgICAgb25EZXN0cm95TWV0aG9kLmFkZFN0bXQocGlwZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICB9XG59XG5leHBvcnRzLmJpbmRQaXBlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyA9IGJpbmRQaXBlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZmVjeWNsZV9iaW5kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV9wcml2YXRlXzEgPSByZXF1aXJlKCcuLi8uLi9jb3JlX3ByaXZhdGUnKTtcbnZhciBjb3JlX3ByaXZhdGVfMiA9IHJlcXVpcmUoJy4uLy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIG8gPSByZXF1aXJlKCcuLi9vdXRwdXQvb3V0cHV0X2FzdCcpO1xudmFyIGlkZW50aWZpZXJzXzEgPSByZXF1aXJlKCcuLi9pZGVudGlmaWVycycpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciB0ZW1wbGF0ZV9hc3RfMSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlX2FzdCcpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBleHByZXNzaW9uX2NvbnZlcnRlcl8xID0gcmVxdWlyZSgnLi9leHByZXNzaW9uX2NvbnZlcnRlcicpO1xudmFyIGNvbXBpbGVfYmluZGluZ18xID0gcmVxdWlyZSgnLi9jb21waWxlX2JpbmRpbmcnKTtcbmZ1bmN0aW9uIGNyZWF0ZUJpbmRGaWVsZEV4cHIoZXhwckluZGV4KSB7XG4gICAgcmV0dXJuIG8uVEhJU19FWFBSLnByb3AoXCJfZXhwcl9cIiArIGV4cHJJbmRleCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDdXJyVmFsdWVFeHByKGV4cHJJbmRleCkge1xuICAgIHJldHVybiBvLnZhcmlhYmxlKFwiY3VyclZhbF9cIiArIGV4cHJJbmRleCk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nOiBgXG59XG5mdW5jdGlvbiBiaW5kKHZpZXcsIGN1cnJWYWxFeHByLCBmaWVsZEV4cHIsIHBhcnNlZEV4cHJlc3Npb24sIGNvbnRleHQsIGFjdGlvbnMsIG1ldGhvZCkge1xuICAgIHZhciBjaGVja0V4cHJlc3Npb24gPSBleHByZXNzaW9uX2NvbnZlcnRlcl8xLmNvbnZlcnRDZEV4cHJlc3Npb25Ub0lyKHZpZXcsIGNvbnRleHQsIHBhcnNlZEV4cHJlc3Npb24sIGNvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLnZhbFVud3JhcHBlcik7XG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNoZWNrRXhwcmVzc2lvbi5leHByZXNzaW9uKSkge1xuICAgICAgICAvLyBlLmcuIGFuIGVtcHR5IGV4cHJlc3Npb24gd2FzIGdpdmVuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSB0aGUgY2FjaGVkIHZhbHVlLi4uXG4gICAgdmlldy5maWVsZHMucHVzaChuZXcgby5DbGFzc0ZpZWxkKGZpZWxkRXhwci5uYW1lLCBudWxsLCBbby5TdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICB2aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KG8uVEhJU19FWFBSLnByb3AoZmllbGRFeHByLm5hbWUpLnNldChvLmltcG9ydEV4cHIoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy51bmluaXRpYWxpemVkKSkudG9TdG10KCkpO1xuICAgIGlmIChjaGVja0V4cHJlc3Npb24ubmVlZHNWYWx1ZVVud3JhcHBlcikge1xuICAgICAgICB2YXIgaW5pdFZhbHVlVW53cmFwcGVyU3RtdCA9IGNvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLnZhbFVud3JhcHBlci5jYWxsTWV0aG9kKCdyZXNldCcsIFtdKS50b1N0bXQoKTtcbiAgICAgICAgbWV0aG9kLmFkZFN0bXQoaW5pdFZhbHVlVW53cmFwcGVyU3RtdCk7XG4gICAgfVxuICAgIG1ldGhvZC5hZGRTdG10KGN1cnJWYWxFeHByLnNldChjaGVja0V4cHJlc3Npb24uZXhwcmVzc2lvbikudG9EZWNsU3RtdChudWxsLCBbby5TdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgdmFyIGNvbmRpdGlvbiA9IG8uaW1wb3J0RXhwcihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLmNoZWNrQmluZGluZylcbiAgICAgICAgLmNhbGxGbihbY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSwgZmllbGRFeHByLCBjdXJyVmFsRXhwcl0pO1xuICAgIGlmIChjaGVja0V4cHJlc3Npb24ubmVlZHNWYWx1ZVVud3JhcHBlcikge1xuICAgICAgICBjb25kaXRpb24gPSBjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy52YWxVbndyYXBwZXIucHJvcCgnaGFzV3JhcHBlZFZhbHVlJykub3IoY29uZGl0aW9uKTtcbiAgICB9XG4gICAgbWV0aG9kLmFkZFN0bXQobmV3IG8uSWZTdG10KGNvbmRpdGlvbiwgYWN0aW9ucy5jb25jYXQoW28uVEhJU19FWFBSLnByb3AoZmllbGRFeHByLm5hbWUpLnNldChjdXJyVmFsRXhwcikudG9TdG10KCldKSkpO1xufVxuZnVuY3Rpb24gYmluZFJlbmRlclRleHQoYm91bmRUZXh0LCBjb21waWxlTm9kZSwgdmlldykge1xuICAgIHZhciBiaW5kaW5nSW5kZXggPSB2aWV3LmJpbmRpbmdzLmxlbmd0aDtcbiAgICB2aWV3LmJpbmRpbmdzLnB1c2gobmV3IGNvbXBpbGVfYmluZGluZ18xLkNvbXBpbGVCaW5kaW5nKGNvbXBpbGVOb2RlLCBib3VuZFRleHQpKTtcbiAgICB2YXIgY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJbmRleCk7XG4gICAgdmFyIHZhbHVlRmllbGQgPSBjcmVhdGVCaW5kRmllbGRFeHByKGJpbmRpbmdJbmRleCk7XG4gICAgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlTm9kZS5ub2RlSW5kZXgsIGJvdW5kVGV4dCk7XG4gICAgYmluZCh2aWV3LCBjdXJyVmFsRXhwciwgdmFsdWVGaWVsZCwgYm91bmRUZXh0LnZhbHVlLCB2aWV3LmNvbXBvbmVudENvbnRleHQsIFtcbiAgICAgICAgby5USElTX0VYUFIucHJvcCgncmVuZGVyZXInKVxuICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldFRleHQnLCBbY29tcGlsZU5vZGUucmVuZGVyTm9kZSwgY3VyclZhbEV4cHJdKVxuICAgICAgICAgICAgLnRvU3RtdCgpXG4gICAgXSwgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZCk7XG59XG5leHBvcnRzLmJpbmRSZW5kZXJUZXh0ID0gYmluZFJlbmRlclRleHQ7XG5mdW5jdGlvbiBiaW5kQW5kV3JpdGVUb1JlbmRlcmVyKGJvdW5kUHJvcHMsIGNvbnRleHQsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgIHZhciByZW5kZXJOb2RlID0gY29tcGlsZUVsZW1lbnQucmVuZGVyTm9kZTtcbiAgICBib3VuZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xuICAgICAgICB2YXIgYmluZGluZ0luZGV4ID0gdmlldy5iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgIHZpZXcuYmluZGluZ3MucHVzaChuZXcgY29tcGlsZV9iaW5kaW5nXzEuQ29tcGlsZUJpbmRpbmcoY29tcGlsZUVsZW1lbnQsIGJvdW5kUHJvcCkpO1xuICAgICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgYm91bmRQcm9wKTtcbiAgICAgICAgdmFyIGZpZWxkRXhwciA9IGNyZWF0ZUJpbmRGaWVsZEV4cHIoYmluZGluZ0luZGV4KTtcbiAgICAgICAgdmFyIGN1cnJWYWxFeHByID0gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSW5kZXgpO1xuICAgICAgICB2YXIgcmVuZGVyTWV0aG9kO1xuICAgICAgICB2YXIgcmVuZGVyVmFsdWUgPSBzYW5pdGl6ZWRWYWx1ZShib3VuZFByb3AsIGN1cnJWYWxFeHByKTtcbiAgICAgICAgdmFyIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgIHN3aXRjaCAoYm91bmRQcm9wLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgdGVtcGxhdGVfYXN0XzEuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTpcbiAgICAgICAgICAgICAgICByZW5kZXJNZXRob2QgPSAnc2V0RWxlbWVudFByb3BlcnR5JztcbiAgICAgICAgICAgICAgICBpZiAodmlldy5nZW5Db25maWcubG9nQmluZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKGxvZ0JpbmRpbmdVcGRhdGVTdG10KHJlbmRlck5vZGUsIGJvdW5kUHJvcC5uYW1lLCBjdXJyVmFsRXhwcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGVtcGxhdGVfYXN0XzEuUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU6XG4gICAgICAgICAgICAgICAgcmVuZGVyTWV0aG9kID0gJ3NldEVsZW1lbnRBdHRyaWJ1dGUnO1xuICAgICAgICAgICAgICAgIHJlbmRlclZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVmFsdWUuaXNCbGFuaygpLmNvbmRpdGlvbmFsKG8uTlVMTF9FWFBSLCByZW5kZXJWYWx1ZS5jYWxsTWV0aG9kKCd0b1N0cmluZycsIFtdKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M6XG4gICAgICAgICAgICAgICAgcmVuZGVyTWV0aG9kID0gJ3NldEVsZW1lbnRDbGFzcyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRlbXBsYXRlX2FzdF8xLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU6XG4gICAgICAgICAgICAgICAgcmVuZGVyTWV0aG9kID0gJ3NldEVsZW1lbnRTdHlsZSc7XG4gICAgICAgICAgICAgICAgdmFyIHN0clZhbHVlID0gcmVuZGVyVmFsdWUuY2FsbE1ldGhvZCgndG9TdHJpbmcnLCBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYm91bmRQcm9wLnVuaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0clZhbHVlID0gc3RyVmFsdWUucGx1cyhvLmxpdGVyYWwoYm91bmRQcm9wLnVuaXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVuZGVyVmFsdWUgPSByZW5kZXJWYWx1ZS5pc0JsYW5rKCkuY29uZGl0aW9uYWwoby5OVUxMX0VYUFIsIHN0clZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVTdG10cy5wdXNoKG8uVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJylcbiAgICAgICAgICAgIC5jYWxsTWV0aG9kKHJlbmRlck1ldGhvZCwgW3JlbmRlck5vZGUsIG8ubGl0ZXJhbChib3VuZFByb3AubmFtZSksIHJlbmRlclZhbHVlXSlcbiAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgIGJpbmQodmlldywgY3VyclZhbEV4cHIsIGZpZWxkRXhwciwgYm91bmRQcm9wLnZhbHVlLCBjb250ZXh0LCB1cGRhdGVTdG10cywgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZWRWYWx1ZShib3VuZFByb3AsIHJlbmRlclZhbHVlKSB7XG4gICAgdmFyIGVudW1WYWx1ZTtcbiAgICBzd2l0Y2ggKGJvdW5kUHJvcC5zZWN1cml0eUNvbnRleHQpIHtcbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuTk9ORTpcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJWYWx1ZTsgLy8gTm8gc2FuaXRpemF0aW9uIG5lZWRlZC5cbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuSFRNTDpcbiAgICAgICAgICAgIGVudW1WYWx1ZSA9ICdIVE1MJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGNvcmVfcHJpdmF0ZV8xLlNlY3VyaXR5Q29udGV4dC5TVFlMRTpcbiAgICAgICAgICAgIGVudW1WYWx1ZSA9ICdTVFlMRSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuU0NSSVBUOlxuICAgICAgICAgICAgZW51bVZhbHVlID0gJ1NDUklQVCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuVVJMOlxuICAgICAgICAgICAgZW51bVZhbHVlID0gJ1VSTCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgZW51bVZhbHVlID0gJ1JFU09VUkNFX1VSTCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGVycm9yLCB1bmV4cGVjdGVkIFNlY3VyaXR5Q29udGV4dCBcIiArIGJvdW5kUHJvcC5zZWN1cml0eUNvbnRleHQgKyBcIi5cIik7XG4gICAgfVxuICAgIHZhciBjdHggPSBjb25zdGFudHNfMS5WaWV3UHJvcGVydGllcy52aWV3VXRpbHMucHJvcCgnc2FuaXRpemVyJyk7XG4gICAgdmFyIGFyZ3MgPSBbby5pbXBvcnRFeHByKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuU2VjdXJpdHlDb250ZXh0KS5wcm9wKGVudW1WYWx1ZSksIHJlbmRlclZhbHVlXTtcbiAgICByZXR1cm4gY3R4LmNhbGxNZXRob2QoJ3Nhbml0aXplJywgYXJncyk7XG59XG5mdW5jdGlvbiBiaW5kUmVuZGVySW5wdXRzKGJvdW5kUHJvcHMsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgYmluZEFuZFdyaXRlVG9SZW5kZXJlcihib3VuZFByb3BzLCBjb21waWxlRWxlbWVudC52aWV3LmNvbXBvbmVudENvbnRleHQsIGNvbXBpbGVFbGVtZW50KTtcbn1cbmV4cG9ydHMuYmluZFJlbmRlcklucHV0cyA9IGJpbmRSZW5kZXJJbnB1dHM7XG5mdW5jdGlvbiBiaW5kRGlyZWN0aXZlSG9zdFByb3BzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgYmluZEFuZFdyaXRlVG9SZW5kZXJlcihkaXJlY3RpdmVBc3QuaG9zdFByb3BlcnRpZXMsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG59XG5leHBvcnRzLmJpbmREaXJlY3RpdmVIb3N0UHJvcHMgPSBiaW5kRGlyZWN0aXZlSG9zdFByb3BzO1xuZnVuY3Rpb24gYmluZERpcmVjdGl2ZUlucHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCkge1xuICAgIGlmIChkaXJlY3RpdmVBc3QuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICB2YXIgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kID0gdmlldy5kZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2Q7XG4gICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLmxpZmVjeWNsZUhvb2tzO1xuICAgIHZhciBjYWxjQ2hhbmdlc01hcCA9IGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoY29yZV9wcml2YXRlXzIuTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzKSAhPT0gLTE7XG4gICAgdmFyIGlzT25QdXNoQ29tcCA9IGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQgJiZcbiAgICAgICAgIWNvcmVfcHJpdmF0ZV8yLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUuY2hhbmdlRGV0ZWN0aW9uKTtcbiAgICBpZiAoY2FsY0NoYW5nZXNNYXApIHtcbiAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQoY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5zZXQoby5OVUxMX0VYUFIpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgaWYgKGlzT25QdXNoQ29tcCkge1xuICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuYWRkU3RtdChjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLnNldChvLmxpdGVyYWwoZmFsc2UpKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIGRpcmVjdGl2ZUFzdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdJbmRleCA9IHZpZXcuYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICB2aWV3LmJpbmRpbmdzLnB1c2gobmV3IGNvbXBpbGVfYmluZGluZ18xLkNvbXBpbGVCaW5kaW5nKGNvbXBpbGVFbGVtZW50LCBpbnB1dCkpO1xuICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBpbnB1dCk7XG4gICAgICAgIHZhciBmaWVsZEV4cHIgPSBjcmVhdGVCaW5kRmllbGRFeHByKGJpbmRpbmdJbmRleCk7XG4gICAgICAgIHZhciBjdXJyVmFsRXhwciA9IGNyZWF0ZUN1cnJWYWx1ZUV4cHIoYmluZGluZ0luZGV4KTtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbZGlyZWN0aXZlSW5zdGFuY2UucHJvcChpbnB1dC5kaXJlY3RpdmVOYW1lKS5zZXQoY3VyclZhbEV4cHIpLnRvU3RtdCgpXTtcbiAgICAgICAgaWYgKGNhbGNDaGFuZ2VzTWFwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IG8uSWZTdG10KGNvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMuaWRlbnRpY2FsKG8uTlVMTF9FWFBSKSwgW1xuICAgICAgICAgICAgICAgIGNvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMuc2V0KG8ubGl0ZXJhbE1hcChbXSwgbmV3IG8uTWFwVHlwZShvLmltcG9ydFR5cGUoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5TaW1wbGVDaGFuZ2UpKSkpXG4gICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKGNvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMua2V5KG8ubGl0ZXJhbChpbnB1dC5kaXJlY3RpdmVOYW1lKSlcbiAgICAgICAgICAgICAgICAuc2V0KG8uaW1wb3J0RXhwcihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLlNpbXBsZUNoYW5nZSkuaW5zdGFudGlhdGUoW2ZpZWxkRXhwciwgY3VyclZhbEV4cHJdKSlcbiAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09uUHVzaENvbXApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLnNldChvLmxpdGVyYWwodHJ1ZSkpLnRvU3RtdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlldy5nZW5Db25maWcubG9nQmluZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKGxvZ0JpbmRpbmdVcGRhdGVTdG10KGNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIGlucHV0LmRpcmVjdGl2ZU5hbWUsIGN1cnJWYWxFeHByKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmluZCh2aWV3LCBjdXJyVmFsRXhwciwgZmllbGRFeHByLCBpbnB1dC52YWx1ZSwgdmlldy5jb21wb25lbnRDb250ZXh0LCBzdGF0ZW1lbnRzLCBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QpO1xuICAgIH0pO1xuICAgIGlmIChpc09uUHVzaENvbXApIHtcbiAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQobmV3IG8uSWZTdG10KGNvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLmNoYW5nZWQsIFtcbiAgICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmFwcEVsZW1lbnQucHJvcCgnY29tcG9uZW50VmlldycpXG4gICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ21hcmtBc0NoZWNrT25jZScsIFtdKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKVxuICAgICAgICBdKSk7XG4gICAgfVxufVxuZXhwb3J0cy5iaW5kRGlyZWN0aXZlSW5wdXRzID0gYmluZERpcmVjdGl2ZUlucHV0cztcbmZ1bmN0aW9uIGxvZ0JpbmRpbmdVcGRhdGVTdG10KHJlbmRlck5vZGUsIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBvLlRISVNfRVhQUi5wcm9wKCdyZW5kZXJlcicpXG4gICAgICAgIC5jYWxsTWV0aG9kKCdzZXRCaW5kaW5nRGVidWdJbmZvJywgW1xuICAgICAgICByZW5kZXJOb2RlLFxuICAgICAgICBvLmxpdGVyYWwoXCJuZy1yZWZsZWN0LVwiICsgdXRpbF8xLmNhbWVsQ2FzZVRvRGFzaENhc2UocHJvcE5hbWUpKSxcbiAgICAgICAgdmFsdWUuaXNCbGFuaygpLmNvbmRpdGlvbmFsKG8uTlVMTF9FWFBSLCB2YWx1ZS5jYWxsTWV0aG9kKCd0b1N0cmluZycsIFtdKSlcbiAgICBdKVxuICAgICAgICAudG9TdG10KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9wZXJ0eV9iaW5kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgbyA9IHJlcXVpcmUoJy4uL291dHB1dC9vdXRwdXRfYXN0Jyk7XG52YXIgaWRlbnRpZmllcnNfMSA9IHJlcXVpcmUoJy4uL2lkZW50aWZpZXJzJyk7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluVmlldyhwcm9wZXJ0eSwgY2FsbGluZ1ZpZXcsIGRlZmluZWRWaWV3KSB7XG4gICAgaWYgKGNhbGxpbmdWaWV3ID09PSBkZWZpbmVkVmlldykge1xuICAgICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmlld1Byb3AgPSBvLlRISVNfRVhQUjtcbiAgICAgICAgdmFyIGN1cnJWaWV3ID0gY2FsbGluZ1ZpZXc7XG4gICAgICAgIHdoaWxlIChjdXJyVmlldyAhPT0gZGVmaW5lZFZpZXcgJiYgbGFuZ18xLmlzUHJlc2VudChjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldykpIHtcbiAgICAgICAgICAgIGN1cnJWaWV3ID0gY3VyclZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnZpZXc7XG4gICAgICAgICAgICB2aWV3UHJvcCA9IHZpZXdQcm9wLnByb3AoJ3BhcmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyVmlldyAhPT0gZGVmaW5lZFZpZXcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkludGVybmFsIGVycm9yOiBDb3VsZCBub3QgY2FsY3VsYXRlIGEgcHJvcGVydHkgaW4gYSBwYXJlbnQgdmlldzogXCIgKyBwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2Ygby5SZWFkUHJvcEV4cHIpIHtcbiAgICAgICAgICAgIHZhciByZWFkUHJvcEV4cHJfMSA9IHByb3BlcnR5O1xuICAgICAgICAgICAgLy8gTm90ZTogRG9uJ3QgY2FzdCBmb3IgbWVtYmVycyBvZiB0aGUgQXBwVmlldyBiYXNlIGNsYXNzLi4uXG4gICAgICAgICAgICBpZiAoZGVmaW5lZFZpZXcuZmllbGRzLnNvbWUoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBmaWVsZC5uYW1lID09IHJlYWRQcm9wRXhwcl8xLm5hbWU7IH0pIHx8XG4gICAgICAgICAgICAgICAgZGVmaW5lZFZpZXcuZ2V0dGVycy5zb21lKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gZmllbGQubmFtZSA9PSByZWFkUHJvcEV4cHJfMS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgIHZpZXdQcm9wID0gdmlld1Byb3AuY2FzdChkZWZpbmVkVmlldy5jbGFzc1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvLnJlcGxhY2VWYXJJbkV4cHJlc3Npb24oby5USElTX0VYUFIubmFtZSwgdmlld1Byb3AsIHByb3BlcnR5KTtcbiAgICB9XG59XG5leHBvcnRzLmdldFByb3BlcnR5SW5WaWV3ID0gZ2V0UHJvcGVydHlJblZpZXc7XG5mdW5jdGlvbiBpbmplY3RGcm9tVmlld1BhcmVudEluamVjdG9yKHRva2VuLCBvcHRpb25hbCkge1xuICAgIHZhciBhcmdzID0gW2NyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHRva2VuKV07XG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIGFyZ3MucHVzaChvLk5VTExfRVhQUik7XG4gICAgfVxuICAgIHJldHVybiBvLlRISVNfRVhQUi5wcm9wKCdwYXJlbnRJbmplY3RvcicpLmNhbGxNZXRob2QoJ2dldCcsIGFyZ3MpO1xufVxuZXhwb3J0cy5pbmplY3RGcm9tVmlld1BhcmVudEluamVjdG9yID0gaW5qZWN0RnJvbVZpZXdQYXJlbnRJbmplY3RvcjtcbmZ1bmN0aW9uIGdldFZpZXdGYWN0b3J5TmFtZShjb21wb25lbnQsIGVtYmVkZGVkVGVtcGxhdGVJbmRleCkge1xuICAgIHJldHVybiBcInZpZXdGYWN0b3J5X1wiICsgY29tcG9uZW50LnR5cGUubmFtZSArIGVtYmVkZGVkVGVtcGxhdGVJbmRleDtcbn1cbmV4cG9ydHMuZ2V0Vmlld0ZhY3RvcnlOYW1lID0gZ2V0Vmlld0ZhY3RvcnlOYW1lO1xuZnVuY3Rpb24gY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pIHtcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG8ubGl0ZXJhbCh0b2tlbi52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRva2VuLmlkZW50aWZpZXJJc0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBvLmltcG9ydEV4cHIodG9rZW4uaWRlbnRpZmllcilcbiAgICAgICAgICAgIC5pbnN0YW50aWF0ZShbXSwgby5pbXBvcnRUeXBlKHRva2VuLmlkZW50aWZpZXIsIFtdLCBbby5UeXBlTW9kaWZpZXIuQ29uc3RdKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gby5pbXBvcnRFeHByKHRva2VuLmlkZW50aWZpZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24gPSBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZUZsYXRBcnJheShleHByZXNzaW9ucykge1xuICAgIHZhciBsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucyA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBvLmxpdGVyYWxBcnIoW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV4cHIgPSBleHByZXNzaW9uc1tpXTtcbiAgICAgICAgaWYgKGV4cHIudHlwZSBpbnN0YW5jZW9mIG8uQXJyYXlUeXBlKSB7XG4gICAgICAgICAgICBpZiAobGFzdE5vbkFycmF5RXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsTWV0aG9kKG8uQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheSwgW28ubGl0ZXJhbEFycihsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucyldKTtcbiAgICAgICAgICAgICAgICBsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNhbGxNZXRob2Qoby5CdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5LCBbZXhwcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdE5vbkFycmF5RXhwcmVzc2lvbnMucHVzaChleHByKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdE5vbkFycmF5RXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgcmVzdWx0LmNhbGxNZXRob2Qoby5CdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5LCBbby5saXRlcmFsQXJyKGxhc3ROb25BcnJheUV4cHJlc3Npb25zKV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jcmVhdGVGbGF0QXJyYXkgPSBjcmVhdGVGbGF0QXJyYXk7XG5mdW5jdGlvbiBjcmVhdGVQdXJlUHJveHkoZm4sIGFyZ0NvdW50LCBwdXJlUHJveHlQcm9wLCB2aWV3KSB7XG4gICAgdmlldy5maWVsZHMucHVzaChuZXcgby5DbGFzc0ZpZWxkKHB1cmVQcm94eVByb3AubmFtZSwgbnVsbCkpO1xuICAgIHZhciBwdXJlUHJveHlJZCA9IGFyZ0NvdW50IDwgaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5wdXJlUHJveGllcy5sZW5ndGggPyBpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLnB1cmVQcm94aWVzW2FyZ0NvdW50XSA6IG51bGw7XG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHB1cmVQcm94eUlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBudW1iZXIgb2YgYXJndW1lbnQgZm9yIHB1cmUgZnVuY3Rpb25zOiBcIiArIGFyZ0NvdW50KTtcbiAgICB9XG4gICAgdmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChvLlRISVNfRVhQUi5wcm9wKHB1cmVQcm94eVByb3AubmFtZSkuc2V0KG8uaW1wb3J0RXhwcihwdXJlUHJveHlJZCkuY2FsbEZuKFtmbl0pKS50b1N0bXQoKSk7XG59XG5leHBvcnRzLmNyZWF0ZVB1cmVQcm94eSA9IGNyZWF0ZVB1cmVQcm94eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgdGVtcGxhdGVfYXN0XzEgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZV9hc3QnKTtcbnZhciBwcm9wZXJ0eV9iaW5kZXJfMSA9IHJlcXVpcmUoJy4vcHJvcGVydHlfYmluZGVyJyk7XG52YXIgZXZlbnRfYmluZGVyXzEgPSByZXF1aXJlKCcuL2V2ZW50X2JpbmRlcicpO1xudmFyIGxpZmVjeWNsZV9iaW5kZXJfMSA9IHJlcXVpcmUoJy4vbGlmZWN5Y2xlX2JpbmRlcicpO1xuZnVuY3Rpb24gYmluZFZpZXcodmlldywgcGFyc2VkVGVtcGxhdGUpIHtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBWaWV3QmluZGVyVmlzaXRvcih2aWV3KTtcbiAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIHBhcnNlZFRlbXBsYXRlKTtcbiAgICB2aWV3LnBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHsgbGlmZWN5Y2xlX2JpbmRlcl8xLmJpbmRQaXBlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhwaXBlLm1ldGEsIHBpcGUuaW5zdGFuY2UsIHBpcGUudmlldyk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVmlldyA9IGJpbmRWaWV3O1xudmFyIFZpZXdCaW5kZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3QmluZGVyVmlzaXRvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuX25vZGVJbmRleCA9IDA7XG4gICAgfVxuICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMudmlldy5ub2Rlc1t0aGlzLl9ub2RlSW5kZXgrK107XG4gICAgICAgIHByb3BlcnR5X2JpbmRlcl8xLmJpbmRSZW5kZXJUZXh0KGFzdCwgbm9kZSwgdGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHRoaXMuX25vZGVJbmRleCsrO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IHRoaXMudmlldy5ub2Rlc1t0aGlzLl9ub2RlSW5kZXgrK107XG4gICAgICAgIHZhciBldmVudExpc3RlbmVycyA9IGV2ZW50X2JpbmRlcl8xLmNvbGxlY3RFdmVudExpc3RlbmVycyhhc3Qub3V0cHV0cywgYXN0LmRpcmVjdGl2ZXMsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgcHJvcGVydHlfYmluZGVyXzEuYmluZFJlbmRlcklucHV0cyhhc3QuaW5wdXRzLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgIGV2ZW50X2JpbmRlcl8xLmJpbmRSZW5kZXJPdXRwdXRzKGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoYXN0LmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVJbnN0YW5jZXNbaW5kZXhdO1xuICAgICAgICAgICAgcHJvcGVydHlfYmluZGVyXzEuYmluZERpcmVjdGl2ZUlucHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICBsaWZlY3ljbGVfYmluZGVyXzEuYmluZERpcmVjdGl2ZURldGVjdENoYW5nZXNMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgcHJvcGVydHlfYmluZGVyXzEuYmluZERpcmVjdGl2ZUhvc3RQcm9wcyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICBldmVudF9iaW5kZXJfMS5iaW5kRGlyZWN0aXZlT3V0cHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAvLyBhZnRlckNvbnRlbnQgYW5kIGFmdGVyVmlldyBsaWZlY3ljbGVzIG5lZWQgdG8gYmUgY2FsbGVkIGJvdHRvbSB1cFxuICAgICAgICAvLyBzbyB0aGF0IGNoaWxkcmVuIGFyZSBub3RpZmllZCBiZWZvcmUgcGFyZW50c1xuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZm9yRWFjaFdpdGhJbmRleChhc3QuZGlyZWN0aXZlcywgZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50LmRpcmVjdGl2ZUluc3RhbmNlc1tpbmRleF07XG4gICAgICAgICAgICBsaWZlY3ljbGVfYmluZGVyXzEuYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgbGlmZWN5Y2xlX2JpbmRlcl8xLmJpbmREaXJlY3RpdmVBZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgIGxpZmVjeWNsZV9iaW5kZXJfMS5iaW5kRGlyZWN0aXZlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IHRoaXMudmlldy5ub2Rlc1t0aGlzLl9ub2RlSW5kZXgrK107XG4gICAgICAgIHZhciBldmVudExpc3RlbmVycyA9IGV2ZW50X2JpbmRlcl8xLmNvbGxlY3RFdmVudExpc3RlbmVycyhhc3Qub3V0cHV0cywgYXN0LmRpcmVjdGl2ZXMsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXgoYXN0LmRpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5kaXJlY3RpdmVJbnN0YW5jZXNbaW5kZXhdO1xuICAgICAgICAgICAgcHJvcGVydHlfYmluZGVyXzEuYmluZERpcmVjdGl2ZUlucHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICBsaWZlY3ljbGVfYmluZGVyXzEuYmluZERpcmVjdGl2ZURldGVjdENoYW5nZXNMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgZXZlbnRfYmluZGVyXzEuYmluZERpcmVjdGl2ZU91dHB1dHMoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgZXZlbnRMaXN0ZW5lcnMpO1xuICAgICAgICAgICAgbGlmZWN5Y2xlX2JpbmRlcl8xLmJpbmREaXJlY3RpdmVBZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgIGxpZmVjeWNsZV9iaW5kZXJfMS5iaW5kRGlyZWN0aXZlQWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICBsaWZlY3ljbGVfYmluZGVyXzEuYmluZERpcmVjdGl2ZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJpbmRWaWV3KGNvbXBpbGVFbGVtZW50LmVtYmVkZGVkVmlldywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFdmVudCA9IGZ1bmN0aW9uIChhc3QsIGV2ZW50VGFyZ2V0QW5kTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFZpZXdCaW5kZXJWaXNpdG9yO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfYmluZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uLy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIG8gPSByZXF1aXJlKCcuLi9vdXRwdXQvb3V0cHV0X2FzdCcpO1xudmFyIGlkZW50aWZpZXJzXzEgPSByZXF1aXJlKCcuLi9pZGVudGlmaWVycycpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBjb21waWxlX3ZpZXdfMSA9IHJlcXVpcmUoJy4vY29tcGlsZV92aWV3Jyk7XG52YXIgY29tcGlsZV9lbGVtZW50XzEgPSByZXF1aXJlKCcuL2NvbXBpbGVfZWxlbWVudCcpO1xudmFyIHRlbXBsYXRlX2FzdF8xID0gcmVxdWlyZSgnLi4vdGVtcGxhdGVfYXN0Jyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgY29tcGlsZV9tZXRhZGF0YV8xID0gcmVxdWlyZSgnLi4vY29tcGlsZV9tZXRhZGF0YScpO1xudmFyIElNUExJQ0lUX1RFTVBMQVRFX1ZBUiA9ICdcXCRpbXBsaWNpdCc7XG52YXIgQ0xBU1NfQVRUUiA9ICdjbGFzcyc7XG52YXIgU1RZTEVfQVRUUiA9ICdzdHlsZSc7XG52YXIgcGFyZW50UmVuZGVyTm9kZVZhciA9IG8udmFyaWFibGUoJ3BhcmVudFJlbmRlck5vZGUnKTtcbnZhciByb290U2VsZWN0b3JWYXIgPSBvLnZhcmlhYmxlKCdyb290U2VsZWN0b3InKTtcbnZhciBWaWV3Q29tcGlsZURlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdDb21waWxlRGVwZW5kZW5jeShjb21wLCBmYWN0b3J5UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgICAgdGhpcy5mYWN0b3J5UGxhY2Vob2xkZXIgPSBmYWN0b3J5UGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29tcGlsZURlcGVuZGVuY3k7XG59KCkpO1xuZXhwb3J0cy5WaWV3Q29tcGlsZURlcGVuZGVuY3kgPSBWaWV3Q29tcGlsZURlcGVuZGVuY3k7XG5mdW5jdGlvbiBidWlsZFZpZXcodmlldywgdGVtcGxhdGUsIHRhcmdldERlcGVuZGVuY2llcykge1xuICAgIHZhciBidWlsZGVyVmlzaXRvciA9IG5ldyBWaWV3QnVpbGRlclZpc2l0b3IodmlldywgdGFyZ2V0RGVwZW5kZW5jaWVzKTtcbiAgICB0ZW1wbGF0ZV9hc3RfMS50ZW1wbGF0ZVZpc2l0QWxsKGJ1aWxkZXJWaXNpdG9yLCB0ZW1wbGF0ZSwgdmlldy5kZWNsYXJhdGlvbkVsZW1lbnQuaXNOdWxsKCkgP1xuICAgICAgICB2aWV3LmRlY2xhcmF0aW9uRWxlbWVudCA6XG4gICAgICAgIHZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnBhcmVudCk7XG4gICAgcmV0dXJuIGJ1aWxkZXJWaXNpdG9yLm5lc3RlZFZpZXdDb3VudDtcbn1cbmV4cG9ydHMuYnVpbGRWaWV3ID0gYnVpbGRWaWV3O1xuZnVuY3Rpb24gZmluaXNoVmlldyh2aWV3LCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgdmlldy5hZnRlck5vZGVzKCk7XG4gICAgY3JlYXRlVmlld1RvcExldmVsU3RtdHModmlldywgdGFyZ2V0U3RhdGVtZW50cyk7XG4gICAgdmlldy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgY29tcGlsZV9lbGVtZW50XzEuQ29tcGlsZUVsZW1lbnQgJiYgbm9kZS5oYXNFbWJlZGRlZFZpZXcpIHtcbiAgICAgICAgICAgIGZpbmlzaFZpZXcobm9kZS5lbWJlZGRlZFZpZXcsIHRhcmdldFN0YXRlbWVudHMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmZpbmlzaFZpZXcgPSBmaW5pc2hWaWV3O1xudmFyIFZpZXdCdWlsZGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0J1aWxkZXJWaXNpdG9yKHZpZXcsIHRhcmdldERlcGVuZGVuY2llcykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRhcmdldERlcGVuZGVuY2llcyA9IHRhcmdldERlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5uZXN0ZWRWaWV3Q291bnQgPSAwO1xuICAgIH1cbiAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9pc1Jvb3ROb2RlID0gZnVuY3Rpb24gKHBhcmVudCkgeyByZXR1cm4gcGFyZW50LnZpZXcgIT09IHRoaXMudmlldzsgfTtcbiAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9hZGRSb290Tm9kZUFuZFByb2plY3QgPSBmdW5jdGlvbiAobm9kZSwgbmdDb250ZW50SW5kZXgsIHBhcmVudCkge1xuICAgICAgICB2YXIgdmNBcHBFbCA9IChub2RlIGluc3RhbmNlb2YgY29tcGlsZV9lbGVtZW50XzEuQ29tcGlsZUVsZW1lbnQgJiYgbm9kZS5oYXNWaWV3Q29udGFpbmVyKSA/IG5vZGUuYXBwRWxlbWVudCA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIGFwcEVsZW1lbnQgYXMgcm9vdCBub2RlIG9ubHkgZm9yIFZpZXdDb250YWluZXJzXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdUeXBlICE9PSBjb3JlX3ByaXZhdGVfMS5WaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50cy5wdXNoKGxhbmdfMS5pc1ByZXNlbnQodmNBcHBFbCkgPyB2Y0FwcEVsIDogbm9kZS5yZW5kZXJOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudC5jb21wb25lbnQpICYmIGxhbmdfMS5pc1ByZXNlbnQobmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICBwYXJlbnQuYWRkQ29udGVudE5vZGUobmdDb250ZW50SW5kZXgsIGxhbmdfMS5pc1ByZXNlbnQodmNBcHBFbCkgPyB2Y0FwcEVsIDogbm9kZS5yZW5kZXJOb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fZ2V0UGFyZW50UmVuZGVyTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy52aWV3VHlwZSA9PT0gY29yZV9wcml2YXRlXzEuVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFJlbmRlck5vZGVWYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByb290IG5vZGUgb2YgYW4gZW1iZWRkZWQvaG9zdCB2aWV3XG4gICAgICAgICAgICAgICAgcmV0dXJuIG8uTlVMTF9FWFBSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQocGFyZW50LmNvbXBvbmVudCkgJiZcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24gIT09IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUgP1xuICAgICAgICAgICAgICAgIG8uTlVMTF9FWFBSIDpcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVuZGVyTm9kZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0KGFzdCwgJycsIGFzdC5uZ0NvbnRlbnRJbmRleCwgcGFyZW50KTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdFRleHQoYXN0LCBhc3QudmFsdWUsIGFzdC5uZ0NvbnRlbnRJbmRleCwgcGFyZW50KTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl90ZXh0X1wiICsgdGhpcy52aWV3Lm5vZGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBvLkNsYXNzRmllbGQoZmllbGROYW1lLCBvLmltcG9ydFR5cGUodGhpcy52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJUZXh0KSkpO1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IG8uVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgdmFyIGNvbXBpbGVOb2RlID0gbmV3IGNvbXBpbGVfZWxlbWVudF8xLkNvbXBpbGVOb2RlKHBhcmVudCwgdGhpcy52aWV3LCB0aGlzLnZpZXcubm9kZXMubGVuZ3RoLCByZW5kZXJOb2RlLCBhc3QpO1xuICAgICAgICB2YXIgY3JlYXRlUmVuZGVyTm9kZSA9IG8uVEhJU19FWFBSLnByb3AoZmllbGROYW1lKVxuICAgICAgICAgICAgLnNldChjb25zdGFudHNfMS5WaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVUZXh0JywgW1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLFxuICAgICAgICAgICAgby5saXRlcmFsKHZhbHVlKSxcbiAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm9FeHByKHRoaXMudmlldy5ub2Rlcy5sZW5ndGgsIGFzdClcbiAgICAgICAgXSkpXG4gICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgIHRoaXMudmlldy5ub2Rlcy5wdXNoKGNvbXBpbGVOb2RlKTtcbiAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KGNyZWF0ZVJlbmRlck5vZGUpO1xuICAgICAgICB0aGlzLl9hZGRSb290Tm9kZUFuZFByb2plY3QoY29tcGlsZU5vZGUsIG5nQ29udGVudEluZGV4LCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVuZGVyTm9kZTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgLy8gdGhlIHByb2plY3RlZCBub2RlcyBvcmlnaW5hdGUgZnJvbSBhIGRpZmZlcmVudCB2aWV3LCBzbyB3ZSBkb24ndFxuICAgICAgICAvLyBoYXZlIGRlYnVnIGluZm9ybWF0aW9uIGZvciB0aGVtLi4uXG4gICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm8obnVsbCwgYXN0KTtcbiAgICAgICAgdmFyIHBhcmVudFJlbmRlck5vZGUgPSB0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCk7XG4gICAgICAgIHZhciBub2Rlc0V4cHJlc3Npb24gPSBjb25zdGFudHNfMS5WaWV3UHJvcGVydGllcy5wcm9qZWN0YWJsZU5vZGVzLmtleShvLmxpdGVyYWwoYXN0LmluZGV4KSwgbmV3IG8uQXJyYXlUeXBlKG8uaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlck5vZGUpKSk7XG4gICAgICAgIGlmIChwYXJlbnRSZW5kZXJOb2RlICE9PSBvLk5VTExfRVhQUikge1xuICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KGNvbnN0YW50c18xLlZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ3Byb2plY3ROb2RlcycsIFtcbiAgICAgICAgICAgICAgICBwYXJlbnRSZW5kZXJOb2RlLFxuICAgICAgICAgICAgICAgIG8uaW1wb3J0RXhwcihpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLmZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW25vZGVzRXhwcmVzc2lvbl0pXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdUeXBlICE9PSBjb3JlX3ByaXZhdGVfMS5WaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSByb290IG5vZGVzIG9ubHkgZm9yIGVtYmVkZGVkL2hvc3Qgdmlld3NcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50cy5wdXNoKG5vZGVzRXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJlbnQuY29tcG9uZW50KSAmJiBsYW5nXzEuaXNQcmVzZW50KGFzdC5uZ0NvbnRlbnRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ29udGVudE5vZGUoYXN0Lm5nQ29udGVudEluZGV4LCBub2Rlc0V4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMudmlldy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciBjcmVhdGVSZW5kZXJOb2RlRXhwcjtcbiAgICAgICAgdmFyIGRlYnVnQ29udGV4dEV4cHIgPSB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvRXhwcihub2RlSW5kZXgsIGFzdCk7XG4gICAgICAgIGlmIChub2RlSW5kZXggPT09IDAgJiYgdGhpcy52aWV3LnZpZXdUeXBlID09PSBjb3JlX3ByaXZhdGVfMS5WaWV3VHlwZS5IT1NUKSB7XG4gICAgICAgICAgICBjcmVhdGVSZW5kZXJOb2RlRXhwciA9IG8uVEhJU19FWFBSLmNhbGxNZXRob2QoJ3NlbGVjdE9yQ3JlYXRlSG9zdEVsZW1lbnQnLCBbby5saXRlcmFsKGFzdC5uYW1lKSwgcm9vdFNlbGVjdG9yVmFyLCBkZWJ1Z0NvbnRleHRFeHByXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVSZW5kZXJOb2RlRXhwciA9IGNvbnN0YW50c18xLlZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2NyZWF0ZUVsZW1lbnQnLCBbdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLCBvLmxpdGVyYWwoYXN0Lm5hbWUpLCBkZWJ1Z0NvbnRleHRFeHByXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IFwiX2VsX1wiICsgbm9kZUluZGV4O1xuICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IG8uQ2xhc3NGaWVsZChmaWVsZE5hbWUsIG8uaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlckVsZW1lbnQpKSk7XG4gICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChvLlRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSkuc2V0KGNyZWF0ZVJlbmRlck5vZGVFeHByKS50b1N0bXQoKSk7XG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gby5USElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGFzdC5kaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICB2YXIgaHRtbEF0dHJzID0gX3JlYWRIdG1sQXR0cnMoYXN0LmF0dHJzKTtcbiAgICAgICAgdmFyIGF0dHJOYW1lQW5kVmFsdWVzID0gX21lcmdlSHRtbEFuZERpcmVjdGl2ZUF0dHJzKGh0bWxBdHRycywgZGlyZWN0aXZlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0ck5hbWVBbmRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJOYW1lQW5kVmFsdWVzW2ldWzBdO1xuICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJOYW1lQW5kVmFsdWVzW2ldWzFdO1xuICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KGNvbnN0YW50c18xLlZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRBdHRyaWJ1dGUnLCBbcmVuZGVyTm9kZSwgby5saXRlcmFsKGF0dHJOYW1lKSwgby5saXRlcmFsKGF0dHJWYWx1ZSldKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBpbGVFbGVtZW50ID0gbmV3IGNvbXBpbGVfZWxlbWVudF8xLkNvbXBpbGVFbGVtZW50KHBhcmVudCwgdGhpcy52aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIGFzdCwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBhc3QucHJvdmlkZXJzLCBhc3QuaGFzVmlld0NvbnRhaW5lciwgZmFsc2UsIGFzdC5yZWZlcmVuY2VzKTtcbiAgICAgICAgdGhpcy52aWV3Lm5vZGVzLnB1c2goY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICB2YXIgY29tcFZpZXdFeHByID0gbnVsbDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcG9uZW50KSkge1xuICAgICAgICAgICAgdmFyIG5lc3RlZENvbXBvbmVudElkZW50aWZpZXIgPSBuZXcgY29tcGlsZV9tZXRhZGF0YV8xLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiB1dGlsXzEuZ2V0Vmlld0ZhY3RvcnlOYW1lKGNvbXBvbmVudCwgMCkgfSk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldERlcGVuZGVuY2llcy5wdXNoKG5ldyBWaWV3Q29tcGlsZURlcGVuZGVuY3koY29tcG9uZW50LCBuZXN0ZWRDb21wb25lbnRJZGVudGlmaWVyKSk7XG4gICAgICAgICAgICBjb21wVmlld0V4cHIgPSBvLnZhcmlhYmxlKFwiY29tcFZpZXdfXCIgKyBub2RlSW5kZXgpOyAvLyBmaXggaGlnaGxpZ2h0aW5nOiBgXG4gICAgICAgICAgICBjb21waWxlRWxlbWVudC5zZXRDb21wb25lbnRWaWV3KGNvbXBWaWV3RXhwcik7XG4gICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoY29tcFZpZXdFeHByLnNldChvLmltcG9ydEV4cHIobmVzdGVkQ29tcG9uZW50SWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICAuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBjb25zdGFudHNfMS5WaWV3UHJvcGVydGllcy52aWV3VXRpbHMsXG4gICAgICAgICAgICAgICAgY29tcGlsZUVsZW1lbnQuaW5qZWN0b3IsXG4gICAgICAgICAgICAgICAgY29tcGlsZUVsZW1lbnQuYXBwRWxlbWVudFxuICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGlsZUVsZW1lbnQuYmVmb3JlQ2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5fYWRkUm9vdE5vZGVBbmRQcm9qZWN0KGNvbXBpbGVFbGVtZW50LCBhc3QubmdDb250ZW50SW5kZXgsIHBhcmVudCk7XG4gICAgICAgIHRlbXBsYXRlX2FzdF8xLnRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgIGNvbXBpbGVFbGVtZW50LmFmdGVyQ2hpbGRyZW4odGhpcy52aWV3Lm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDEpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wVmlld0V4cHIpKSB7XG4gICAgICAgICAgICB2YXIgY29kZUdlbkNvbnRlbnROb2RlcztcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuY29tcG9uZW50LnR5cGUuaXNIb3N0KSB7XG4gICAgICAgICAgICAgICAgY29kZUdlbkNvbnRlbnROb2RlcyA9IGNvbnN0YW50c18xLlZpZXdQcm9wZXJ0aWVzLnByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlR2VuQ29udGVudE5vZGVzID0gby5saXRlcmFsQXJyKGNvbXBpbGVFbGVtZW50LmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXgubWFwKGZ1bmN0aW9uIChub2RlcykgeyByZXR1cm4gdXRpbF8xLmNyZWF0ZUZsYXRBcnJheShub2Rlcyk7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChjb21wVmlld0V4cHIuY2FsbE1ldGhvZCgnY3JlYXRlJywgW2NvbXBpbGVFbGVtZW50LmdldENvbXBvbmVudCgpLCBjb2RlR2VuQ29udGVudE5vZGVzLCBvLk5VTExfRVhQUl0pXG4gICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLnZpZXcubm9kZXMubGVuZ3RoO1xuICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfYW5jaG9yX1wiICsgbm9kZUluZGV4O1xuICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IG8uQ2xhc3NGaWVsZChmaWVsZE5hbWUsIG8uaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlckNvbW1lbnQpKSk7XG4gICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChvLlRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgIC5zZXQoY29uc3RhbnRzXzEuVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVGVtcGxhdGVBbmNob3InLCBbXG4gICAgICAgICAgICB0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksXG4gICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvRXhwcihub2RlSW5kZXgsIGFzdClcbiAgICAgICAgXSkpXG4gICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IG8uVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlVmFyaWFibGVCaW5kaW5ncyA9IGFzdC52YXJpYWJsZXMubWFwKGZ1bmN0aW9uICh2YXJBc3QpIHsgcmV0dXJuIFt2YXJBc3QudmFsdWUubGVuZ3RoID4gMCA/IHZhckFzdC52YWx1ZSA6IElNUExJQ0lUX1RFTVBMQVRFX1ZBUiwgdmFyQXN0Lm5hbWVdOyB9KTtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBhc3QuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IG5ldyBjb21waWxlX2VsZW1lbnRfMS5Db21waWxlRWxlbWVudChwYXJlbnQsIHRoaXMudmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBhc3QsIG51bGwsIGRpcmVjdGl2ZXMsIGFzdC5wcm92aWRlcnMsIGFzdC5oYXNWaWV3Q29udGFpbmVyLCB0cnVlLCBhc3QucmVmZXJlbmNlcyk7XG4gICAgICAgIHRoaXMudmlldy5ub2Rlcy5wdXNoKGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5uZXN0ZWRWaWV3Q291bnQrKztcbiAgICAgICAgdmFyIGVtYmVkZGVkVmlldyA9IG5ldyBjb21waWxlX3ZpZXdfMS5Db21waWxlVmlldyh0aGlzLnZpZXcuY29tcG9uZW50LCB0aGlzLnZpZXcuZ2VuQ29uZmlnLCB0aGlzLnZpZXcucGlwZU1ldGFzLCBvLk5VTExfRVhQUiwgdGhpcy52aWV3LnZpZXdJbmRleCArIHRoaXMubmVzdGVkVmlld0NvdW50LCBjb21waWxlRWxlbWVudCwgdGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzKTtcbiAgICAgICAgdGhpcy5uZXN0ZWRWaWV3Q291bnQgKz0gYnVpbGRWaWV3KGVtYmVkZGVkVmlldywgYXN0LmNoaWxkcmVuLCB0aGlzLnRhcmdldERlcGVuZGVuY2llcyk7XG4gICAgICAgIGNvbXBpbGVFbGVtZW50LmJlZm9yZUNoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuX2FkZFJvb3ROb2RlQW5kUHJvamVjdChjb21waWxlRWxlbWVudCwgYXN0Lm5nQ29udGVudEluZGV4LCBwYXJlbnQpO1xuICAgICAgICBjb21waWxlRWxlbWVudC5hZnRlckNoaWxkcmVuKDApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgZXZlbnRUYXJnZXRBbmROYW1lcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFZpZXdCdWlsZGVyVmlzaXRvcjtcbn0oKSk7XG5mdW5jdGlvbiBfbWVyZ2VIdG1sQW5kRGlyZWN0aXZlQXR0cnMoZGVjbGFyZWRIdG1sQXR0cnMsIGRpcmVjdGl2ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChkZWNsYXJlZEh0bWxBdHRycywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgcmVzdWx0W2tleV0gPSB2YWx1ZTsgfSk7XG4gICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVNZXRhKSB7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goZGlyZWN0aXZlTWV0YS5ob3N0QXR0cmlidXRlcywgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gcmVzdWx0W25hbWVdO1xuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gbGFuZ18xLmlzUHJlc2VudChwcmV2VmFsdWUpID8gbWVyZ2VBdHRyaWJ1dGVWYWx1ZShuYW1lLCBwcmV2VmFsdWUsIHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFwVG9LZXlWYWx1ZUFycmF5KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBfcmVhZEh0bWxBdHRycyhhdHRycykge1xuICAgIHZhciBodG1sQXR0cnMgPSB7fTtcbiAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHsgaHRtbEF0dHJzW2FzdC5uYW1lXSA9IGFzdC52YWx1ZTsgfSk7XG4gICAgcmV0dXJuIGh0bWxBdHRycztcbn1cbmZ1bmN0aW9uIG1lcmdlQXR0cmlidXRlVmFsdWUoYXR0ck5hbWUsIGF0dHJWYWx1ZTEsIGF0dHJWYWx1ZTIpIHtcbiAgICBpZiAoYXR0ck5hbWUgPT0gQ0xBU1NfQVRUUiB8fCBhdHRyTmFtZSA9PSBTVFlMRV9BVFRSKSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUxICsgXCIgXCIgKyBhdHRyVmFsdWUyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF0dHJWYWx1ZTI7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwVG9LZXlWYWx1ZUFycmF5KGRhdGEpIHtcbiAgICB2YXIgZW50cnlBcnJheSA9IFtdO1xuICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goZGF0YSwgZnVuY3Rpb24gKHZhbHVlLCBuYW1lKSB7IGVudHJ5QXJyYXkucHVzaChbbmFtZSwgdmFsdWVdKTsgfSk7XG4gICAgLy8gV2UgbmVlZCB0byBzb3J0IHRvIGdldCBhIGRlZmluZWQgb3V0cHV0IG9yZGVyXG4gICAgLy8gZm9yIHRlc3RzIGFuZCBmb3IgY2FjaGluZyBnZW5lcmF0ZWQgYXJ0aWZhY3RzLi4uXG4gICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnNvcnQoZW50cnlBcnJheSwgZnVuY3Rpb24gKGVudHJ5MSwgZW50cnkyKSB7IHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5jb21wYXJlKGVudHJ5MVswXSwgZW50cnkyWzBdKTsgfSk7XG4gICAgdmFyIGtleVZhbHVlQXJyYXkgPSBbXTtcbiAgICBlbnRyeUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IGtleVZhbHVlQXJyYXkucHVzaChbZW50cnlbMF0sIGVudHJ5WzFdXSk7IH0pO1xuICAgIHJldHVybiBrZXlWYWx1ZUFycmF5O1xufVxuZnVuY3Rpb24gY3JlYXRlVmlld1RvcExldmVsU3RtdHModmlldywgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgIHZhciBub2RlRGVidWdJbmZvc1ZhciA9IG8uTlVMTF9FWFBSO1xuICAgIGlmICh2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8pIHtcbiAgICAgICAgbm9kZURlYnVnSW5mb3NWYXIgPSBvLnZhcmlhYmxlKFwibm9kZURlYnVnSW5mb3NfXCIgKyB2aWV3LmNvbXBvbmVudC50eXBlLm5hbWUgKyB2aWV3LnZpZXdJbmRleCk7IC8vIGZpeCBoaWdobGlnaHRpbmc6IGBcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKG5vZGVEZWJ1Z0luZm9zVmFyXG4gICAgICAgICAgICAuc2V0KG8ubGl0ZXJhbEFycih2aWV3Lm5vZGVzLm1hcChjcmVhdGVTdGF0aWNOb2RlRGVidWdJbmZvKSwgbmV3IG8uQXJyYXlUeXBlKG5ldyBvLkV4dGVybmFsVHlwZShpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLlN0YXRpY05vZGVEZWJ1Z0luZm8pLCBbby5UeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbby5TdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgfVxuICAgIHZhciByZW5kZXJDb21wVHlwZVZhciA9IG8udmFyaWFibGUoXCJyZW5kZXJUeXBlX1wiICsgdmlldy5jb21wb25lbnQudHlwZS5uYW1lKTsgLy8gZml4IGhpZ2hsaWdodGluZzogYFxuICAgIGlmICh2aWV3LnZpZXdJbmRleCA9PT0gMCkge1xuICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2gocmVuZGVyQ29tcFR5cGVWYXIuc2V0KG8uTlVMTF9FWFBSKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQoby5pbXBvcnRUeXBlKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuUmVuZGVyQ29tcG9uZW50VHlwZSkpKTtcbiAgICB9XG4gICAgdmFyIHZpZXdDbGFzcyA9IGNyZWF0ZVZpZXdDbGFzcyh2aWV3LCByZW5kZXJDb21wVHlwZVZhciwgbm9kZURlYnVnSW5mb3NWYXIpO1xuICAgIHRhcmdldFN0YXRlbWVudHMucHVzaCh2aWV3Q2xhc3MpO1xuICAgIHRhcmdldFN0YXRlbWVudHMucHVzaChjcmVhdGVWaWV3RmFjdG9yeSh2aWV3LCB2aWV3Q2xhc3MsIHJlbmRlckNvbXBUeXBlVmFyKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNOb2RlRGVidWdJbmZvKG5vZGUpIHtcbiAgICB2YXIgY29tcGlsZUVsZW1lbnQgPSBub2RlIGluc3RhbmNlb2YgY29tcGlsZV9lbGVtZW50XzEuQ29tcGlsZUVsZW1lbnQgPyBub2RlIDogbnVsbDtcbiAgICB2YXIgcHJvdmlkZXJUb2tlbnMgPSBbXTtcbiAgICB2YXIgY29tcG9uZW50VG9rZW4gPSBvLk5VTExfRVhQUjtcbiAgICB2YXIgdmFyVG9rZW5FbnRyaWVzID0gW107XG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcGlsZUVsZW1lbnQpKSB7XG4gICAgICAgIHByb3ZpZGVyVG9rZW5zID0gY29tcGlsZUVsZW1lbnQuZ2V0UHJvdmlkZXJUb2tlbnMoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcGlsZUVsZW1lbnQuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgY29tcG9uZW50VG9rZW4gPSB1dGlsXzEuY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24oaWRlbnRpZmllcnNfMS5pZGVudGlmaWVyVG9rZW4oY29tcGlsZUVsZW1lbnQuY29tcG9uZW50LnR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGNvbXBpbGVFbGVtZW50LnJlZmVyZW5jZVRva2VucywgZnVuY3Rpb24gKHRva2VuLCB2YXJOYW1lKSB7XG4gICAgICAgICAgICB2YXJUb2tlbkVudHJpZXMucHVzaChbdmFyTmFtZSwgbGFuZ18xLmlzUHJlc2VudCh0b2tlbikgPyB1dGlsXzEuY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pIDogby5OVUxMX0VYUFJdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvLmltcG9ydEV4cHIoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvKVxuICAgICAgICAuaW5zdGFudGlhdGUoW1xuICAgICAgICBvLmxpdGVyYWxBcnIocHJvdmlkZXJUb2tlbnMsIG5ldyBvLkFycmF5VHlwZShvLkRZTkFNSUNfVFlQRSwgW28uVHlwZU1vZGlmaWVyLkNvbnN0XSkpLFxuICAgICAgICBjb21wb25lbnRUb2tlbixcbiAgICAgICAgby5saXRlcmFsTWFwKHZhclRva2VuRW50cmllcywgbmV3IG8uTWFwVHlwZShvLkRZTkFNSUNfVFlQRSwgW28uVHlwZU1vZGlmaWVyLkNvbnN0XSkpXG4gICAgXSwgby5pbXBvcnRUeXBlKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuU3RhdGljTm9kZURlYnVnSW5mbywgbnVsbCwgW28uVHlwZU1vZGlmaWVyLkNvbnN0XSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlVmlld0NsYXNzKHZpZXcsIHJlbmRlckNvbXBUeXBlVmFyLCBub2RlRGVidWdJbmZvc1Zhcikge1xuICAgIHZhciB2aWV3Q29uc3RydWN0b3JBcmdzID0gW1xuICAgICAgICBuZXcgby5GblBhcmFtKGNvbnN0YW50c18xLlZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzLm5hbWUsIG8uaW1wb3J0VHlwZShpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLlZpZXdVdGlscykpLFxuICAgICAgICBuZXcgby5GblBhcmFtKGNvbnN0YW50c18xLlZpZXdDb25zdHJ1Y3RvclZhcnMucGFyZW50SW5qZWN0b3IubmFtZSwgby5pbXBvcnRUeXBlKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuSW5qZWN0b3IpKSxcbiAgICAgICAgbmV3IG8uRm5QYXJhbShjb25zdGFudHNfMS5WaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwubmFtZSwgby5pbXBvcnRUeXBlKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuQXBwRWxlbWVudCkpXG4gICAgXTtcbiAgICB2YXIgc3VwZXJDb25zdHJ1Y3RvckFyZ3MgPSBbXG4gICAgICAgIG8udmFyaWFibGUodmlldy5jbGFzc05hbWUpLFxuICAgICAgICByZW5kZXJDb21wVHlwZVZhcixcbiAgICAgICAgY29uc3RhbnRzXzEuVmlld1R5cGVFbnVtLmZyb21WYWx1ZSh2aWV3LnZpZXdUeXBlKSxcbiAgICAgICAgY29uc3RhbnRzXzEuVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMsXG4gICAgICAgIGNvbnN0YW50c18xLlZpZXdDb25zdHJ1Y3RvclZhcnMucGFyZW50SW5qZWN0b3IsXG4gICAgICAgIGNvbnN0YW50c18xLlZpZXdDb25zdHJ1Y3RvclZhcnMuZGVjbGFyYXRpb25FbCxcbiAgICAgICAgY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lFbnVtLmZyb21WYWx1ZShnZXRDaGFuZ2VEZXRlY3Rpb25Nb2RlKHZpZXcpKVxuICAgIF07XG4gICAgaWYgKHZpZXcuZ2VuQ29uZmlnLmdlbkRlYnVnSW5mbykge1xuICAgICAgICBzdXBlckNvbnN0cnVjdG9yQXJncy5wdXNoKG5vZGVEZWJ1Z0luZm9zVmFyKTtcbiAgICB9XG4gICAgdmFyIHZpZXdDb25zdHJ1Y3RvciA9IG5ldyBvLkNsYXNzTWV0aG9kKG51bGwsIHZpZXdDb25zdHJ1Y3RvckFyZ3MsIFtvLlNVUEVSX0VYUFIuY2FsbEZuKHN1cGVyQ29uc3RydWN0b3JBcmdzKS50b1N0bXQoKV0pO1xuICAgIHZhciB2aWV3TWV0aG9kcyA9IFtcbiAgICAgICAgbmV3IG8uQ2xhc3NNZXRob2QoJ2NyZWF0ZUludGVybmFsJywgW25ldyBvLkZuUGFyYW0ocm9vdFNlbGVjdG9yVmFyLm5hbWUsIG8uU1RSSU5HX1RZUEUpXSwgZ2VuZXJhdGVDcmVhdGVNZXRob2QodmlldyksIG8uaW1wb3J0VHlwZShpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkFwcEVsZW1lbnQpKSxcbiAgICAgICAgbmV3IG8uQ2xhc3NNZXRob2QoJ2luamVjdG9yR2V0SW50ZXJuYWwnLCBbXG4gICAgICAgICAgICBuZXcgby5GblBhcmFtKGNvbnN0YW50c18xLkluamVjdE1ldGhvZFZhcnMudG9rZW4ubmFtZSwgby5EWU5BTUlDX1RZUEUpLFxuICAgICAgICAgICAgLy8gTm90ZTogQ2FuJ3QgdXNlIG8uSU5UX1RZUEUgaGVyZSBhcyB0aGUgbWV0aG9kIGluIEFwcFZpZXcgdXNlcyBudW1iZXJcbiAgICAgICAgICAgIG5ldyBvLkZuUGFyYW0oY29uc3RhbnRzXzEuSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4Lm5hbWUsIG8uTlVNQkVSX1RZUEUpLFxuICAgICAgICAgICAgbmV3IG8uRm5QYXJhbShjb25zdGFudHNfMS5JbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0Lm5hbWUsIG8uRFlOQU1JQ19UWVBFKVxuICAgICAgICBdLCBhZGRSZXR1cm5WYWx1ZWZOb3RFbXB0eSh2aWV3LmluamVjdG9yR2V0TWV0aG9kLmZpbmlzaCgpLCBjb25zdGFudHNfMS5JbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0KSwgby5EWU5BTUlDX1RZUEUpLFxuICAgICAgICBuZXcgby5DbGFzc01ldGhvZCgnZGV0ZWN0Q2hhbmdlc0ludGVybmFsJywgW25ldyBvLkZuUGFyYW0oY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZS5uYW1lLCBvLkJPT0xfVFlQRSldLCBnZW5lcmF0ZURldGVjdENoYW5nZXNNZXRob2QodmlldykpLFxuICAgICAgICBuZXcgby5DbGFzc01ldGhvZCgnZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwnLCBbXSwgdmlldy5kaXJ0eVBhcmVudFF1ZXJpZXNNZXRob2QuZmluaXNoKCkpLFxuICAgICAgICBuZXcgby5DbGFzc01ldGhvZCgnZGVzdHJveUludGVybmFsJywgW10sIHZpZXcuZGVzdHJveU1ldGhvZC5maW5pc2goKSlcbiAgICBdLmNvbmNhdCh2aWV3LmV2ZW50SGFuZGxlck1ldGhvZHMpO1xuICAgIHZhciBzdXBlckNsYXNzID0gdmlldy5nZW5Db25maWcuZ2VuRGVidWdJbmZvID8gaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5EZWJ1Z0FwcFZpZXcgOiBpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkFwcFZpZXc7XG4gICAgdmFyIHZpZXdDbGFzcyA9IG5ldyBvLkNsYXNzU3RtdCh2aWV3LmNsYXNzTmFtZSwgby5pbXBvcnRFeHByKHN1cGVyQ2xhc3MsIFtnZXRDb250ZXh0VHlwZSh2aWV3KV0pLCB2aWV3LmZpZWxkcywgdmlldy5nZXR0ZXJzLCB2aWV3Q29uc3RydWN0b3IsIHZpZXdNZXRob2RzLmZpbHRlcihmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBtZXRob2QuYm9keS5sZW5ndGggPiAwOyB9KSk7XG4gICAgcmV0dXJuIHZpZXdDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdGYWN0b3J5KHZpZXcsIHZpZXdDbGFzcywgcmVuZGVyQ29tcFR5cGVWYXIpIHtcbiAgICB2YXIgdmlld0ZhY3RvcnlBcmdzID0gW1xuICAgICAgICBuZXcgby5GblBhcmFtKGNvbnN0YW50c18xLlZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzLm5hbWUsIG8uaW1wb3J0VHlwZShpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLlZpZXdVdGlscykpLFxuICAgICAgICBuZXcgby5GblBhcmFtKGNvbnN0YW50c18xLlZpZXdDb25zdHJ1Y3RvclZhcnMucGFyZW50SW5qZWN0b3IubmFtZSwgby5pbXBvcnRUeXBlKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuSW5qZWN0b3IpKSxcbiAgICAgICAgbmV3IG8uRm5QYXJhbShjb25zdGFudHNfMS5WaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwubmFtZSwgby5pbXBvcnRUeXBlKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuQXBwRWxlbWVudCkpXG4gICAgXTtcbiAgICB2YXIgaW5pdFJlbmRlckNvbXBUeXBlU3RtdHMgPSBbXTtcbiAgICB2YXIgdGVtcGxhdGVVcmxJbmZvO1xuICAgIGlmICh2aWV3LmNvbXBvbmVudC50ZW1wbGF0ZS50ZW1wbGF0ZVVybCA9PSB2aWV3LmNvbXBvbmVudC50eXBlLm1vZHVsZVVybCkge1xuICAgICAgICB0ZW1wbGF0ZVVybEluZm8gPVxuICAgICAgICAgICAgdmlldy5jb21wb25lbnQudHlwZS5tb2R1bGVVcmwgKyBcIiBjbGFzcyBcIiArIHZpZXcuY29tcG9uZW50LnR5cGUubmFtZSArIFwiIC0gaW5saW5lIHRlbXBsYXRlXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZVVybEluZm8gPSB2aWV3LmNvbXBvbmVudC50ZW1wbGF0ZS50ZW1wbGF0ZVVybDtcbiAgICB9XG4gICAgaWYgKHZpZXcudmlld0luZGV4ID09PSAwKSB7XG4gICAgICAgIGluaXRSZW5kZXJDb21wVHlwZVN0bXRzID0gW1xuICAgICAgICAgICAgbmV3IG8uSWZTdG10KHJlbmRlckNvbXBUeXBlVmFyLmlkZW50aWNhbChvLk5VTExfRVhQUiksIFtcbiAgICAgICAgICAgICAgICByZW5kZXJDb21wVHlwZVZhci5zZXQoY29uc3RhbnRzXzEuVmlld0NvbnN0cnVjdG9yVmFyc1xuICAgICAgICAgICAgICAgICAgICAudmlld1V0aWxzLmNhbGxNZXRob2QoJ2NyZWF0ZVJlbmRlckNvbXBvbmVudFR5cGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIG8ubGl0ZXJhbCh0ZW1wbGF0ZVVybEluZm8pLFxuICAgICAgICAgICAgICAgICAgICBvLmxpdGVyYWwodmlldy5jb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzXzEuVmlld0VuY2Fwc3VsYXRpb25FbnVtXG4gICAgICAgICAgICAgICAgICAgICAgICAuZnJvbVZhbHVlKHZpZXcuY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB2aWV3LnN0eWxlc1xuICAgICAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAgICAgICAudG9TdG10KClcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBvLmZuKHZpZXdGYWN0b3J5QXJncywgaW5pdFJlbmRlckNvbXBUeXBlU3RtdHMuY29uY2F0KFtcbiAgICAgICAgbmV3IG8uUmV0dXJuU3RhdGVtZW50KG8udmFyaWFibGUodmlld0NsYXNzLm5hbWUpXG4gICAgICAgICAgICAuaW5zdGFudGlhdGUodmlld0NsYXNzLmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBvLnZhcmlhYmxlKHBhcmFtLm5hbWUpOyB9KSkpXG4gICAgXSksIG8uaW1wb3J0VHlwZShpZGVudGlmaWVyc18xLklkZW50aWZpZXJzLkFwcFZpZXcsIFtnZXRDb250ZXh0VHlwZSh2aWV3KV0pKVxuICAgICAgICAudG9EZWNsU3RtdCh2aWV3LnZpZXdGYWN0b3J5Lm5hbWUsIFtvLlN0bXRNb2RpZmllci5GaW5hbF0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDcmVhdGVNZXRob2Qodmlldykge1xuICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlRXhwciA9IG8uTlVMTF9FWFBSO1xuICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlU3RtdHMgPSBbXTtcbiAgICBpZiAodmlldy52aWV3VHlwZSA9PT0gY29yZV9wcml2YXRlXzEuVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgIHBhcmVudFJlbmRlck5vZGVFeHByID0gY29uc3RhbnRzXzEuVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVmlld1Jvb3QnLCBbby5USElTX0VYUFIucHJvcCgnZGVjbGFyYXRpb25BcHBFbGVtZW50JykucHJvcCgnbmF0aXZlRWxlbWVudCcpXSk7XG4gICAgICAgIHBhcmVudFJlbmRlck5vZGVTdG10cyA9IFtcbiAgICAgICAgICAgIHBhcmVudFJlbmRlck5vZGVWYXIuc2V0KHBhcmVudFJlbmRlck5vZGVFeHByKVxuICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG8uaW1wb3J0VHlwZSh2aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJOb2RlKSwgW28uU3RtdE1vZGlmaWVyLkZpbmFsXSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdEV4cHI7XG4gICAgaWYgKHZpZXcudmlld1R5cGUgPT09IGNvcmVfcHJpdmF0ZV8xLlZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgcmVzdWx0RXhwciA9IHZpZXcubm9kZXNbMF0uYXBwRWxlbWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdEV4cHIgPSBvLk5VTExfRVhQUjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudFJlbmRlck5vZGVTdG10cy5jb25jYXQodmlldy5jcmVhdGVNZXRob2QuZmluaXNoKCkpXG4gICAgICAgIC5jb25jYXQoW1xuICAgICAgICBvLlRISVNfRVhQUi5jYWxsTWV0aG9kKCdpbml0JywgW1xuICAgICAgICAgICAgdXRpbF8xLmNyZWF0ZUZsYXRBcnJheSh2aWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHMpLFxuICAgICAgICAgICAgby5saXRlcmFsQXJyKHZpZXcubm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnJlbmRlck5vZGU7IH0pKSxcbiAgICAgICAgICAgIG8ubGl0ZXJhbEFycih2aWV3LmRpc3Bvc2FibGVzKSxcbiAgICAgICAgICAgIG8ubGl0ZXJhbEFycih2aWV3LnN1YnNjcmlwdGlvbnMpXG4gICAgICAgIF0pXG4gICAgICAgICAgICAudG9TdG10KCksXG4gICAgICAgIG5ldyBvLlJldHVyblN0YXRlbWVudChyZXN1bHRFeHByKVxuICAgIF0pO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVEZXRlY3RDaGFuZ2VzTWV0aG9kKHZpZXcpIHtcbiAgICB2YXIgc3RtdHMgPSBbXTtcbiAgICBpZiAodmlldy5kZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuaXNFbXB0eSgpICYmIHZpZXcudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QuaXNFbXB0eSgpICYmXG4gICAgICAgIHZpZXcuYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmlzRW1wdHkoKSAmJlxuICAgICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLmlzRW1wdHkoKSAmJlxuICAgICAgICB2aWV3LnVwZGF0ZVZpZXdRdWVyaWVzTWV0aG9kLmlzRW1wdHkoKSAmJiB2aWV3LmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIHN0bXRzO1xuICAgIH1cbiAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuYWRkQWxsKHN0bXRzLCB2aWV3LmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZC5maW5pc2goKSk7XG4gICAgc3RtdHMucHVzaChvLlRISVNfRVhQUi5jYWxsTWV0aG9kKCdkZXRlY3RDb250ZW50Q2hpbGRyZW5DaGFuZ2VzJywgW2NvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdKVxuICAgICAgICAudG9TdG10KCkpO1xuICAgIHZhciBhZnRlckNvbnRlbnRTdG10cyA9IHZpZXcudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QuZmluaXNoKCkuY29uY2F0KHZpZXcuYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmZpbmlzaCgpKTtcbiAgICBpZiAoYWZ0ZXJDb250ZW50U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG10cy5wdXNoKG5ldyBvLklmU3RtdChvLm5vdChjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlKSwgYWZ0ZXJDb250ZW50U3RtdHMpKTtcbiAgICB9XG4gICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmFkZEFsbChzdG10cywgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5maW5pc2goKSk7XG4gICAgc3RtdHMucHVzaChvLlRISVNfRVhQUi5jYWxsTWV0aG9kKCdkZXRlY3RWaWV3Q2hpbGRyZW5DaGFuZ2VzJywgW2NvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdKVxuICAgICAgICAudG9TdG10KCkpO1xuICAgIHZhciBhZnRlclZpZXdTdG10cyA9IHZpZXcudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QuZmluaXNoKCkuY29uY2F0KHZpZXcuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmZpbmlzaCgpKTtcbiAgICBpZiAoYWZ0ZXJWaWV3U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdG10cy5wdXNoKG5ldyBvLklmU3RtdChvLm5vdChjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlKSwgYWZ0ZXJWaWV3U3RtdHMpKTtcbiAgICB9XG4gICAgdmFyIHZhclN0bXRzID0gW107XG4gICAgdmFyIHJlYWRWYXJzID0gby5maW5kUmVhZFZhck5hbWVzKHN0bXRzKTtcbiAgICBpZiAoY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKHJlYWRWYXJzLCBjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLm5hbWUpKSB7XG4gICAgICAgIHZhclN0bXRzLnB1c2goY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlZC5zZXQoby5saXRlcmFsKHRydWUpKS50b0RlY2xTdG10KG8uQk9PTF9UWVBFKSk7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5oYXMocmVhZFZhcnMsIGNvbnN0YW50c18xLkRldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMubmFtZSkpIHtcbiAgICAgICAgdmFyU3RtdHMucHVzaChjb25zdGFudHNfMS5EZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VzLnNldChvLk5VTExfRVhQUilcbiAgICAgICAgICAgIC50b0RlY2xTdG10KG5ldyBvLk1hcFR5cGUoby5pbXBvcnRUeXBlKGlkZW50aWZpZXJzXzEuSWRlbnRpZmllcnMuU2ltcGxlQ2hhbmdlKSkpKTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb25fMS5TZXRXcmFwcGVyLmhhcyhyZWFkVmFycywgY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyLm5hbWUpKSB7XG4gICAgICAgIHZhclN0bXRzLnB1c2goY29uc3RhbnRzXzEuRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyLnNldChvLmltcG9ydEV4cHIoaWRlbnRpZmllcnNfMS5JZGVudGlmaWVycy5WYWx1ZVVud3JhcHBlcikuaW5zdGFudGlhdGUoW10pKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW28uU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFyU3RtdHMuY29uY2F0KHN0bXRzKTtcbn1cbmZ1bmN0aW9uIGFkZFJldHVyblZhbHVlZk5vdEVtcHR5KHN0YXRlbWVudHMsIHZhbHVlKSB7XG4gICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RhdGVtZW50cy5jb25jYXQoW25ldyBvLlJldHVyblN0YXRlbWVudCh2YWx1ZSldKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbnRleHRUeXBlKHZpZXcpIHtcbiAgICBpZiAodmlldy52aWV3VHlwZSA9PT0gY29yZV9wcml2YXRlXzEuVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgIHJldHVybiBvLmltcG9ydFR5cGUodmlldy5jb21wb25lbnQudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBvLkRZTkFNSUNfVFlQRTtcbn1cbmZ1bmN0aW9uIGdldENoYW5nZURldGVjdGlvbk1vZGUodmlldykge1xuICAgIHZhciBtb2RlO1xuICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBjb3JlX3ByaXZhdGVfMS5WaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgbW9kZSA9IGNvcmVfcHJpdmF0ZV8xLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5KHZpZXcuY29tcG9uZW50LmNoYW5nZURldGVjdGlvbikgP1xuICAgICAgICAgICAgY29yZV8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzIDpcbiAgICAgICAgICAgIGNvcmVfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja09uY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtb2RlID0gY29yZV8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfYnVpbGRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgY29tcGlsZV9lbGVtZW50XzEgPSByZXF1aXJlKCcuL2NvbXBpbGVfZWxlbWVudCcpO1xudmFyIGNvbXBpbGVfdmlld18xID0gcmVxdWlyZSgnLi9jb21waWxlX3ZpZXcnKTtcbnZhciB2aWV3X2J1aWxkZXJfMSA9IHJlcXVpcmUoJy4vdmlld19idWlsZGVyJyk7XG52YXIgdmlld19iaW5kZXJfMSA9IHJlcXVpcmUoJy4vdmlld19iaW5kZXInKTtcbnZhciBjb25maWdfMSA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xudmFyIFZpZXdDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCB2aWV3RmFjdG9yeVZhciwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgIHRoaXMudmlld0ZhY3RvcnlWYXIgPSB2aWV3RmFjdG9yeVZhcjtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29tcGlsZVJlc3VsdDtcbn0oKSk7XG5leHBvcnRzLlZpZXdDb21waWxlUmVzdWx0ID0gVmlld0NvbXBpbGVSZXN1bHQ7XG52YXIgVmlld0NvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZXIoX2dlbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9nZW5Db25maWcgPSBfZ2VuQ29uZmlnO1xuICAgIH1cbiAgICBWaWV3Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgc3R5bGVzLCBwaXBlcykge1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IGNvbXBpbGVfdmlld18xLkNvbXBpbGVWaWV3KGNvbXBvbmVudCwgdGhpcy5fZ2VuQ29uZmlnLCBwaXBlcywgc3R5bGVzLCAwLCBjb21waWxlX2VsZW1lbnRfMS5Db21waWxlRWxlbWVudC5jcmVhdGVOdWxsKCksIFtdKTtcbiAgICAgICAgdmlld19idWlsZGVyXzEuYnVpbGRWaWV3KHZpZXcsIHRlbXBsYXRlLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICAvLyBOZWVkIHRvIHNlcGFyYXRlIGJpbmRpbmcgZnJvbSBjcmVhdGlvbiB0byBiZSBhYmxlIHRvIHJlZmVyIHRvXG4gICAgICAgIC8vIHZhcmlhYmxlcyB0aGF0IGhhdmUgYmVlbiBkZWNsYXJlZCBhZnRlciB1c2FnZS5cbiAgICAgICAgdmlld19iaW5kZXJfMS5iaW5kVmlldyh2aWV3LCB0ZW1wbGF0ZSk7XG4gICAgICAgIHZpZXdfYnVpbGRlcl8xLmZpbmlzaFZpZXcodmlldywgc3RhdGVtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlldy52aWV3RmFjdG9yeS5uYW1lLCBkZXBlbmRlbmNpZXMpO1xuICAgIH07XG4gICAgVmlld0NvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIFZpZXdDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb25maWdfMS5Db21waWxlckNvbmZpZywgfSxcbiAgICBdO1xuICAgIHJldHVybiBWaWV3Q29tcGlsZXI7XG59KCkpO1xuZXhwb3J0cy5WaWV3Q29tcGlsZXIgPSBWaWV3Q29tcGlsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3X2NvbXBpbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uL2NvcmVfcHJpdmF0ZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIFZpZXdSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld1Jlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KF9yZWZsZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gY29yZV8xLnJlZmxlY3RvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWaWV3UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fY2FjaGUuZ2V0KGNvbXBvbmVudCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3KSkge1xuICAgICAgICAgICAgdmlldyA9IHRoaXMuX3Jlc29sdmUoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLnNldChjb21wb25lbnQsIHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFZpZXdSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjb21wTWV0YTtcbiAgICAgICAgdmFyIHZpZXdNZXRhO1xuICAgICAgICB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMoY29tcG9uZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAobSBpbnN0YW5jZW9mIGNvcmVfMS5WaWV3TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB2aWV3TWV0YSA9IG07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobSBpbnN0YW5jZW9mIGNvcmVfMS5Db21wb25lbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbXBNZXRhID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhKSkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbXBNZXRhLnRlbXBsYXRlKSAmJiBsYW5nXzEuaXNCbGFuayhjb21wTWV0YS50ZW1wbGF0ZVVybCkgJiYgbGFuZ18xLmlzQmxhbmsodmlld01ldGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50ICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoY29tcG9uZW50KSArIFwiJyBtdXN0IGhhdmUgZWl0aGVyICd0ZW1wbGF0ZScgb3IgJ3RlbXBsYXRlVXJsJyBzZXQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YS50ZW1wbGF0ZSkgJiYgbGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJ0ZW1wbGF0ZVwiLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YS50ZW1wbGF0ZVVybCkgJiYgbGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJ0ZW1wbGF0ZVVybFwiLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChjb21wTWV0YS5kaXJlY3RpdmVzKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93TWl4aW5nVmlld0FuZENvbXBvbmVudChcImRpcmVjdGl2ZXNcIiwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEucGlwZXMpICYmIGxhbmdfMS5pc1ByZXNlbnQodmlld01ldGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dNaXhpbmdWaWV3QW5kQ29tcG9uZW50KFwicGlwZXNcIiwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEuZW5jYXBzdWxhdGlvbikgJiYgbGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJlbmNhcHN1bGF0aW9uXCIsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KGNvbXBNZXRhLnN0eWxlcykgJiYgbGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd01peGluZ1ZpZXdBbmRDb21wb25lbnQoXCJzdHlsZXNcIiwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY29tcE1ldGEuc3R5bGVVcmxzKSAmJiBsYW5nXzEuaXNQcmVzZW50KHZpZXdNZXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93TWl4aW5nVmlld0FuZENvbXBvbmVudChcInN0eWxlVXJsc1wiLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudCh2aWV3TWV0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlld01ldGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvcmVfMS5WaWV3TWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogY29tcE1ldGEudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBjb21wTWV0YS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogY29tcE1ldGEuZGlyZWN0aXZlcyxcbiAgICAgICAgICAgICAgICAgICAgcGlwZXM6IGNvbXBNZXRhLnBpcGVzLFxuICAgICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBjb21wTWV0YS5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGNvbXBNZXRhLnN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBjb21wTWV0YS5zdHlsZVVybHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayh2aWV3TWV0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGNvbXBvbmVudCkgKyBcIicgYmVjYXVzZSBpdCBpcyBub3QgYSBjb21wb25lbnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdNZXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFZpZXdSZXNvbHZlci5wcm90b3R5cGUuX3Rocm93TWl4aW5nVmlld0FuZENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGNvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJDb21wb25lbnQgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShjb21wb25lbnQpICsgXCInIGNhbm5vdCBoYXZlIGJvdGggJ1wiICsgcHJvcGVydHlOYW1lICsgXCInIGFuZCAnQFZpZXcnIHNldCBhdCB0aGUgc2FtZSB0aW1lXFxcIlwiKTtcbiAgICB9O1xuICAgIFZpZXdSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBWaWV3UmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV9wcml2YXRlXzEuUmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIFZpZXdSZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLlZpZXdSZXNvbHZlciA9IFZpZXdSZXNvbHZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdfcmVzb2x2ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUT0RPOiB2c2F2a2luIHJlbmFtZSBpdCBpbnRvIFRlbXBsYXRlTG9hZGVyXG4vKipcbiAqIEFuIGludGVyZmFjZSBmb3IgcmV0cmlldmluZyBkb2N1bWVudHMgYnkgVVJMIHRoYXQgdGhlIGNvbXBpbGVyIHVzZXNcbiAqIHRvIGxvYWQgdGVtcGxhdGVzLlxuICovXG52YXIgWEhSID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYSFIoKSB7XG4gICAgfVxuICAgIFhIUi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gWEhSO1xufSgpKTtcbmV4cG9ydHMuWEhSID0gWEhSO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbi8qKlxuKiBAbW9kdWxlXG4qIEBkZXNjcmlwdGlvblxuKiBTdGFydGluZyBwb2ludCB0byBpbXBvcnQgYWxsIHB1YmxpYyBjb3JlIEFQSXMuXG4qL1xuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvbWV0YWRhdGEnKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy91dGlsJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvZGknKSk7XG52YXIgYXBwbGljYXRpb25fcmVmXzEgPSByZXF1aXJlKCcuL3NyYy9hcHBsaWNhdGlvbl9yZWYnKTtcbmV4cG9ydHMuY3JlYXRlUGxhdGZvcm0gPSBhcHBsaWNhdGlvbl9yZWZfMS5jcmVhdGVQbGF0Zm9ybTtcbmV4cG9ydHMuYXNzZXJ0UGxhdGZvcm0gPSBhcHBsaWNhdGlvbl9yZWZfMS5hc3NlcnRQbGF0Zm9ybTtcbmV4cG9ydHMuZGlzcG9zZVBsYXRmb3JtID0gYXBwbGljYXRpb25fcmVmXzEuZGlzcG9zZVBsYXRmb3JtO1xuZXhwb3J0cy5nZXRQbGF0Zm9ybSA9IGFwcGxpY2F0aW9uX3JlZl8xLmdldFBsYXRmb3JtO1xuZXhwb3J0cy5jb3JlQm9vdHN0cmFwID0gYXBwbGljYXRpb25fcmVmXzEuY29yZUJvb3RzdHJhcDtcbmV4cG9ydHMuY29yZUxvYWRBbmRCb290c3RyYXAgPSBhcHBsaWNhdGlvbl9yZWZfMS5jb3JlTG9hZEFuZEJvb3RzdHJhcDtcbmV4cG9ydHMuY3JlYXRlTmdab25lID0gYXBwbGljYXRpb25fcmVmXzEuY3JlYXRlTmdab25lO1xuZXhwb3J0cy5QbGF0Zm9ybVJlZiA9IGFwcGxpY2F0aW9uX3JlZl8xLlBsYXRmb3JtUmVmO1xuZXhwb3J0cy5BcHBsaWNhdGlvblJlZiA9IGFwcGxpY2F0aW9uX3JlZl8xLkFwcGxpY2F0aW9uUmVmO1xudmFyIGFwcGxpY2F0aW9uX3Rva2Vuc18xID0gcmVxdWlyZSgnLi9zcmMvYXBwbGljYXRpb25fdG9rZW5zJyk7XG5leHBvcnRzLkFQUF9JRCA9IGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9JRDtcbmV4cG9ydHMuQVBQX0lOSVRJQUxJWkVSID0gYXBwbGljYXRpb25fdG9rZW5zXzEuQVBQX0lOSVRJQUxJWkVSO1xuZXhwb3J0cy5QQUNLQUdFX1JPT1RfVVJMID0gYXBwbGljYXRpb25fdG9rZW5zXzEuUEFDS0FHRV9ST09UX1VSTDtcbmV4cG9ydHMuUExBVEZPUk1fSU5JVElBTElaRVIgPSBhcHBsaWNhdGlvbl90b2tlbnNfMS5QTEFURk9STV9JTklUSUFMSVpFUjtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL3pvbmUnKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9yZW5kZXInKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9saW5rZXInKSk7XG52YXIgZGVidWdfbm9kZV8xID0gcmVxdWlyZSgnLi9zcmMvZGVidWcvZGVidWdfbm9kZScpO1xuZXhwb3J0cy5EZWJ1Z0VsZW1lbnQgPSBkZWJ1Z19ub2RlXzEuRGVidWdFbGVtZW50O1xuZXhwb3J0cy5EZWJ1Z05vZGUgPSBkZWJ1Z19ub2RlXzEuRGVidWdOb2RlO1xuZXhwb3J0cy5hc05hdGl2ZUVsZW1lbnRzID0gZGVidWdfbm9kZV8xLmFzTmF0aXZlRWxlbWVudHM7XG5leHBvcnRzLmdldERlYnVnTm9kZSA9IGRlYnVnX25vZGVfMS5nZXREZWJ1Z05vZGU7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy90ZXN0YWJpbGl0eS90ZXN0YWJpbGl0eScpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL2NoYW5nZV9kZXRlY3Rpb24nKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9wbGF0Zm9ybV9kaXJlY3RpdmVzX2FuZF9waXBlcycpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc3JjL3BsYXRmb3JtX2NvbW1vbl9wcm92aWRlcnMnKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NyYy9hcHBsaWNhdGlvbl9jb21tb25fcHJvdmlkZXJzJykpO1xuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvcmVmbGVjdGlvbi9yZWZsZWN0aW9uJykpO1xudmFyIHByb2ZpbGVfMSA9IHJlcXVpcmUoJy4vc3JjL3Byb2ZpbGUvcHJvZmlsZScpO1xuZXhwb3J0cy53dGZDcmVhdGVTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZTtcbmV4cG9ydHMud3RmTGVhdmUgPSBwcm9maWxlXzEud3RmTGVhdmU7XG5leHBvcnRzLnd0ZlN0YXJ0VGltZVJhbmdlID0gcHJvZmlsZV8xLnd0ZlN0YXJ0VGltZVJhbmdlO1xuZXhwb3J0cy53dGZFbmRUaW1lUmFuZ2UgPSBwcm9maWxlXzEud3RmRW5kVGltZVJhbmdlO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoXCIuL3NyYy9mYWNhZGUvbGFuZ1wiKTtcbmV4cG9ydHMuVHlwZSA9IGxhbmdfMS5UeXBlO1xuZXhwb3J0cy5lbmFibGVQcm9kTW9kZSA9IGxhbmdfMS5lbmFibGVQcm9kTW9kZTtcbnZhciBhc3luY18xID0gcmVxdWlyZShcIi4vc3JjL2ZhY2FkZS9hc3luY1wiKTtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gYXN5bmNfMS5FdmVudEVtaXR0ZXI7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zXCIpO1xuZXhwb3J0cy5FeGNlcHRpb25IYW5kbGVyID0gZXhjZXB0aW9uc18xLkV4Y2VwdGlvbkhhbmRsZXI7XG5leHBvcnRzLldyYXBwZWRFeGNlcHRpb24gPSBleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbjtcbmV4cG9ydHMuQmFzZUV4Y2VwdGlvbiA9IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uO1xuX19leHBvcnQocmVxdWlyZSgnLi9wcml2YXRlX2V4cG9ydCcpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vc3JjL2NoYW5nZV9kZXRlY3Rpb24vY29uc3RhbnRzJyk7XG52YXIgc2VjdXJpdHkgPSByZXF1aXJlKCcuL3NyYy9zZWN1cml0eScpO1xudmFyIHJlZmxlY3RpdmVfcHJvdmlkZXIgPSByZXF1aXJlKCcuL3NyYy9kaS9yZWZsZWN0aXZlX3Byb3ZpZGVyJyk7XG52YXIgbGlmZWN5Y2xlX2hvb2tzID0gcmVxdWlyZSgnLi9zcmMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzJyk7XG52YXIgcmVmbGVjdG9yX3JlYWRlciA9IHJlcXVpcmUoJy4vc3JjL3JlZmxlY3Rpb24vcmVmbGVjdG9yX3JlYWRlcicpO1xudmFyIGNvbXBvbmVudF9yZXNvbHZlciA9IHJlcXVpcmUoJy4vc3JjL2xpbmtlci9jb21wb25lbnRfcmVzb2x2ZXInKTtcbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi9zcmMvbGlua2VyL2VsZW1lbnQnKTtcbnZhciB2aWV3ID0gcmVxdWlyZSgnLi9zcmMvbGlua2VyL3ZpZXcnKTtcbnZhciB2aWV3X3R5cGUgPSByZXF1aXJlKCcuL3NyYy9saW5rZXIvdmlld190eXBlJyk7XG52YXIgdmlld191dGlscyA9IHJlcXVpcmUoJy4vc3JjL2xpbmtlci92aWV3X3V0aWxzJyk7XG52YXIgbWV0YWRhdGFfdmlldyA9IHJlcXVpcmUoJy4vc3JjL21ldGFkYXRhL3ZpZXcnKTtcbnZhciBkZWJ1Z19jb250ZXh0ID0gcmVxdWlyZSgnLi9zcmMvbGlua2VyL2RlYnVnX2NvbnRleHQnKTtcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWwgPSByZXF1aXJlKCcuL3NyYy9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb25fdXRpbCcpO1xudmFyIGFwaSA9IHJlcXVpcmUoJy4vc3JjL3JlbmRlci9hcGknKTtcbnZhciB0ZW1wbGF0ZV9yZWYgPSByZXF1aXJlKCcuL3NyYy9saW5rZXIvdGVtcGxhdGVfcmVmJyk7XG52YXIgd3RmX2luaXQgPSByZXF1aXJlKCcuL3NyYy9wcm9maWxlL3d0Zl9pbml0Jyk7XG52YXIgcmVmbGVjdGlvbl9jYXBhYmlsaXRpZXMgPSByZXF1aXJlKCcuL3NyYy9yZWZsZWN0aW9uL3JlZmxlY3Rpb25fY2FwYWJpbGl0aWVzJyk7XG52YXIgZGVjb3JhdG9ycyA9IHJlcXVpcmUoJy4vc3JjL3V0aWwvZGVjb3JhdG9ycycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9zcmMvZGVidWcvZGVidWdfcmVuZGVyZXInKTtcbnZhciBwcm92aWRlcl91dGlsID0gcmVxdWlyZSgnLi9zcmMvZGkvcHJvdmlkZXJfdXRpbCcpO1xudmFyIGNvbnNvbGUgPSByZXF1aXJlKCcuL3NyYy9jb25zb2xlJyk7XG5leHBvcnRzLl9fY29yZV9wcml2YXRlX18gPSB7XG4gICAgaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k6IGNvbnN0YW50cy5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclN0YXRlOiBjb25zdGFudHMuQ2hhbmdlRGV0ZWN0b3JTdGF0ZSxcbiAgICBDSEFOR0VfREVURUNUSU9OX1NUUkFURUdZX1ZBTFVFUzogY29uc3RhbnRzLkNIQU5HRV9ERVRFQ1RJT05fU1RSQVRFR1lfVkFMVUVTLFxuICAgIGNvbnN0cnVjdERlcGVuZGVuY2llczogcmVmbGVjdGl2ZV9wcm92aWRlci5jb25zdHJ1Y3REZXBlbmRlbmNpZXMsXG4gICAgTGlmZWN5Y2xlSG9va3M6IGxpZmVjeWNsZV9ob29rcy5MaWZlY3ljbGVIb29rcyxcbiAgICBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTOiBsaWZlY3ljbGVfaG9va3MuTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUyxcbiAgICBSZWZsZWN0b3JSZWFkZXI6IHJlZmxlY3Rvcl9yZWFkZXIuUmVmbGVjdG9yUmVhZGVyLFxuICAgIFJlZmxlY3RvckNvbXBvbmVudFJlc29sdmVyOiBjb21wb25lbnRfcmVzb2x2ZXIuUmVmbGVjdG9yQ29tcG9uZW50UmVzb2x2ZXIsXG4gICAgQXBwRWxlbWVudDogZWxlbWVudC5BcHBFbGVtZW50LFxuICAgIEFwcFZpZXc6IHZpZXcuQXBwVmlldyxcbiAgICBEZWJ1Z0FwcFZpZXc6IHZpZXcuRGVidWdBcHBWaWV3LFxuICAgIFZpZXdUeXBlOiB2aWV3X3R5cGUuVmlld1R5cGUsXG4gICAgTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTOiB2aWV3X3V0aWxzLk1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUyxcbiAgICBjaGVja0JpbmRpbmc6IHZpZXdfdXRpbHMuY2hlY2tCaW5kaW5nLFxuICAgIGZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXM6IHZpZXdfdXRpbHMuZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcyxcbiAgICBpbnRlcnBvbGF0ZTogdmlld191dGlscy5pbnRlcnBvbGF0ZSxcbiAgICBWaWV3VXRpbHM6IHZpZXdfdXRpbHMuVmlld1V0aWxzLFxuICAgIFZJRVdfRU5DQVBTVUxBVElPTl9WQUxVRVM6IG1ldGFkYXRhX3ZpZXcuVklFV19FTkNBUFNVTEFUSU9OX1ZBTFVFUyxcbiAgICBEZWJ1Z0NvbnRleHQ6IGRlYnVnX2NvbnRleHQuRGVidWdDb250ZXh0LFxuICAgIFN0YXRpY05vZGVEZWJ1Z0luZm86IGRlYnVnX2NvbnRleHQuU3RhdGljTm9kZURlYnVnSW5mbyxcbiAgICBkZXZNb2RlRXF1YWw6IGNoYW5nZV9kZXRlY3Rpb25fdXRpbC5kZXZNb2RlRXF1YWwsXG4gICAgdW5pbml0aWFsaXplZDogY2hhbmdlX2RldGVjdGlvbl91dGlsLnVuaW5pdGlhbGl6ZWQsXG4gICAgVmFsdWVVbndyYXBwZXI6IGNoYW5nZV9kZXRlY3Rpb25fdXRpbC5WYWx1ZVVud3JhcHBlcixcbiAgICBSZW5kZXJEZWJ1Z0luZm86IGFwaS5SZW5kZXJEZWJ1Z0luZm8sXG4gICAgU2VjdXJpdHlDb250ZXh0OiBzZWN1cml0eS5TZWN1cml0eUNvbnRleHQsXG4gICAgU2FuaXRpemF0aW9uU2VydmljZTogc2VjdXJpdHkuU2FuaXRpemF0aW9uU2VydmljZSxcbiAgICBUZW1wbGF0ZVJlZl86IHRlbXBsYXRlX3JlZi5UZW1wbGF0ZVJlZl8sXG4gICAgd3RmSW5pdDogd3RmX2luaXQud3RmSW5pdCxcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzOiByZWZsZWN0aW9uX2NhcGFiaWxpdGllcy5SZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLFxuICAgIG1ha2VEZWNvcmF0b3I6IGRlY29yYXRvcnMubWFrZURlY29yYXRvcixcbiAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjogZGVidWcuRGVidWdEb21Sb290UmVuZGVyZXIsXG4gICAgY3JlYXRlUHJvdmlkZXI6IHByb3ZpZGVyX3V0aWwuY3JlYXRlUHJvdmlkZXIsXG4gICAgaXNQcm92aWRlckxpdGVyYWw6IHByb3ZpZGVyX3V0aWwuaXNQcm92aWRlckxpdGVyYWwsXG4gICAgRU1QVFlfQVJSQVk6IHZpZXdfdXRpbHMuRU1QVFlfQVJSQVksXG4gICAgRU1QVFlfTUFQOiB2aWV3X3V0aWxzLkVNUFRZX01BUCxcbiAgICBwdXJlUHJveHkxOiB2aWV3X3V0aWxzLnB1cmVQcm94eTEsXG4gICAgcHVyZVByb3h5Mjogdmlld191dGlscy5wdXJlUHJveHkyLFxuICAgIHB1cmVQcm94eTM6IHZpZXdfdXRpbHMucHVyZVByb3h5MyxcbiAgICBwdXJlUHJveHk0OiB2aWV3X3V0aWxzLnB1cmVQcm94eTQsXG4gICAgcHVyZVByb3h5NTogdmlld191dGlscy5wdXJlUHJveHk1LFxuICAgIHB1cmVQcm94eTY6IHZpZXdfdXRpbHMucHVyZVByb3h5NixcbiAgICBwdXJlUHJveHk3OiB2aWV3X3V0aWxzLnB1cmVQcm94eTcsXG4gICAgcHVyZVByb3h5ODogdmlld191dGlscy5wdXJlUHJveHk4LFxuICAgIHB1cmVQcm94eTk6IHZpZXdfdXRpbHMucHVyZVByb3h5OSxcbiAgICBwdXJlUHJveHkxMDogdmlld191dGlscy5wdXJlUHJveHkxMCxcbiAgICBjYXN0QnlWYWx1ZTogdmlld191dGlscy5jYXN0QnlWYWx1ZSxcbiAgICBDb25zb2xlOiBjb25zb2xlLkNvbnNvbGUsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpdmF0ZV9leHBvcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXBwbGljYXRpb25fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uX3Rva2VucycpO1xudmFyIGFwcGxpY2F0aW9uX3JlZl8xID0gcmVxdWlyZSgnLi9hcHBsaWNhdGlvbl9yZWYnKTtcbnZhciBjaGFuZ2VfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKCcuL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xudmFyIHZpZXdfdXRpbHNfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3ZpZXdfdXRpbHMnKTtcbnZhciBjb21wb25lbnRfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2NvbXBvbmVudF9yZXNvbHZlcicpO1xudmFyIGR5bmFtaWNfY29tcG9uZW50X2xvYWRlcl8xID0gcmVxdWlyZSgnLi9saW5rZXIvZHluYW1pY19jb21wb25lbnRfbG9hZGVyJyk7XG52YXIgX191bnVzZWQ7IC8vIGF2b2lkIHVudXNlZCBpbXBvcnQgd2hlbiBUeXBlIHVuaW9uIHR5cGVzIGFyZSBlcmFzZWRcbi8qKlxuICogQSBkZWZhdWx0IHNldCBvZiBwcm92aWRlcnMgd2hpY2ggc2hvdWxkIGJlIGluY2x1ZGVkIGluIGFueSBBbmd1bGFyXG4gKiBhcHBsaWNhdGlvbiwgcmVnYXJkbGVzcyBvZiB0aGUgcGxhdGZvcm0gaXQgcnVucyBvbnRvLlxuICovXG5leHBvcnRzLkFQUExJQ0FUSU9OX0NPTU1PTl9QUk9WSURFUlMgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBbXG4gICAgYXBwbGljYXRpb25fcmVmXzEuQVBQTElDQVRJT05fQ09SRV9QUk9WSURFUlMsXG4gICAgLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8geyBwcm92aWRlOiBjb21wb25lbnRfcmVzb2x2ZXJfMS5Db21wb25lbnRSZXNvbHZlciwgdXNlQ2xhc3M6IGNvbXBvbmVudF9yZXNvbHZlcl8xLlJlZmxlY3RvckNvbXBvbmVudFJlc29sdmVyIH0sXG4gICAgYXBwbGljYXRpb25fdG9rZW5zXzEuQVBQX0lEX1JBTkRPTV9QUk9WSURFUixcbiAgICB2aWV3X3V0aWxzXzEuVmlld1V0aWxzLFxuICAgIC8qIEB0czJkYXJ0X1Byb3ZpZGVyICovIHsgcHJvdmlkZTogY2hhbmdlX2RldGVjdGlvbl8xLkl0ZXJhYmxlRGlmZmVycywgdXNlVmFsdWU6IGNoYW5nZV9kZXRlY3Rpb25fMS5kZWZhdWx0SXRlcmFibGVEaWZmZXJzIH0sXG4gICAgLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8geyBwcm92aWRlOiBjaGFuZ2VfZGV0ZWN0aW9uXzEuS2V5VmFsdWVEaWZmZXJzLCB1c2VWYWx1ZTogY2hhbmdlX2RldGVjdGlvbl8xLmRlZmF1bHRLZXlWYWx1ZURpZmZlcnMgfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGR5bmFtaWNfY29tcG9uZW50X2xvYWRlcl8xLkR5bmFtaWNDb21wb25lbnRMb2FkZXIsIHVzZUNsYXNzOiBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMS5EeW5hbWljQ29tcG9uZW50TG9hZGVyXyB9XG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYXRpb25fY29tbW9uX3Byb3ZpZGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIG5nX3pvbmVfMSA9IHJlcXVpcmUoJy4vem9uZS9uZ196b25lJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZGlfMSA9IHJlcXVpcmUoJy4vZGknKTtcbnZhciBhcHBsaWNhdGlvbl90b2tlbnNfMSA9IHJlcXVpcmUoJy4vYXBwbGljYXRpb25fdG9rZW5zJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvYXN5bmMnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciB0ZXN0YWJpbGl0eV8xID0gcmVxdWlyZSgnLi90ZXN0YWJpbGl0eS90ZXN0YWJpbGl0eScpO1xudmFyIGNvbXBvbmVudF9yZXNvbHZlcl8xID0gcmVxdWlyZSgnLi9saW5rZXIvY29tcG9uZW50X3Jlc29sdmVyJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29uc29sZV8xID0gcmVxdWlyZSgnLi9jb25zb2xlJyk7XG52YXIgcHJvZmlsZV8xID0gcmVxdWlyZSgnLi9wcm9maWxlL3Byb2ZpbGUnKTtcbi8qKlxuICogQ3JlYXRlIGFuIEFuZ3VsYXIgem9uZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTmdab25lKCkge1xuICAgIHJldHVybiBuZXcgbmdfem9uZV8xLk5nWm9uZSh7IGVuYWJsZUxvbmdTdGFja1RyYWNlOiBsYW5nXzEuYXNzZXJ0aW9uc0VuYWJsZWQoKSB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlTmdab25lID0gY3JlYXRlTmdab25lO1xudmFyIF9wbGF0Zm9ybTtcbnZhciBfaW5QbGF0Zm9ybUNyZWF0ZSA9IGZhbHNlO1xuLyoqXG4gKiBDcmVhdGVzIGEgcGxhdGZvcm0uXG4gKiBQbGF0Zm9ybXMgaGF2ZSB0byBiZSBlYWdlcmx5IGNyZWF0ZWQgdmlhIHRoaXMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBsYXRmb3JtKGluamVjdG9yKSB7XG4gICAgaWYgKF9pblBsYXRmb3JtQ3JlYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignQWxyZWFkeSBjcmVhdGluZyBhIHBsYXRmb3JtLi4uJyk7XG4gICAgfVxuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KF9wbGF0Zm9ybSkgJiYgIV9wbGF0Zm9ybS5kaXNwb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJUaGVyZSBjYW4gYmUgb25seSBvbmUgcGxhdGZvcm0uIERlc3Ryb3kgdGhlIHByZXZpb3VzIG9uZSB0byBjcmVhdGUgYSBuZXcgb25lLlwiKTtcbiAgICB9XG4gICAgbGFuZ18xLmxvY2tNb2RlKCk7XG4gICAgX2luUGxhdGZvcm1DcmVhdGUgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIF9wbGF0Zm9ybSA9IGluamVjdG9yLmdldChQbGF0Zm9ybVJlZik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBfaW5QbGF0Zm9ybUNyZWF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX3BsYXRmb3JtO1xufVxuZXhwb3J0cy5jcmVhdGVQbGF0Zm9ybSA9IGNyZWF0ZVBsYXRmb3JtO1xuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGVyZSBjdXJyZW50bHkgaXMgYSBwbGF0Zm9ybVxuICogd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIHRva2VuIGFzIGEgcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFBsYXRmb3JtKHJlcXVpcmVkVG9rZW4pIHtcbiAgICB2YXIgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICAgIGlmIChsYW5nXzEuaXNCbGFuayhwbGF0Zm9ybSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdOb3QgcGxhdGZvcm0gZXhpc3RzIScpO1xuICAgIH1cbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwbGF0Zm9ybSkgJiYgbGFuZ18xLmlzQmxhbmsocGxhdGZvcm0uaW5qZWN0b3IuZ2V0KHJlcXVpcmVkVG9rZW4sIG51bGwpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ0EgcGxhdGZvcm0gd2l0aCBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuIFBsZWFzZSBkZXN0cm95IGl0IGZpcnN0LicpO1xuICAgIH1cbiAgICByZXR1cm4gcGxhdGZvcm07XG59XG5leHBvcnRzLmFzc2VydFBsYXRmb3JtID0gYXNzZXJ0UGxhdGZvcm07XG4vKipcbiAqIERpc3Bvc2UgdGhlIGV4aXN0aW5nIHBsYXRmb3JtLlxuICovXG5mdW5jdGlvbiBkaXNwb3NlUGxhdGZvcm0oKSB7XG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3BsYXRmb3JtKSAmJiAhX3BsYXRmb3JtLmRpc3Bvc2VkKSB7XG4gICAgICAgIF9wbGF0Zm9ybS5kaXNwb3NlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kaXNwb3NlUGxhdGZvcm0gPSBkaXNwb3NlUGxhdGZvcm07XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gKi9cbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KF9wbGF0Zm9ybSkgJiYgIV9wbGF0Zm9ybS5kaXNwb3NlZCA/IF9wbGF0Zm9ybSA6IG51bGw7XG59XG5leHBvcnRzLmdldFBsYXRmb3JtID0gZ2V0UGxhdGZvcm07XG4vKipcbiAqIFNob3J0Y3V0IGZvciBBcHBsaWNhdGlvblJlZi5ib290c3RyYXAuXG4gKiBSZXF1aXJlcyBhIHBsYXRmb3JtIHRoZSBiZSBjcmVhdGVkIGZpcnN0LlxuICovXG5mdW5jdGlvbiBjb3JlQm9vdHN0cmFwKGluamVjdG9yLCBjb21wb25lbnRGYWN0b3J5KSB7XG4gICAgdmFyIGFwcFJlZiA9IGluamVjdG9yLmdldChBcHBsaWNhdGlvblJlZik7XG4gICAgcmV0dXJuIGFwcFJlZi5ib290c3RyYXAoY29tcG9uZW50RmFjdG9yeSk7XG59XG5leHBvcnRzLmNvcmVCb290c3RyYXAgPSBjb3JlQm9vdHN0cmFwO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgY29tcG9uZW50RmFjdG9yeSBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCxcbiAqIHdhaXRzIGZvciBhc3luY2hyb25vdXMgaW5pdGlhbGl6ZXJzIGFuZCBib290c3RyYXBzIHRoZSBjb21wb25lbnQuXG4gKiBSZXF1aXJlcyBhIHBsYXRmb3JtIHRoZSBiZSBjcmVhdGVkIGZpcnN0LlxuICovXG5mdW5jdGlvbiBjb3JlTG9hZEFuZEJvb3RzdHJhcChpbmplY3RvciwgY29tcG9uZW50VHlwZSkge1xuICAgIHZhciBhcHBSZWYgPSBpbmplY3Rvci5nZXQoQXBwbGljYXRpb25SZWYpO1xuICAgIHJldHVybiBhcHBSZWYucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudFJlc29sdmVyID0gaW5qZWN0b3IuZ2V0KGNvbXBvbmVudF9yZXNvbHZlcl8xLkNvbXBvbmVudFJlc29sdmVyKTtcbiAgICAgICAgcmV0dXJuIGFzeW5jXzEuUHJvbWlzZVdyYXBwZXJcbiAgICAgICAgICAgIC5hbGwoW2NvbXBvbmVudFJlc29sdmVyLnJlc29sdmVDb21wb25lbnQoY29tcG9uZW50VHlwZSksIGFwcFJlZi53YWl0Rm9yQXN5bmNJbml0aWFsaXplcnMoKV0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcHBSZWYuYm9vdHN0cmFwKGFyclswXSk7IH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb3JlTG9hZEFuZEJvb3RzdHJhcCA9IGNvcmVMb2FkQW5kQm9vdHN0cmFwO1xuLyoqXG4gKiBUaGUgQW5ndWxhciBwbGF0Zm9ybSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIEFuZ3VsYXIgb24gYSB3ZWIgcGFnZS4gRWFjaCBwYWdlXG4gKiBoYXMgZXhhY3RseSBvbmUgcGxhdGZvcm0sIGFuZCBzZXJ2aWNlcyAoc3VjaCBhcyByZWZsZWN0aW9uKSB3aGljaCBhcmUgY29tbW9uXG4gKiB0byBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gdGhlIHBhZ2UgYXJlIGJvdW5kIGluIGl0cyBzY29wZS5cbiAqXG4gKiBBIHBhZ2UncyBwbGF0Zm9ybSBpcyBpbml0aWFsaXplZCBpbXBsaWNpdGx5IHdoZW4ge0BsaW5rIGJvb3RzdHJhcH0oKSBpcyBjYWxsZWQsIG9yXG4gKiBleHBsaWNpdGx5IGJ5IGNhbGxpbmcge0BsaW5rIGNyZWF0ZVBsYXRmb3JtfSgpLlxuICovXG52YXIgUGxhdGZvcm1SZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBwbGF0Zm9ybSB7QGxpbmsgSW5qZWN0b3J9LCB3aGljaCBpcyB0aGUgcGFyZW50IGluamVjdG9yIGZvclxuICAgICAgICAgKiBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIGFuZCBwcm92aWRlcyBzaW5nbGV0b24gcHJvdmlkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWYucHJvdG90eXBlLCBcImRpc3Bvc2VkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBQbGF0Zm9ybVJlZjtcbn0oKSk7XG5leHBvcnRzLlBsYXRmb3JtUmVmID0gUGxhdGZvcm1SZWY7XG52YXIgUGxhdGZvcm1SZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGxhdGZvcm1SZWZfLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmXyhfaW5qZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucyA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFfaW5QbGF0Zm9ybUNyZWF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdQbGF0Zm9ybXMgaGF2ZSB0byBiZSBjcmVhdGVkIHZpYSBgY3JlYXRlUGxhdGZvcm1gIScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbml0cyA9IF9pbmplY3Rvci5nZXQoYXBwbGljYXRpb25fdG9rZW5zXzEuUExBVEZPUk1fSU5JVElBTElaRVIsIG51bGwpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChpbml0cykpXG4gICAgICAgICAgICBpbml0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbml0KSB7IHJldHVybiBpbml0KCk7IH0pO1xuICAgIH1cbiAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLnJlZ2lzdGVyRGlzcG9zZUxpc3RlbmVyID0gZnVuY3Rpb24gKGRpc3Bvc2UpIHsgdGhpcy5fZGlzcG9zZUxpc3RlbmVycy5wdXNoKGRpc3Bvc2UpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmXy5wcm90b3R5cGUsIFwiZGlzcG9zZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLmFkZEFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKGFwcFJlZikgeyB0aGlzLl9hcHBsaWNhdGlvbnMucHVzaChhcHBSZWYpOyB9O1xuICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsb25lKHRoaXMuX2FwcGxpY2F0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7IHJldHVybiBhcHAuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChkaXNwb3NlKSB7IHJldHVybiBkaXNwb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5fYXBwbGljYXRpb25EaXNwb3NlZCA9IGZ1bmN0aW9uIChhcHApIHsgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9hcHBsaWNhdGlvbnMsIGFwcCk7IH07XG4gICAgUGxhdGZvcm1SZWZfLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogZGlfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBQbGF0Zm9ybVJlZl8uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogZGlfMS5JbmplY3RvciwgfSxcbiAgICBdO1xuICAgIHJldHVybiBQbGF0Zm9ybVJlZl87XG59KFBsYXRmb3JtUmVmKSk7XG5leHBvcnRzLlBsYXRmb3JtUmVmXyA9IFBsYXRmb3JtUmVmXztcbi8qKlxuICogQSByZWZlcmVuY2UgdG8gYW4gQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIGEgcGFnZS5cbiAqXG4gKiBGb3IgbW9yZSBhYm91dCBBbmd1bGFyIGFwcGxpY2F0aW9ucywgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB7QGxpbmsgYm9vdHN0cmFwfS5cbiAqL1xudmFyIEFwcGxpY2F0aW9uUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcHBsaWNhdGlvblJlZigpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgYXBwbGljYXRpb24ge0BsaW5rIEluamVjdG9yfS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiem9uZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgYXBwbGljYXRpb24ge0BsaW5rIE5nWm9uZX0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWYucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGxpc3Qgb2YgY29tcG9uZW50IHR5cGVzIHJlZ2lzdGVyZWQgdG8gdGhpcyBhcHBsaWNhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgO1xuICAgIHJldHVybiBBcHBsaWNhdGlvblJlZjtcbn0oKSk7XG5leHBvcnRzLkFwcGxpY2F0aW9uUmVmID0gQXBwbGljYXRpb25SZWY7XG52YXIgQXBwbGljYXRpb25SZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXBwbGljYXRpb25SZWZfLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uUmVmXyhfcGxhdGZvcm0sIF96b25lLCBfaW5qZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Jvb3RzdHJhcExpc3RlbmVycyA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cyA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRUeXBlcyA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcyA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB2YXIgem9uZSA9IF9pbmplY3Rvci5nZXQobmdfem9uZV8xLk5nWm9uZSk7XG4gICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBsYW5nXzEuYXNzZXJ0aW9uc0VuYWJsZWQoKTtcbiAgICAgICAgem9uZS5ydW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5fZXhjZXB0aW9uSGFuZGxlciA9IF9pbmplY3Rvci5nZXQoZXhjZXB0aW9uc18xLkV4Y2VwdGlvbkhhbmRsZXIpOyB9KTtcbiAgICAgICAgdGhpcy5fYXN5bmNJbml0RG9uZVByb21pc2UgPSB0aGlzLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5pdHMgPSBfaW5qZWN0b3IuZ2V0KGFwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9JTklUSUFMSVpFUiwgbnVsbCk7XG4gICAgICAgICAgICB2YXIgYXN5bmNJbml0UmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFzeW5jSW5pdERvbmVQcm9taXNlO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoaW5pdHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFJlc3VsdCA9IGluaXRzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcm9taXNlKGluaXRSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luY0luaXRSZXN1bHRzLnB1c2goaW5pdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXN5bmNJbml0UmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXN5bmNJbml0RG9uZVByb21pc2UgPVxuICAgICAgICAgICAgICAgICAgICBhc3luY18xLlByb21pc2VXcmFwcGVyLmFsbChhc3luY0luaXRSZXN1bHRzKS50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfdGhpcy5fYXN5bmNJbml0RG9uZSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLl9hc3luY0luaXREb25lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYXN5bmNJbml0RG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXN5bmNJbml0RG9uZVByb21pc2UgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNJbml0RG9uZVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZSh6b25lLm9uRXJyb3IsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMuX2V4Y2VwdGlvbkhhbmRsZXIuY2FsbChlcnJvci5lcnJvciwgZXJyb3Iuc3RhY2tUcmFjZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLnN1YnNjcmliZSh0aGlzLl96b25lLm9uTWljcm90YXNrRW1wdHksIGZ1bmN0aW9uIChfKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IF90aGlzLnRpY2soKTsgfSk7IH0pO1xuICAgIH1cbiAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLnJlZ2lzdGVyQm9vdHN0cmFwTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYm9vdHN0cmFwTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG4gICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5yZWdpc3RlckRpc3Bvc2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChkaXNwb3NlKSB7IHRoaXMuX2Rpc3Bvc2VMaXN0ZW5lcnMucHVzaChkaXNwb3NlKTsgfTtcbiAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLnJlZ2lzdGVyQ2hhbmdlRGV0ZWN0b3IgPSBmdW5jdGlvbiAoY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWZzLnB1c2goY2hhbmdlRGV0ZWN0b3IpO1xuICAgIH07XG4gICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS51bnJlZ2lzdGVyQ2hhbmdlRGV0ZWN0b3IgPSBmdW5jdGlvbiAoY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMsIGNoYW5nZURldGVjdG9yKTtcbiAgICB9O1xuICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUud2FpdEZvckFzeW5jSW5pdGlhbGl6ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYXN5bmNJbml0RG9uZVByb21pc2U7IH07XG4gICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHpvbmUgPSB0aGlzLmluamVjdG9yLmdldChuZ196b25lXzEuTmdab25lKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgLy8gTm90ZTogRG9uJ3QgdXNlIHpvbmUucnVuR3VhcmRlZCBhcyB3ZSB3YW50IHRvIGtub3cgYWJvdXRcbiAgICAgICAgLy8gdGhlIHRocm93biBleGNlcHRpb24hXG4gICAgICAgIC8vIE5vdGU6IHRoZSBjb21wbGV0ZXIgbmVlZHMgdG8gYmUgY3JlYXRlZCBvdXRzaWRlXG4gICAgICAgIC8vIG9mIGB6b25lLnJ1bmAgYXMgRGFydCBzd2FsbG93cyByZWplY3RlZCBwcm9taXNlc1xuICAgICAgICAvLyB2aWEgdGhlIG9uRXJyb3IgY2FsbGJhY2sgb2YgdGhlIHByb21pc2UuXG4gICAgICAgIHZhciBjb21wbGV0ZXIgPSBhc3luY18xLlByb21pc2VXcmFwcGVyLmNvbXBsZXRlcigpO1xuICAgICAgICB6b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBhc3luY18xLlByb21pc2VXcmFwcGVyLnRoZW4ocmVzdWx0LCBmdW5jdGlvbiAocmVmKSB7IGNvbXBsZXRlci5yZXNvbHZlKHJlZik7IH0sIGZ1bmN0aW9uIChlcnIsIHN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlci5yZWplY3QoZXJyLCBzdGFja1RyYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9leGNlcHRpb25IYW5kbGVyLmNhbGwoZXJyLCBzdGFja1RyYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZXhjZXB0aW9uSGFuZGxlci5jYWxsKGUsIGUuc3RhY2spO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJvbWlzZShyZXN1bHQpID8gY29tcGxldGVyLnByb21pc2UgOiByZXN1bHQ7XG4gICAgfTtcbiAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLmJvb3RzdHJhcCA9IGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fYXN5bmNJbml0RG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdDYW5ub3QgYm9vdHN0cmFwIGFzIHRoZXJlIGFyZSBzdGlsbCBhc3luY2hyb25vdXMgaW5pdGlhbGl6ZXJzIHJ1bm5pbmcuIFdhaXQgZm9yIHRoZW0gdXNpbmcgd2FpdEZvckFzeW5jSW5pdGlhbGl6ZXJzKCkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9yb290Q29tcG9uZW50VHlwZXMucHVzaChjb21wb25lbnRGYWN0b3J5LmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgdmFyIGNvbXBSZWYgPSBjb21wb25lbnRGYWN0b3J5LmNyZWF0ZShfdGhpcy5faW5qZWN0b3IsIFtdLCBjb21wb25lbnRGYWN0b3J5LnNlbGVjdG9yKTtcbiAgICAgICAgICAgIGNvbXBSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgX3RoaXMuX3VubG9hZENvbXBvbmVudChjb21wUmVmKTsgfSk7XG4gICAgICAgICAgICB2YXIgdGVzdGFiaWxpdHkgPSBjb21wUmVmLmluamVjdG9yLmdldCh0ZXN0YWJpbGl0eV8xLlRlc3RhYmlsaXR5LCBudWxsKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRlc3RhYmlsaXR5KSkge1xuICAgICAgICAgICAgICAgIGNvbXBSZWYuaW5qZWN0b3IuZ2V0KHRlc3RhYmlsaXR5XzEuVGVzdGFiaWxpdHlSZWdpc3RyeSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZ2lzdGVyQXBwbGljYXRpb24oY29tcFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCB0ZXN0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fbG9hZENvbXBvbmVudChjb21wUmVmKTtcbiAgICAgICAgICAgIHZhciBjID0gX3RoaXMuX2luamVjdG9yLmdldChjb25zb2xlXzEuQ29uc29sZSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmFzc2VydGlvbnNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICBjLmxvZyhcIkFuZ3VsYXIgMiBpcyBydW5uaW5nIGluIHRoZSBkZXZlbG9wbWVudCBtb2RlLiBDYWxsIGVuYWJsZVByb2RNb2RlKCkgdG8gZW5hYmxlIHRoZSBwcm9kdWN0aW9uIG1vZGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBSZWY7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUuX2xvYWRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5wdXNoKGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudFJlZik7XG4gICAgICAgIHRoaXMuX2Jvb3RzdHJhcExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoY29tcG9uZW50UmVmKTsgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5fdW5sb2FkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xuICAgICAgICBpZiAoIWNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb250YWlucyh0aGlzLl9yb290Q29tcG9uZW50cywgY29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5yZWdpc3RlckNoYW5nZURldGVjdG9yKGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fcm9vdENvbXBvbmVudHMsIGNvbXBvbmVudFJlZik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5qZWN0b3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLCBcInpvbmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3pvbmU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmdUaWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJBcHBsaWNhdGlvblJlZi50aWNrIGlzIGNhbGxlZCByZWN1cnNpdmVseVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IEFwcGxpY2F0aW9uUmVmXy5fdGlja1Njb3BlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGV0ZWN0b3IpIHsgcmV0dXJuIGRldGVjdG9yLmRldGVjdENoYW5nZXMoKTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXRlY3RvcikgeyByZXR1cm4gZGV0ZWN0b3IuY2hlY2tOb0NoYW5nZXMoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IGZhbHNlO1xuICAgICAgICAgICAgcHJvZmlsZV8xLnd0ZkxlYXZlKHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogRGlzcG9zZSBvZiB0aGUgTmdab25lLlxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY2xvbmUodGhpcy5fcm9vdENvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoZGlzcG9zZSkgeyByZXR1cm4gZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0uX2FwcGxpY2F0aW9uRGlzcG9zZWQodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgQXBwbGljYXRpb25SZWZfLl90aWNrU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ0FwcGxpY2F0aW9uUmVmI3RpY2soKScpO1xuICAgIEFwcGxpY2F0aW9uUmVmXy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGRpXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgQXBwbGljYXRpb25SZWZfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IFBsYXRmb3JtUmVmXywgfSxcbiAgICAgICAgeyB0eXBlOiBuZ196b25lXzEuTmdab25lLCB9LFxuICAgICAgICB7IHR5cGU6IGRpXzEuSW5qZWN0b3IsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gQXBwbGljYXRpb25SZWZfO1xufShBcHBsaWNhdGlvblJlZikpO1xuZXhwb3J0cy5BcHBsaWNhdGlvblJlZl8gPSBBcHBsaWNhdGlvblJlZl87XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnRzLlBMQVRGT1JNX0NPUkVfUFJPVklERVJTID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gW1xuICAgIFBsYXRmb3JtUmVmXyxcbiAgICAvKkB0czJkYXJ0X2NvbnN0Ki8gKFxuICAgIC8qIEB0czJkYXJ0X1Byb3ZpZGVyICovIHsgcHJvdmlkZTogUGxhdGZvcm1SZWYsIHVzZUV4aXN0aW5nOiBQbGF0Zm9ybVJlZl8gfSlcbl07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnRzLkFQUExJQ0FUSU9OX0NPUkVfUFJPVklERVJTID0gW1xuICAgIC8qIEB0czJkYXJ0X1Byb3ZpZGVyICovIHsgcHJvdmlkZTogbmdfem9uZV8xLk5nWm9uZSwgdXNlRmFjdG9yeTogY3JlYXRlTmdab25lLCBkZXBzOiBbXSB9LFxuICAgIEFwcGxpY2F0aW9uUmVmXyxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IEFwcGxpY2F0aW9uUmVmLCB1c2VFeGlzdGluZzogQXBwbGljYXRpb25SZWZfIH1cbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBsaWNhdGlvbl9yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGlfMSA9IHJlcXVpcmUoJy4vZGknKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbi8qKlxuICogQSBESSBUb2tlbiByZXByZXNlbnRpbmcgYSB1bmlxdWUgc3RyaW5nIGlkIGFzc2lnbmVkIHRvIHRoZSBhcHBsaWNhdGlvbiBieSBBbmd1bGFyIGFuZCB1c2VkXG4gKiBwcmltYXJpbHkgZm9yIHByZWZpeGluZyBhcHBsaWNhdGlvbiBhdHRyaWJ1dGVzIGFuZCBDU1Mgc3R5bGVzIHdoZW5cbiAqIHtAbGluayBWaWV3RW5jYXBzdWxhdGlvbiNFbXVsYXRlZH0gaXMgYmVpbmcgdXNlZC5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBhdm9pZCByYW5kb21seSBnZW5lcmF0ZWQgdmFsdWUgdG8gYmUgdXNlZCBhcyBhbiBhcHBsaWNhdGlvbiBpZCwgeW91IGNhbiBwcm92aWRlXG4gKiBhIGN1c3RvbSB2YWx1ZSB2aWEgYSBESSBwcm92aWRlciA8IS0tIFRPRE86IHByb3ZpZGVyIC0tPiBjb25maWd1cmluZyB0aGUgcm9vdCB7QGxpbmsgSW5qZWN0b3J9XG4gKiB1c2luZyB0aGlzIHRva2VuLlxuICovXG5leHBvcnRzLkFQUF9JRCA9IG5ldyBkaV8xLk9wYXF1ZVRva2VuKCdBcHBJZCcpO1xuZnVuY3Rpb24gX2FwcElkUmFuZG9tUHJvdmlkZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiBcIlwiICsgX3JhbmRvbUNoYXIoKSArIF9yYW5kb21DaGFyKCkgKyBfcmFuZG9tQ2hhcigpO1xufVxuLyoqXG4gKiBQcm92aWRlcnMgdGhhdCB3aWxsIGdlbmVyYXRlIGEgcmFuZG9tIEFQUF9JRF9UT0tFTi5cbiAqL1xuZXhwb3J0cy5BUFBfSURfUkFORE9NX1BST1ZJREVSID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8ge1xuICAgIHByb3ZpZGU6IGV4cG9ydHMuQVBQX0lELFxuICAgIHVzZUZhY3Rvcnk6IF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSxcbiAgICBkZXBzOiBbXVxufTtcbmZ1bmN0aW9uIF9yYW5kb21DaGFyKCkge1xuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUoOTcgKyBsYW5nXzEuTWF0aC5mbG9vcihsYW5nXzEuTWF0aC5yYW5kb20oKSAqIDI1KSk7XG59XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYSBwbGF0Zm9ybSBpcyBpbml0aWFsaXplZC5cbiAqL1xuZXhwb3J0cy5QTEFURk9STV9JTklUSUFMSVpFUiA9IFxuLypAdHMyZGFydF9jb25zdCovIG5ldyBkaV8xLk9wYXF1ZVRva2VuKFwiUGxhdGZvcm0gSW5pdGlhbGl6ZXJcIik7XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYW4gYXBwbGljYXRpb24gaXMgaW5pdGlhbGl6ZWQuXG4gKi9cbmV4cG9ydHMuQVBQX0lOSVRJQUxJWkVSID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gbmV3IGRpXzEuT3BhcXVlVG9rZW4oXCJBcHBsaWNhdGlvbiBJbml0aWFsaXplclwiKTtcbi8qKlxuICogQSB0b2tlbiB3aGljaCBpbmRpY2F0ZXMgdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLlBBQ0tBR0VfUk9PVF9VUkwgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBuZXcgZGlfMS5PcGFxdWVUb2tlbihcIkFwcGxpY2F0aW9uIFBhY2thZ2VzIFJvb3QgVVJMXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYXRpb25fdG9rZW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4qIEBtb2R1bGVcbiogQGRlc2NyaXB0aW9uXG4qIENoYW5nZSBkZXRlY3Rpb24gZW5hYmxlcyBkYXRhIGJpbmRpbmcgaW4gQW5ndWxhci5cbiovXG52YXIgY2hhbmdlX2RldGVjdGlvbl8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XG5leHBvcnRzLkNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdG9yUmVmO1xuZXhwb3J0cy5XcmFwcGVkVmFsdWUgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuV3JhcHBlZFZhbHVlO1xuZXhwb3J0cy5TaW1wbGVDaGFuZ2UgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuU2ltcGxlQ2hhbmdlO1xuZXhwb3J0cy5EZWZhdWx0SXRlcmFibGVEaWZmZXIgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuRGVmYXVsdEl0ZXJhYmxlRGlmZmVyO1xuZXhwb3J0cy5JdGVyYWJsZURpZmZlcnMgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuSXRlcmFibGVEaWZmZXJzO1xuZXhwb3J0cy5LZXlWYWx1ZURpZmZlcnMgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuS2V5VmFsdWVEaWZmZXJzO1xuZXhwb3J0cy5Db2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gY2hhbmdlX2RldGVjdGlvbl8xLkNvbGxlY3Rpb25DaGFuZ2VSZWNvcmQ7XG5leHBvcnRzLktleVZhbHVlQ2hhbmdlUmVjb3JkID0gY2hhbmdlX2RldGVjdGlvbl8xLktleVZhbHVlQ2hhbmdlUmVjb3JkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbmdlX2RldGVjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpdGVyYWJsZV9kaWZmZXJzXzEgPSByZXF1aXJlKCcuL2RpZmZlcnMvaXRlcmFibGVfZGlmZmVycycpO1xudmFyIGRlZmF1bHRfaXRlcmFibGVfZGlmZmVyXzEgPSByZXF1aXJlKCcuL2RpZmZlcnMvZGVmYXVsdF9pdGVyYWJsZV9kaWZmZXInKTtcbnZhciBrZXl2YWx1ZV9kaWZmZXJzXzEgPSByZXF1aXJlKCcuL2RpZmZlcnMva2V5dmFsdWVfZGlmZmVycycpO1xudmFyIGRlZmF1bHRfa2V5dmFsdWVfZGlmZmVyXzEgPSByZXF1aXJlKCcuL2RpZmZlcnMvZGVmYXVsdF9rZXl2YWx1ZV9kaWZmZXInKTtcbnZhciBkZWZhdWx0X2tleXZhbHVlX2RpZmZlcl8yID0gcmVxdWlyZSgnLi9kaWZmZXJzL2RlZmF1bHRfa2V5dmFsdWVfZGlmZmVyJyk7XG5leHBvcnRzLkRlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkgPSBkZWZhdWx0X2tleXZhbHVlX2RpZmZlcl8yLkRlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3Rvcnk7XG5leHBvcnRzLktleVZhbHVlQ2hhbmdlUmVjb3JkID0gZGVmYXVsdF9rZXl2YWx1ZV9kaWZmZXJfMi5LZXlWYWx1ZUNoYW5nZVJlY29yZDtcbnZhciBkZWZhdWx0X2l0ZXJhYmxlX2RpZmZlcl8yID0gcmVxdWlyZSgnLi9kaWZmZXJzL2RlZmF1bHRfaXRlcmFibGVfZGlmZmVyJyk7XG5leHBvcnRzLkRlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkgPSBkZWZhdWx0X2l0ZXJhYmxlX2RpZmZlcl8yLkRlZmF1bHRJdGVyYWJsZURpZmZlckZhY3Rvcnk7XG5leHBvcnRzLkNvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgPSBkZWZhdWx0X2l0ZXJhYmxlX2RpZmZlcl8yLkNvbGxlY3Rpb25DaGFuZ2VSZWNvcmQ7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuZXhwb3J0cy5DSEFOR0VfREVURUNUSU9OX1NUUkFURUdZX1ZBTFVFUyA9IGNvbnN0YW50c18xLkNIQU5HRV9ERVRFQ1RJT05fU1RSQVRFR1lfVkFMVUVTO1xuZXhwb3J0cy5DaGFuZ2VEZXRlY3RvclN0YXRlID0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0b3JTdGF0ZTtcbmV4cG9ydHMuQ0hBTkdFX0RFVEVDVE9SX1NUQVRFX1ZBTFVFUyA9IGNvbnN0YW50c18xLkNIQU5HRV9ERVRFQ1RPUl9TVEFURV9WQUxVRVM7XG5leHBvcnRzLmlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gY29uc3RhbnRzXzEuaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XG52YXIgY2hhbmdlX2RldGVjdG9yX3JlZl8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0b3JfcmVmJyk7XG5leHBvcnRzLkNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlX2RldGVjdG9yX3JlZl8xLkNoYW5nZURldGVjdG9yUmVmO1xudmFyIGl0ZXJhYmxlX2RpZmZlcnNfMiA9IHJlcXVpcmUoJy4vZGlmZmVycy9pdGVyYWJsZV9kaWZmZXJzJyk7XG5leHBvcnRzLkl0ZXJhYmxlRGlmZmVycyA9IGl0ZXJhYmxlX2RpZmZlcnNfMi5JdGVyYWJsZURpZmZlcnM7XG52YXIga2V5dmFsdWVfZGlmZmVyc18yID0gcmVxdWlyZSgnLi9kaWZmZXJzL2tleXZhbHVlX2RpZmZlcnMnKTtcbmV4cG9ydHMuS2V5VmFsdWVEaWZmZXJzID0ga2V5dmFsdWVfZGlmZmVyc18yLktleVZhbHVlRGlmZmVycztcbnZhciBkZWZhdWx0X2l0ZXJhYmxlX2RpZmZlcl8zID0gcmVxdWlyZSgnLi9kaWZmZXJzL2RlZmF1bHRfaXRlcmFibGVfZGlmZmVyJyk7XG5leHBvcnRzLkRlZmF1bHRJdGVyYWJsZURpZmZlciA9IGRlZmF1bHRfaXRlcmFibGVfZGlmZmVyXzMuRGVmYXVsdEl0ZXJhYmxlRGlmZmVyO1xudmFyIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xID0gcmVxdWlyZSgnLi9jaGFuZ2VfZGV0ZWN0aW9uX3V0aWwnKTtcbmV4cG9ydHMuV3JhcHBlZFZhbHVlID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEuV3JhcHBlZFZhbHVlO1xuZXhwb3J0cy5WYWx1ZVVud3JhcHBlciA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLlZhbHVlVW53cmFwcGVyO1xuZXhwb3J0cy5TaW1wbGVDaGFuZ2UgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5TaW1wbGVDaGFuZ2U7XG5leHBvcnRzLmRldk1vZGVFcXVhbCA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLmRldk1vZGVFcXVhbDtcbmV4cG9ydHMubG9vc2VJZGVudGljYWwgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS5sb29zZUlkZW50aWNhbDtcbmV4cG9ydHMudW5pbml0aWFsaXplZCA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLnVuaW5pdGlhbGl6ZWQ7XG4vKipcbiAqIFN0cnVjdHVyYWwgZGlmZmluZyBmb3IgYE9iamVjdGBzIGFuZCBgTWFwYHMuXG4gKi9cbmV4cG9ydHMua2V5VmFsRGlmZiA9IFxuLypAdHMyZGFydF9jb25zdCovIFtuZXcgZGVmYXVsdF9rZXl2YWx1ZV9kaWZmZXJfMS5EZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5KCldO1xuLyoqXG4gKiBTdHJ1Y3R1cmFsIGRpZmZpbmcgZm9yIGBJdGVyYWJsZWAgdHlwZXMgc3VjaCBhcyBgQXJyYXlgcy5cbiAqL1xuZXhwb3J0cy5pdGVyYWJsZURpZmYgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBbbmV3IGRlZmF1bHRfaXRlcmFibGVfZGlmZmVyXzEuRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSgpXTtcbmV4cG9ydHMuZGVmYXVsdEl0ZXJhYmxlRGlmZmVycyA9IG5ldyBpdGVyYWJsZV9kaWZmZXJzXzEuSXRlcmFibGVEaWZmZXJzKGV4cG9ydHMuaXRlcmFibGVEaWZmKTtcbmV4cG9ydHMuZGVmYXVsdEtleVZhbHVlRGlmZmVycyA9IG5ldyBrZXl2YWx1ZV9kaWZmZXJzXzEuS2V5VmFsdWVEaWZmZXJzKGV4cG9ydHMua2V5VmFsRGlmZik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFuZ2VfZGV0ZWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGxhbmdfMiA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xuZXhwb3J0cy5sb29zZUlkZW50aWNhbCA9IGxhbmdfMi5sb29zZUlkZW50aWNhbDtcbmV4cG9ydHMudW5pbml0aWFsaXplZCA9IG5ldyBPYmplY3QoKTtcbmZ1bmN0aW9uIGRldk1vZGVFcXVhbChhLCBiKSB7XG4gICAgaWYgKGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUoYSkgJiYgY29sbGVjdGlvbl8xLmlzTGlzdExpa2VJdGVyYWJsZShiKSkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLmFyZUl0ZXJhYmxlc0VxdWFsKGEsIGIsIGRldk1vZGVFcXVhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFjb2xsZWN0aW9uXzEuaXNMaXN0TGlrZUl0ZXJhYmxlKGEpICYmICFsYW5nXzEuaXNQcmltaXRpdmUoYSkgJiYgIWNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUoYikgJiZcbiAgICAgICAgIWxhbmdfMS5pc1ByaW1pdGl2ZShiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEubG9vc2VJZGVudGljYWwoYSwgYik7XG4gICAgfVxufVxuZXhwb3J0cy5kZXZNb2RlRXF1YWwgPSBkZXZNb2RlRXF1YWw7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXN1bHQgb2YgYSB7QGxpbmsgUGlwZU1ldGFkYXRhfSB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZCBldmVuIHRob3VnaCB0aGVcbiAqIHJlZmVyZW5jZVxuICogaGFzIG5vdCBjaGFuZ2VkLlxuICpcbiAqIFRoZSB3cmFwcGVkIHZhbHVlIHdpbGwgYmUgdW53cmFwcGVkIGJ5IGNoYW5nZSBkZXRlY3Rpb24sIGFuZCB0aGUgdW53cmFwcGVkIHZhbHVlIHdpbGwgYmUgc3RvcmVkLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiBpZiAodGhpcy5fbGF0ZXN0VmFsdWUgPT09IHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUpIHtcbiAqICAgIHJldHVybiB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlO1xuICogIH0gZWxzZSB7XG4gKiAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gKiAgICByZXR1cm4gV3JhcHBlZFZhbHVlLndyYXAodGhpcy5fbGF0ZXN0VmFsdWUpOyAvLyB0aGlzIHdpbGwgZm9yY2UgdXBkYXRlXG4gKiAgfVxuICogYGBgXG4gKi9cbnZhciBXcmFwcGVkVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdyYXBwZWRWYWx1ZSh3cmFwcGVkKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZCA9IHdyYXBwZWQ7XG4gICAgfVxuICAgIFdyYXBwZWRWYWx1ZS53cmFwID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgV3JhcHBlZFZhbHVlKHZhbHVlKTsgfTtcbiAgICByZXR1cm4gV3JhcHBlZFZhbHVlO1xufSgpKTtcbmV4cG9ydHMuV3JhcHBlZFZhbHVlID0gV3JhcHBlZFZhbHVlO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHVud3JhcHBpbmcgV3JhcHBlZFZhbHVlIHNcbiAqL1xudmFyIFZhbHVlVW53cmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYWx1ZVVud3JhcHBlcigpIHtcbiAgICAgICAgdGhpcy5oYXNXcmFwcGVkVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgVmFsdWVVbndyYXBwZXIucHJvdG90eXBlLnVud3JhcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBXcmFwcGVkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzV3JhcHBlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS53cmFwcGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFZhbHVlVW53cmFwcGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5oYXNXcmFwcGVkVmFsdWUgPSBmYWxzZTsgfTtcbiAgICByZXR1cm4gVmFsdWVVbndyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5WYWx1ZVVud3JhcHBlciA9IFZhbHVlVW53cmFwcGVyO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmFzaWMgY2hhbmdlIGZyb20gYSBwcmV2aW91cyB0byBhIG5ldyB2YWx1ZS5cbiAqL1xudmFyIFNpbXBsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxlQ2hhbmdlKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgbmV3IHZhbHVlIGlzIHRoZSBmaXJzdCB2YWx1ZSBhc3NpZ25lZC5cbiAgICAgKi9cbiAgICBTaW1wbGVDaGFuZ2UucHJvdG90eXBlLmlzRmlyc3RDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnByZXZpb3VzVmFsdWUgPT09IGV4cG9ydHMudW5pbml0aWFsaXplZDsgfTtcbiAgICByZXR1cm4gU2ltcGxlQ2hhbmdlO1xufSgpKTtcbmV4cG9ydHMuU2ltcGxlQ2hhbmdlID0gU2ltcGxlQ2hhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbmdlX2RldGVjdGlvbl91dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIENoYW5nZURldGVjdG9yUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZigpIHtcbiAgICB9XG4gICAgcmV0dXJuIENoYW5nZURldGVjdG9yUmVmO1xufSgpKTtcbmV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JSZWYgPSBDaGFuZ2VEZXRlY3RvclJlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5nZV9kZXRlY3Rvcl9yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG4vKipcbiAqIERlc2NyaWJlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY2hhbmdlIGRldGVjdG9yLlxuICovXG4oZnVuY3Rpb24gKENoYW5nZURldGVjdG9yU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBgTmV2ZXJDaGVja2VkYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IgaGFzIG5vdCBiZWVuIGNoZWNrZWQgeWV0LCBhbmRcbiAgICAgKiBpbml0aWFsaXphdGlvbiBtZXRob2RzIHNob3VsZCBiZSBjYWxsZWQgZHVyaW5nIGRldGVjdGlvbi5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3RvclN0YXRlW0NoYW5nZURldGVjdG9yU3RhdGVbXCJOZXZlckNoZWNrZWRcIl0gPSAwXSA9IFwiTmV2ZXJDaGVja2VkXCI7XG4gICAgLyoqXG4gICAgICogYENoZWNrZWRCZWZvcmVgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBoYXMgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBhdCBsZWFzdFxuICAgICAqIG9uZSBkZXRlY3Rpb24gcHJldmlvdXNseS5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3RvclN0YXRlW0NoYW5nZURldGVjdG9yU3RhdGVbXCJDaGVja2VkQmVmb3JlXCJdID0gMV0gPSBcIkNoZWNrZWRCZWZvcmVcIjtcbiAgICAvKipcbiAgICAgKiBgRXJyb3JlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIGVuY291bnRlcmVkIGFuIGVycm9yIGNoZWNraW5nIGEgYmluZGluZ1xuICAgICAqIG9yIGNhbGxpbmcgYSBkaXJlY3RpdmUgbGlmZWN5Y2xlIG1ldGhvZCBhbmQgaXMgbm93IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gQ2hhbmdlXG4gICAgICogZGV0ZWN0b3JzIGluIHRoaXMgc3RhdGUgd2lsbCBubyBsb25nZXIgZGV0ZWN0IGNoYW5nZXMuXG4gICAgICovXG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0ZVtDaGFuZ2VEZXRlY3RvclN0YXRlW1wiRXJyb3JlZFwiXSA9IDJdID0gXCJFcnJvcmVkXCI7XG59KShleHBvcnRzLkNoYW5nZURldGVjdG9yU3RhdGUgfHwgKGV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JTdGF0ZSA9IHt9KSk7XG52YXIgQ2hhbmdlRGV0ZWN0b3JTdGF0ZSA9IGV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JTdGF0ZTtcbi8qKlxuICogRGVzY3JpYmVzIHdpdGhpbiB0aGUgY2hhbmdlIGRldGVjdG9yIHdoaWNoIHN0cmF0ZWd5IHdpbGwgYmUgdXNlZCB0aGUgbmV4dCB0aW1lIGNoYW5nZVxuICogZGV0ZWN0aW9uIGlzIHRyaWdnZXJlZC5cbiAqL1xuKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgIC8qKlxuICAgICAqIGBDaGVja2VkT25jZWAgbWVhbnMgdGhhdCBhZnRlciBjYWxsaW5nIGRldGVjdENoYW5nZXMgdGhlIG1vZGUgb2YgdGhlIGNoYW5nZSBkZXRlY3RvclxuICAgICAqIHdpbGwgYmVjb21lIGBDaGVja2VkYC5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkNoZWNrT25jZVwiXSA9IDBdID0gXCJDaGVja09uY2VcIjtcbiAgICAvKipcbiAgICAgKiBgQ2hlY2tlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIHNob3VsZCBiZSBza2lwcGVkIHVudGlsIGl0cyBtb2RlIGNoYW5nZXMgdG9cbiAgICAgKiBgQ2hlY2tPbmNlYC5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkNoZWNrZWRcIl0gPSAxXSA9IFwiQ2hlY2tlZFwiO1xuICAgIC8qKlxuICAgICAqIGBDaGVja0Fsd2F5c2AgbWVhbnMgdGhhdCBhZnRlciBjYWxsaW5nIGRldGVjdENoYW5nZXMgdGhlIG1vZGUgb2YgdGhlIGNoYW5nZSBkZXRlY3RvclxuICAgICAqIHdpbGwgcmVtYWluIGBDaGVja0Fsd2F5c2AuXG4gICAgICovXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJDaGVja0Fsd2F5c1wiXSA9IDJdID0gXCJDaGVja0Fsd2F5c1wiO1xuICAgIC8qKlxuICAgICAqIGBEZXRhY2hlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIHN1YiB0cmVlIGlzIG5vdCBhIHBhcnQgb2YgdGhlIG1haW4gdHJlZSBhbmRcbiAgICAgKiBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkRldGFjaGVkXCJdID0gM10gPSBcIkRldGFjaGVkXCI7XG4gICAgLyoqXG4gICAgICogYE9uUHVzaGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yJ3MgbW9kZSB3aWxsIGJlIHNldCB0byBgQ2hlY2tPbmNlYCBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAqL1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoXCJdID0gNF0gPSBcIk9uUHVzaFwiO1xuICAgIC8qKlxuICAgICAqIGBEZWZhdWx0YCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IncyBtb2RlIHdpbGwgYmUgc2V0IHRvIGBDaGVja0Fsd2F5c2AgZHVyaW5nIGh5ZHJhdGlvbi5cbiAgICAgKi9cbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkRlZmF1bHRcIl0gPSA1XSA9IFwiRGVmYXVsdFwiO1xufSkoZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHt9KSk7XG52YXIgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuLyoqXG4gKiBMaXN0IG9mIHBvc3NpYmxlIHtAbGluayBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneX0gdmFsdWVzLlxuICovXG5leHBvcnRzLkNIQU5HRV9ERVRFQ1RJT05fU1RSQVRFR1lfVkFMVUVTID0gW1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrT25jZSxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja2VkLFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzLFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRldGFjaGVkLFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0XG5dO1xuLyoqXG4gKiBMaXN0IG9mIHBvc3NpYmxlIHtAbGluayBDaGFuZ2VEZXRlY3RvclN0YXRlfSB2YWx1ZXMuXG4gKi9cbmV4cG9ydHMuQ0hBTkdFX0RFVEVDVE9SX1NUQVRFX1ZBTFVFUyA9IFtcbiAgICBDaGFuZ2VEZXRlY3RvclN0YXRlLk5ldmVyQ2hlY2tlZCxcbiAgICBDaGFuZ2VEZXRlY3RvclN0YXRlLkNoZWNrZWRCZWZvcmUsXG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0ZS5FcnJvcmVkXG5dO1xuZnVuY3Rpb24gaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICByZXR1cm4gbGFuZ18xLmlzQmxhbmsoY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHx8XG4gICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID09PSBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0O1xufVxuZXhwb3J0cy5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xuLyogQHRzMmRhcnRfY29uc3QgKi9cbnZhciBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KCkge1xuICAgIH1cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUob2JqKTsgfTtcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYsIHRyYWNrQnlGbikge1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRJdGVyYWJsZURpZmZlcih0cmFja0J5Rm4pO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5EZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5ID0gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeTtcbnZhciB0cmFja0J5SWRlbnRpdHkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH07XG52YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0SXRlcmFibGVEaWZmZXIoX3RyYWNrQnlGbikge1xuICAgICAgICB0aGlzLl90cmFja0J5Rm4gPSBfdHJhY2tCeUZuO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBudWxsO1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHVzZWQgcmVjb3JkcyBhdCBhbnkgcG9pbnQgaW4gdGltZSAoZHVyaW5nICYgYWNyb3NzIGBfY2hlY2soKWAgY2FsbHMpXG4gICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMgPSBudWxsO1xuICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgcmVtb3ZlZCByZWNvcmRzIGF0IGFueSBwb2ludCBpbiB0aW1lIGR1cmluZyBgX2NoZWNrKClgIGNhbGxzLlxuICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcmV2aW91c0l0SGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2l0SGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2l0VGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbW92ZXNIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgcmVjb3JkcyB3aGVyZSBjdXN0b20gdHJhY2sgYnkgaXMgdGhlIHNhbWUsIGJ1dCBpdGVtIGlkZW50aXR5IGhhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhY2tCeUZuID0gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl90cmFja0J5Rm4pID8gdGhpcy5fdHJhY2tCeUZuIDogdHJhY2tCeUlkZW50aXR5O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJjb2xsZWN0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xsZWN0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hNb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaElkZW50aXR5Q2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRJZGVudGl0eUNoYW5nZSkge1xuICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbGxlY3Rpb24pKVxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICBpZiAoIWNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkVycm9yIHRyeWluZyB0byBkaWZmICdcIiArIGNvbGxlY3Rpb24gKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hlY2soY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8vIHRvZG8odmljYik6IG9wdGltIGZvciBVbm1vZGlmaWFibGVMaXN0VmlldyAoZnJvemVuIGFycmF5cylcbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2l0SGVhZDtcbiAgICAgICAgdmFyIG1heUJlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgdmFyIGl0ZW1UcmFja0J5O1xuICAgICAgICBpZiAobGFuZ18xLmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGl0ZW1UcmFja0J5ID0gdGhpcy5fdHJhY2tCeUZuKGluZGV4LCBpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgaXRlbVRyYWNrQnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbWF5QmVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5QmVEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhtaXNrbyk6IGNhbiB3ZSBsaW1pdCB0aGlzIHRvIGR1cGxpY2F0ZXMgb25seT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3ZlcmlmeVJlaW5zZXJ0aW9uKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhbmdfMS5sb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuaXRlcmF0ZUxpc3RMaWtlKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRyYWNrQnkgPSBfdGhpcy5fdHJhY2tCeUZuKGluZGV4LCBpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgaXRlbVRyYWNrQnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IF90aGlzLl9taXNtYXRjaChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heUJlRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBfdGhpcy5fdmVyaWZ5UmVpbnNlcnRpb24ocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJ1bmNhdGUocmVjb3JkKTtcbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgLyogQ29sbGVjdGlvbkNoYW5nZXMgaXMgY29uc2lkZXJlZCBkaXJ0eSBpZiBpdCBoYXMgYW55IGFkZGl0aW9ucywgbW92ZXMsIHJlbW92YWxzLCBvciBpZGVudGl0eVxuICAgICAgICAgKiBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9tb3Zlc0hlYWQgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGwgfHwgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBjaGFuZ2Ugb2JqZWN0cyB0byBzaG93IG5vIGNoYW5nZXMuIFRoaXMgbWVhbnMgc2V0IHByZXZpb3VzS2V5IHRvXG4gICAgICogY3VycmVudEtleSwgYW5kIGNsZWFyIGFsbCBvZiB0aGUgcXVldWVzIChhZGRpdGlvbnMsIG1vdmVzLCByZW1vdmFscykuXG4gICAgICogU2V0IHRoZSBwcmV2aW91c0luZGV4ZXMgb2YgbW92ZWQgYW5kIGFkZGVkIGl0ZW1zIHRvIHRoZWlyIGN1cnJlbnRJbmRleGVzXG4gICAgICogUmVzZXQgdGhlIGxpc3Qgb2YgYWRkaXRpb25zLCBtb3ZlcyBhbmQgcmVtb3ZhbHNcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkID0gdGhpcy5faXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzSW5kZXggPSByZWNvcmQuY3VycmVudEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gbmV4dFJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c0luZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSB0aGlzLl9tb3Zlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY29yZSBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIGRpZmZlcmVuY2VzIGJldHdlZW4gY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiAtIGByZWNvcmRgIGlzIHRoZSByZWNvcmQgd2hpY2ggd2Ugc2F3IGF0IHRoaXMgcG9zaXRpb24gbGFzdCB0aW1lLiBJZiBudWxsIHRoZW4gaXQgaXMgYSBuZXdcbiAgICAgKiAgIGl0ZW0uXG4gICAgICogLSBgaXRlbWAgaXMgdGhlIGN1cnJlbnQgaXRlbSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIC0gYGluZGV4YCBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX21pc21hdGNoID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KSB7XG4gICAgICAgIC8vIFRoZSBwcmV2aW91cyByZWNvcmQgYWZ0ZXIgd2hpY2ggd2Ugd2lsbCBhcHBlbmQgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgICB2YXIgcHJldmlvdXNSZWNvcmQ7XG4gICAgICAgIGlmIChyZWNvcmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByZXZpb3VzUmVjb3JkID0gdGhpcy5faXRUYWlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNSZWNvcmQgPSByZWNvcmQuX3ByZXY7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHJlY29yZCBmcm9tIHRoZSBjb2xsZWN0aW9uIHNpbmNlIHdlIGtub3cgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGl0ZW0uXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdHRlbXB0IHRvIHNlZSBpZiB3ZSBoYXZlIHNlZW4gdGhlIGl0ZW0gYmVmb3JlLlxuICAgICAgICByZWNvcmQgPSB0aGlzLl9saW5rZWRSZWNvcmRzID09PSBudWxsID8gbnVsbCA6IHRoaXMuX2xpbmtlZFJlY29yZHMuZ2V0KGl0ZW1UcmFja0J5LCBpbmRleCk7XG4gICAgICAgIGlmIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgc2VlbiB0aGlzIGJlZm9yZSwgd2UgbmVlZCB0byBtb3ZlIGl0IGZvcndhcmQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAvLyBCdXQgZmlyc3Qgd2UgbmVlZCB0byBjaGVjayBpZiBpZGVudGl0eSBjaGFuZ2VkLCBzbyB3ZSBjYW4gdXBkYXRlIGluIHZpZXcgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoIWxhbmdfMS5sb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX21vdmVBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOZXZlciBzZWVuIGl0LCBjaGVjayBldmljdGVkIGxpc3QuXG4gICAgICAgICAgICByZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSk7XG4gICAgICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gaXRlbSB3aGljaCB3ZSBoYXZlIGV2aWN0ZWQgZWFybGllcjogcmVpbnNlcnQgaXQgYmFjayBpbnRvIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgIC8vIEJ1dCBmaXJzdCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGlkZW50aXR5IGNoYW5nZWQsIHNvIHdlIGNhbiB1cGRhdGUgaW4gdmlldyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoIWxhbmdfMS5sb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVpbnNlcnRBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBpcyBhIG5ldyBpdGVtOiBhZGQgaXQuXG4gICAgICAgICAgICAgICAgcmVjb3JkID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQWZ0ZXIobmV3IENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQoaXRlbSwgaXRlbVRyYWNrQnkpLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoZWNrIGlzIG9ubHkgbmVlZGVkIGlmIGFuIGFycmF5IGNvbnRhaW5zIGR1cGxpY2F0ZXMuIChTaG9ydCBjaXJjdWl0IG9mIG5vdGhpbmcgZGlydHkpXG4gICAgICpcbiAgICAgKiBVc2UgY2FzZTogYFthLCBhXWAgPT4gYFtiLCBhLCBhXWBcbiAgICAgKlxuICAgICAqIElmIHdlIGRpZCBub3QgaGF2ZSB0aGlzIGNoZWNrIHRoZW4gdGhlIGluc2VydGlvbiBvZiBgYmAgd291bGQ6XG4gICAgICogICAxKSBldmljdCBmaXJzdCBgYWBcbiAgICAgKiAgIDIpIGluc2VydCBgYmAgYXQgYDBgIGluZGV4LlxuICAgICAqICAgMykgbGVhdmUgYGFgIGF0IGluZGV4IGAxYCBhcyBpcy4gPC0tIHRoaXMgaXMgd3JvbmchXG4gICAgICogICAzKSByZWluc2VydCBgYWAgYXQgaW5kZXggMi4gPC0tIHRoaXMgaXMgd3JvbmchXG4gICAgICpcbiAgICAgKiBUaGUgY29ycmVjdCBiZWhhdmlvciBpczpcbiAgICAgKiAgIDEpIGV2aWN0IGZpcnN0IGBhYFxuICAgICAqICAgMikgaW5zZXJ0IGBiYCBhdCBgMGAgaW5kZXguXG4gICAgICogICAzKSByZWluc2VydCBgYWAgYXQgaW5kZXggMS5cbiAgICAgKiAgIDMpIG1vdmUgYGFgIGF0IGZyb20gYDFgIHRvIGAyYC5cbiAgICAgKlxuICAgICAqXG4gICAgICogRG91YmxlIGNoZWNrIHRoYXQgd2UgaGF2ZSBub3QgZXZpY3RlZCBhIGR1cGxpY2F0ZSBpdGVtLiBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpdGVtIHR5cGUgbWF5XG4gICAgICogaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZDpcbiAgICAgKiBUaGUgaW5zZXJ0aW9uIG9mIGIgd2lsbCBldmljdCB0aGUgZmlyc3QgJ2EnLiBJZiB3ZSBkb24ndCByZWluc2VydCBpdCBub3cgaXQgd2lsbCBiZSByZWluc2VydGVkXG4gICAgICogYXQgdGhlIGVuZC4gV2hpY2ggd2lsbCBzaG93IHVwIGFzIHRoZSB0d28gJ2EncyBzd2l0Y2hpbmcgcG9zaXRpb24uIFRoaXMgaXMgaW5jb3JyZWN0LCBzaW5jZSBhXG4gICAgICogYmV0dGVyIHdheSB0byB0aGluayBvZiBpdCBpcyBhcyBpbnNlcnQgb2YgJ2InIHJhdGhlciB0aGVuIHN3aXRjaCAnYScgd2l0aCAnYicgYW5kIHRoZW4gYWRkICdhJ1xuICAgICAqIGF0IHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl92ZXJpZnlSZWluc2VydGlvbiA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCkge1xuICAgICAgICB2YXIgcmVpbnNlcnRSZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSk7XG4gICAgICAgIGlmIChyZWluc2VydFJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fcmVpbnNlcnRBZnRlcihyZWluc2VydFJlY29yZCwgcmVjb3JkLl9wcmV2LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVjb3JkLmN1cnJlbnRJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHJpZCBvZiBhbnkgZXhjZXNzIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfXMgZnJvbSB0aGUgcHJldmlvdXMgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogLSBgcmVjb3JkYCBUaGUgZmlyc3QgZXhjZXNzIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3RydW5jYXRlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAvLyBBbnl0aGluZyBhZnRlciB0aGF0IG5lZWRzIHRvIGJlIHJlbW92ZWQ7XG4gICAgICAgIHdoaWxlIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9SZW1vdmFscyh0aGlzLl91bmxpbmsocmVjb3JkKSk7XG4gICAgICAgICAgICByZWNvcmQgPSBuZXh0UmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hZGRpdGlvbnNUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tb3Zlc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbC5fbmV4dE1vdmVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXRUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9pdFRhaWwuX25leHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fcmVpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5yZW1vdmUocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldlJlbW92ZWQ7XG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0UmVtb3ZlZDtcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fbW92ZUFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdW5saW5rKHJlY29yZCk7XG4gICAgICAgIHRoaXMuX2luc2VydEFmdGVyKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpO1xuICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLl9hZGRpdGlvbnNUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zSGVhZCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydChfYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID09PSBudWxsKTtcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRBZGRlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5faW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQgIT0gcHJldlJlY29yZCk7XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHQgPT09IG51bGwpO1xuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9wcmV2ID09PSBudWxsKTtcbiAgICAgICAgdmFyIG5leHQgPSBwcmV2UmVjb3JkID09PSBudWxsID8gdGhpcy5faXRIZWFkIDogcHJldlJlY29yZC5fbmV4dDtcbiAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAvLyBhc3NlcnQobmV4dCAhPSByZWNvcmQpO1xuICAgICAgICAvLyBhc3NlcnQocHJldlJlY29yZCAhPSByZWNvcmQpO1xuICAgICAgICByZWNvcmQuX25leHQgPSBuZXh0O1xuICAgICAgICByZWNvcmQuX3ByZXYgPSBwcmV2UmVjb3JkO1xuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dC5fcHJldiA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldlJlY29yZC5fbmV4dCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGlua2VkUmVjb3Jkcy5wdXQocmVjb3JkKTtcbiAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvUmVtb3ZhbHModGhpcy5fdW5saW5rKHJlY29yZCkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3VubGluayA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmtlZFJlY29yZHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgIC8vIGFzc2VydCgocmVjb3JkLl9wcmV2ID0gbnVsbCkgPT09IG51bGwpO1xuICAgICAgICAvLyBhc3NlcnQoKHJlY29yZC5fbmV4dCA9IG51bGwpID09PSBudWxsKTtcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0SGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2Ll9uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQuX3ByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9Nb3ZlcyA9IGZ1bmN0aW9uIChyZWNvcmQsIHRvSW5kZXgpIHtcbiAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0TW92ZWQgPT09IG51bGwpO1xuICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzSW5kZXggPT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9tb3Zlc0hlYWQgPT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNIZWFkID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwgPSB0aGlzLl9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZFRvUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLnB1dChyZWNvcmQpO1xuICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgcmVjb3JkLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydChfcmVtb3ZhbHNIZWFkID09PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KF9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRSZW1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSB0aGlzLl9yZW1vdmFsc1RhaWw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSB0aGlzLl9yZW1vdmFsc1RhaWwuX25leHRSZW1vdmVkID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkSWRlbnRpdHlDaGFuZ2UgPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtKSB7XG4gICAgICAgIHJlY29yZC5pdGVtID0gaXRlbTtcbiAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwuX25leHRJZGVudGl0eUNoYW5nZSA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH07XG4gICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBsaXN0LnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2hQcmV2aW91c0l0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gcHJldmlvdXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gYWRkaXRpb25zLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgIHZhciBtb3ZlcyA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2hNb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gbW92ZXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgdmFyIHJlbW92YWxzID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIHJlbW92YWxzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgIHZhciBpZGVudGl0eUNoYW5nZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UoZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gaWRlbnRpdHlDaGFuZ2VzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgIHJldHVybiBcImNvbGxlY3Rpb246IFwiICsgbGlzdC5qb2luKCcsICcpICsgXCJcXG5cIiArIFwicHJldmlvdXM6IFwiICsgcHJldmlvdXMuam9pbignLCAnKSArIFwiXFxuXCIgK1xuICAgICAgICAgICAgXCJhZGRpdGlvbnM6IFwiICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyBcIlxcblwiICsgXCJtb3ZlczogXCIgKyBtb3Zlcy5qb2luKCcsICcpICsgXCJcXG5cIiArXG4gICAgICAgICAgICBcInJlbW92YWxzOiBcIiArIHJlbW92YWxzLmpvaW4oJywgJykgKyBcIlxcblwiICsgXCJpZGVudGl0eUNoYW5nZXM6IFwiICtcbiAgICAgICAgICAgIGlkZW50aXR5Q2hhbmdlcy5qb2luKCcsICcpICsgXCJcXG5cIjtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0SXRlcmFibGVEaWZmZXI7XG59KCkpO1xuZXhwb3J0cy5EZWZhdWx0SXRlcmFibGVEaWZmZXIgPSBEZWZhdWx0SXRlcmFibGVEaWZmZXI7XG52YXIgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvbkNoYW5nZVJlY29yZChpdGVtLCB0cmFja0J5SWQpIHtcbiAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy50cmFja0J5SWQgPSB0cmFja0J5SWQ7XG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c0luZGV4ID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3ByZXZEdXAgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHREdXAgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3ByZXZSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmV4dEFkZGVkID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9uZXh0TW92ZWQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRJZGVudGl0eUNoYW5nZSA9IG51bGw7XG4gICAgfVxuICAgIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c0luZGV4ID09PSB0aGlzLmN1cnJlbnRJbmRleCA/XG4gICAgICAgICAgICBsYW5nXzEuc3RyaW5naWZ5KHRoaXMuaXRlbSkgOlxuICAgICAgICAgICAgbGFuZ18xLnN0cmluZ2lmeSh0aGlzLml0ZW0pICsgJ1snICsgbGFuZ18xLnN0cmluZ2lmeSh0aGlzLnByZXZpb3VzSW5kZXgpICsgJy0+JyArXG4gICAgICAgICAgICAgICAgbGFuZ18xLnN0cmluZ2lmeSh0aGlzLmN1cnJlbnRJbmRleCkgKyAnXSc7XG4gICAgfTtcbiAgICByZXR1cm4gQ29sbGVjdGlvbkNoYW5nZVJlY29yZDtcbn0oKSk7XG5leHBvcnRzLkNvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgPSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkO1xuLy8gQSBsaW5rZWQgbGlzdCBvZiBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkcyB3aXRoIHRoZSBzYW1lIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQuaXRlbVxudmFyIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0KCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgdGhlIHJlY29yZCB0byB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAqXG4gICAgICogTm90ZTogYnkgZGVzaWduIGFsbCByZWNvcmRzIGluIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaG9sZCB0aGUgc2FtZSB2YWx1ZSBpbiByZWNvcmQuaXRlbS5cbiAgICAgKi9cbiAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB0aGlzLl90YWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgcmVjb3JkLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLml0ZW0gPT0gIF9oZWFkLml0ZW0gfHxcbiAgICAgICAgICAgIC8vICAgICAgIHJlY29yZC5pdGVtIGlzIG51bSAmJiByZWNvcmQuaXRlbS5pc05hTiAmJiBfaGVhZC5pdGVtIGlzIG51bSAmJiBfaGVhZC5pdGVtLmlzTmFOKTtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwuX25leHREdXAgPSByZWNvcmQ7XG4gICAgICAgICAgICByZWNvcmQuX3ByZXZEdXAgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgcmVjb3JkLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJldHVybnMgYSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkIGhhdmluZyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLnRyYWNrQnlJZCA9PSB0cmFja0J5SWQgYW5kXG4gICAgLy8gQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5jdXJyZW50SW5kZXggPj0gYWZ0ZXJJbmRleFxuICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRyYWNrQnlJZCwgYWZ0ZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0RHVwKSB7XG4gICAgICAgICAgICBpZiAoKGFmdGVySW5kZXggPT09IG51bGwgfHwgYWZ0ZXJJbmRleCA8IHJlY29yZC5jdXJyZW50SW5kZXgpICYmXG4gICAgICAgICAgICAgICAgbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHJlY29yZC50cmFja0J5SWQsIHRyYWNrQnlJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG9uZSB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0gZnJvbSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaXMgZW1wdHkuXG4gICAgICovXG4gICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgLy8gYXNzZXJ0KCgpIHtcbiAgICAgICAgLy8gIC8vIHZlcmlmeSB0aGF0IHRoZSByZWNvcmQgYmVpbmcgcmVtb3ZlZCBpcyBpbiB0aGUgbGlzdC5cbiAgICAgICAgLy8gIGZvciAoQ29sbGVjdGlvbkNoYW5nZVJlY29yZCBjdXJzb3IgPSBfaGVhZDsgY3Vyc29yICE9IG51bGw7IGN1cnNvciA9IGN1cnNvci5fbmV4dER1cCkge1xuICAgICAgICAvLyAgICBpZiAoaWRlbnRpY2FsKGN1cnNvciwgcmVjb3JkKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vICB9XG4gICAgICAgIC8vICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vfSk7XG4gICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2RHVwO1xuICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dER1cDtcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldi5fbmV4dER1cCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dC5fcHJldkR1cCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgPT09IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0O1xufSgpKTtcbnZhciBfRHVwbGljYXRlTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfRHVwbGljYXRlTWFwKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAvLyB0b2RvKHZpY2IpIGhhbmRsZSBjb3JuZXIgY2FzZXNcbiAgICAgICAgdmFyIGtleSA9IGxhbmdfMS5nZXRNYXBLZXkocmVjb3JkLnRyYWNrQnlJZCk7XG4gICAgICAgIHZhciBkdXBsaWNhdGVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghbGFuZ18xLmlzUHJlc2VudChkdXBsaWNhdGVzKSkge1xuICAgICAgICAgICAgZHVwbGljYXRlcyA9IG5ldyBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QoKTtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChrZXksIGR1cGxpY2F0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGR1cGxpY2F0ZXMuYWRkKHJlY29yZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgYHZhbHVlYCB1c2luZyBrZXkuIEJlY2F1c2UgdGhlIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgdmFsdWUgbWF5IGJlIG9uZSB3aGljaCB3ZVxuICAgICAqIGhhdmUgYWxyZWFkeSBpdGVyYXRlZCBvdmVyLCB3ZSB1c2UgdGhlIGFmdGVySW5kZXggdG8gcHJldGVuZCBpdCBpcyBub3QgdGhlcmUuXG4gICAgICpcbiAgICAgKiBVc2UgY2FzZTogYFthLCBiLCBjLCBhLCBhXWAgaWYgd2UgYXJlIGF0IGluZGV4IGAzYCB3aGljaCBpcyB0aGUgc2Vjb25kIGBhYCB0aGVuIGFza2luZyBpZiB3ZVxuICAgICAqIGhhdmUgYW55IG1vcmUgYGFgcyBuZWVkcyB0byByZXR1cm4gdGhlIGxhc3QgYGFgIG5vdCB0aGUgZmlyc3Qgb3Igc2Vjb25kLlxuICAgICAqL1xuICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0cmFja0J5SWQsIGFmdGVySW5kZXgpIHtcbiAgICAgICAgaWYgKGFmdGVySW5kZXggPT09IHZvaWQgMCkgeyBhZnRlckluZGV4ID0gbnVsbDsgfVxuICAgICAgICB2YXIga2V5ID0gbGFuZ18xLmdldE1hcEtleSh0cmFja0J5SWQpO1xuICAgICAgICB2YXIgcmVjb3JkTGlzdCA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICByZXR1cm4gbGFuZ18xLmlzQmxhbmsocmVjb3JkTGlzdCkgPyBudWxsIDogcmVjb3JkTGlzdC5nZXQodHJhY2tCeUlkLCBhZnRlckluZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0gZnJvbSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAqXG4gICAgICogVGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBhbHNvIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIGl0IGdldHMgZW1wdHkuXG4gICAgICovXG4gICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICB2YXIga2V5ID0gbGFuZ18xLmdldE1hcEtleShyZWNvcmQudHJhY2tCeUlkKTtcbiAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAvLyBhc3NlcnQodGhpcy5tYXAuY29udGFpbnNLZXkoa2V5KSk7XG4gICAgICAgIHZhciByZWNvcmRMaXN0ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIHdoZW4gaXQgZ2V0cyBlbXB0eVxuICAgICAgICBpZiAocmVjb3JkTGlzdC5yZW1vdmUocmVjb3JkKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfRHVwbGljYXRlTWFwLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1hcC5zaXplID09PSAwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5tYXAuY2xlYXIoKTsgfTtcbiAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdfRHVwbGljYXRlTWFwKCcgKyBsYW5nXzEuc3RyaW5naWZ5KHRoaXMubWFwKSArICcpJzsgfTtcbiAgICByZXR1cm4gX0R1cGxpY2F0ZU1hcDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0X2l0ZXJhYmxlX2RpZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbi8qIEB0czJkYXJ0X2NvbnN0ICovXG52YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSgpIHtcbiAgICB9XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogaW5zdGFuY2VvZiBNYXAgfHwgbGFuZ18xLmlzSnNPYmplY3Qob2JqKTsgfTtcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYpIHsgcmV0dXJuIG5ldyBEZWZhdWx0S2V5VmFsdWVEaWZmZXIoKTsgfTtcbiAgICByZXR1cm4gRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLkRlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkgPSBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5O1xudmFyIERlZmF1bHRLZXlWYWx1ZURpZmZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyKCkge1xuICAgICAgICB0aGlzLl9yZWNvcmRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9tYXBIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNNYXBIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUsIFwiaXNEaXJ0eVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZGl0aW9uc0hlYWQgIT09IG51bGwgfHwgdGhpcy5fY2hhbmdlc0hlYWQgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUHJldmlvdXNJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNNYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hDaGFuZ2VkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEFkZGVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKG1hcCkpXG4gICAgICAgICAgICBtYXAgPSBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci5jcmVhdGVGcm9tUGFpcnMoW10pO1xuICAgICAgICBpZiAoIShtYXAgaW5zdGFuY2VvZiBNYXAgfHwgbGFuZ18xLmlzSnNPYmplY3QobWFwKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkVycm9yIHRyeWluZyB0byBkaWZmICdcIiArIG1hcCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGVjayhtYXApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHM7XG4gICAgICAgIHZhciBvbGRTZXFSZWNvcmQgPSB0aGlzLl9tYXBIZWFkO1xuICAgICAgICB2YXIgbGFzdE9sZFNlcVJlY29yZCA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0TmV3U2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgdmFyIHNlcUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaChtYXAsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgaWYgKG9sZFNlcVJlY29yZCAhPT0gbnVsbCAmJiBrZXkgPT09IG9sZFNlcVJlY29yZC5rZXkpIHtcbiAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwodmFsdWUsIG9sZFNlcVJlY29yZC5jdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFNlcVJlY29yZC5wcmV2aW91c1ZhbHVlID0gb2xkU2VxUmVjb3JkLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2xkU2VxUmVjb3JkLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9DaGFuZ2VzKG9sZFNlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VxQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFNlcVJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRTZXFSZWNvcmQuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVNlcShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9SZW1vdmFscyhvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVjb3Jkcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSByZWNvcmRzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gbmV3IEtleVZhbHVlQ2hhbmdlUmVjb3JkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMuc2V0KGtleSwgbmV3U2VxUmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9BZGRpdGlvbnMobmV3U2VxUmVjb3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VxQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNJblJlbW92YWxzKG5ld1NlcVJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUZyb21SZW1vdmFscyhuZXdTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdE5ld1NlcVJlY29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXBIZWFkID0gbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZC5fbmV4dCA9IG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0T2xkU2VxUmVjb3JkID0gb2xkU2VxUmVjb3JkO1xuICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZCA9IG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgIG9sZFNlcVJlY29yZCA9IG9sZFNlcVJlY29yZCA9PT0gbnVsbCA/IG51bGwgOiBvbGRTZXFSZWNvcmQuX25leHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cnVuY2F0ZShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RpcnR5O1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBzdGF0ZSBvZiB0aGUgbWFwcGluZ1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9jaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpIG9uY2UgYXNzZXJ0IGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gYXNzZXJ0KCgpIHtcbiAgICAgICAgICAgIC8vICB2YXIgciA9IF9jaGFuZ2VzSGVhZDtcbiAgICAgICAgICAgIC8vICB3aGlsZSAociAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyAgICB2YXIgbmV4dFJlY29yZCA9IHIuX25leHRDaGFuZ2VkO1xuICAgICAgICAgICAgLy8gICAgci5fbmV4dENoYW5nZWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gICAgciA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICAvLyAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICByID0gX2FkZGl0aW9uc0hlYWQ7XG4gICAgICAgICAgICAvLyAgd2hpbGUgKHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gICAgdmFyIG5leHRSZWNvcmQgPSByLl9uZXh0QWRkZWQ7XG4gICAgICAgICAgICAvLyAgICByLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gICAgciA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICAvLyAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICByID0gX3JlbW92YWxzSGVhZDtcbiAgICAgICAgICAgIC8vICB3aGlsZSAociAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyAgICB2YXIgbmV4dFJlY29yZCA9IHIuX25leHRSZW1vdmVkO1xuICAgICAgICAgICAgLy8gICAgci5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gICAgciA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICAvLyAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VzSGVhZCA9IHRoaXMuX2NoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IHRoaXMuX3JlbW92YWxzVGFpbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl90cnVuY2F0ZSA9IGZ1bmN0aW9uIChsYXN0UmVjb3JkLCByZWNvcmQpIHtcbiAgICAgICAgd2hpbGUgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3RSZWNvcmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RSZWNvcmQuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpIGFzc2VydFxuICAgICAgICAgICAgLy8gYXNzZXJ0KCgoKSB7XG4gICAgICAgICAgICAvLyAgcmVjb3JkLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vfSkpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9SZW1vdmFscyhyZWNvcmQpO1xuICAgICAgICAgICAgbGFzdFJlY29yZCA9IHJlY29yZDtcbiAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcmVjID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWMgIT09IG51bGw7IHJlYyA9IHJlYy5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJlYy5wcmV2aW91c1ZhbHVlID0gcmVjLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHJlYy5jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVjb3Jkcy5kZWxldGUocmVjLmtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9pc0luUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIHJldHVybiByZWNvcmQgPT09IHRoaXMuX3JlbW92YWxzSGVhZCB8fCByZWNvcmQuX25leHRSZW1vdmVkICE9PSBudWxsIHx8XG4gICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkICE9PSBudWxsO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgIC8vIHRvZG8odmljYikgYXNzZXJ0XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHQgPT0gbnVsbCk7XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRBZGRlZCA9PSBudWxsKTtcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dENoYW5nZWQgPT0gbnVsbCk7XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRSZW1vdmVkID09IG51bGwpO1xuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9wcmV2UmVtb3ZlZCA9PSBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSB0aGlzLl9yZW1vdmFsc1RhaWw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmVGcm9tU2VxID0gZnVuY3Rpb24gKHByZXYsIHJlY29yZCkge1xuICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbyh2aWNiKSBhc3NlcnRcbiAgICAgICAgLy8gYXNzZXJ0KCgoKSB7XG4gICAgICAgIC8vICByZWNvcmQuX25leHQgPSBudWxsO1xuICAgICAgICAvLyAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vfSkoKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVJlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAvLyB0b2RvKHZpY2IpIGFzc2VydFxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0ID09IG51bGwpO1xuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT0gbnVsbCk7XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRDaGFuZ2VkID09IG51bGwpO1xuICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldlJlbW92ZWQ7XG4gICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0UmVtb3ZlZDtcbiAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvQWRkaXRpb25zID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAvLyB0b2RvKHZpY2IpOiBhc3NlcnRcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PSBudWxsKTtcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dEFkZGVkID09IG51bGwpO1xuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0Q2hhbmdlZCA9PSBudWxsKTtcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dFJlbW92ZWQgPT0gbnVsbCk7XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX3ByZXZSZW1vdmVkID09IG51bGwpO1xuICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9DaGFuZ2VzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAvLyB0b2RvKHZpY2IpIGFzc2VydFxuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT0gbnVsbCk7XG4gICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRDaGFuZ2VkID09IG51bGwpO1xuICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0UmVtb3ZlZCA9PSBudWxsKTtcbiAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fcHJldlJlbW92ZWQgPT0gbnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsLl9uZXh0Q2hhbmdlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsID0gcmVjb3JkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gW107XG4gICAgICAgIHZhciBjaGFuZ2VzID0gW107XG4gICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92YWxzID0gW107XG4gICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2gobGFuZ18xLnN0cmluZ2lmeShyZWNvcmQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xuICAgICAgICAgICAgcHJldmlvdXMucHVzaChsYW5nXzEuc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGxhbmdfMS5zdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICBhZGRpdGlvbnMucHVzaChsYW5nXzEuc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJlbW92YWxzLnB1c2gobGFuZ18xLnN0cmluZ2lmeShyZWNvcmQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJtYXA6IFwiICsgaXRlbXMuam9pbignLCAnKSArIFwiXFxuXCIgKyBcInByZXZpb3VzOiBcIiArIHByZXZpb3VzLmpvaW4oJywgJykgKyBcIlxcblwiICtcbiAgICAgICAgICAgIFwiYWRkaXRpb25zOiBcIiArIGFkZGl0aW9ucy5qb2luKCcsICcpICsgXCJcXG5cIiArIFwiY2hhbmdlczogXCIgKyBjaGFuZ2VzLmpvaW4oJywgJykgKyBcIlxcblwiICtcbiAgICAgICAgICAgIFwicmVtb3ZhbHM6IFwiICsgcmVtb3ZhbHMuam9pbignLCAnKSArIFwiXFxuXCI7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmosIGZuKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIG9iai5mb3JFYWNoKGZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmZvckVhY2gob2JqLCBmbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXI7XG59KCkpO1xuZXhwb3J0cy5EZWZhdWx0S2V5VmFsdWVEaWZmZXIgPSBEZWZhdWx0S2V5VmFsdWVEaWZmZXI7XG52YXIgS2V5VmFsdWVDaGFuZ2VSZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleVZhbHVlQ2hhbmdlUmVjb3JkKGtleSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRQcmV2aW91cyA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmV4dEFkZGVkID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX25leHRDaGFuZ2VkID0gbnVsbDtcbiAgICB9XG4gICAgS2V5VmFsdWVDaGFuZ2VSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHRoaXMucHJldmlvdXNWYWx1ZSwgdGhpcy5jdXJyZW50VmFsdWUpID9cbiAgICAgICAgICAgIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5rZXkpIDpcbiAgICAgICAgICAgIChsYW5nXzEuc3RyaW5naWZ5KHRoaXMua2V5KSArICdbJyArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5wcmV2aW91c1ZhbHVlKSArICctPicgK1xuICAgICAgICAgICAgICAgIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5jdXJyZW50VmFsdWUpICsgJ10nKTtcbiAgICB9O1xuICAgIHJldHVybiBLZXlWYWx1ZUNoYW5nZVJlY29yZDtcbn0oKSk7XG5leHBvcnRzLktleVZhbHVlQ2hhbmdlUmVjb3JkID0gS2V5VmFsdWVDaGFuZ2VSZWNvcmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0X2tleXZhbHVlX2RpZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBkaV8xID0gcmVxdWlyZSgnLi4vLi4vZGknKTtcbi8qKlxuICogQSByZXBvc2l0b3J5IG9mIGRpZmZlcmVudCBpdGVyYWJsZSBkaWZmaW5nIHN0cmF0ZWdpZXMgdXNlZCBieSBOZ0ZvciwgTmdDbGFzcywgYW5kIG90aGVycy5cbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBJdGVyYWJsZURpZmZlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qQHRzMmRhcnRfY29uc3QqL1xuICAgIGZ1bmN0aW9uIEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgfVxuICAgIEl0ZXJhYmxlRGlmZmVycy5jcmVhdGUgPSBmdW5jdGlvbiAoZmFjdG9yaWVzLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgdmFyIGNvcGllZCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jbG9uZShwYXJlbnQuZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBhcnJheSBvZiB7QGxpbmsgSXRlcmFibGVEaWZmZXJGYWN0b3J5fSBhbmQgcmV0dXJucyBhIHByb3ZpZGVyIHVzZWQgdG8gZXh0ZW5kIHRoZVxuICAgICAqIGluaGVyaXRlZCB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAqIHtAbGluayBJdGVyYWJsZURpZmZlcnN9IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICAgICAgICogd2hpY2ggd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluamVjdG9yIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAqIFRoaXMgc3RlcCBpcyBhbGwgdGhhdCdzIHJlcXVpcmVkIHRvIG1ha2UgYSBuZXcge0BsaW5rIEl0ZXJhYmxlRGlmZmVyfSBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICB2aWV3UHJvdmlkZXJzOiBbXG4gICAgICogICAgIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVMaXN0RGlmZmVyKCldKVxuICAgICAqICAgXVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCA9IGZ1bmN0aW9uIChmYWN0b3JpZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkaV8xLlByb3ZpZGVyKEl0ZXJhYmxlRGlmZmVycywge1xuICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSB3b3VsZCBvY2N1ciB3aGVuIGNhbGxpbmcgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCBpbnNpZGUgb2YgZGVwZW5kZW5jaWVzIHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ0Nhbm5vdCBleHRlbmQgSXRlcmFibGVEaWZmZXJzIHdpdGhvdXQgYSBwYXJlbnQgaW5qZWN0b3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEl0ZXJhYmxlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIERlcGVuZGVuY3kgdGVjaG5pY2FsbHkgaXNuJ3Qgb3B0aW9uYWwsIGJ1dCB3ZSBjYW4gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtZXNzYWdlIHRoaXMgd2F5LlxuICAgICAgICAgICAgZGVwczogW1tJdGVyYWJsZURpZmZlcnMsIG5ldyBkaV8xLlNraXBTZWxmTWV0YWRhdGEoKSwgbmV3IGRpXzEuT3B0aW9uYWxNZXRhZGF0YSgpXV1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJdGVyYWJsZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLmZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnN1cHBvcnRzKGl0ZXJhYmxlKTsgfSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGZhY3RvcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIGl0ZXJhYmxlICsgXCInIG9mIHR5cGUgJ1wiICsgbGFuZ18xLmdldFR5cGVOYW1lRm9yRGVidWdnaW5nKGl0ZXJhYmxlKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEl0ZXJhYmxlRGlmZmVycztcbn0oKSk7XG5leHBvcnRzLkl0ZXJhYmxlRGlmZmVycyA9IEl0ZXJhYmxlRGlmZmVycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhYmxlX2RpZmZlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgZGlfMSA9IHJlcXVpcmUoJy4uLy4uL2RpJyk7XG4vKipcbiAqIEEgcmVwb3NpdG9yeSBvZiBkaWZmZXJlbnQgTWFwIGRpZmZpbmcgc3RyYXRlZ2llcyB1c2VkIGJ5IE5nQ2xhc3MsIE5nU3R5bGUsIGFuZCBvdGhlcnMuXG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgS2V5VmFsdWVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKkB0czJkYXJ0X2NvbnN0Ki9cbiAgICBmdW5jdGlvbiBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xuICAgIH1cbiAgICBLZXlWYWx1ZURpZmZlcnMuY3JlYXRlID0gZnVuY3Rpb24gKGZhY3RvcmllcywgcGFyZW50KSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIHZhciBjb3BpZWQgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY2xvbmUocGFyZW50LmZhY3Rvcmllcyk7XG4gICAgICAgICAgICBmYWN0b3JpZXMgPSBmYWN0b3JpZXMuY29uY2F0KGNvcGllZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gYXJyYXkgb2Yge0BsaW5rIEtleVZhbHVlRGlmZmVyRmFjdG9yeX0gYW5kIHJldHVybnMgYSBwcm92aWRlciB1c2VkIHRvIGV4dGVuZCB0aGVcbiAgICAgKiBpbmhlcml0ZWQge0BsaW5rIEtleVZhbHVlRGlmZmVyc30gaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgZmFjdG9yaWVzIGFuZCByZXR1cm4gYSBuZXdcbiAgICAgKiB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGxpc3Qgb2YgZmFjdG9yaWVzLFxuICAgICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgKiBUaGlzIHN0ZXAgaXMgYWxsIHRoYXQncyByZXF1aXJlZCB0byBtYWtlIGEgbmV3IHtAbGluayBLZXlWYWx1ZURpZmZlcn0gYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgdmlld1Byb3ZpZGVyczogW1xuICAgICAqICAgICBLZXlWYWx1ZURpZmZlcnMuZXh0ZW5kKFtuZXcgSW1tdXRhYmxlTWFwRGlmZmVyKCldKVxuICAgICAqICAgXVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZCA9IGZ1bmN0aW9uIChmYWN0b3JpZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkaV8xLlByb3ZpZGVyKEtleVZhbHVlRGlmZmVycywge1xuICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSB3b3VsZCBvY2N1ciB3aGVuIGNhbGxpbmcgS2V5VmFsdWVEaWZmZXJzLmV4dGVuZCBpbnNpZGUgb2YgZGVwZW5kZW5jaWVzIHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ0Nhbm5vdCBleHRlbmQgS2V5VmFsdWVEaWZmZXJzIHdpdGhvdXQgYSBwYXJlbnQgaW5qZWN0b3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtleVZhbHVlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIERlcGVuZGVuY3kgdGVjaG5pY2FsbHkgaXNuJ3Qgb3B0aW9uYWwsIGJ1dCB3ZSBjYW4gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtZXNzYWdlIHRoaXMgd2F5LlxuICAgICAgICAgICAgZGVwczogW1tLZXlWYWx1ZURpZmZlcnMsIG5ldyBkaV8xLlNraXBTZWxmTWV0YWRhdGEoKSwgbmV3IGRpXzEuT3B0aW9uYWxNZXRhZGF0YSgpXV1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLZXlWYWx1ZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa3YpIHtcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLmZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnN1cHBvcnRzKGt2KTsgfSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGZhY3RvcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIGt2ICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gS2V5VmFsdWVEaWZmZXJzO1xufSgpKTtcbmV4cG9ydHMuS2V5VmFsdWVEaWZmZXJzID0gS2V5VmFsdWVEaWZmZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5dmFsdWVfZGlmZmVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9sYW5nJyk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZSgnLi9kaS9kZWNvcmF0b3JzJyk7XG4vLyBOb3RlOiBOZWVkIHRvIHJlbmFtZSB3YXJuIGFzIGluIERhcnRcbi8vIGNsYXNzIG1lbWJlcnMgYW5kIGltcG9ydHMgY2FuJ3QgdXNlIHRoZSBzYW1lIG5hbWUuXG52YXIgX3dhcm5JbXBsID0gbGFuZ18xLndhcm47XG52YXIgQ29uc29sZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc29sZSgpIHtcbiAgICB9XG4gICAgQ29uc29sZS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgbGFuZ18xLnByaW50KG1lc3NhZ2UpOyB9O1xuICAgIC8vIE5vdGU6IGZvciByZXBvcnRpbmcgZXJyb3JzIHVzZSBgRE9NLmxvZ0Vycm9yKClgIGFzIGl0IGlzIHBsYXRmb3JtIHNwZWNpZmljXG4gICAgQ29uc29sZS5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IF93YXJuSW1wbChtZXNzYWdlKTsgfTtcbiAgICBDb25zb2xlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogZGVjb3JhdG9yc18xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIHJldHVybiBDb25zb2xlO1xufSgpKTtcbmV4cG9ydHMuQ29uc29sZSA9IENvbnNvbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zb2xlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIDtcbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lcjtcbn0oKSk7XG5leHBvcnRzLkV2ZW50TGlzdGVuZXIgPSBFdmVudExpc3RlbmVyO1xudmFyIERlYnVnTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVidWdOb2RlKG5hdGl2ZU5vZGUsIHBhcmVudCwgX2RlYnVnSW5mbykge1xuICAgICAgICB0aGlzLl9kZWJ1Z0luZm8gPSBfZGVidWdJbmZvO1xuICAgICAgICB0aGlzLm5hdGl2ZU5vZGUgPSBuYXRpdmVOb2RlO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJlbnQpICYmIHBhcmVudCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgcGFyZW50LmFkZENoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8uaW5qZWN0b3IgOiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJjb21wb25lbnRJbnN0YW5jZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fZGVidWdJbmZvKSA/IHRoaXMuX2RlYnVnSW5mby5jb21wb25lbnQgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8uY29udGV4dCA6IG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8ucmVmZXJlbmNlcyA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcInByb3ZpZGVyVG9rZW5zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9kZWJ1Z0luZm8pID8gdGhpcy5fZGVidWdJbmZvLnByb3ZpZGVyVG9rZW5zIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwic291cmNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8uc291cmNlIDogbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVXNlIGluamVjdG9yLmdldCh0b2tlbikgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgRGVidWdOb2RlLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRoaXMuaW5qZWN0b3IuZ2V0KHRva2VuKTsgfTtcbiAgICByZXR1cm4gRGVidWdOb2RlO1xufSgpKTtcbmV4cG9ydHMuRGVidWdOb2RlID0gRGVidWdOb2RlO1xudmFyIERlYnVnRWxlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYnVnRWxlbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWJ1Z0VsZW1lbnQobmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdJbmZvKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5hdGl2ZU5vZGUsIHBhcmVudCwgX2RlYnVnSW5mbyk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gW107XG4gICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZU5vZGU7XG4gICAgfVxuICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZEluZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLmluc2VydENoaWxkcmVuQWZ0ZXIgPSBmdW5jdGlvbiAoY2hpbGQsIG5ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBzaWJsaW5nSW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChzaWJsaW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNDaGlsZHJlbiA9IHRoaXMuY2hpbGROb2Rlcy5zbGljZSgwLCBzaWJsaW5nSW5kZXggKyAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLmNoaWxkTm9kZXMuc2xpY2Uoc2libGluZ0luZGV4ICsgMSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb25jYXQoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNvbmNhdChwcmV2aW91c0NoaWxkcmVuLCBuZXdDaGlsZHJlbiksIG5leHRDaGlsZHJlbik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobmV3Q2hpbGQucGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMucXVlcnlBbGwocHJlZGljYXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMubGVuZ3RoID4gMCA/IHJlc3VsdHNbMF0gOiBudWxsO1xuICAgIH07XG4gICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeUFsbCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgX3F1ZXJ5RWxlbWVudENoaWxkcmVuKHRoaXMsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH07XG4gICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeUFsbE5vZGVzID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICBfcXVlcnlOb2RlQ2hpbGRyZW4odGhpcywgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50LnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUudHJpZ2dlckV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50T2JqKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjayhldmVudE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERlYnVnRWxlbWVudDtcbn0oRGVidWdOb2RlKSk7XG5leHBvcnRzLkRlYnVnRWxlbWVudCA9IERlYnVnRWxlbWVudDtcbmZ1bmN0aW9uIGFzTmF0aXZlRWxlbWVudHMoZGVidWdFbHMpIHtcbiAgICByZXR1cm4gZGVidWdFbHMubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwubmF0aXZlRWxlbWVudDsgfSk7XG59XG5leHBvcnRzLmFzTmF0aXZlRWxlbWVudHMgPSBhc05hdGl2ZUVsZW1lbnRzO1xuZnVuY3Rpb24gX3F1ZXJ5RWxlbWVudENoaWxkcmVuKGVsZW1lbnQsIHByZWRpY2F0ZSwgbWF0Y2hlcykge1xuICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3F1ZXJ5RWxlbWVudENoaWxkcmVuKG5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9xdWVyeU5vZGVDaGlsZHJlbihwYXJlbnROb2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpIHtcbiAgICBpZiAocGFyZW50Tm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICBwYXJlbnROb2RlLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX3F1ZXJ5Tm9kZUNoaWxkcmVuKG5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIE5lZWQgdG8ga2VlcCB0aGUgbm9kZXMgaW4gYSBnbG9iYWwgTWFwIHNvIHRoYXQgbXVsdGlwbGUgYW5ndWxhciBhcHBzIGFyZSBzdXBwb3J0ZWQuXG52YXIgX25hdGl2ZU5vZGVUb0RlYnVnTm9kZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldERlYnVnTm9kZShuYXRpdmVOb2RlKSB7XG4gICAgcmV0dXJuIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUuZ2V0KG5hdGl2ZU5vZGUpO1xufVxuZXhwb3J0cy5nZXREZWJ1Z05vZGUgPSBnZXREZWJ1Z05vZGU7XG5mdW5jdGlvbiBnZXRBbGxEZWJ1Z05vZGVzKCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci52YWx1ZXMoX25hdGl2ZU5vZGVUb0RlYnVnTm9kZSk7XG59XG5leHBvcnRzLmdldEFsbERlYnVnTm9kZXMgPSBnZXRBbGxEZWJ1Z05vZGVzO1xuZnVuY3Rpb24gaW5kZXhEZWJ1Z05vZGUobm9kZSkge1xuICAgIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUuc2V0KG5vZGUubmF0aXZlTm9kZSwgbm9kZSk7XG59XG5leHBvcnRzLmluZGV4RGVidWdOb2RlID0gaW5kZXhEZWJ1Z05vZGU7XG5mdW5jdGlvbiByZW1vdmVEZWJ1Z05vZGVGcm9tSW5kZXgobm9kZSkge1xuICAgIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUuZGVsZXRlKG5vZGUubmF0aXZlTm9kZSk7XG59XG5leHBvcnRzLnJlbW92ZURlYnVnTm9kZUZyb21JbmRleCA9IHJlbW92ZURlYnVnTm9kZUZyb21JbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnX25vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZGVidWdfbm9kZV8xID0gcmVxdWlyZSgnLi9kZWJ1Z19ub2RlJyk7XG52YXIgRGVidWdEb21Sb290UmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYnVnRG9tUm9vdFJlbmRlcmVyKF9kZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IF9kZWxlZ2F0ZTtcbiAgICB9XG4gICAgRGVidWdEb21Sb290UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRQcm90bykge1xuICAgICAgICByZXR1cm4gbmV3IERlYnVnRG9tUmVuZGVyZXIodGhpcy5fZGVsZWdhdGUucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFByb3RvKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVidWdEb21Sb290UmVuZGVyZXI7XG59KCkpO1xuZXhwb3J0cy5EZWJ1Z0RvbVJvb3RSZW5kZXJlciA9IERlYnVnRG9tUm9vdFJlbmRlcmVyO1xudmFyIERlYnVnRG9tUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYnVnRG9tUmVuZGVyZXIoX2RlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgIH1cbiAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3RSb290RWxlbWVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKSB7XG4gICAgICAgIHZhciBuYXRpdmVFbCA9IHRoaXMuX2RlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pO1xuICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBkZWJ1Z19ub2RlXzEuRGVidWdFbGVtZW50KG5hdGl2ZUVsLCBudWxsLCBkZWJ1Z0luZm8pO1xuICAgICAgICBkZWJ1Z19ub2RlXzEuaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVFbDtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbmFtZSwgZGVidWdJbmZvKSB7XG4gICAgICAgIHZhciBuYXRpdmVFbCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZUVsZW1lbnQocGFyZW50RWxlbWVudCwgbmFtZSwgZGVidWdJbmZvKTtcbiAgICAgICAgdmFyIGRlYnVnRWwgPSBuZXcgZGVidWdfbm9kZV8xLkRlYnVnRWxlbWVudChuYXRpdmVFbCwgZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShwYXJlbnRFbGVtZW50KSwgZGVidWdJbmZvKTtcbiAgICAgICAgZGVidWdFbC5uYW1lID0gbmFtZTtcbiAgICAgICAgZGVidWdfbm9kZV8xLmluZGV4RGVidWdOb2RlKGRlYnVnRWwpO1xuICAgICAgICByZXR1cm4gbmF0aXZlRWw7XG4gICAgfTtcbiAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVWaWV3Um9vdCA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCkgeyByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY3JlYXRlVmlld1Jvb3QoaG9zdEVsZW1lbnQpOyB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbyk7XG4gICAgICAgIHZhciBkZWJ1Z0VsID0gbmV3IGRlYnVnX25vZGVfMS5EZWJ1Z05vZGUoY29tbWVudCwgZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShwYXJlbnRFbGVtZW50KSwgZGVidWdJbmZvKTtcbiAgICAgICAgZGVidWdfbm9kZV8xLmluZGV4RGVidWdOb2RlKGRlYnVnRWwpO1xuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgdmFsdWUsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRleHQocGFyZW50RWxlbWVudCwgdmFsdWUsIGRlYnVnSW5mbyk7XG4gICAgICAgIHZhciBkZWJ1Z0VsID0gbmV3IGRlYnVnX25vZGVfMS5EZWJ1Z05vZGUodGV4dCwgZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShwYXJlbnRFbGVtZW50KSwgZGVidWdJbmZvKTtcbiAgICAgICAgZGVidWdfbm9kZV8xLmluZGV4RGVidWdOb2RlKGRlYnVnRWwpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnByb2plY3ROb2RlcyA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBub2Rlcykge1xuICAgICAgICB2YXIgZGVidWdQYXJlbnQgPSBkZWJ1Z19ub2RlXzEuZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkZWJ1Z1BhcmVudCkgJiYgZGVidWdQYXJlbnQgaW5zdGFuY2VvZiBkZWJ1Z19ub2RlXzEuRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbGVtZW50XzEgPSBkZWJ1Z1BhcmVudDtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgZGVidWdFbGVtZW50XzEuYWRkQ2hpbGQoZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShub2RlKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLnByb2plY3ROb2RlcyhwYXJlbnRFbGVtZW50LCBub2Rlcyk7XG4gICAgfTtcbiAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hWaWV3QWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdmlld1Jvb3ROb2Rlcykge1xuICAgICAgICB2YXIgZGVidWdOb2RlID0gZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZGVidWdOb2RlKSkge1xuICAgICAgICAgICAgdmFyIGRlYnVnUGFyZW50ID0gZGVidWdOb2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmICh2aWV3Um9vdE5vZGVzLmxlbmd0aCA+IDAgJiYgbGFuZ18xLmlzUHJlc2VudChkZWJ1Z1BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVidWdWaWV3Um9vdE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb290Tm9kZSkgeyByZXR1cm4gZGVidWdWaWV3Um9vdE5vZGVzLnB1c2goZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShyb290Tm9kZSkpOyB9KTtcbiAgICAgICAgICAgICAgICBkZWJ1Z1BhcmVudC5pbnNlcnRDaGlsZHJlbkFmdGVyKGRlYnVnTm9kZSwgZGVidWdWaWV3Um9vdE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5hdHRhY2hWaWV3QWZ0ZXIobm9kZSwgdmlld1Jvb3ROb2Rlcyk7XG4gICAgfTtcbiAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSb290Tm9kZXMpIHtcbiAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdOb2RlID0gZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRlYnVnTm9kZSkgJiYgbGFuZ18xLmlzUHJlc2VudChkZWJ1Z05vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGRlYnVnTm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQoZGVidWdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLmRldGFjaFZpZXcodmlld1Jvb3ROb2Rlcyk7XG4gICAgfTtcbiAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95VmlldyA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCwgdmlld0FsbE5vZGVzKSB7XG4gICAgICAgIHZpZXdBbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IGRlYnVnX25vZGVfMS5yZW1vdmVEZWJ1Z05vZGVGcm9tSW5kZXgoZGVidWdfbm9kZV8xLmdldERlYnVnTm9kZShub2RlKSk7IH0pO1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgdmlld0FsbE5vZGVzKTtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGVidWdFbCA9IGRlYnVnX25vZGVfMS5nZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRlYnVnRWwpKSB7XG4gICAgICAgICAgICBkZWJ1Z0VsLmxpc3RlbmVycy5wdXNoKG5ldyBkZWJ1Z19ub2RlXzEuRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5saXN0ZW4ocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuR2xvYmFsID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmxpc3Rlbkdsb2JhbCh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgdmFyIGRlYnVnRWwgPSBkZWJ1Z19ub2RlXzEuZ2V0RGVidWdOb2RlKHJlbmRlckVsZW1lbnQpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChkZWJ1Z0VsKSAmJiBkZWJ1Z0VsIGluc3RhbmNlb2YgZGVidWdfbm9kZV8xLkRlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgZGVidWdFbC5wcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEVsZW1lbnRQcm9wZXJ0eShyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgIH07XG4gICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICB2YXIgZGVidWdFbCA9IGRlYnVnX25vZGVfMS5nZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBkZWJ1Z19ub2RlXzEuRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBkZWJ1Z0VsLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRFbGVtZW50QXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEJpbmRpbmdEZWJ1Z0luZm8ocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRDbGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUsIGlzQWRkKSB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEVsZW1lbnRDbGFzcyhyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUsIGlzQWRkKTtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudFN0eWxlKHJlbmRlckVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfTtcbiAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5pbnZva2VFbGVtZW50TWV0aG9kID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUuaW52b2tlRWxlbWVudE1ldGhvZChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKTtcbiAgICB9O1xuICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAocmVuZGVyTm9kZSwgdGV4dCkgeyB0aGlzLl9kZWxlZ2F0ZS5zZXRUZXh0KHJlbmRlck5vZGUsIHRleHQpOyB9O1xuICAgIHJldHVybiBEZWJ1Z0RvbVJlbmRlcmVyO1xufSgpKTtcbmV4cG9ydHMuRGVidWdEb21SZW5kZXJlciA9IERlYnVnRG9tUmVuZGVyZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Z19yZW5kZXJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG4vKipcbiogQG1vZHVsZVxuKiBAZGVzY3JpcHRpb25cbiogVGhlIGBkaWAgbW9kdWxlIHByb3ZpZGVzIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGNvbnRhaW5lciBzZXJ2aWNlcy5cbiovXG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vZGkvbWV0YWRhdGEnKTtcbmV4cG9ydHMuSW5qZWN0TWV0YWRhdGEgPSBtZXRhZGF0YV8xLkluamVjdE1ldGFkYXRhO1xuZXhwb3J0cy5PcHRpb25hbE1ldGFkYXRhID0gbWV0YWRhdGFfMS5PcHRpb25hbE1ldGFkYXRhO1xuZXhwb3J0cy5JbmplY3RhYmxlTWV0YWRhdGEgPSBtZXRhZGF0YV8xLkluamVjdGFibGVNZXRhZGF0YTtcbmV4cG9ydHMuU2VsZk1ldGFkYXRhID0gbWV0YWRhdGFfMS5TZWxmTWV0YWRhdGE7XG5leHBvcnRzLkhvc3RNZXRhZGF0YSA9IG1ldGFkYXRhXzEuSG9zdE1ldGFkYXRhO1xuZXhwb3J0cy5Ta2lwU2VsZk1ldGFkYXRhID0gbWV0YWRhdGFfMS5Ta2lwU2VsZk1ldGFkYXRhO1xuZXhwb3J0cy5EZXBlbmRlbmN5TWV0YWRhdGEgPSBtZXRhZGF0YV8xLkRlcGVuZGVuY3lNZXRhZGF0YTtcbi8vIHdlIGhhdmUgdG8gcmVleHBvcnQgKiBiZWNhdXNlIERhcnQgYW5kIFRTIGV4cG9ydCB0d28gZGlmZmVyZW50IHNldHMgb2YgdHlwZXNcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGkvZGVjb3JhdG9ycycpKTtcbnZhciBmb3J3YXJkX3JlZl8xID0gcmVxdWlyZSgnLi9kaS9mb3J3YXJkX3JlZicpO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZF9yZWZfMS5mb3J3YXJkUmVmO1xuZXhwb3J0cy5yZXNvbHZlRm9yd2FyZFJlZiA9IGZvcndhcmRfcmVmXzEucmVzb2x2ZUZvcndhcmRSZWY7XG52YXIgaW5qZWN0b3JfMSA9IHJlcXVpcmUoJy4vZGkvaW5qZWN0b3InKTtcbmV4cG9ydHMuSW5qZWN0b3IgPSBpbmplY3Rvcl8xLkluamVjdG9yO1xudmFyIHJlZmxlY3RpdmVfaW5qZWN0b3JfMSA9IHJlcXVpcmUoJy4vZGkvcmVmbGVjdGl2ZV9pbmplY3RvcicpO1xuZXhwb3J0cy5SZWZsZWN0aXZlSW5qZWN0b3IgPSByZWZsZWN0aXZlX2luamVjdG9yXzEuUmVmbGVjdGl2ZUluamVjdG9yO1xudmFyIHByb3ZpZGVyXzEgPSByZXF1aXJlKCcuL2RpL3Byb3ZpZGVyJyk7XG5leHBvcnRzLkJpbmRpbmcgPSBwcm92aWRlcl8xLkJpbmRpbmc7XG5leHBvcnRzLlByb3ZpZGVyQnVpbGRlciA9IHByb3ZpZGVyXzEuUHJvdmlkZXJCdWlsZGVyO1xuZXhwb3J0cy5iaW5kID0gcHJvdmlkZXJfMS5iaW5kO1xuZXhwb3J0cy5Qcm92aWRlciA9IHByb3ZpZGVyXzEuUHJvdmlkZXI7XG5leHBvcnRzLnByb3ZpZGUgPSBwcm92aWRlcl8xLnByb3ZpZGU7XG52YXIgcmVmbGVjdGl2ZV9wcm92aWRlcl8xID0gcmVxdWlyZSgnLi9kaS9yZWZsZWN0aXZlX3Byb3ZpZGVyJyk7XG5leHBvcnRzLlJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkgPSByZWZsZWN0aXZlX3Byb3ZpZGVyXzEuUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeTtcbmV4cG9ydHMuUmVmbGVjdGl2ZURlcGVuZGVuY3kgPSByZWZsZWN0aXZlX3Byb3ZpZGVyXzEuUmVmbGVjdGl2ZURlcGVuZGVuY3k7XG52YXIgcmVmbGVjdGl2ZV9rZXlfMSA9IHJlcXVpcmUoJy4vZGkvcmVmbGVjdGl2ZV9rZXknKTtcbmV4cG9ydHMuUmVmbGVjdGl2ZUtleSA9IHJlZmxlY3RpdmVfa2V5XzEuUmVmbGVjdGl2ZUtleTtcbnZhciByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4vZGkvcmVmbGVjdGl2ZV9leGNlcHRpb25zJyk7XG5leHBvcnRzLk5vUHJvdmlkZXJFcnJvciA9IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLk5vUHJvdmlkZXJFcnJvcjtcbmV4cG9ydHMuQWJzdHJhY3RQcm92aWRlckVycm9yID0gcmVmbGVjdGl2ZV9leGNlcHRpb25zXzEuQWJzdHJhY3RQcm92aWRlckVycm9yO1xuZXhwb3J0cy5DeWNsaWNEZXBlbmRlbmN5RXJyb3IgPSByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMS5DeWNsaWNEZXBlbmRlbmN5RXJyb3I7XG5leHBvcnRzLkluc3RhbnRpYXRpb25FcnJvciA9IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLkluc3RhbnRpYXRpb25FcnJvcjtcbmV4cG9ydHMuSW52YWxpZFByb3ZpZGVyRXJyb3IgPSByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMS5JbnZhbGlkUHJvdmlkZXJFcnJvcjtcbmV4cG9ydHMuTm9Bbm5vdGF0aW9uRXJyb3IgPSByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMS5Ob0Fubm90YXRpb25FcnJvcjtcbmV4cG9ydHMuT3V0T2ZCb3VuZHNFcnJvciA9IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLk91dE9mQm91bmRzRXJyb3I7XG52YXIgb3BhcXVlX3Rva2VuXzEgPSByZXF1aXJlKCcuL2RpL29wYXF1ZV90b2tlbicpO1xuZXhwb3J0cy5PcGFxdWVUb2tlbiA9IG9wYXF1ZV90b2tlbl8xLk9wYXF1ZVRva2VuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEnKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCcuLi91dGlsL2RlY29yYXRvcnMnKTtcbi8qKlxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcge0BsaW5rIEluamVjdE1ldGFkYXRhfS5cbiAqL1xuZXhwb3J0cy5JbmplY3QgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKG1ldGFkYXRhXzEuSW5qZWN0TWV0YWRhdGEpO1xuLyoqXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyB7QGxpbmsgT3B0aW9uYWxNZXRhZGF0YX0uXG4gKi9cbmV4cG9ydHMuT3B0aW9uYWwgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKG1ldGFkYXRhXzEuT3B0aW9uYWxNZXRhZGF0YSk7XG4vKipcbiAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIHtAbGluayBJbmplY3RhYmxlTWV0YWRhdGF9LlxuICovXG5leHBvcnRzLkluamVjdGFibGUgPSBkZWNvcmF0b3JzXzEubWFrZURlY29yYXRvcihtZXRhZGF0YV8xLkluamVjdGFibGVNZXRhZGF0YSk7XG4vKipcbiAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIHtAbGluayBTZWxmTWV0YWRhdGF9LlxuICovXG5leHBvcnRzLlNlbGYgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKG1ldGFkYXRhXzEuU2VsZk1ldGFkYXRhKTtcbi8qKlxuICogRmFjdG9yeSBmb3IgY3JlYXRpbmcge0BsaW5rIEhvc3RNZXRhZGF0YX0uXG4gKi9cbmV4cG9ydHMuSG9zdCA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IobWV0YWRhdGFfMS5Ib3N0TWV0YWRhdGEpO1xuLyoqXG4gKiBGYWN0b3J5IGZvciBjcmVhdGluZyB7QGxpbmsgU2tpcFNlbGZNZXRhZGF0YX0uXG4gKi9cbmV4cG9ydHMuU2tpcFNlbGYgPSBkZWNvcmF0b3JzXzEubWFrZVBhcmFtRGVjb3JhdG9yKG1ldGFkYXRhXzEuU2tpcFNlbGZNZXRhZGF0YSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvcmF0b3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xuLyoqXG4gKiBBbGxvd3MgdG8gcmVmZXIgdG8gcmVmZXJlbmNlcyB3aGljaCBhcmUgbm90IHlldCBkZWZpbmVkLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgYGZvcndhcmRSZWZgIGlzIHVzZWQgd2hlbiB0aGUgYHRva2VuYCB3aGljaCB3ZSBuZWVkIHRvIHJlZmVyIHRvIGZvciB0aGUgcHVycG9zZXMgb2ZcbiAqIERJIGlzIGRlY2xhcmVkLFxuICogYnV0IG5vdCB5ZXQgZGVmaW5lZC4gSXQgaXMgYWxzbyB1c2VkIHdoZW4gdGhlIGB0b2tlbmAgd2hpY2ggd2UgdXNlIHdoZW4gY3JlYXRpbmcgYSBxdWVyeSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiB7QGV4YW1wbGUgY29yZS9kaS90cy9mb3J3YXJkX3JlZi9mb3J3YXJkX3JlZi50cyByZWdpb249J2ZvcndhcmRfcmVmJ31cbiAqL1xuZnVuY3Rpb24gZm9yd2FyZFJlZihmb3J3YXJkUmVmRm4pIHtcbiAgICBmb3J3YXJkUmVmRm4uX19mb3J3YXJkX3JlZl9fID0gZm9yd2FyZFJlZjtcbiAgICBmb3J3YXJkUmVmRm4udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuc3RyaW5naWZ5KHRoaXMoKSk7IH07XG4gICAgcmV0dXJuIGZvcndhcmRSZWZGbjtcbn1cbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG4vKipcbiAqIExhemlseSByZXRyaWV2ZXMgdGhlIHJlZmVyZW5jZSB2YWx1ZSBmcm9tIGEgZm9yd2FyZFJlZi5cbiAqXG4gKiBBY3RzIGFzIHRoZSBpZGVudGl0eSBmdW5jdGlvbiB3aGVuIGdpdmVuIGEgbm9uLWZvcndhcmQtcmVmIHZhbHVlLlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HVTcybUpyazFmaW9kQ2hjbWlEUj9wPXByZXZpZXcpKVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHZhciByZWYgPSBmb3J3YXJkUmVmKCgpID0+IFwicmVmVmFsdWVcIik7XG4gKiBleHBlY3QocmVzb2x2ZUZvcndhcmRSZWYocmVmKSkudG9FcXVhbChcInJlZlZhbHVlXCIpO1xuICogZXhwZWN0KHJlc29sdmVGb3J3YXJkUmVmKFwicmVndWxhclZhbHVlXCIpKS50b0VxdWFsKFwicmVndWxhclZhbHVlXCIpO1xuICogYGBgXG4gKlxuICogU2VlOiB7QGxpbmsgZm9yd2FyZFJlZn1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSkge1xuICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbih0eXBlKSAmJiB0eXBlLmhhc093blByb3BlcnR5KCdfX2ZvcndhcmRfcmVmX18nKSAmJlxuICAgICAgICB0eXBlLl9fZm9yd2FyZF9yZWZfXyA9PT0gZm9yd2FyZFJlZikge1xuICAgICAgICByZXR1cm4gdHlwZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxufVxuZXhwb3J0cy5yZXNvbHZlRm9yd2FyZFJlZiA9IHJlc29sdmVGb3J3YXJkUmVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yd2FyZF9yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgX1RIUk9XX0lGX05PVF9GT1VORCA9IG5ldyBPYmplY3QoKTtcbmV4cG9ydHMuVEhST1dfSUZfTk9UX0ZPVU5EID0gX1RIUk9XX0lGX05PVF9GT1VORDtcbnZhciBJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5qZWN0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBpbnN0YW5jZSBmcm9tIHRoZSBpbmplY3RvciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdG9rZW4uXG4gICAgICogSWYgbm90IGZvdW5kOlxuICAgICAqIC0gVGhyb3dzIHtAbGluayBOb1Byb3ZpZGVyRXJyb3J9IGlmIG5vIGBub3RGb3VuZFZhbHVlYCB0aGF0IGlzIG5vdCBlcXVhbCB0b1xuICAgICAqIEluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORCBpcyBnaXZlblxuICAgICAqIC0gUmV0dXJucyB0aGUgYG5vdEZvdW5kVmFsdWVgIG90aGVyd2lzZVxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0hlWFNIZz9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHByb3ZpZGUoXCJ2YWxpZFRva2VuXCIsIHt1c2VWYWx1ZTogXCJWYWx1ZVwifSlcbiAgICAgKiBdKTtcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KFwidmFsaWRUb2tlblwiKSkudG9FcXVhbChcIlZhbHVlXCIpO1xuICAgICAqIGV4cGVjdCgoKSA9PiBpbmplY3Rvci5nZXQoXCJpbnZhbGlkVG9rZW5cIikpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYEluamVjdG9yYCByZXR1cm5zIGl0c2VsZiB3aGVuIGdpdmVuIGBJbmplY3RvcmAgYXMgYSB0b2tlbi5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXSk7XG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldChJbmplY3RvcikpLnRvQmUoaW5qZWN0b3IpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEluamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH07XG4gICAgSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EID0gX1RIUk9XX0lGX05PVF9GT1VORDtcbiAgICByZXR1cm4gSW5qZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5JbmplY3RvciA9IEluamVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG4vKipcbiAqIEEgcGFyYW1ldGVyIG1ldGFkYXRhIHRoYXQgc3BlY2lmaWVzIGEgZGVwZW5kZW5jeS5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvNnVIWUpLP3A9cHJldmlldykpXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgRW5naW5lIHt9XG4gKlxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgQ2FyIHtcbiAqICAgZW5naW5lO1xuICogICBjb25zdHJ1Y3RvcihASW5qZWN0KFwiTXlFbmdpbmVcIikgZW5naW5lOkVuZ2luZSkge1xuICogICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gKiAgcHJvdmlkZShcIk15RW5naW5lXCIsIHt1c2VDbGFzczogRW5naW5lfSksXG4gKiAgQ2FyXG4gKiBdKTtcbiAqXG4gKiBleHBlY3QoaW5qZWN0b3IuZ2V0KENhcikuZW5naW5lIGluc3RhbmNlb2YgRW5naW5lKS50b0JlKHRydWUpO1xuICogYGBgXG4gKlxuICogV2hlbiBgQEluamVjdCgpYCBpcyBub3QgcHJlc2VudCwge0BsaW5rIEluamVjdG9yfSB3aWxsIHVzZSB0aGUgdHlwZSBhbm5vdGF0aW9uIG9mIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBFbmdpbmUge31cbiAqXG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBDYXIge1xuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOiBFbmdpbmUpIHt9IC8vc2FtZSBhcyBjb25zdHJ1Y3RvcihASW5qZWN0KEVuZ2luZSkgZW5naW5lOkVuZ2luZSlcbiAqIH1cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtFbmdpbmUsIENhcl0pO1xuICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpLmVuZ2luZSBpbnN0YW5jZW9mIEVuZ2luZSkudG9CZSh0cnVlKTtcbiAqIGBgYFxuICogQHRzMmRhcnRfY29uc3RcbiAqL1xudmFyIEluamVjdE1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmplY3RNZXRhZGF0YSh0b2tlbikge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIEluamVjdE1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQEluamVjdChcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIilcIjsgfTtcbiAgICByZXR1cm4gSW5qZWN0TWV0YWRhdGE7XG59KCkpO1xuZXhwb3J0cy5JbmplY3RNZXRhZGF0YSA9IEluamVjdE1ldGFkYXRhO1xuLyoqXG4gKiBBIHBhcmFtZXRlciBtZXRhZGF0YSB0aGF0IG1hcmtzIGEgZGVwZW5kZW5jeSBhcyBvcHRpb25hbC4ge0BsaW5rIEluamVjdG9yfSBwcm92aWRlcyBgbnVsbGAgaWZcbiAqIHRoZSBkZXBlbmRlbmN5IGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvQXNyeU9tP3A9cHJldmlldykpXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgRW5naW5lIHt9XG4gKlxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgQ2FyIHtcbiAqICAgZW5naW5lO1xuICogICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBlbmdpbmU6RW5naW5lKSB7XG4gKiAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtDYXJdKTtcbiAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKS5lbmdpbmUpLnRvQmVOdWxsKCk7XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBPcHRpb25hbE1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHRpb25hbE1ldGFkYXRhKCkge1xuICAgIH1cbiAgICBPcHRpb25hbE1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQE9wdGlvbmFsKClcIjsgfTtcbiAgICByZXR1cm4gT3B0aW9uYWxNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLk9wdGlvbmFsTWV0YWRhdGEgPSBPcHRpb25hbE1ldGFkYXRhO1xuLyoqXG4gKiBgRGVwZW5kZW5jeU1ldGFkYXRhYCBpcyB1c2VkIGJ5IHRoZSBmcmFtZXdvcmsgdG8gZXh0ZW5kIERJLlxuICogVGhpcyBpcyBpbnRlcm5hbCB0byBBbmd1bGFyIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkuXG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgRGVwZW5kZW5jeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXBlbmRlbmN5TWV0YWRhdGEoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZXBlbmRlbmN5TWV0YWRhdGEucHJvdG90eXBlLCBcInRva2VuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGVwZW5kZW5jeU1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuRGVwZW5kZW5jeU1ldGFkYXRhID0gRGVwZW5kZW5jeU1ldGFkYXRhO1xuLyoqXG4gKiBBIG1hcmtlciBtZXRhZGF0YSB0aGF0IG1hcmtzIGEgY2xhc3MgYXMgYXZhaWxhYmxlIHRvIHtAbGluayBJbmplY3Rvcn0gZm9yIGNyZWF0aW9uLlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9XazRETVE/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBVc2VmdWxTZXJ2aWNlIHt9XG4gKlxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgTmVlZHNTZXJ2aWNlIHtcbiAqICAgY29uc3RydWN0b3IocHVibGljIHNlcnZpY2U6VXNlZnVsU2VydmljZSkge31cbiAqIH1cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtOZWVkc1NlcnZpY2UsIFVzZWZ1bFNlcnZpY2VdKTtcbiAqIGV4cGVjdChpbmplY3Rvci5nZXQoTmVlZHNTZXJ2aWNlKS5zZXJ2aWNlIGluc3RhbmNlb2YgVXNlZnVsU2VydmljZSkudG9CZSh0cnVlKTtcbiAqIGBgYFxuICoge0BsaW5rIEluamVjdG9yfSB3aWxsIHRocm93IHtAbGluayBOb0Fubm90YXRpb25FcnJvcn0gd2hlbiB0cnlpbmcgdG8gaW5zdGFudGlhdGUgYSBjbGFzcyB0aGF0XG4gKiBkb2VzIG5vdCBoYXZlIGBASW5qZWN0YWJsZWAgbWFya2VyLCBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBVc2VmdWxTZXJ2aWNlIHt9XG4gKlxuICogY2xhc3MgTmVlZHNTZXJ2aWNlIHtcbiAqICAgY29uc3RydWN0b3IocHVibGljIHNlcnZpY2U6VXNlZnVsU2VydmljZSkge31cbiAqIH1cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtOZWVkc1NlcnZpY2UsIFVzZWZ1bFNlcnZpY2VdKTtcbiAqIGV4cGVjdCgoKSA9PiBpbmplY3Rvci5nZXQoTmVlZHNTZXJ2aWNlKSkudG9UaHJvd0Vycm9yKCk7XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBJbmplY3RhYmxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluamVjdGFibGVNZXRhZGF0YSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEluamVjdGFibGVNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLkluamVjdGFibGVNZXRhZGF0YSA9IEluamVjdGFibGVNZXRhZGF0YTtcbi8qKlxuICogU3BlY2lmaWVzIHRoYXQgYW4ge0BsaW5rIEluamVjdG9yfSBzaG91bGQgcmV0cmlldmUgYSBkZXBlbmRlbmN5IG9ubHkgZnJvbSBpdHNlbGYuXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L05lYWdBZz9wPXByZXZpZXcpKVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIERlcGVuZGVuY3kge1xuICogfVxuICpcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIE5lZWRzRGVwZW5kZW5jeSB7XG4gKiAgIGRlcGVuZGVuY3k7XG4gKiAgIGNvbnN0cnVjdG9yKEBTZWxmKCkgZGVwZW5kZW5jeTpEZXBlbmRlbmN5KSB7XG4gKiAgICAgdGhpcy5kZXBlbmRlbmN5ID0gZGVwZW5kZW5jeTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBpbmogPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtEZXBlbmRlbmN5LCBOZWVkc0RlcGVuZGVuY3ldKTtcbiAqIHZhciBuZCA9IGluai5nZXQoTmVlZHNEZXBlbmRlbmN5KTtcbiAqXG4gKiBleHBlY3QobmQuZGVwZW5kZW5jeSBpbnN0YW5jZW9mIERlcGVuZGVuY3kpLnRvQmUodHJ1ZSk7XG4gKlxuICogdmFyIGluaiA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0RlcGVuZGVuY3ldKTtcbiAqIHZhciBjaGlsZCA9IGluai5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQoW05lZWRzRGVwZW5kZW5jeV0pO1xuICogZXhwZWN0KCgpID0+IGNoaWxkLmdldChOZWVkc0RlcGVuZGVuY3kpKS50b1Rocm93RXJyb3IoKTtcbiAqIGBgYFxuICogQHRzMmRhcnRfY29uc3RcbiAqL1xudmFyIFNlbGZNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZk1ldGFkYXRhKCkge1xuICAgIH1cbiAgICBTZWxmTWV0YWRhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJAU2VsZigpXCI7IH07XG4gICAgcmV0dXJuIFNlbGZNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLlNlbGZNZXRhZGF0YSA9IFNlbGZNZXRhZGF0YTtcbi8qKlxuICogU3BlY2lmaWVzIHRoYXQgdGhlIGRlcGVuZGVuY3kgcmVzb2x1dGlvbiBzaG91bGQgc3RhcnQgZnJvbSB0aGUgcGFyZW50IGluamVjdG9yLlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9XY2hkemI/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBEZXBlbmRlbmN5IHtcbiAqIH1cbiAqXG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBOZWVkc0RlcGVuZGVuY3kge1xuICogICBkZXBlbmRlbmN5O1xuICogICBjb25zdHJ1Y3RvcihAU2tpcFNlbGYoKSBkZXBlbmRlbmN5OkRlcGVuZGVuY3kpIHtcbiAqICAgICB0aGlzLmRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5O1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIHBhcmVudCA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0RlcGVuZGVuY3ldKTtcbiAqIHZhciBjaGlsZCA9IHBhcmVudC5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQoW05lZWRzRGVwZW5kZW5jeV0pO1xuICogZXhwZWN0KGNoaWxkLmdldChOZWVkc0RlcGVuZGVuY3kpLmRlcGVuZGVuY3kgaW5zdGFuY2VvZiBEZXBlZGVuY3kpLnRvQmUodHJ1ZSk7XG4gKlxuICogdmFyIGluaiA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0RlcGVuZGVuY3ksIE5lZWRzRGVwZW5kZW5jeV0pO1xuICogZXhwZWN0KCgpID0+IGluai5nZXQoTmVlZHNEZXBlbmRlbmN5KSkudG9UaHJvd0Vycm9yKCk7XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBTa2lwU2VsZk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTa2lwU2VsZk1ldGFkYXRhKCkge1xuICAgIH1cbiAgICBTa2lwU2VsZk1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQFNraXBTZWxmKClcIjsgfTtcbiAgICByZXR1cm4gU2tpcFNlbGZNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLlNraXBTZWxmTWV0YWRhdGEgPSBTa2lwU2VsZk1ldGFkYXRhO1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhhdCBhbiBpbmplY3RvciBzaG91bGQgcmV0cmlldmUgYSBkZXBlbmRlbmN5IGZyb20gYW55IGluamVjdG9yIHVudGlsIHJlYWNoaW5nIHRoZVxuICogY2xvc2VzdCBob3N0LlxuICpcbiAqIEluIEFuZ3VsYXIsIGEgY29tcG9uZW50IGVsZW1lbnQgaXMgYXV0b21hdGljYWxseSBkZWNsYXJlZCBhcyBhIGhvc3QgZm9yIGFsbCB0aGUgaW5qZWN0b3JzIGluXG4gKiBpdHMgdmlldy5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvR1g3OXBWP3A9cHJldmlldykpXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlIGBBcHBgIGNvbnRhaW5zIGBQYXJlbnRDbXBgLCB3aGljaCBjb250YWlucyBgQ2hpbGREaXJlY3RpdmVgLlxuICogU28gYFBhcmVudENtcGAgaXMgdGhlIGhvc3Qgb2YgYENoaWxkRGlyZWN0aXZlYC5cbiAqXG4gKiBgQ2hpbGREaXJlY3RpdmVgIGRlcGVuZHMgb24gdHdvIHNlcnZpY2VzOiBgSG9zdFNlcnZpY2VgIGFuZCBgT3RoZXJTZXJ2aWNlYC5cbiAqIGBIb3N0U2VydmljZWAgaXMgZGVmaW5lZCBhdCBgUGFyZW50Q21wYCwgYW5kIGBPdGhlclNlcnZpY2VgIGlzIGRlZmluZWQgYXQgYEFwcGAuXG4gKlxuICpgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBPdGhlclNlcnZpY2Uge31cbiAqIGNsYXNzIEhvc3RTZXJ2aWNlIHt9XG4gKlxuICogQERpcmVjdGl2ZSh7XG4gKiAgIHNlbGVjdG9yOiAnY2hpbGQtZGlyZWN0aXZlJ1xuICogfSlcbiAqIGNsYXNzIENoaWxkRGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEhvc3QoKSBvczpPdGhlclNlcnZpY2UsIEBPcHRpb25hbCgpIEBIb3N0KCkgaHM6SG9zdFNlcnZpY2Upe1xuICogICAgIGNvbnNvbGUubG9nKFwib3MgaXMgbnVsbFwiLCBvcyk7XG4gKiAgICAgY29uc29sZS5sb2coXCJocyBpcyBOT1QgbnVsbFwiLCBocyk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdwYXJlbnQtY21wJyxcbiAqICAgcHJvdmlkZXJzOiBbSG9zdFNlcnZpY2VdLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIERpcjogPGNoaWxkLWRpcmVjdGl2ZT48L2NoaWxkLWRpcmVjdGl2ZT5cbiAqICAgYCxcbiAqICAgZGlyZWN0aXZlczogW0NoaWxkRGlyZWN0aXZlXVxuICogfSlcbiAqIGNsYXNzIFBhcmVudENtcCB7XG4gKiB9XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcbiAqICAgcHJvdmlkZXJzOiBbT3RoZXJTZXJ2aWNlXSxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICBQYXJlbnQ6IDxwYXJlbnQtY21wPjwvcGFyZW50LWNtcD5cbiAqICAgYCxcbiAqICAgZGlyZWN0aXZlczogW1BhcmVudENtcF1cbiAqIH0pXG4gKiBjbGFzcyBBcHAge1xuICogfVxuICpcbiAqIGJvb3RzdHJhcChBcHApO1xuICpgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBIb3N0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhvc3RNZXRhZGF0YSgpIHtcbiAgICB9XG4gICAgSG9zdE1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQEhvc3QoKVwiOyB9O1xuICAgIHJldHVybiBIb3N0TWV0YWRhdGE7XG59KCkpO1xuZXhwb3J0cy5Ib3N0TWV0YWRhdGEgPSBIb3N0TWV0YWRhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuKiBDcmVhdGVzIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCBpbiBhIERJIFByb3ZpZGVyLlxuKlxuKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvWXM5ZXpYcGoyTW5veTNVYzhLQnA/cD1wcmV2aWV3KSlcbipcbiogYGBgdHlwZXNjcmlwdFxuKiB2YXIgdCA9IG5ldyBPcGFxdWVUb2tlbihcInZhbHVlXCIpO1xuKlxuKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiogICBwcm92aWRlKHQsIHt1c2VWYWx1ZTogXCJiaW5kaW5nVmFsdWVcIn0pXG4qIF0pO1xuKlxuKiBleHBlY3QoaW5qZWN0b3IuZ2V0KHQpKS50b0VxdWFsKFwiYmluZGluZ1ZhbHVlXCIpO1xuKiBgYGBcbipcbiogVXNpbmcgYW4gYE9wYXF1ZVRva2VuYCBpcyBwcmVmZXJhYmxlIHRvIHVzaW5nIHN0cmluZ3MgYXMgdG9rZW5zIGJlY2F1c2Ugb2YgcG9zc2libGUgY29sbGlzaW9uc1xuKiBjYXVzZWQgYnkgbXVsdGlwbGUgcHJvdmlkZXJzIHVzaW5nIHRoZSBzYW1lIHN0cmluZyBhcyB0d28gZGlmZmVyZW50IHRva2Vucy5cbipcbiogVXNpbmcgYW4gYE9wYXF1ZVRva2VuYCBpcyBwcmVmZXJhYmxlIHRvIHVzaW5nIGFuIGBPYmplY3RgIGFzIHRva2VucyBiZWNhdXNlIGl0IHByb3ZpZGVzIGJldHRlclxuKiBlcnJvciBtZXNzYWdlcy5cbiogQHRzMmRhcnRfY29uc3RcbiovXG52YXIgT3BhcXVlVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wYXF1ZVRva2VuKF9kZXNjKSB7XG4gICAgICAgIHRoaXMuX2Rlc2MgPSBfZGVzYztcbiAgICB9XG4gICAgT3BhcXVlVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUb2tlbiBcIiArIHRoaXMuX2Rlc2M7IH07XG4gICAgcmV0dXJuIE9wYXF1ZVRva2VuO1xufSgpKTtcbmV4cG9ydHMuT3BhcXVlVG9rZW4gPSBPcGFxdWVUb2tlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wYXF1ZV90b2tlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IHRoZSB7QGxpbmsgSW5qZWN0b3J9IHNob3VsZCBpbnN0YW50aWF0ZSBhIGdpdmVuIHRva2VuLlxuICpcbiAqIFNlZSB7QGxpbmsgcHJvdmlkZX0uXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0dOQXlqNks2UGZZZzJOQnpnd1o1P3AlM0RwcmV2aWV3JnA9cHJldmlldykpXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gKiAgIG5ldyBQcm92aWRlcihcIm1lc3NhZ2VcIiwgeyB1c2VWYWx1ZTogJ0hlbGxvJyB9KVxuICogXSk7XG4gKlxuICogZXhwZWN0KGluamVjdG9yLmdldChcIm1lc3NhZ2VcIikpLnRvRXF1YWwoJ0hlbGxvJyk7XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBQcm92aWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXIodG9rZW4sIF9hKSB7XG4gICAgICAgIHZhciB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy51c2VDbGFzcyA9IHVzZUNsYXNzO1xuICAgICAgICB0aGlzLnVzZVZhbHVlID0gdXNlVmFsdWU7XG4gICAgICAgIHRoaXMudXNlRXhpc3RpbmcgPSB1c2VFeGlzdGluZztcbiAgICAgICAgdGhpcy51c2VGYWN0b3J5ID0gdXNlRmFjdG9yeTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBzO1xuICAgICAgICB0aGlzLl9tdWx0aSA9IG11bHRpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXIucHJvdG90eXBlLCBcIm11bHRpXCIsIHtcbiAgICAgICAgLy8gVE9ETzogUHJvdmlkZSBhIGZ1bGwgd29ya2luZyBleGFtcGxlIGFmdGVyIGFscGhhMzggaXMgcmVsZWFzZWQuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIG11bHRpcGxlIHByb3ZpZGVycyBtYXRjaGluZyB0aGUgc2FtZSB0b2tlbiAoYSBtdWx0aS1wcm92aWRlcikuXG4gICAgICAgICAqXG4gICAgICAgICAqIE11bHRpLXByb3ZpZGVycyBhcmUgdXNlZCBmb3IgY3JlYXRpbmcgcGx1Z2dhYmxlIHNlcnZpY2UsIHdoZXJlIHRoZSBzeXN0ZW0gY29tZXNcbiAgICAgICAgICogd2l0aCBzb21lIGRlZmF1bHQgcHJvdmlkZXJzLCBhbmQgdGhlIHVzZXIgY2FuIHJlZ2lzdGVyIGFkZGl0aW9uYWwgcHJvdmlkZXJzLlxuICAgICAgICAgKiBUaGUgY29tYmluYXRpb24gb2YgdGhlIGRlZmF1bHQgcHJvdmlkZXJzIGFuZCB0aGUgYWRkaXRpb25hbCBwcm92aWRlcnMgd2lsbCBiZVxuICAgICAgICAgKiB1c2VkIHRvIGRyaXZlIHRoZSBiZWhhdmlvciBvZiB0aGUgc3lzdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAgICAgKiAgIG5ldyBQcm92aWRlcihcIlN0cmluZ3NcIiwgeyB1c2VWYWx1ZTogXCJTdHJpbmcxXCIsIG11bHRpOiB0cnVlfSksXG4gICAgICAgICAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7IHVzZVZhbHVlOiBcIlN0cmluZzJcIiwgbXVsdGk6IHRydWV9KVxuICAgICAgICAgKiBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KGluamVjdG9yLmdldChcIlN0cmluZ3NcIikpLnRvRXF1YWwoW1wiU3RyaW5nMVwiLCBcIlN0cmluZzJcIl0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogTXVsdGktcHJvdmlkZXJzIGFuZCByZWd1bGFyIHByb3ZpZGVycyBjYW5ub3QgYmUgbWl4ZWQuIFRoZSBmb2xsb3dpbmdcbiAgICAgICAgICogd2lsbCB0aHJvdyBhbiBleGNlcHRpb246XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICAgICAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7IHVzZVZhbHVlOiBcIlN0cmluZzFcIiwgbXVsdGk6IHRydWUgfSksXG4gICAgICAgICAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7IHVzZVZhbHVlOiBcIlN0cmluZzJcIn0pXG4gICAgICAgICAqIF0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLm5vcm1hbGl6ZUJvb2wodGhpcy5fbXVsdGkpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvdmlkZXI7XG59KCkpO1xuZXhwb3J0cy5Qcm92aWRlciA9IFByb3ZpZGVyO1xuLyoqXG4gKiBTZWUge0BsaW5rIFByb3ZpZGVyfSBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgQmluZGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbmRpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmluZGluZyh0b2tlbiwgX2EpIHtcbiAgICAgICAgdmFyIHRvQ2xhc3MgPSBfYS50b0NsYXNzLCB0b1ZhbHVlID0gX2EudG9WYWx1ZSwgdG9BbGlhcyA9IF9hLnRvQWxpYXMsIHRvRmFjdG9yeSA9IF9hLnRvRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHRva2VuLCB7XG4gICAgICAgICAgICB1c2VDbGFzczogdG9DbGFzcyxcbiAgICAgICAgICAgIHVzZVZhbHVlOiB0b1ZhbHVlLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRvQWxpYXMsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiB0b0ZhY3RvcnksXG4gICAgICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICAgICAgbXVsdGk6IG11bHRpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZGluZy5wcm90b3R5cGUsIFwidG9DbGFzc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVzZUNsYXNzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZGluZy5wcm90b3R5cGUsIFwidG9BbGlhc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnVzZUV4aXN0aW5nOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZGluZy5wcm90b3R5cGUsIFwidG9GYWN0b3J5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudXNlRmFjdG9yeTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRpbmcucHJvdG90eXBlLCBcInRvVmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy51c2VWYWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEJpbmRpbmc7XG59KFByb3ZpZGVyKSk7XG5leHBvcnRzLkJpbmRpbmcgPSBCaW5kaW5nO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFByb3ZpZGVyfS5cbiAqXG4gKiBUbyBjb25zdHJ1Y3QgYSB7QGxpbmsgUHJvdmlkZXJ9LCBiaW5kIGEgYHRva2VuYCB0byBlaXRoZXIgYSBjbGFzcywgYSB2YWx1ZSwgYSBmYWN0b3J5IGZ1bmN0aW9uLFxuICogb3JcbiAqIHRvIGFuIGV4aXN0aW5nIGB0b2tlbmAuXG4gKiBTZWUge0BsaW5rIFByb3ZpZGVyQnVpbGRlcn0gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBUaGUgYHRva2VuYCBpcyBtb3N0IGNvbW1vbmx5IGEgY2xhc3Mgb3Ige0BsaW5rIE9wYXF1ZVRva2VuLWNsYXNzLmh0bWx9LlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIGJpbmQodG9rZW4pIHtcbiAgICByZXR1cm4gbmV3IFByb3ZpZGVyQnVpbGRlcih0b2tlbik7XG59XG5leHBvcnRzLmJpbmQgPSBiaW5kO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHRoZSB7QGxpbmsgYmluZH0gZnVuY3Rpb24uXG4gKi9cbnZhciBQcm92aWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyQnVpbGRlcih0b2tlbikge1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIGEgREkgdG9rZW4gdG8gYSBjbGFzcy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9acEJDU1lxdjZlMnVkNUtYTGR4UT9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogQmVjYXVzZSBgdG9BbGlhc2AgYW5kIGB0b0NsYXNzYCBhcmUgb2Z0ZW4gY29uZnVzZWQsIHRoZSBleGFtcGxlIGNvbnRhaW5zXG4gICAgICogYm90aCB1c2UgY2FzZXMgZm9yIGVhc3kgY29tcGFyaXNvbi5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBWZWhpY2xlIHt9XG4gICAgICpcbiAgICAgKiBjbGFzcyBDYXIgZXh0ZW5kcyBWZWhpY2xlIHt9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3JDbGFzcyA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAqICAgQ2FyLFxuICAgICAqICAgcHJvdmlkZShWZWhpY2xlLCB7dXNlQ2xhc3M6IENhcn0pXG4gICAgICogXSk7XG4gICAgICogdmFyIGluamVjdG9yQWxpYXMgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIENhcixcbiAgICAgKiAgIHByb3ZpZGUoVmVoaWNsZSwge3VzZUV4aXN0aW5nOiBDYXJ9KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KGluamVjdG9yQ2xhc3MuZ2V0KFZlaGljbGUpKS5ub3QudG9CZShpbmplY3RvckNsYXNzLmdldChDYXIpKTtcbiAgICAgKiBleHBlY3QoaW5qZWN0b3JDbGFzcy5nZXQoVmVoaWNsZSkgaW5zdGFuY2VvZiBDYXIpLnRvQmUodHJ1ZSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoaW5qZWN0b3JBbGlhcy5nZXQoVmVoaWNsZSkpLnRvQmUoaW5qZWN0b3JBbGlhcy5nZXQoQ2FyKSk7XG4gICAgICogZXhwZWN0KGluamVjdG9yQWxpYXMuZ2V0KFZlaGljbGUpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUudG9DbGFzcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICghbGFuZ18xLmlzVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiVHJ5aW5nIHRvIGNyZWF0ZSBhIGNsYXNzIHByb3ZpZGVyIGJ1dCBcXFwiXCIgKyBsYW5nXzEuc3RyaW5naWZ5KHR5cGUpICsgXCJcXFwiIGlzIG5vdCBhIGNsYXNzIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb3ZpZGVyKHRoaXMudG9rZW4sIHsgdXNlQ2xhc3M6IHR5cGUgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIERJIHRva2VuIHRvIGEgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvRzAyNFBGSG1ETDBjSkZnZlpLOE8/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHByb3ZpZGUoJ21lc3NhZ2UnLCB7dXNlVmFsdWU6ICdIZWxsbyd9KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldCgnbWVzc2FnZScpKS50b0VxdWFsKCdIZWxsbycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUudG9WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFByb3ZpZGVyKHRoaXMudG9rZW4sIHsgdXNlVmFsdWU6IHZhbHVlIH0pOyB9O1xuICAgIC8qKlxuICAgICAqIEJpbmRzIGEgREkgdG9rZW4gdG8gYW4gZXhpc3RpbmcgdG9rZW4uXG4gICAgICpcbiAgICAgKiBBbmd1bGFyIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlIGFzIGlmIHRoZSBwcm92aWRlZCB0b2tlbiB3YXMgdXNlZC4gKFRoaXMgaXNcbiAgICAgKiBpbiBjb250cmFzdCB0byBgdXNlQ2xhc3NgIHdoZXJlIGEgc2VwYXJhdGUgaW5zdGFuY2Ugb2YgYHVzZUNsYXNzYCB3aWxsIGJlIHJldHVybmVkLilcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC91QmFvRjJwTjVjZmM1QWZaYXBOdz9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogQmVjYXVzZSBgdG9BbGlhc2AgYW5kIGB0b0NsYXNzYCBhcmUgb2Z0ZW4gY29uZnVzZWQsIHRoZSBleGFtcGxlIGNvbnRhaW5zXG4gICAgICogYm90aCB1c2UgY2FzZXMgZm9yIGVhc3kgY29tcGFyaXNvbi5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBWZWhpY2xlIHt9XG4gICAgICpcbiAgICAgKiBjbGFzcyBDYXIgZXh0ZW5kcyBWZWhpY2xlIHt9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3JBbGlhcyA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAqICAgQ2FyLFxuICAgICAqICAgcHJvdmlkZShWZWhpY2xlLCB7dXNlRXhpc3Rpbmc6IENhcn0pXG4gICAgICogXSk7XG4gICAgICogdmFyIGluamVjdG9yQ2xhc3MgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIENhcixcbiAgICAgKiAgIHByb3ZpZGUoVmVoaWNsZSwge3VzZUNsYXNzOiBDYXJ9KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KGluamVjdG9yQWxpYXMuZ2V0KFZlaGljbGUpKS50b0JlKGluamVjdG9yQWxpYXMuZ2V0KENhcikpO1xuICAgICAqIGV4cGVjdChpbmplY3RvckFsaWFzLmdldChWZWhpY2xlKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChpbmplY3RvckNsYXNzLmdldChWZWhpY2xlKSkubm90LnRvQmUoaW5qZWN0b3JDbGFzcy5nZXQoQ2FyKSk7XG4gICAgICogZXhwZWN0KGluamVjdG9yQ2xhc3MuZ2V0KFZlaGljbGUpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUudG9BbGlhcyA9IGZ1bmN0aW9uIChhbGlhc1Rva2VuKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhhbGlhc1Rva2VuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2FuIG5vdCBhbGlhcyBcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIiB0byBhIGJsYW5rIHZhbHVlIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb3ZpZGVyKHRoaXMudG9rZW4sIHsgdXNlRXhpc3Rpbmc6IGFsaWFzVG9rZW4gfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kcyBhIERJIHRva2VuIHRvIGEgZnVuY3Rpb24gd2hpY2ggY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L09lak5JZlRUM3piMWlCeGFJWU9iP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICogICBwcm92aWRlKE51bWJlciwge3VzZUZhY3Rvcnk6ICgpID0+IHsgcmV0dXJuIDErMjsgfX0pLFxuICAgICAqICAgcHJvdmlkZShTdHJpbmcsIHt1c2VGYWN0b3J5OiAodikgPT4geyByZXR1cm4gXCJWYWx1ZTogXCIgKyB2OyB9LCBkZXBzOiBbTnVtYmVyXX0pXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KE51bWJlcikpLnRvRXF1YWwoMyk7XG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldChTdHJpbmcpKS50b0VxdWFsKCdWYWx1ZTogMycpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUudG9GYWN0b3J5ID0gZnVuY3Rpb24gKGZhY3RvcnksIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIWxhbmdfMS5pc0Z1bmN0aW9uKGZhY3RvcnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJUcnlpbmcgdG8gY3JlYXRlIGEgZmFjdG9yeSBwcm92aWRlciBidXQgXFxcIlwiICsgbGFuZ18xLnN0cmluZ2lmeShmYWN0b3J5KSArIFwiXFxcIiBpcyBub3QgYSBmdW5jdGlvbiFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlcih0aGlzLnRva2VuLCB7IHVzZUZhY3Rvcnk6IGZhY3RvcnksIGRlcHM6IGRlcGVuZGVuY2llcyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQcm92aWRlckJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5Qcm92aWRlckJ1aWxkZXIgPSBQcm92aWRlckJ1aWxkZXI7XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUHJvdmlkZXJ9LlxuICpcbiAqIFNlZSB7QGxpbmsgUHJvdmlkZXJ9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogPCEtLSBUT0RPOiBpbXByb3ZlIHRoZSBkb2NzIC0tPlxuICovXG5mdW5jdGlvbiBwcm92aWRlKHRva2VuLCBfYSkge1xuICAgIHZhciB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XG4gICAgcmV0dXJuIG5ldyBQcm92aWRlcih0b2tlbiwge1xuICAgICAgICB1c2VDbGFzczogdXNlQ2xhc3MsXG4gICAgICAgIHVzZVZhbHVlOiB1c2VWYWx1ZSxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IHVzZUV4aXN0aW5nLFxuICAgICAgICB1c2VGYWN0b3J5OiB1c2VGYWN0b3J5LFxuICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICBtdWx0aTogbXVsdGlcbiAgICB9KTtcbn1cbmV4cG9ydHMucHJvdmlkZSA9IHByb3ZpZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm92aWRlcl8xID0gcmVxdWlyZSgnLi9wcm92aWRlcicpO1xuZnVuY3Rpb24gaXNQcm92aWRlckxpdGVyYWwob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09ICdvYmplY3QnICYmIG9iai5wcm92aWRlO1xufVxuZXhwb3J0cy5pc1Byb3ZpZGVyTGl0ZXJhbCA9IGlzUHJvdmlkZXJMaXRlcmFsO1xuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIob2JqKSB7XG4gICAgcmV0dXJuIG5ldyBwcm92aWRlcl8xLlByb3ZpZGVyKG9iai5wcm92aWRlLCBvYmopO1xufVxuZXhwb3J0cy5jcmVhdGVQcm92aWRlciA9IGNyZWF0ZVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJfdXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xuZnVuY3Rpb24gZmluZEZpcnN0Q2xvc2VkQ3ljbGUoa2V5cykge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb250YWlucyhyZXMsIGtleXNbaV0pKSB7XG4gICAgICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBmaW5kRmlyc3RDbG9zZWRDeWNsZShjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmV2ZXJzZWQoa2V5cykpO1xuICAgICAgICB2YXIgdG9rZW5TdHJzID0gcmV2ZXJzZWQubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBsYW5nXzEuc3RyaW5naWZ5KGsudG9rZW4pOyB9KTtcbiAgICAgICAgcmV0dXJuIFwiIChcIiArIHRva2VuU3Rycy5qb2luKCcgLT4gJykgKyBcIilcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGVycm9ycyBhcmlzaW5nIGZyb20gbWlzY29uZmlndXJlZCBwcm92aWRlcnMuXG4gKi9cbnZhciBBYnN0cmFjdFByb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RQcm92aWRlckVycm9yKGluamVjdG9yLCBrZXksIGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJESSBFeGNlcHRpb25cIik7XG4gICAgICAgIHRoaXMua2V5cyA9IFtrZXldO1xuICAgICAgICB0aGlzLmluamVjdG9ycyA9IFtpbmplY3Rvcl07XG4gICAgICAgIHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSA9IGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2U7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSh0aGlzLmtleXMpO1xuICAgIH1cbiAgICBBYnN0cmFjdFByb3ZpZGVyRXJyb3IucHJvdG90eXBlLmFkZEtleSA9IGZ1bmN0aW9uIChpbmplY3Rvciwga2V5KSB7XG4gICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xuICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdFByb3ZpZGVyRXJyb3IucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5qZWN0b3JzW3RoaXMuaW5qZWN0b3JzLmxlbmd0aCAtIDFdLmRlYnVnQ29udGV4dCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQWJzdHJhY3RQcm92aWRlckVycm9yO1xufShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbikpO1xuZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyRXJyb3IgPSBBYnN0cmFjdFByb3ZpZGVyRXJyb3I7XG4vKipcbiAqIFRocm93biB3aGVuIHRyeWluZyB0byByZXRyaWV2ZSBhIGRlcGVuZGVuY3kgYnkgYEtleWAgZnJvbSB7QGxpbmsgSW5qZWN0b3J9LCBidXQgdGhlXG4gKiB7QGxpbmsgSW5qZWN0b3J9IGRvZXMgbm90IGhhdmUgYSB7QGxpbmsgUHJvdmlkZXJ9IGZvciB7QGxpbmsgS2V5fS5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvdnE4RDNGUkI5YUdibldKcXRFUEU/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBBIHtcbiAqICAgY29uc3RydWN0b3IoYjpCKSB7fVxuICogfVxuICpcbiAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSkpLnRvVGhyb3dFcnJvcigpO1xuICogYGBgXG4gKi9cbnZhciBOb1Byb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb1Byb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9Qcm92aWRlckVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IGxhbmdfMS5zdHJpbmdpZnkoY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpcnN0KGtleXMpLnRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5vIHByb3ZpZGVyIGZvciBcIiArIGZpcnN0ICsgXCIhXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE5vUHJvdmlkZXJFcnJvcjtcbn0oQWJzdHJhY3RQcm92aWRlckVycm9yKSk7XG5leHBvcnRzLk5vUHJvdmlkZXJFcnJvciA9IE5vUHJvdmlkZXJFcnJvcjtcbi8qKlxuICogVGhyb3duIHdoZW4gZGVwZW5kZW5jaWVzIGZvcm0gYSBjeWNsZS5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvd1lRZE5vczBUenFsM2VpMUVWOWo/cD1pbmZvKSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAqICAgcHJvdmlkZShcIm9uZVwiLCB7dXNlRmFjdG9yeTogKHR3bykgPT4gXCJ0d29cIiwgZGVwczogW1tuZXcgSW5qZWN0KFwidHdvXCIpXV19KSxcbiAqICAgcHJvdmlkZShcInR3b1wiLCB7dXNlRmFjdG9yeTogKG9uZSkgPT4gXCJvbmVcIiwgZGVwczogW1tuZXcgSW5qZWN0KFwib25lXCIpXV19KVxuICogXSk7XG4gKlxuICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldChcIm9uZVwiKSkudG9UaHJvd0Vycm9yKCk7XG4gKiBgYGBcbiAqXG4gKiBSZXRyaWV2aW5nIGBBYCBvciBgQmAgdGhyb3dzIGEgYEN5Y2xpY0RlcGVuZGVuY3lFcnJvcmAgYXMgdGhlIGdyYXBoIGFib3ZlIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIEN5Y2xpY0RlcGVuZGVuY3lFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN5Y2xpY0RlcGVuZGVuY3lFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDeWNsaWNEZXBlbmRlbmN5RXJyb3IoaW5qZWN0b3IsIGtleSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBpbmplY3Rvciwga2V5LCBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5IVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBDeWNsaWNEZXBlbmRlbmN5RXJyb3I7XG59KEFic3RyYWN0UHJvdmlkZXJFcnJvcikpO1xuZXhwb3J0cy5DeWNsaWNEZXBlbmRlbmN5RXJyb3IgPSBDeWNsaWNEZXBlbmRlbmN5RXJyb3I7XG4vKipcbiAqIFRocm93biB3aGVuIGEgY29uc3RydWN0aW5nIHR5cGUgcmV0dXJucyB3aXRoIGFuIEVycm9yLlxuICpcbiAqIFRoZSBgSW5zdGFudGlhdGlvbkVycm9yYCBjbGFzcyBjb250YWlucyB0aGUgb3JpZ2luYWwgZXJyb3IgcGx1cyB0aGUgZGVwZW5kZW5jeSBncmFwaCB3aGljaCBjYXVzZWRcbiAqIHRoaXMgb2JqZWN0IHRvIGJlIGluc3RhbnRpYXRlZC5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvN2FXWWRjcVRRc1AwZU5xRWRVQWY/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBBIHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlJyk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XG5cbiAqIHRyeSB7XG4gKiAgIGluamVjdG9yLmdldChBKTtcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgZXhwZWN0KGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0aW9uRXJyb3IpLnRvQmUodHJ1ZSk7XG4gKiAgIGV4cGVjdChlLm9yaWdpbmFsRXhjZXB0aW9uLm1lc3NhZ2UpLnRvRXF1YWwoXCJtZXNzYWdlXCIpO1xuICogICBleHBlY3QoZS5vcmlnaW5hbFN0YWNrKS50b0JlRGVmaW5lZCgpO1xuICogfVxuICogYGBgXG4gKi9cbnZhciBJbnN0YW50aWF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnN0YW50aWF0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5zdGFudGlhdGlvbkVycm9yKGluamVjdG9yLCBvcmlnaW5hbEV4Y2VwdGlvbiwgb3JpZ2luYWxTdGFjaywga2V5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiREkgRXhjZXB0aW9uXCIsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBudWxsKTtcbiAgICAgICAgdGhpcy5rZXlzID0gW2tleV07XG4gICAgICAgIHRoaXMuaW5qZWN0b3JzID0gW2luamVjdG9yXTtcbiAgICB9XG4gICAgSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZS5hZGRLZXkgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIGtleSkge1xuICAgICAgICB0aGlzLmluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcbiAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW50aWF0aW9uRXJyb3IucHJvdG90eXBlLCBcIndyYXBwZXJNZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBsYW5nXzEuc3RyaW5naWZ5KGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maXJzdCh0aGlzLmtleXMpLnRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yIGR1cmluZyBpbnN0YW50aWF0aW9uIG9mIFwiICsgZmlyc3QgKyBcIiFcIiArIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgodGhpcy5rZXlzKSArIFwiLlwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZSwgXCJjYXVzZUtleVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzWzBdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluamVjdG9yc1t0aGlzLmluamVjdG9ycy5sZW5ndGggLSAxXS5kZWJ1Z0NvbnRleHQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEluc3RhbnRpYXRpb25FcnJvcjtcbn0oZXhjZXB0aW9uc18xLldyYXBwZWRFeGNlcHRpb24pKTtcbmV4cG9ydHMuSW5zdGFudGlhdGlvbkVycm9yID0gSW5zdGFudGlhdGlvbkVycm9yO1xuLyoqXG4gKiBUaHJvd24gd2hlbiBhbiBvYmplY3Qgb3RoZXIgdGhlbiB7QGxpbmsgUHJvdmlkZXJ9IChvciBgVHlwZWApIGlzIHBhc3NlZCB0byB7QGxpbmsgSW5qZWN0b3J9XG4gKiBjcmVhdGlvbi5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvWWF0Q0ZiUEFNQ0wwSlNTUTRtdkg/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXCJub3QgYSB0eXBlXCJdKSkudG9UaHJvd0Vycm9yKCk7XG4gKiBgYGBcbiAqL1xudmFyIEludmFsaWRQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52YWxpZFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52YWxpZFByb3ZpZGVyRXJyb3IocHJvdmlkZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbnZhbGlkIHByb3ZpZGVyIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogXCIgK1xuICAgICAgICAgICAgcHJvdmlkZXIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiBJbnZhbGlkUHJvdmlkZXJFcnJvcjtcbn0oZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pKTtcbmV4cG9ydHMuSW52YWxpZFByb3ZpZGVyRXJyb3IgPSBJbnZhbGlkUHJvdmlkZXJFcnJvcjtcbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIGNsYXNzIGhhcyBubyBhbm5vdGF0aW9uIGluZm9ybWF0aW9uLlxuICpcbiAqIExhY2sgb2YgYW5ub3RhdGlvbiBpbmZvcm1hdGlvbiBwcmV2ZW50cyB0aGUge0BsaW5rIEluamVjdG9yfSBmcm9tIGRldGVybWluaW5nIHdoaWNoIGRlcGVuZGVuY2llc1xuICogbmVlZCB0byBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvckhuWnRsTlM3dkpPUFE2cGNWa20/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBBIHtcbiAqICAgY29uc3RydWN0b3IoYikge31cbiAqIH1cbiAqXG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pKS50b1Rocm93RXJyb3IoKTtcbiAqIGBgYFxuICpcbiAqIFRoaXMgZXJyb3IgaXMgYWxzbyB0aHJvd24gd2hlbiB0aGUgY2xhc3Mgbm90IG1hcmtlZCB3aXRoIHtAbGluayBJbmplY3RhYmxlfSBoYXMgcGFyYW1ldGVyIHR5cGVzLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIEIge31cbiAqXG4gKiBjbGFzcyBBIHtcbiAqICAgY29uc3RydWN0b3IoYjpCKSB7fSAvLyBubyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyYW1ldGVyIHR5cGVzIG9mIEEgaXMgYXZhaWxhYmxlIGF0IHJ1bnRpbWUuXG4gKiB9XG4gKlxuICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0EsQl0pKS50b1Rocm93RXJyb3IoKTtcbiAqIGBgYFxuICovXG52YXIgTm9Bbm5vdGF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb0Fubm90YXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgTm9Bbm5vdGF0aW9uRXJyb3IuX2dlbk1lc3NhZ2UodHlwZU9yRnVuYywgcGFyYW1zKSk7XG4gICAgfVxuICAgIE5vQW5ub3RhdGlvbkVycm9yLl9nZW5NZXNzYWdlID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIHBhcmFtcykge1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmFtZXRlcikgfHwgcGFyYW1ldGVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLnB1c2goJz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5wdXNoKHBhcmFtZXRlci5tYXAobGFuZ18xLnN0cmluZ2lmeSkuam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJDYW5ub3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeSh0eXBlT3JGdW5jKSArIFwiJyhcIiArXG4gICAgICAgICAgICBzaWduYXR1cmUuam9pbignLCAnKSArIFwiKS4gXCIgK1xuICAgICAgICAgICAgXCJNYWtlIHN1cmUgdGhhdCBhbGwgdGhlIHBhcmFtZXRlcnMgYXJlIGRlY29yYXRlZCB3aXRoIEluamVjdCBvciBoYXZlIHZhbGlkIHR5cGUgYW5ub3RhdGlvbnMgYW5kIHRoYXQgJ1wiICtcbiAgICAgICAgICAgIGxhbmdfMS5zdHJpbmdpZnkodHlwZU9yRnVuYykgKyBcIicgaXMgZGVjb3JhdGVkIHdpdGggSW5qZWN0YWJsZS5cIjtcbiAgICB9O1xuICAgIHJldHVybiBOb0Fubm90YXRpb25FcnJvcjtcbn0oZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pKTtcbmV4cG9ydHMuTm9Bbm5vdGF0aW9uRXJyb3IgPSBOb0Fubm90YXRpb25FcnJvcjtcbi8qKlxuICogVGhyb3duIHdoZW4gZ2V0dGluZyBhbiBvYmplY3QgYnkgaW5kZXguXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2JSczBTWDJPVFFpSnpxdmpnbDhQP3A9cHJldmlldykpXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgQSB7fVxuICpcbiAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcbiAqXG4gKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0QXQoMTAwKSkudG9UaHJvd0Vycm9yKCk7XG4gKiBgYGBcbiAqL1xudmFyIE91dE9mQm91bmRzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRPZkJvdW5kc0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dE9mQm91bmRzRXJyb3IoaW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbmRleCBcIiArIGluZGV4ICsgXCIgaXMgb3V0LW9mLWJvdW5kcy5cIik7XG4gICAgfVxuICAgIHJldHVybiBPdXRPZkJvdW5kc0Vycm9yO1xufShleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbikpO1xuZXhwb3J0cy5PdXRPZkJvdW5kc0Vycm9yID0gT3V0T2ZCb3VuZHNFcnJvcjtcbi8vIFRPRE86IGFkZCBhIHdvcmtpbmcgZXhhbXBsZSBhZnRlciBhbHBoYTM4IGlzIHJlbGVhc2VkXG4vKipcbiAqIFRocm93biB3aGVuIGEgbXVsdGkgcHJvdmlkZXIgYW5kIGEgcmVndWxhciBwcm92aWRlciBhcmUgYm91bmQgdG8gdGhlIHNhbWUgdG9rZW4uXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gKiAgIG5ldyBQcm92aWRlcihcIlN0cmluZ3NcIiwge3VzZVZhbHVlOiBcInN0cmluZzFcIiwgbXVsdGk6IHRydWV9KSxcbiAqICAgbmV3IFByb3ZpZGVyKFwiU3RyaW5nc1wiLCB7dXNlVmFsdWU6IFwic3RyaW5nMlwiLCBtdWx0aTogZmFsc2V9KVxuICogXSkpLnRvVGhyb3dFcnJvcigpO1xuICogYGBgXG4gKi9cbnZhciBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yKHByb3ZpZGVyMSwgcHJvdmlkZXIyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQ2Fubm90IG1peCBtdWx0aSBwcm92aWRlcnMgYW5kIHJlZ3VsYXIgcHJvdmlkZXJzLCBnb3Q6IFwiICsgcHJvdmlkZXIxLnRvU3RyaW5nKCkgKyBcIiBcIiArXG4gICAgICAgICAgICBwcm92aWRlcjIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3I7XG59KGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKSk7XG5leHBvcnRzLk1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvciA9IE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmxlY3RpdmVfZXhjZXB0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciByZWZsZWN0aXZlX3Byb3ZpZGVyXzEgPSByZXF1aXJlKCcuL3JlZmxlY3RpdmVfcHJvdmlkZXInKTtcbnZhciByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdGl2ZV9leGNlcHRpb25zJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgcmVmbGVjdGl2ZV9rZXlfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdGl2ZV9rZXknKTtcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9tZXRhZGF0YScpO1xudmFyIGluamVjdG9yXzEgPSByZXF1aXJlKCcuL2luamVjdG9yJyk7XG52YXIgX191bnVzZWQ7IC8vIGF2b2lkIHVudXNlZCBpbXBvcnQgd2hlbiBUeXBlIHVuaW9uIHR5cGVzIGFyZSBlcmFzZWRcbi8vIFRocmVzaG9sZCBmb3IgdGhlIGR5bmFtaWMgdmVyc2lvblxudmFyIF9NQVhfQ09OU1RSVUNUSU9OX0NPVU5URVIgPSAxMDtcbnZhciBVTkRFRklORUQgPSBuZXcgT2JqZWN0KCk7XG52YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneShwcm90b0VJLCBwcm92aWRlcnMpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcjAgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvdmlkZXIyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm92aWRlcjMgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvdmlkZXI1ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm92aWRlcjYgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvdmlkZXI4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm92aWRlcjkgPSBudWxsO1xuICAgICAgICB0aGlzLmtleUlkMCA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5SWQxID0gbnVsbDtcbiAgICAgICAgdGhpcy5rZXlJZDIgPSBudWxsO1xuICAgICAgICB0aGlzLmtleUlkMyA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5SWQ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5rZXlJZDUgPSBudWxsO1xuICAgICAgICB0aGlzLmtleUlkNiA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5SWQ3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5rZXlJZDggPSBudWxsO1xuICAgICAgICB0aGlzLmtleUlkOSA9IG51bGw7XG4gICAgICAgIHZhciBsZW5ndGggPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjAgPSBwcm92aWRlcnNbMF07XG4gICAgICAgICAgICB0aGlzLmtleUlkMCA9IHByb3ZpZGVyc1swXS5rZXkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIxID0gcHJvdmlkZXJzWzFdO1xuICAgICAgICAgICAgdGhpcy5rZXlJZDEgPSBwcm92aWRlcnNbMV0ua2V5LmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMiA9IHByb3ZpZGVyc1syXTtcbiAgICAgICAgICAgIHRoaXMua2V5SWQyID0gcHJvdmlkZXJzWzJdLmtleS5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjMgPSBwcm92aWRlcnNbM107XG4gICAgICAgICAgICB0aGlzLmtleUlkMyA9IHByb3ZpZGVyc1szXS5rZXkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI0ID0gcHJvdmlkZXJzWzRdO1xuICAgICAgICAgICAgdGhpcy5rZXlJZDQgPSBwcm92aWRlcnNbNF0ua2V5LmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPiA1KSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNSA9IHByb3ZpZGVyc1s1XTtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ1ID0gcHJvdmlkZXJzWzVdLmtleS5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gNikge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjYgPSBwcm92aWRlcnNbNl07XG4gICAgICAgICAgICB0aGlzLmtleUlkNiA9IHByb3ZpZGVyc1s2XS5rZXkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI3ID0gcHJvdmlkZXJzWzddO1xuICAgICAgICAgICAgdGhpcy5rZXlJZDcgPSBwcm92aWRlcnNbN10ua2V5LmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPiA4KSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyOCA9IHByb3ZpZGVyc1s4XTtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ4ID0gcHJvdmlkZXJzWzhdLmtleS5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gOSkge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlcjkgPSBwcm92aWRlcnNbOV07XG4gICAgICAgICAgICB0aGlzLmtleUlkOSA9IHByb3ZpZGVyc1s5XS5rZXkuaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIwO1xuICAgICAgICBpZiAoaW5kZXggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyMTtcbiAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjI7XG4gICAgICAgIGlmIChpbmRleCA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIzO1xuICAgICAgICBpZiAoaW5kZXggPT0gNClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyNDtcbiAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjU7XG4gICAgICAgIGlmIChpbmRleCA9PSA2KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI2O1xuICAgICAgICBpZiAoaW5kZXggPT0gNylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyNztcbiAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcjg7XG4gICAgICAgIGlmIChpbmRleCA9PSA5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI5O1xuICAgICAgICB0aHJvdyBuZXcgcmVmbGVjdGl2ZV9leGNlcHRpb25zXzEuT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5ID0gZnVuY3Rpb24gKGluamVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3k7XG59KCkpO1xuZXhwb3J0cy5SZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5ID0gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneTtcbnZhciBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kocHJvdG9JbmosIHByb3ZpZGVycykge1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdmFyIGxlbiA9IHByb3ZpZGVycy5sZW5ndGg7XG4gICAgICAgIHRoaXMua2V5SWRzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmtleUlkc1tpXSA9IHByb3ZpZGVyc1tpXS5rZXkuaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMucHJvdmlkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLk91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyc1tpbmRleF07XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSA9IGZ1bmN0aW9uIChlaSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneSh0aGlzLCBlaSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XG59KCkpO1xuZXhwb3J0cy5SZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5O1xudmFyIFJlZmxlY3RpdmVQcm90b0luamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpIHtcbiAgICAgICAgdGhpcy5udW1iZXJPZlByb3ZpZGVycyA9IHByb3ZpZGVycy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gcHJvdmlkZXJzLmxlbmd0aCA+IF9NQVhfQ09OU1RSVUNUSU9OX0NPVU5URVIgP1xuICAgICAgICAgICAgbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycykgOlxuICAgICAgICAgICAgbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kodGhpcywgcHJvdmlkZXJzKTtcbiAgICB9XG4gICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yKHByb3ZpZGVycyk7XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJhdGVneS5nZXRQcm92aWRlckF0SW5kZXgoaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9yO1xufSgpKTtcbmV4cG9ydHMuUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IgPSBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcjtcbnZhciBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHByb3RvU3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLnByb3RvU3RyYXRlZ3kgPSBwcm90b1N0cmF0ZWd5O1xuICAgICAgICB0aGlzLm9iajAgPSBVTkRFRklORUQ7XG4gICAgICAgIHRoaXMub2JqMSA9IFVOREVGSU5FRDtcbiAgICAgICAgdGhpcy5vYmoyID0gVU5ERUZJTkVEO1xuICAgICAgICB0aGlzLm9iajMgPSBVTkRFRklORUQ7XG4gICAgICAgIHRoaXMub2JqNCA9IFVOREVGSU5FRDtcbiAgICAgICAgdGhpcy5vYmo1ID0gVU5ERUZJTkVEO1xuICAgICAgICB0aGlzLm9iajYgPSBVTkRFRklORUQ7XG4gICAgICAgIHRoaXMub2JqNyA9IFVOREVGSU5FRDtcbiAgICAgICAgdGhpcy5vYmo4ID0gVU5ERUZJTkVEO1xuICAgICAgICB0aGlzLm9iajkgPSBVTkRFRklORUQ7XG4gICAgfVxuICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5qZWN0b3IuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwOyB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLl9uZXcocHJvdmlkZXIpO1xuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnByb3RvU3RyYXRlZ3k7XG4gICAgICAgIHZhciBpbmogPSB0aGlzLmluamVjdG9yO1xuICAgICAgICBpZiAocC5rZXlJZDAgPT09IGtleUlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmowID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9iajAgPSBpbmouX25ldyhwLnByb3ZpZGVyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmowO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLmtleUlkMSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajEgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqMSA9IGluai5fbmV3KHAucHJvdmlkZXIxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAua2V5SWQyID09PSBrZXlJZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub2JqMiA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmoyID0gaW5qLl9uZXcocC5wcm92aWRlcjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5rZXlJZDMgPT09IGtleUlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmozID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9iajMgPSBpbmouX25ldyhwLnByb3ZpZGVyMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmozO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLmtleUlkNCA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajQgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqNCA9IGluai5fbmV3KHAucHJvdmlkZXI0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAua2V5SWQ1ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub2JqNSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmo1ID0gaW5qLl9uZXcocC5wcm92aWRlcjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5rZXlJZDYgPT09IGtleUlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmo2ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9iajYgPSBpbmouX25ldyhwLnByb3ZpZGVyNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLmtleUlkNyA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9iajcgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqNyA9IGluai5fbmV3KHAucHJvdmlkZXI3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAua2V5SWQ4ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub2JqOCA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmo4ID0gaW5qLl9uZXcocC5wcm92aWRlcjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqODtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5rZXlJZDkgPT09IGtleUlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmo5ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9iajkgPSBpbmouX25ldyhwLnByb3ZpZGVyOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0T2JqQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajA7XG4gICAgICAgIGlmIChpbmRleCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMTtcbiAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoyO1xuICAgICAgICBpZiAoaW5kZXggPT0gMylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajM7XG4gICAgICAgIGlmIChpbmRleCA9PSA0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNDtcbiAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo1O1xuICAgICAgICBpZiAoaW5kZXggPT0gNilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajY7XG4gICAgICAgIGlmIChpbmRleCA9PSA3KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNztcbiAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo4O1xuICAgICAgICBpZiAoaW5kZXggPT0gOSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajk7XG4gICAgICAgIHRocm93IG5ldyByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMS5PdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhOdW1iZXJPZk9iamVjdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSOyB9O1xuICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneTtcbn0oKSk7XG5leHBvcnRzLlJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5ID0gUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3k7XG52YXIgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kocHJvdG9TdHJhdGVneSwgaW5qZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLm9ianMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHByb3RvU3RyYXRlZ3kucHJvdmlkZXJzLmxlbmd0aCk7XG4gICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5maWxsKHRoaXMub2JqcywgVU5ERUZJTkVEKTtcbiAgICB9XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5qZWN0b3IuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwOyB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuaW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5fbmV3KHByb3ZpZGVyKTtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0T2JqQnlLZXlJZCA9IGZ1bmN0aW9uIChrZXlJZCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMucHJvdG9TdHJhdGVneTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmtleUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHAua2V5SWRzW2ldID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ianNbaV0gPSB0aGlzLmluamVjdG9yLl9uZXcocC5wcm92aWRlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmpzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmbGVjdGl2ZV9leGNlcHRpb25zXzEuT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub2Jqc1tpbmRleF07XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE1heE51bWJlck9mT2JqZWN0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub2Jqcy5sZW5ndGg7IH07XG4gICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneTtcbn0oKSk7XG5leHBvcnRzLlJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneTtcbi8qKlxuICogQSBSZWZsZWN0aXZlRGVwZW5kZW5jeSBpbmplY3Rpb24gY29udGFpbmVyIHVzZWQgZm9yIGluc3RhbnRpYXRpbmcgb2JqZWN0cyBhbmQgcmVzb2x2aW5nXG4gKiBkZXBlbmRlbmNpZXMuXG4gKlxuICogQW4gYEluamVjdG9yYCBpcyBhIHJlcGxhY2VtZW50IGZvciBhIGBuZXdgIG9wZXJhdG9yLCB3aGljaCBjYW4gYXV0b21hdGljYWxseSByZXNvbHZlIHRoZVxuICogY29uc3RydWN0b3IgZGVwZW5kZW5jaWVzLlxuICpcbiAqIEluIHR5cGljYWwgdXNlLCBhcHBsaWNhdGlvbiBjb2RlIGFza3MgZm9yIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIGNvbnN0cnVjdG9yIGFuZCB0aGV5IGFyZVxuICogcmVzb2x2ZWQgYnkgdGhlIGBJbmplY3RvcmAuXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2p6amVjMD9wPXByZXZpZXcpKVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBjcmVhdGVzIGFuIGBJbmplY3RvcmAgY29uZmlndXJlZCB0byBjcmVhdGUgYEVuZ2luZWAgYW5kIGBDYXJgLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIEVuZ2luZSB7XG4gKiB9XG4gKlxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgQ2FyIHtcbiAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gKiB9XG4gKlxuICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0NhciwgRW5naW5lXSk7XG4gKiB2YXIgY2FyID0gaW5qZWN0b3IuZ2V0KENhcik7XG4gKiBleHBlY3QoY2FyIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICogZXhwZWN0KGNhci5lbmdpbmUgaW5zdGFuY2VvZiBFbmdpbmUpLnRvQmUodHJ1ZSk7XG4gKiBgYGBcbiAqXG4gKiBOb3RpY2UsIHdlIGRvbid0IHVzZSB0aGUgYG5ld2Agb3BlcmF0b3IgYmVjYXVzZSB3ZSBleHBsaWNpdGx5IHdhbnQgdG8gaGF2ZSB0aGUgYEluamVjdG9yYFxuICogcmVzb2x2ZSBhbGwgb2YgdGhlIG9iamVjdCdzIGRlcGVuZGVuY2llcyBhdXRvbWF0aWNhbGx5LlxuICovXG52YXIgUmVmbGVjdGl2ZUluamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR1cm5zIGFuIGFycmF5IG9mIHByb3ZpZGVyIGRlZmluaXRpb25zIGludG8gYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogQSByZXNvbHV0aW9uIGlzIGEgcHJvY2VzcyBvZiBmbGF0dGVuaW5nIG11bHRpcGxlIG5lc3RlZCBhcnJheXMgYW5kIGNvbnZlcnRpbmcgaW5kaXZpZHVhbFxuICAgICAqIHByb3ZpZGVycyBpbnRvIGFuIGFycmF5IG9mIHtAbGluayBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcn1zLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0FpWFRIaT9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBDYXIge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXIsIFtbRW5naW5lXV1dKTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChwcm92aWRlcnMubGVuZ3RoKS50b0VxdWFsKDIpO1xuICAgICAqXG4gICAgICogZXhwZWN0KHByb3ZpZGVyc1swXSBpbnN0YW5jZW9mIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0ua2V5LmRpc3BsYXlOYW1lKS50b0JlKFwiQ2FyXCIpO1xuICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0uZGVwZW5kZW5jaWVzLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmZhY3RvcnkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICpcbiAgICAgKiBleHBlY3QocHJvdmlkZXJzWzFdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkVuZ2luZVwiKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yI2Zyb21SZXNvbHZlZFByb3ZpZGVyc30gZm9yIG1vcmUgaW5mby5cbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHJlZmxlY3RpdmVfcHJvdmlkZXJfMS5yZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVycyhwcm92aWRlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYW4gYXJyYXkgb2YgcHJvdmlkZXJzIGFuZCBjcmVhdGVzIGFuIGluamVjdG9yIGZyb20gdGhvc2UgcHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogVGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgY2FuIGJlIGFuIGFycmF5IG9mIGBUeXBlYCwge0BsaW5rIFByb3ZpZGVyfSxcbiAgICAgKiBvciBhIHJlY3Vyc2l2ZSBhcnJheSBvZiBtb3JlIHByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9lUE9jY0E/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgQ2FyIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtDYXIsIEVuZ2luZV0pO1xuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc2xvd2VyIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgYGZyb21SZXNvbHZlZFByb3ZpZGVyc2BcbiAgICAgKiBiZWNhdXNlIGl0IG5lZWRzIHRvIHJlc29sdmUgdGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgZmlyc3QuXG4gICAgICogU2VlIHtAbGluayBJbmplY3RvciNyZXNvbHZlfSBhbmQge0BsaW5rIEluamVjdG9yI2Zyb21SZXNvbHZlZFByb3ZpZGVyc30uXG4gICAgICovXG4gICAgUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycywgcGFyZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSBwcmV2aW91c2x5IHJlc29sdmVkIHByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS3JTTWNpP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIENhciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgcHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NhciwgRW5naW5lXSk7XG4gICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwcm92aWRlcnMpO1xuICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycywgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZUluamVjdG9yXyhSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocHJvdmlkZXJzKSwgcGFyZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZEJpbmRpbmdzID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhwcm92aWRlcnMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcmVudCBvZiB0aGlzIGluamVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxuICAgICAgICAgKiAtLT5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2Vvc01Hbz9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXSk7XG4gICAgICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQoW10pO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQucGFyZW50KS50b0JlKHBhcmVudCk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLmRlYnVnQ29udGV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYW4gYXJyYXkgb2YgcHJvdmlkZXJzIGFuZCBjcmVhdGVzIGEgY2hpbGQgaW5qZWN0b3IgZnJvbSB0aG9zZSBwcm92aWRlcnMuXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxuICAgICAqIC0tPlxuICAgICAqXG4gICAgICogVGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgY2FuIGJlIGFuIGFycmF5IG9mIGBUeXBlYCwge0BsaW5rIFByb3ZpZGVyfSxcbiAgICAgKiBvciBhIHJlY3Vyc2l2ZSBhcnJheSBvZiBtb3JlIHByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9vcEIzVDQ/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBQYXJlbnRQcm92aWRlciB7fVxuICAgICAqIGNsYXNzIENoaWxkUHJvdmlkZXIge31cbiAgICAgKlxuICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbUGFyZW50UHJvdmlkZXJdKTtcbiAgICAgKiB2YXIgY2hpbGQgPSBwYXJlbnQucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKFtDaGlsZFByb3ZpZGVyXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSBpbnN0YW5jZW9mIFBhcmVudFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAqIGV4cGVjdChjaGlsZC5nZXQoQ2hpbGRQcm92aWRlcikgaW5zdGFuY2VvZiBDaGlsZFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpKS50b0JlKHBhcmVudC5nZXQoUGFyZW50UHJvdmlkZXIpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc2xvd2VyIHRoYW4gdGhlIGNvcnJlc3BvbmRpbmcgYGNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkYFxuICAgICAqIGJlY2F1c2UgaXQgbmVlZHMgdG8gcmVzb2x2ZSB0aGUgcGFzc2VkLWluIHByb3ZpZGVycyBmaXJzdC5cbiAgICAgKiBTZWUge0BsaW5rIEluamVjdG9yI3Jlc29sdmV9IGFuZCB7QGxpbmsgSW5qZWN0b3IjY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWR9LlxuICAgICAqL1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUucmVzb2x2ZUFuZENyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBpbmplY3RvciBmcm9tIHByZXZpb3VzbHkgcmVzb2x2ZWQgcHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cbiAgICAgKiAtLT5cbiAgICAgKlxuICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvVmh5ZmpOP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2xhc3MgUGFyZW50UHJvdmlkZXIge31cbiAgICAgKiBjbGFzcyBDaGlsZFByb3ZpZGVyIHt9XG4gICAgICpcbiAgICAgKiB2YXIgcGFyZW50UHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW1BhcmVudFByb3ZpZGVyXSk7XG4gICAgICogdmFyIGNoaWxkUHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NoaWxkUHJvdmlkZXJdKTtcbiAgICAgKlxuICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHBhcmVudFByb3ZpZGVycyk7XG4gICAgICogdmFyIGNoaWxkID0gcGFyZW50LmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKGNoaWxkUHJvdmlkZXJzKTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpIGluc3RhbmNlb2YgUGFyZW50UHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICogZXhwZWN0KGNoaWxkLmdldChDaGlsZFByb3ZpZGVyKSBpbnN0YW5jZW9mIENoaWxkUHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikpLnRvQmUocGFyZW50LmdldChQYXJlbnRQcm92aWRlcikpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgIHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSBwcm92aWRlciBhbmQgaW5zdGFudGlhdGVzIGFuIG9iamVjdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5qZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGUgY3JlYXRlZCBvYmplY3QgZG9lcyBub3QgZ2V0IGNhY2hlZCBieSB0aGUgaW5qZWN0b3IuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQveXZWWG9CP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIENhciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRW5naW5lXSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IucmVzb2x2ZUFuZEluc3RhbnRpYXRlKENhcik7XG4gICAgICogZXhwZWN0KGNhci5lbmdpbmUpLnRvQmUoaW5qZWN0b3IuZ2V0KEVuZ2luZSkpO1xuICAgICAqIGV4cGVjdChjYXIpLm5vdC50b0JlKGluamVjdG9yLnJlc29sdmVBbmRJbnN0YW50aWF0ZShDYXIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLnJlc29sdmVBbmRJbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gb2JqZWN0IHVzaW5nIGEgcmVzb2x2ZWQgcHJvdmlkZXIgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGluamVjdG9yLlxuICAgICAqXG4gICAgICogVGhlIGNyZWF0ZWQgb2JqZWN0IGRvZXMgbm90IGdldCBjYWNoZWQgYnkgdGhlIGluamVjdG9yLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3B0Q0ltUT9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBDYXIge1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0VuZ2luZV0pO1xuICAgICAqIHZhciBjYXJQcm92aWRlciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXJdKVswXTtcbiAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChjYXJQcm92aWRlcik7XG4gICAgICogZXhwZWN0KGNhci5lbmdpbmUpLnRvQmUoaW5qZWN0b3IuZ2V0KEVuZ2luZSkpO1xuICAgICAqIGV4cGVjdChjYXIpLm5vdC50b0JlKGluamVjdG9yLmluc3RhbnRpYXRlUmVzb2x2ZWQoY2FyUHJvdmlkZXIpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLmluc3RhbnRpYXRlUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH07XG4gICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3Rvcjtcbn0oKSk7XG5leHBvcnRzLlJlZmxlY3RpdmVJbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3RvcjtcbnZhciBSZWZsZWN0aXZlSW5qZWN0b3JfID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9yXyhfcHJvdG8gLyogUHJvdG9JbmplY3RvciAqLywgX3BhcmVudCwgX2RlYnVnQ29udGV4dCkge1xuICAgICAgICBpZiAoX3BhcmVudCA9PT0gdm9pZCAwKSB7IF9wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIGlmIChfZGVidWdDb250ZXh0ID09PSB2b2lkIDApIHsgX2RlYnVnQ29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fZGVidWdDb250ZXh0ID0gX2RlYnVnQ29udGV4dDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fcHJvdG8gPSBfcHJvdG87XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gX3Byb3RvLl9zdHJhdGVneS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5KHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5kZWJ1Z0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWJ1Z0NvbnRleHQoKTsgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gaW5qZWN0b3JfMS5USFJPV19JRl9OT1RfRk9VTkQ7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KHJlZmxlY3RpdmVfa2V5XzEuUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBudWxsLCBudWxsLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmdldEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9zdHJhdGVneS5nZXRPYmpBdEluZGV4KGluZGV4KTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZSwgXCJpbnRlcm5hbFN0cmF0ZWd5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBJbnRlcm5hbC4gRG8gbm90IHVzZS5cbiAgICAgICAgICogV2UgcmV0dXJuIGBhbnlgIG5vdCB0byBleHBvcnQgdGhlIEluamVjdG9yU3RyYXRlZ3kgdHlwZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RyYXRlZ3k7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnJlc29sdmVBbmRDcmVhdGVDaGlsZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyk7XG4gICAgfTtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgdmFyIHByb3RvID0gbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yKHByb3ZpZGVycyk7XG4gICAgICAgIHZhciBpbmogPSBuZXcgUmVmbGVjdGl2ZUluamVjdG9yXyhwcm90byk7XG4gICAgICAgIGluai5fcGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGluajtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnJlc29sdmVBbmRJbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW50aWF0ZVJlc29sdmVkKFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtwcm92aWRlcl0pWzBdKTtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmluc3RhbnRpYXRlUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9uZXcgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnN0cnVjdGlvbkNvdW50ZXIrKyA+IHRoaXMuX3N0cmF0ZWd5LmdldE1heE51bWJlck9mT2JqZWN0cygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmbGVjdGl2ZV9leGNlcHRpb25zXzEuQ3ljbGljRGVwZW5kZW5jeUVycm9yKHRoaXMsIHByb3ZpZGVyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2luc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5faW5zdGFudGlhdGUocHJvdmlkZXIsIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGUocHJvdmlkZXIsIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzWzBdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2luc3RhbnRpYXRlID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5KSB7XG4gICAgICAgIHZhciBmYWN0b3J5ID0gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeS5mYWN0b3J5O1xuICAgICAgICB2YXIgZGVwcyA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkuZGVwZW5kZW5jaWVzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gZGVwcy5sZW5ndGg7XG4gICAgICAgIHZhciBkMDtcbiAgICAgICAgdmFyIGQxO1xuICAgICAgICB2YXIgZDI7XG4gICAgICAgIHZhciBkMztcbiAgICAgICAgdmFyIGQ0O1xuICAgICAgICB2YXIgZDU7XG4gICAgICAgIHZhciBkNjtcbiAgICAgICAgdmFyIGQ3O1xuICAgICAgICB2YXIgZDg7XG4gICAgICAgIHZhciBkOTtcbiAgICAgICAgdmFyIGQxMDtcbiAgICAgICAgdmFyIGQxMTtcbiAgICAgICAgdmFyIGQxMjtcbiAgICAgICAgdmFyIGQxMztcbiAgICAgICAgdmFyIGQxNDtcbiAgICAgICAgdmFyIGQxNTtcbiAgICAgICAgdmFyIGQxNjtcbiAgICAgICAgdmFyIGQxNztcbiAgICAgICAgdmFyIGQxODtcbiAgICAgICAgdmFyIGQxOTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGQwID0gbGVuZ3RoID4gMCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMF0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxID0gbGVuZ3RoID4gMSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMV0pIDogbnVsbDtcbiAgICAgICAgICAgIGQyID0gbGVuZ3RoID4gMiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMl0pIDogbnVsbDtcbiAgICAgICAgICAgIGQzID0gbGVuZ3RoID4gMyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbM10pIDogbnVsbDtcbiAgICAgICAgICAgIGQ0ID0gbGVuZ3RoID4gNCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNF0pIDogbnVsbDtcbiAgICAgICAgICAgIGQ1ID0gbGVuZ3RoID4gNSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNV0pIDogbnVsbDtcbiAgICAgICAgICAgIGQ2ID0gbGVuZ3RoID4gNiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNl0pIDogbnVsbDtcbiAgICAgICAgICAgIGQ3ID0gbGVuZ3RoID4gNyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbN10pIDogbnVsbDtcbiAgICAgICAgICAgIGQ4ID0gbGVuZ3RoID4gOCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbOF0pIDogbnVsbDtcbiAgICAgICAgICAgIGQ5ID0gbGVuZ3RoID4gOSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbOV0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxMCA9IGxlbmd0aCA+IDEwID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMF0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxMSA9IGxlbmd0aCA+IDExID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMV0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxMiA9IGxlbmd0aCA+IDEyID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMl0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxMyA9IGxlbmd0aCA+IDEzID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxM10pIDogbnVsbDtcbiAgICAgICAgICAgIGQxNCA9IGxlbmd0aCA+IDE0ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNF0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxNSA9IGxlbmd0aCA+IDE1ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNV0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxNiA9IGxlbmd0aCA+IDE2ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNl0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxNyA9IGxlbmd0aCA+IDE3ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxN10pIDogbnVsbDtcbiAgICAgICAgICAgIGQxOCA9IGxlbmd0aCA+IDE4ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxOF0pIDogbnVsbDtcbiAgICAgICAgICAgIGQxOSA9IGxlbmd0aCA+IDE5ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxOV0pIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMS5BYnN0cmFjdFByb3ZpZGVyRXJyb3IgfHwgZSBpbnN0YW5jZW9mIHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLkluc3RhbnRpYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGUuYWRkS2V5KHRoaXMsIHByb3ZpZGVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNywgZDE4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcsIGQxOCwgZDE5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ2Fubm90IGluc3RhbnRpYXRlICdcIiArIHByb3ZpZGVyLmtleS5kaXNwbGF5TmFtZSArIFwiJyBiZWNhdXNlIGl0IGhhcyBtb3JlIHRoYW4gMjAgZGVwZW5kZW5jaWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmbGVjdGl2ZV9leGNlcHRpb25zXzEuSW5zdGFudGlhdGlvbkVycm9yKHRoaXMsIGUsIGUuc3RhY2ssIHByb3ZpZGVyLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBkZXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KGRlcC5rZXksIGRlcC5sb3dlckJvdW5kVmlzaWJpbGl0eSwgZGVwLnVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXAub3B0aW9uYWwgPyBudWxsIDogaW5qZWN0b3JfMS5USFJPV19JRl9OT1RfRk9VTkQpO1xuICAgIH07XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5ID0gZnVuY3Rpb24gKGtleSwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09IElOSkVDVE9SX0tFWSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwcGVyQm91bmRWaXNpYmlsaXR5IGluc3RhbmNlb2YgbWV0YWRhdGFfMS5TZWxmTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleVNlbGYoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleURlZmF1bHQoa2V5LCBub3RGb3VuZFZhbHVlLCBsb3dlckJvdW5kVmlzaWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fdGhyb3dPck51bGwgPSBmdW5jdGlvbiAoa2V5LCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmIChub3RGb3VuZFZhbHVlICE9PSBpbmplY3Rvcl8xLlRIUk9XX0lGX05PVF9GT1VORCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcmVmbGVjdGl2ZV9leGNlcHRpb25zXzEuTm9Qcm92aWRlckVycm9yKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXlTZWxmID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5fc3RyYXRlZ3kuZ2V0T2JqQnlLZXlJZChrZXkuaWQpO1xuICAgICAgICByZXR1cm4gKG9iaiAhPT0gVU5ERUZJTkVEKSA/IG9iaiA6IHRoaXMuX3Rocm93T3JOdWxsKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5RGVmYXVsdCA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUsIGxvd2VyQm91bmRWaXNpYmlsaXR5KSB7XG4gICAgICAgIHZhciBpbmo7XG4gICAgICAgIGlmIChsb3dlckJvdW5kVmlzaWJpbGl0eSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuU2tpcFNlbGZNZXRhZGF0YSkge1xuICAgICAgICAgICAgaW5qID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5qID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5qIGluc3RhbmNlb2YgUmVmbGVjdGl2ZUluamVjdG9yXykge1xuICAgICAgICAgICAgdmFyIGlual8gPSBpbmo7XG4gICAgICAgICAgICB2YXIgb2JqID0gaW5qXy5fc3RyYXRlZ3kuZ2V0T2JqQnlLZXlJZChrZXkuaWQpO1xuICAgICAgICAgICAgaWYgKG9iaiAhPT0gVU5ERUZJTkVEKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICBpbmogPSBpbmpfLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGluai5nZXQoa2V5LnRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvd09yTnVsbChrZXksIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlJlZmxlY3RpdmVJbmplY3Rvcihwcm92aWRlcnM6IFtcIiArIF9tYXBQcm92aWRlcnModGhpcywgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIChcIiBcXFwiXCIgKyBiLmtleS5kaXNwbGF5TmFtZSArIFwiXFxcIiBcIik7IH0pLmpvaW4oXCIsIFwiKSArIFwiXSlcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc3BsYXlOYW1lOyB9O1xuICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3JfO1xufSgpKTtcbmV4cG9ydHMuUmVmbGVjdGl2ZUluamVjdG9yXyA9IFJlZmxlY3RpdmVJbmplY3Rvcl87XG52YXIgSU5KRUNUT1JfS0VZID0gcmVmbGVjdGl2ZV9rZXlfMS5SZWZsZWN0aXZlS2V5LmdldChpbmplY3Rvcl8xLkluamVjdG9yKTtcbmZ1bmN0aW9uIF9tYXBQcm92aWRlcnMoaW5qZWN0b3IsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0b3IuX3Byb3RvLm51bWJlck9mUHJvdmlkZXJzOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goZm4oaW5qZWN0b3IuX3Byb3RvLmdldFByb3ZpZGVyQXRJbmRleChpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdGl2ZV9pbmplY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBmb3J3YXJkX3JlZl8xID0gcmVxdWlyZSgnLi9mb3J3YXJkX3JlZicpO1xuLyoqXG4gKiBBIHVuaXF1ZSBvYmplY3QgdXNlZCBmb3IgcmV0cmlldmluZyBpdGVtcyBmcm9tIHRoZSB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfS5cbiAqXG4gKiBLZXlzIGhhdmU6XG4gKiAtIGEgc3lzdGVtLXdpZGUgdW5pcXVlIGBpZGAuXG4gKiAtIGEgYHRva2VuYC5cbiAqXG4gKiBgS2V5YCBpcyB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIFJlZmxlY3RpdmVJbmplY3Rvcn0gYmVjYXVzZSBpdHMgc3lzdGVtLXdpZGUgdW5pcXVlIGBpZGAgYWxsb3dzXG4gKiB0aGVcbiAqIGluamVjdG9yIHRvIHN0b3JlIGNyZWF0ZWQgb2JqZWN0cyBpbiBhIG1vcmUgZWZmaWNpZW50IHdheS5cbiAqXG4gKiBgS2V5YCBzaG91bGQgbm90IGJlIGNyZWF0ZWQgZGlyZWN0bHkuIHtAbGluayBSZWZsZWN0aXZlSW5qZWN0b3J9IGNyZWF0ZXMga2V5cyBhdXRvbWF0aWNhbGx5IHdoZW5cbiAqIHJlc29sdmluZ1xuICogcHJvdmlkZXJzLlxuICovXG52YXIgUmVmbGVjdGl2ZUtleSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVLZXkodG9rZW4sIGlkKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsodG9rZW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1Rva2VuIG11c3QgYmUgZGVmaW5lZCEnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUtleS5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHN0cmluZ2lmaWVkIHRva2VuLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuc3RyaW5naWZ5KHRoaXMudG9rZW4pOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBgS2V5YCBmb3IgYSB0b2tlbi5cbiAgICAgKi9cbiAgICBSZWZsZWN0aXZlS2V5LmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gX2dsb2JhbEtleVJlZ2lzdHJ5LmdldChmb3J3YXJkX3JlZl8xLnJlc29sdmVGb3J3YXJkUmVmKHRva2VuKSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUtleSwgXCJudW1iZXJPZktleXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdGhlIG51bWJlciBvZiBrZXlzIHJlZ2lzdGVyZWQgaW4gdGhlIHN5c3RlbS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2dsb2JhbEtleVJlZ2lzdHJ5Lm51bWJlck9mS2V5czsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZmxlY3RpdmVLZXk7XG59KCkpO1xuZXhwb3J0cy5SZWZsZWN0aXZlS2V5ID0gUmVmbGVjdGl2ZUtleTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBLZXlSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS2V5UmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuX2FsbEtleXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIEtleVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgUmVmbGVjdGl2ZUtleSlcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgaWYgKHRoaXMuX2FsbEtleXMuaGFzKHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbEtleXMuZ2V0KHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3S2V5ID0gbmV3IFJlZmxlY3RpdmVLZXkodG9rZW4sIFJlZmxlY3RpdmVLZXkubnVtYmVyT2ZLZXlzKTtcbiAgICAgICAgdGhpcy5fYWxsS2V5cy5zZXQodG9rZW4sIG5ld0tleSk7XG4gICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS2V5UmVnaXN0cnkucHJvdG90eXBlLCBcIm51bWJlck9mS2V5c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWxsS2V5cy5zaXplOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gS2V5UmVnaXN0cnk7XG59KCkpO1xuZXhwb3J0cy5LZXlSZWdpc3RyeSA9IEtleVJlZ2lzdHJ5O1xudmFyIF9nbG9iYWxLZXlSZWdpc3RyeSA9IG5ldyBLZXlSZWdpc3RyeSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdGl2ZV9rZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XG52YXIgcmVmbGVjdGl2ZV9rZXlfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdGl2ZV9rZXknKTtcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnLi9tZXRhZGF0YScpO1xudmFyIHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi9yZWZsZWN0aXZlX2V4Y2VwdGlvbnMnKTtcbnZhciBmb3J3YXJkX3JlZl8xID0gcmVxdWlyZSgnLi9mb3J3YXJkX3JlZicpO1xudmFyIHByb3ZpZGVyXzEgPSByZXF1aXJlKCcuL3Byb3ZpZGVyJyk7XG52YXIgcHJvdmlkZXJfdXRpbF8xID0gcmVxdWlyZSgnLi9wcm92aWRlcl91dGlsJyk7XG4vKipcbiAqIGBEZXBlbmRlbmN5YCBpcyB1c2VkIGJ5IHRoZSBmcmFtZXdvcmsgdG8gZXh0ZW5kIERJLlxuICogVGhpcyBpcyBpbnRlcm5hbCB0byBBbmd1bGFyIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkuXG4gKi9cbnZhciBSZWZsZWN0aXZlRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmbGVjdGl2ZURlcGVuZGVuY3koa2V5LCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZFZpc2liaWxpdHkgPSBsb3dlckJvdW5kVmlzaWJpbGl0eTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kVmlzaWJpbGl0eSA9IHVwcGVyQm91bmRWaXNpYmlsaXR5O1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBSZWZsZWN0aXZlRGVwZW5kZW5jeS5mcm9tS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVEZXBlbmRlbmN5KGtleSwgZmFsc2UsIG51bGwsIG51bGwsIFtdKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWZsZWN0aXZlRGVwZW5kZW5jeTtcbn0oKSk7XG5leHBvcnRzLlJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gUmVmbGVjdGl2ZURlcGVuZGVuY3k7XG52YXIgX0VNUFRZX0xJU1QgPSBbXTtcbnZhciBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhrZXksIHJlc29sdmVkRmFjdG9yaWVzLCBtdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnJlc29sdmVkRmFjdG9yaWVzID0gcmVzb2x2ZWRGYWN0b3JpZXM7XG4gICAgICAgIHRoaXMubXVsdGlQcm92aWRlciA9IG11bHRpUHJvdmlkZXI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8ucHJvdG90eXBlLCBcInJlc29sdmVkRmFjdG9yeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yZXNvbHZlZEZhY3Rvcmllc1swXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXztcbn0oKSk7XG5leHBvcnRzLlJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyA9IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXztcbi8qKlxuICogQW4gaW50ZXJuYWwgcmVzb2x2ZWQgcmVwcmVzZW50YXRpb24gb2YgYSBmYWN0b3J5IGZ1bmN0aW9uIGNyZWF0ZWQgYnkgcmVzb2x2aW5nIHtAbGluayBQcm92aWRlcn0uXG4gKi9cbnZhciBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5KFxuICAgICAgICAvKipcbiAgICAgICAgICogRmFjdG9yeSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCByZXByZXNlbnRlZCBieSBhIGtleS5cbiAgICAgICAgICovXG4gICAgICAgIGZhY3RvcnksIFxuICAgICAgICAvKipcbiAgICAgICAgICogQXJndW1lbnRzIChkZXBlbmRlbmNpZXMpIHRvIHRoZSBgZmFjdG9yeWAgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIHJldHVybiBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3Rvcnk7XG4vKipcbiAqIFJlc29sdmUgYSBzaW5nbGUgcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlRmFjdG9yeShwcm92aWRlcikge1xuICAgIHZhciBmYWN0b3J5Rm47XG4gICAgdmFyIHJlc29sdmVkRGVwcztcbiAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgdmFyIHVzZUNsYXNzID0gZm9yd2FyZF9yZWZfMS5yZXNvbHZlRm9yd2FyZFJlZihwcm92aWRlci51c2VDbGFzcyk7XG4gICAgICAgIGZhY3RvcnlGbiA9IHJlZmxlY3Rpb25fMS5yZWZsZWN0b3IuZmFjdG9yeSh1c2VDbGFzcyk7XG4gICAgICAgIHJlc29sdmVkRGVwcyA9IF9kZXBlbmRlbmNpZXNGb3IodXNlQ2xhc3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICBmYWN0b3J5Rm4gPSBmdW5jdGlvbiAoYWxpYXNJbnN0YW5jZSkgeyByZXR1cm4gYWxpYXNJbnN0YW5jZTsgfTtcbiAgICAgICAgcmVzb2x2ZWREZXBzID0gW1JlZmxlY3RpdmVEZXBlbmRlbmN5LmZyb21LZXkocmVmbGVjdGl2ZV9rZXlfMS5SZWZsZWN0aXZlS2V5LmdldChwcm92aWRlci51c2VFeGlzdGluZykpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudChwcm92aWRlci51c2VGYWN0b3J5KSkge1xuICAgICAgICBmYWN0b3J5Rm4gPSBwcm92aWRlci51c2VGYWN0b3J5O1xuICAgICAgICByZXNvbHZlZERlcHMgPSBjb25zdHJ1Y3REZXBlbmRlbmNpZXMocHJvdmlkZXIudXNlRmFjdG9yeSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyLnVzZVZhbHVlOyB9O1xuICAgICAgICByZXNvbHZlZERlcHMgPSBfRU1QVFlfTElTVDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5KGZhY3RvcnlGbiwgcmVzb2x2ZWREZXBzKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVJlZmxlY3RpdmVGYWN0b3J5ID0gcmVzb2x2ZVJlZmxlY3RpdmVGYWN0b3J5O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUge0BsaW5rIFByb3ZpZGVyfSBpbnRvIHtAbGluayBSZXNvbHZlZFByb3ZpZGVyfS5cbiAqXG4gKiB7QGxpbmsgSW5qZWN0b3J9IGludGVybmFsbHkgb25seSB1c2VzIHtAbGluayBSZXNvbHZlZFByb3ZpZGVyfSwge0BsaW5rIFByb3ZpZGVyfSBjb250YWluc1xuICogY29udmVuaWVuY2UgcHJvdmlkZXIgc3ludGF4LlxuICovXG5mdW5jdGlvbiByZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8ocmVmbGVjdGl2ZV9rZXlfMS5SZWZsZWN0aXZlS2V5LmdldChwcm92aWRlci50b2tlbiksIFtyZXNvbHZlUmVmbGVjdGl2ZUZhY3RvcnkocHJvdmlkZXIpXSwgcHJvdmlkZXIubXVsdGkpO1xufVxuZXhwb3J0cy5yZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVyID0gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcjtcbi8qKlxuICogUmVzb2x2ZSBhIGxpc3Qgb2YgUHJvdmlkZXJzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVycyhwcm92aWRlcnMpIHtcbiAgICB2YXIgbm9ybWFsaXplZCA9IF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXJzLCBbXSk7XG4gICAgdmFyIHJlc29sdmVkID0gbm9ybWFsaXplZC5tYXAocmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcik7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5NYXBXcmFwcGVyLnZhbHVlcyhtZXJnZVJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyhyZXNvbHZlZCwgbmV3IE1hcCgpKSk7XG59XG5leHBvcnRzLnJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXJzID0gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcnM7XG4vKipcbiAqIE1lcmdlcyBhIGxpc3Qgb2YgUmVzb2x2ZWRQcm92aWRlcnMgaW50byBhIGxpc3Qgd2hlcmVcbiAqIGVhY2gga2V5IGlzIGNvbnRhaW5lZCBleGFjdGx5IG9uY2UgYW5kIG11bHRpIHByb3ZpZGVyc1xuICogaGF2ZSBiZWVuIG1lcmdlZC5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzLCBub3JtYWxpemVkUHJvdmlkZXJzTWFwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm92aWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gcHJvdmlkZXJzW2ldO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBub3JtYWxpemVkUHJvdmlkZXJzTWFwLmdldChwcm92aWRlci5rZXkuaWQpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChleGlzdGluZykpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aVByb3ZpZGVyICE9PSBleGlzdGluZy5tdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLk1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihleGlzdGluZywgcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnJlc29sdmVkRmFjdG9yaWVzLnB1c2gocHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm92aWRlcnNNYXAuc2V0KHByb3ZpZGVyLmtleS5pZCwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXI7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIgPSBuZXcgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfKHByb3ZpZGVyLmtleSwgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsb25lKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzKSwgcHJvdmlkZXIubXVsdGlQcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemVkUHJvdmlkZXJzTWFwLnNldChwcm92aWRlci5rZXkuaWQsIHJlc29sdmVkUHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkUHJvdmlkZXJzTWFwO1xufVxuZXhwb3J0cy5tZXJnZVJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IG1lcmdlUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzO1xuZnVuY3Rpb24gX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlcnMsIHJlcykge1xuICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgbGFuZ18xLlR5cGUpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHByb3ZpZGVyXzEucHJvdmlkZShiLCB7IHVzZUNsYXNzOiBiIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgcHJvdmlkZXJfMS5Qcm92aWRlcikge1xuICAgICAgICAgICAgcmVzLnB1c2goYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXJfdXRpbF8xLmlzUHJvdmlkZXJMaXRlcmFsKGIpKSB7XG4gICAgICAgICAgICByZXMucHVzaChwcm92aWRlcl91dGlsXzEuY3JlYXRlUHJvdmlkZXIoYikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhiLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBwcm92aWRlcl8xLlByb3ZpZGVyQnVpbGRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLkludmFsaWRQcm92aWRlckVycm9yKGIudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLkludmFsaWRQcm92aWRlckVycm9yKGIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdERlcGVuZGVuY2llcyh0eXBlT3JGdW5jLCBkZXBlbmRlbmNpZXMpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoZGVwZW5kZW5jaWVzKSkge1xuICAgICAgICByZXR1cm4gX2RlcGVuZGVuY2llc0Zvcih0eXBlT3JGdW5jKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBbdF07IH0pO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2V4dHJhY3RUb2tlbih0eXBlT3JGdW5jLCB0LCBwYXJhbXMpOyB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNvbnN0cnVjdERlcGVuZGVuY2llcyA9IGNvbnN0cnVjdERlcGVuZGVuY2llcztcbmZ1bmN0aW9uIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYykge1xuICAgIHZhciBwYXJhbXMgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmFtcykpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBpZiAocGFyYW1zLnNvbWUobGFuZ18xLmlzQmxhbmspKSB7XG4gICAgICAgIHRocm93IG5ldyByZWZsZWN0aXZlX2V4Y2VwdGlvbnNfMS5Ob0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gX2V4dHJhY3RUb2tlbih0eXBlT3JGdW5jLCBwLCBwYXJhbXMpOyB9KTtcbn1cbmZ1bmN0aW9uIF9leHRyYWN0VG9rZW4odHlwZU9yRnVuYywgbWV0YWRhdGEgLyphbnlbXSB8IGFueSovLCBwYXJhbXMpIHtcbiAgICB2YXIgZGVwUHJvcHMgPSBbXTtcbiAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgIHZhciBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGlmICghbGFuZ18xLmlzQXJyYXkobWV0YWRhdGEpKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuSW5qZWN0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeShtZXRhZGF0YS50b2tlbiwgb3B0aW9uYWwsIG51bGwsIG51bGwsIGRlcFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeShtZXRhZGF0YSwgb3B0aW9uYWwsIG51bGwsIG51bGwsIGRlcFByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbG93ZXJCb3VuZFZpc2liaWxpdHkgPSBudWxsO1xuICAgIHZhciB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcGFyYW1NZXRhZGF0YSA9IG1ldGFkYXRhW2ldO1xuICAgICAgICBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIGxhbmdfMS5UeXBlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuSW5qZWN0TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRva2VuID0gcGFyYW1NZXRhZGF0YS50b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5PcHRpb25hbE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuU2VsZk1ldGFkYXRhKSB7XG4gICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuSG9zdE1ldGFkYXRhKSB7XG4gICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuU2tpcFNlbGZNZXRhZGF0YSkge1xuICAgICAgICAgICAgbG93ZXJCb3VuZFZpc2liaWxpdHkgPSBwYXJhbU1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLkRlcGVuZGVuY3lNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyYW1NZXRhZGF0YS50b2tlbikpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGEudG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXBQcm9wcy5wdXNoKHBhcmFtTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRva2VuID0gZm9yd2FyZF9yZWZfMS5yZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodG9rZW4pKSB7XG4gICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeSh0b2tlbiwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IHJlZmxlY3RpdmVfZXhjZXB0aW9uc18xLk5vQW5ub3RhdGlvbkVycm9yKHR5cGVPckZ1bmMsIHBhcmFtcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4sIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcFByb3BzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlRGVwZW5kZW5jeShyZWZsZWN0aXZlX2tleV8xLlJlZmxlY3RpdmVLZXkuZ2V0KHRva2VuKSwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdGl2ZV9wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGdsb2JhbFNjb3BlO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XG4gICAgfVxufVxuZWxzZSB7XG4gICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG59XG5mdW5jdGlvbiBzY2hlZHVsZU1pY3JvVGFzayhmbikge1xuICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XG59XG5leHBvcnRzLnNjaGVkdWxlTWljcm9UYXNrID0gc2NoZWR1bGVNaWNyb1Rhc2s7XG5leHBvcnRzLklTX0RBUlQgPSBmYWxzZTtcbi8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbnZhciBfZ2xvYmFsID0gZ2xvYmFsU2NvcGU7XG5leHBvcnRzLmdsb2JhbCA9IF9nbG9iYWw7XG5leHBvcnRzLlR5cGUgPSBGdW5jdGlvbjtcbmZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGUpIHtcbiAgICBpZiAodHlwZVsnbmFtZSddKSB7XG4gICAgICAgIHJldHVybiB0eXBlWyduYW1lJ107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdHlwZTtcbn1cbmV4cG9ydHMuZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcgPSBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZztcbmV4cG9ydHMuTWF0aCA9IF9nbG9iYWwuTWF0aDtcbmV4cG9ydHMuRGF0ZSA9IF9nbG9iYWwuRGF0ZTtcbnZhciBfZGV2TW9kZSA9IHRydWU7XG52YXIgX21vZGVMb2NrZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGxvY2tNb2RlKCkge1xuICAgIF9tb2RlTG9ja2VkID0gdHJ1ZTtcbn1cbmV4cG9ydHMubG9ja01vZGUgPSBsb2NrTW9kZTtcbi8qKlxuICogRGlzYWJsZSBBbmd1bGFyJ3MgZGV2ZWxvcG1lbnQgbW9kZSwgd2hpY2ggdHVybnMgb2ZmIGFzc2VydGlvbnMgYW5kIG90aGVyXG4gKiBjaGVja3Mgd2l0aGluIHRoZSBmcmFtZXdvcmsuXG4gKlxuICogT25lIGltcG9ydGFudCBhc3NlcnRpb24gdGhpcyBkaXNhYmxlcyB2ZXJpZmllcyB0aGF0IGEgY2hhbmdlIGRldGVjdGlvbiBwYXNzXG4gKiBkb2VzIG5vdCByZXN1bHQgaW4gYWRkaXRpb25hbCBjaGFuZ2VzIHRvIGFueSBiaW5kaW5ncyAoYWxzbyBrbm93biBhc1xuICogdW5pZGlyZWN0aW9uYWwgZGF0YSBmbG93KS5cbiAqL1xuZnVuY3Rpb24gZW5hYmxlUHJvZE1vZGUoKSB7XG4gICAgaWYgKF9tb2RlTG9ja2VkKSB7XG4gICAgICAgIC8vIENhbm5vdCB1c2UgQmFzZUV4Y2VwdGlvbiBhcyB0aGF0IGVuZHMgdXAgaW1wb3J0aW5nIGZyb20gZmFjYWRlL2xhbmcuXG4gICAgICAgIHRocm93ICdDYW5ub3QgZW5hYmxlIHByb2QgbW9kZSBhZnRlciBwbGF0Zm9ybSBzZXR1cC4nO1xuICAgIH1cbiAgICBfZGV2TW9kZSA9IGZhbHNlO1xufVxuZXhwb3J0cy5lbmFibGVQcm9kTW9kZSA9IGVuYWJsZVByb2RNb2RlO1xuZnVuY3Rpb24gYXNzZXJ0aW9uc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIF9kZXZNb2RlO1xufVxuZXhwb3J0cy5hc3NlcnRpb25zRW5hYmxlZCA9IGFzc2VydGlvbnNFbmFibGVkO1xuLy8gVE9ETzogcmVtb3ZlIGNhbGxzIHRvIGFzc2VydCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4vLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbi8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG5fZ2xvYmFsLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xufTtcbmZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG5mdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XG59XG5leHBvcnRzLmlzQmxhbmsgPSBpc0JsYW5rO1xuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImJvb2xlYW5cIjtcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCI7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5mdW5jdGlvbiBpc1R5cGUob2JqKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqKTtcbn1cbmV4cG9ydHMuaXNUeXBlID0gaXNUeXBlO1xuZnVuY3Rpb24gaXNTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNTdHJpbmdNYXAgPSBpc1N0cmluZ01hcDtcbnZhciBTVFJJTkdfTUFQX1BST1RPID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbmZ1bmN0aW9uIGlzU3RyaWN0U3RyaW5nTWFwKG9iaikge1xuICAgIHJldHVybiBpc1N0cmluZ01hcChvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xufVxuZXhwb3J0cy5pc1N0cmljdFN0cmluZ01hcCA9IGlzU3RyaWN0U3RyaW5nTWFwO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBfZ2xvYmFsLlByb21pc2U7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIGV4cG9ydHMuRGF0ZSAmJiAhaXNOYU4ob2JqLnZhbHVlT2YoKSk7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5mdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgIH1cbiAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICB9XG4gICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKFwiXFxuXCIpO1xuICAgIHJldHVybiAobmV3TGluZUluZGV4ID09PSAtMSkgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbi8vIHNlcmlhbGl6ZSAvIGRlc2VyaWFsaXplIGVudW0gZXhpc3Qgb25seSBmb3IgY29uc2lzdGVuY3kgd2l0aCBkYXJ0IEFQSVxuLy8gZW51bXMgaW4gdHlwZXNjcmlwdCBkb24ndCBuZWVkIHRvIGJlIHNlcmlhbGl6ZWRcbmZ1bmN0aW9uIHNlcmlhbGl6ZUVudW0odmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmV4cG9ydHMuc2VyaWFsaXplRW51bSA9IHNlcmlhbGl6ZUVudW07XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVudW0odmFsLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZUVudW0gPSBkZXNlcmlhbGl6ZUVudW07XG5mdW5jdGlvbiByZXNvbHZlRW51bVRva2VuKGVudW1WYWx1ZSwgdmFsKSB7XG4gICAgcmV0dXJuIGVudW1WYWx1ZVt2YWxdO1xufVxuZXhwb3J0cy5yZXNvbHZlRW51bVRva2VuID0gcmVzb2x2ZUVudW1Ub2tlbjtcbnZhciBTdHJpbmdXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdXcmFwcGVyKCkge1xuICAgIH1cbiAgICBTdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdCA9IGZ1bmN0aW9uIChzLCBpbmRleCkgeyByZXR1cm4gcy5jaGFyQ29kZUF0KGluZGV4KTsgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnNwbGl0ID0gZnVuY3Rpb24gKHMsIHJlZ0V4cCkgeyByZXR1cm4gcy5zcGxpdChyZWdFeHApOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKHMsIHMyKSB7IHJldHVybiBzID09PSBzMjsgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnN0cmlwTGVmdCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnN0cmlwUmlnaHQgPSBmdW5jdGlvbiAocywgY2hhclZhbCkge1xuICAgICAgICBpZiAocyAmJiBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPSBjaGFyVmFsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzLCBmcm9tLCByZXBsYWNlKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgcmVwbGFjZSk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnNsaWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBzLnNsaWNlKGZyb20sIHRvID09PSBudWxsID8gdW5kZWZpbmVkIDogdG8pO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkID0gZnVuY3Rpb24gKHMsIGZyb20sIGNiKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzZXQgJiBzdHJpbmcgZnJvbSB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICBtYXRjaGVzLnNwbGljZSgtMiwgMik7XG4gICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbWF0Y2gsIHAxLCAuLi4sIHBuXG4gICAgICAgICAgICByZXR1cm4gY2IobWF0Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChzLCBzdWJzdHIpIHsgcmV0dXJuIHMuaW5kZXhPZihzdWJzdHIpICE9IC0xOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5nV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ1dyYXBwZXIgPSBTdHJpbmdXcmFwcGVyO1xudmFyIFN0cmluZ0pvaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nSm9pbmVyKHBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7IHBhcnRzID0gW107IH1cbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIH1cbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwYXJ0KSB7IHRoaXMucGFydHMucHVzaChwYXJ0KTsgfTtcbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJ0cy5qb2luKFwiXCIpOyB9O1xuICAgIHJldHVybiBTdHJpbmdKb2luZXI7XG59KCkpO1xuZXhwb3J0cy5TdHJpbmdKb2luZXIgPSBTdHJpbmdKb2luZXI7XG52YXIgTnVtYmVyUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlclBhcnNlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVtYmVyUGFyc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBOdW1iZXJQYXJzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcbiAgICByZXR1cm4gTnVtYmVyUGFyc2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuTnVtYmVyUGFyc2VFcnJvciA9IE51bWJlclBhcnNlRXJyb3I7XG52YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVyV3JhcHBlcigpIHtcbiAgICB9XG4gICAgTnVtYmVyV3JhcHBlci50b0ZpeGVkID0gZnVuY3Rpb24gKG4sIGZyYWN0aW9uRGlnaXRzKSB7IHJldHVybiBuLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpOyB9O1xuICAgIE51bWJlcldyYXBwZXIuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcbiAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE51bWJlclBhcnNlRXJyb3IoXCJJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgXCIgKyB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUludCA9IGZ1bmN0aW9uICh0ZXh0LCByYWRpeCkge1xuICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05XSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYWRpeCA9PSAxNikge1xuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE51bWJlclBhcnNlRXJyb3IoXCJJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgXCIgKyB0ZXh0ICsgXCIgaW4gYmFzZSBcIiArXG4gICAgICAgICAgICByYWRpeCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBOYU4gaXMgYSB2YWxpZCBsaXRlcmFsIGJ1dCBpcyByZXR1cm5lZCBieSBwYXJzZUZsb2F0IHRvIGluZGljYXRlIGFuIGVycm9yLlxuICAgIE51bWJlcldyYXBwZXIucGFyc2VGbG9hdCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBwYXJzZUZsb2F0KHRleHQpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBcIk5hTlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmFOOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOdW1iZXJXcmFwcGVyLmlzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc05hTih2YWx1ZSk7IH07XG4gICAgTnVtYmVyV3JhcHBlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpOyB9O1xuICAgIHJldHVybiBOdW1iZXJXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuTnVtYmVyV3JhcHBlciA9IE51bWJlcldyYXBwZXI7XG5leHBvcnRzLlJlZ0V4cCA9IF9nbG9iYWwuUmVnRXhwO1xudmFyIFJlZ0V4cFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZ0V4cFdyYXBwZXIoKSB7XG4gICAgfVxuICAgIFJlZ0V4cFdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHJlZ0V4cFN0ciwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAnJzsgfVxuICAgICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoL2cvZywgJycpO1xuICAgICAgICByZXR1cm4gbmV3IF9nbG9iYWwuUmVnRXhwKHJlZ0V4cFN0ciwgZmxhZ3MgKyAnZycpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgLy8gUmVzZXQgbXVsdGltYXRjaCByZWdleCBzdGF0ZVxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICB9O1xuICAgIFJlZ0V4cFdyYXBwZXIudGVzdCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0KSB7XG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcmVnRXhwLnRlc3QoaW5wdXQpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci5tYXRjaGVyID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgLy8gUmVzZXQgcmVnZXggc3RhdGUgZm9yIHRoZSBjYXNlXG4gICAgICAgIC8vIHNvbWVvbmUgZGlkIG5vdCBsb29wIG92ZXIgYWxsIG1hdGNoZXNcbiAgICAgICAgLy8gbGFzdCB0aW1lLlxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHsgcmU6IHJlZ0V4cCwgaW5wdXQ6IGlucHV0IH07XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgYyA9IHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICAgICAgdmFyIHJlcyA9ICcnO1xuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIHByZXYgPSAwO1xuICAgICAgICB3aGlsZSAoYykge1xuICAgICAgICAgICAgcmVzICs9IGlucHV0LnN1YnN0cmluZyhwcmV2LCBjLmluZGV4KTtcbiAgICAgICAgICAgIHJlcyArPSByZXBsYWNlKGMpO1xuICAgICAgICAgICAgcHJldiA9IGMuaW5kZXggKyBjWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSBwcmV2O1xuICAgICAgICAgICAgYyA9IHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gaW5wdXQuc3Vic3RyaW5nKHByZXYpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ0V4cFdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5SZWdFeHBXcmFwcGVyID0gUmVnRXhwV3JhcHBlcjtcbnZhciBSZWdFeHBNYXRjaGVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnRXhwTWF0Y2hlcldyYXBwZXIoKSB7XG4gICAgfVxuICAgIFJlZ0V4cE1hdGNoZXJXcmFwcGVyLm5leHQgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5yZS5leGVjKG1hdGNoZXIuaW5wdXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ0V4cE1hdGNoZXJXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuUmVnRXhwTWF0Y2hlcldyYXBwZXIgPSBSZWdFeHBNYXRjaGVyV3JhcHBlcjtcbnZhciBGdW5jdGlvbldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uV3JhcHBlcigpIHtcbiAgICB9XG4gICAgRnVuY3Rpb25XcmFwcGVyLmFwcGx5ID0gZnVuY3Rpb24gKGZuLCBwb3NBcmdzKSB7IHJldHVybiBmbi5hcHBseShudWxsLCBwb3NBcmdzKTsgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25XcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRnVuY3Rpb25XcmFwcGVyID0gRnVuY3Rpb25XcmFwcGVyO1xuLy8gSlMgaGFzIE5hTiAhPT0gTmFOXG5mdW5jdGlvbiBsb29zZUlkZW50aWNhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XG59XG5leHBvcnRzLmxvb3NlSWRlbnRpY2FsID0gbG9vc2VJZGVudGljYWw7XG4vLyBKUyBjb25zaWRlcnMgTmFOIGlzIHRoZSBzYW1lIGFzIE5hTiBmb3IgbWFwIEtleSAod2hpbGUgTmFOICE9PSBOYU4gb3RoZXJ3aXNlKVxuLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcFxuZnVuY3Rpb24gZ2V0TWFwS2V5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5nZXRNYXBLZXkgPSBnZXRNYXBLZXk7XG5mdW5jdGlvbiBub3JtYWxpemVCbGFuayhvYmopIHtcbiAgICByZXR1cm4gaXNCbGFuayhvYmopID8gbnVsbCA6IG9iajtcbn1cbmV4cG9ydHMubm9ybWFsaXplQmxhbmsgPSBub3JtYWxpemVCbGFuaztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJvb2wob2JqKSB7XG4gICAgcmV0dXJuIGlzQmxhbmsob2JqKSA/IGZhbHNlIDogb2JqO1xufVxuZXhwb3J0cy5ub3JtYWxpemVCb29sID0gbm9ybWFsaXplQm9vbDtcbmZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvID09PSBcIm9iamVjdFwiKTtcbn1cbmV4cG9ydHMuaXNKc09iamVjdCA9IGlzSnNPYmplY3Q7XG5mdW5jdGlvbiBwcmludChvYmopIHtcbiAgICBjb25zb2xlLmxvZyhvYmopO1xufVxuZXhwb3J0cy5wcmludCA9IHByaW50O1xuZnVuY3Rpb24gd2FybihvYmopIHtcbiAgICBjb25zb2xlLndhcm4ob2JqKTtcbn1cbmV4cG9ydHMud2FybiA9IHdhcm47XG4vLyBDYW4ndCBiZSBhbGwgdXBwZXJjYXNlIGFzIG91ciB0cmFuc3BpbGVyIHdvdWxkIHRoaW5rIGl0IGlzIGEgc3BlY2lhbCBkaXJlY3RpdmUuLi5cbnZhciBKc29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKc29uKCkge1xuICAgIH1cbiAgICBKc29uLnBhcnNlID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF9nbG9iYWwuSlNPTi5wYXJzZShzKTsgfTtcbiAgICBKc29uLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIERhcnQgZG9lc24ndCB0YWtlIDMgYXJndW1lbnRzXG4gICAgICAgIHJldHVybiBfZ2xvYmFsLkpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb247XG59KCkpO1xuZXhwb3J0cy5Kc29uID0gSnNvbjtcbnZhciBEYXRlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVdyYXBwZXIoKSB7XG4gICAgfVxuICAgIERhdGVXcmFwcGVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgaWYgKG1vbnRoID09PSB2b2lkIDApIHsgbW9udGggPSAxOyB9XG4gICAgICAgIGlmIChkYXkgPT09IHZvaWQgMCkgeyBkYXkgPSAxOyB9XG4gICAgICAgIGlmIChob3VyID09PSB2b2lkIDApIHsgaG91ciA9IDA7IH1cbiAgICAgICAgaWYgKG1pbnV0ZXMgPT09IHZvaWQgMCkgeyBtaW51dGVzID0gMDsgfVxuICAgICAgICBpZiAoc2Vjb25kcyA9PT0gdm9pZCAwKSB7IHNlY29uZHMgPSAwOyB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMgPT09IHZvaWQgMCkgeyBtaWxsaXNlY29uZHMgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpO1xuICAgIH07XG4gICAgRGF0ZVdyYXBwZXIuZnJvbUlTT1N0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoc3RyKTsgfTtcbiAgICBEYXRlV3JhcHBlci5mcm9tTWlsbGlzID0gZnVuY3Rpb24gKG1zKSB7IHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKG1zKTsgfTtcbiAgICBEYXRlV3JhcHBlci50b01pbGxpcyA9IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfTtcbiAgICBEYXRlV3JhcHBlci5ub3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKCk7IH07XG4gICAgRGF0ZVdyYXBwZXIudG9Kc29uID0gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUudG9KU09OKCk7IH07XG4gICAgcmV0dXJuIERhdGVXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRGF0ZVdyYXBwZXIgPSBEYXRlV3JhcHBlcjtcbmZ1bmN0aW9uIHNldFZhbHVlT25QYXRoKGdsb2JhbCwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIG9iaiA9IGdsb2JhbDtcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNQcmVzZW50KG9ialtuYW1lXSkpIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgfVxuICAgIG9ialtwYXJ0cy5zaGlmdCgpXSA9IHZhbHVlO1xufVxuZXhwb3J0cy5zZXRWYWx1ZU9uUGF0aCA9IHNldFZhbHVlT25QYXRoO1xudmFyIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XG5mdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICBpZiAoaXNCbGFuayhfc3ltYm9sSXRlcmF0b3IpKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZ2xvYmFsU2NvcGUuU3ltYm9sKSAmJiBpc1ByZXNlbnQoU3ltYm9sLml0ZXJhdG9yKSkge1xuICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXM2LXNoaW0gc3BlY2lmaWMgbG9naWNcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtrZXldID09PSBNYXAucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3N5bWJvbEl0ZXJhdG9yO1xufVxuZXhwb3J0cy5nZXRTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbEl0ZXJhdG9yO1xuZnVuY3Rpb24gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsLCBleHByLCBkZWNsYXJhdGlvbnMsIHZhcnMpIHtcbiAgICB2YXIgZm5Cb2R5ID0gZGVjbGFyYXRpb25zICsgXCJcXG5yZXR1cm4gXCIgKyBleHByICsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgc291cmNlVXJsO1xuICAgIHZhciBmbkFyZ05hbWVzID0gW107XG4gICAgdmFyIGZuQXJnVmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgYXJnTmFtZSBpbiB2YXJzKSB7XG4gICAgICAgIGZuQXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgW3ZvaWQgMF0uY29uY2F0KGZuQXJnTmFtZXMuY29uY2F0KGZuQm9keSkpKSkoKS5hcHBseSh2b2lkIDAsIGZuQXJnVmFsdWVzKTtcbn1cbmV4cG9ydHMuZXZhbEV4cHJlc3Npb24gPSBldmFsRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZnVuY3Rpb24gaGFzQ29uc3RydWN0b3IodmFsdWUsIHR5cGUpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IHR5cGU7XG59XG5leHBvcnRzLmhhc0NvbnN0cnVjdG9yID0gaGFzQ29uc3RydWN0b3I7XG5mdW5jdGlvbiBiaXRXaXNlT3IodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgfCBiOyB9KTtcbn1cbmV4cG9ydHMuYml0V2lzZU9yID0gYml0V2lzZU9yO1xuZnVuY3Rpb24gYml0V2lzZUFuZCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAmIGI7IH0pO1xufVxuZXhwb3J0cy5iaXRXaXNlQW5kID0gYml0V2lzZUFuZDtcbmZ1bmN0aW9uIGVzY2FwZShzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWwuZW5jb2RlVVJJKHMpO1xufVxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gUHVibGljIEFQSSBmb3IgY29tcGlsZXJcbnZhciBjb21wb25lbnRfcmVzb2x2ZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2NvbXBvbmVudF9yZXNvbHZlcicpO1xuZXhwb3J0cy5Db21wb25lbnRSZXNvbHZlciA9IGNvbXBvbmVudF9yZXNvbHZlcl8xLkNvbXBvbmVudFJlc29sdmVyO1xudmFyIHF1ZXJ5X2xpc3RfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3F1ZXJ5X2xpc3QnKTtcbmV4cG9ydHMuUXVlcnlMaXN0ID0gcXVlcnlfbGlzdF8xLlF1ZXJ5TGlzdDtcbnZhciBkeW5hbWljX2NvbXBvbmVudF9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vbGlua2VyL2R5bmFtaWNfY29tcG9uZW50X2xvYWRlcicpO1xuZXhwb3J0cy5EeW5hbWljQ29tcG9uZW50TG9hZGVyID0gZHluYW1pY19jb21wb25lbnRfbG9hZGVyXzEuRHluYW1pY0NvbXBvbmVudExvYWRlcjtcbnZhciBlbGVtZW50X3JlZl8xID0gcmVxdWlyZSgnLi9saW5rZXIvZWxlbWVudF9yZWYnKTtcbmV4cG9ydHMuRWxlbWVudFJlZiA9IGVsZW1lbnRfcmVmXzEuRWxlbWVudFJlZjtcbnZhciB0ZW1wbGF0ZV9yZWZfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3RlbXBsYXRlX3JlZicpO1xuZXhwb3J0cy5UZW1wbGF0ZVJlZiA9IHRlbXBsYXRlX3JlZl8xLlRlbXBsYXRlUmVmO1xudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCcuL2xpbmtlci92aWV3X3JlZicpO1xuZXhwb3J0cy5FbWJlZGRlZFZpZXdSZWYgPSB2aWV3X3JlZl8xLkVtYmVkZGVkVmlld1JlZjtcbmV4cG9ydHMuVmlld1JlZiA9IHZpZXdfcmVmXzEuVmlld1JlZjtcbnZhciB2aWV3X2NvbnRhaW5lcl9yZWZfMSA9IHJlcXVpcmUoJy4vbGlua2VyL3ZpZXdfY29udGFpbmVyX3JlZicpO1xuZXhwb3J0cy5WaWV3Q29udGFpbmVyUmVmID0gdmlld19jb250YWluZXJfcmVmXzEuVmlld0NvbnRhaW5lclJlZjtcbnZhciBjb21wb25lbnRfZmFjdG9yeV8xID0gcmVxdWlyZSgnLi9saW5rZXIvY29tcG9uZW50X2ZhY3RvcnknKTtcbmV4cG9ydHMuQ29tcG9uZW50UmVmID0gY29tcG9uZW50X2ZhY3RvcnlfMS5Db21wb25lbnRSZWY7XG5leHBvcnRzLkNvbXBvbmVudEZhY3RvcnkgPSBjb21wb25lbnRfZmFjdG9yeV8xLkNvbXBvbmVudEZhY3Rvcnk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi9saW5rZXIvZXhjZXB0aW9ucycpO1xuZXhwb3J0cy5FeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbiA9IGV4Y2VwdGlvbnNfMS5FeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIHZpZXdfdXRpbHNfMSA9IHJlcXVpcmUoJy4vdmlld191dGlscycpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIGEgQ29tcG9uZW50IGNyZWF0ZWQgdmlhIGEge0BsaW5rIENvbXBvbmVudEZhY3Rvcnl9LlxuICpcbiAqIGBDb21wb25lbnRSZWZgIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgQ29tcG9uZW50IEluc3RhbmNlIGFzIHdlbGwgb3RoZXIgb2JqZWN0cyByZWxhdGVkIHRvIHRoaXNcbiAqIENvbXBvbmVudCBJbnN0YW5jZSBhbmQgYWxsb3dzIHlvdSB0byBkZXN0cm95IHRoZSBDb21wb25lbnQgSW5zdGFuY2UgdmlhIHRoZSB7QGxpbmsgI2Rlc3Ryb3l9XG4gKiBtZXRob2QuXG4gKi9cbnZhciBDb21wb25lbnRSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZigpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwibG9jYXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9jYXRpb24gb2YgdGhlIEhvc3QgRWxlbWVudCBvZiB0aGlzIENvbXBvbmVudCBJbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluamVjdG9yIG9uIHdoaWNoIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgZXhpc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5zdGFuY2Ugb2YgdGhlIENvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImhvc3RWaWV3XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgVmlld1JlZn0gb2YgdGhlIEhvc3QgVmlldyBvZiB0aGlzIENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImNoYW5nZURldGVjdG9yUmVmXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgQ2hhbmdlRGV0ZWN0b3JSZWZ9IG9mIHRoZSBDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbXBvbmVudCB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ29tcG9uZW50UmVmO1xufSgpKTtcbmV4cG9ydHMuQ29tcG9uZW50UmVmID0gQ29tcG9uZW50UmVmO1xudmFyIENvbXBvbmVudFJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRSZWZfLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZl8oX2hvc3RFbGVtZW50LCBfY29tcG9uZW50VHlwZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQgPSBfaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFR5cGUgPSBfY29tcG9uZW50VHlwZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImxvY2F0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ob3N0RWxlbWVudC5lbGVtZW50UmVmOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LmluamVjdG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LmNvbXBvbmVudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJob3N0Vmlld1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faG9zdEVsZW1lbnQucGFyZW50Vmlldy5yZWY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LnBhcmVudFZpZXcucmVmOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICA7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFR5cGU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvbXBvbmVudFJlZl8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hvc3RFbGVtZW50LnBhcmVudFZpZXcuZGVzdHJveSgpOyB9O1xuICAgIENvbXBvbmVudFJlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLmhvc3RWaWV3Lm9uRGVzdHJveShjYWxsYmFjayk7IH07XG4gICAgcmV0dXJuIENvbXBvbmVudFJlZl87XG59KENvbXBvbmVudFJlZikpO1xuZXhwb3J0cy5Db21wb25lbnRSZWZfID0gQ29tcG9uZW50UmVmXztcbnZhciBFTVBUWV9DT05URVhUID0gbmV3IE9iamVjdCgpO1xuLypAdHMyZGFydF9jb25zdCovXG52YXIgQ29tcG9uZW50RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeShzZWxlY3RvciwgX3ZpZXdGYWN0b3J5LCBfY29tcG9uZW50VHlwZSkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuX3ZpZXdGYWN0b3J5ID0gX3ZpZXdGYWN0b3J5O1xuICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlID0gX2NvbXBvbmVudFR5cGU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRGYWN0b3J5LnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb21wb25lbnRUeXBlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBDb21wb25lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICBpZiAocHJvamVjdGFibGVOb2RlcyA9PT0gdm9pZCAwKSB7IHByb2plY3RhYmxlTm9kZXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChyb290U2VsZWN0b3JPck5vZGUgPT09IHZvaWQgMCkgeyByb290U2VsZWN0b3JPck5vZGUgPSBudWxsOyB9XG4gICAgICAgIHZhciB2dSA9IGluamVjdG9yLmdldCh2aWV3X3V0aWxzXzEuVmlld1V0aWxzKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHByb2plY3RhYmxlTm9kZXMpKSB7XG4gICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogSG9zdCB2aWV3cyBkb24ndCBuZWVkIGEgZGVjbGFyYXRpb25BcHBFbGVtZW50IVxuICAgICAgICB2YXIgaG9zdFZpZXcgPSB0aGlzLl92aWV3RmFjdG9yeSh2dSwgaW5qZWN0b3IsIG51bGwpO1xuICAgICAgICB2YXIgaG9zdEVsZW1lbnQgPSBob3N0Vmlldy5jcmVhdGUoRU1QVFlfQ09OVEVYVCwgcHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRSZWZfKGhvc3RFbGVtZW50LCB0aGlzLl9jb21wb25lbnRUeXBlKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuQ29tcG9uZW50RmFjdG9yeSA9IENvbXBvbmVudEZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wb25lbnRfZmFjdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgcmVmbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vcmVmbGVjdGlvbi9yZWZsZWN0aW9uJyk7XG52YXIgY29tcG9uZW50X2ZhY3RvcnlfMSA9IHJlcXVpcmUoJy4vY29tcG9uZW50X2ZhY3RvcnknKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCcuLi9kaS9kZWNvcmF0b3JzJyk7XG4vKipcbiAqIExvdy1sZXZlbCBzZXJ2aWNlIGZvciBsb2FkaW5nIHtAbGluayBDb21wb25lbnRGYWN0b3J5fXMsIHdoaWNoXG4gKiBjYW4gbGF0ZXIgYmUgdXNlZCB0byBjcmVhdGUgYW5kIHJlbmRlciBhIENvbXBvbmVudCBpbnN0YW5jZS5cbiAqL1xudmFyIENvbXBvbmVudFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRSZXNvbHZlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvbmVudFJlc29sdmVyO1xufSgpKTtcbmV4cG9ydHMuQ29tcG9uZW50UmVzb2x2ZXIgPSBDb21wb25lbnRSZXNvbHZlcjtcbmZ1bmN0aW9uIF9pc0NvbXBvbmVudEZhY3RvcnkodHlwZSkge1xuICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgY29tcG9uZW50X2ZhY3RvcnlfMS5Db21wb25lbnRGYWN0b3J5O1xufVxudmFyIFJlZmxlY3RvckNvbXBvbmVudFJlc29sdmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmbGVjdG9yQ29tcG9uZW50UmVzb2x2ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmbGVjdG9yQ29tcG9uZW50UmVzb2x2ZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBSZWZsZWN0b3JDb21wb25lbnRSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YXMgPSByZWZsZWN0aW9uXzEucmVmbGVjdG9yLmFubm90YXRpb25zKGNvbXBvbmVudFR5cGUpO1xuICAgICAgICB2YXIgY29tcG9uZW50RmFjdG9yeSA9IG1ldGFkYXRhcy5maW5kKF9pc0NvbXBvbmVudEZhY3RvcnkpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29tcG9uZW50RmFjdG9yeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIk5vIHByZWNvbXBpbGVkIGNvbXBvbmVudCBcIiArIGxhbmdfMS5zdHJpbmdpZnkoY29tcG9uZW50VHlwZSkgKyBcIiBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmNfMS5Qcm9taXNlV3JhcHBlci5yZXNvbHZlKGNvbXBvbmVudEZhY3RvcnkpO1xuICAgIH07XG4gICAgUmVmbGVjdG9yQ29tcG9uZW50UmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgUmVmbGVjdG9yQ29tcG9uZW50UmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBkZWNvcmF0b3JzXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIFJlZmxlY3RvckNvbXBvbmVudFJlc29sdmVyO1xufShDb21wb25lbnRSZXNvbHZlcikpO1xuZXhwb3J0cy5SZWZsZWN0b3JDb21wb25lbnRSZXNvbHZlciA9IFJlZmxlY3RvckNvbXBvbmVudFJlc29sdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcG9uZW50X3Jlc29sdmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIHZpZXdfdHlwZV8xID0gcmVxdWlyZSgnLi92aWV3X3R5cGUnKTtcbi8qIEB0czJkYXJ0X2NvbnN0ICovXG52YXIgU3RhdGljTm9kZURlYnVnSW5mbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljTm9kZURlYnVnSW5mbyhwcm92aWRlclRva2VucywgY29tcG9uZW50VG9rZW4sIHJlZlRva2Vucykge1xuICAgICAgICB0aGlzLnByb3ZpZGVyVG9rZW5zID0gcHJvdmlkZXJUb2tlbnM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50VG9rZW4gPSBjb21wb25lbnRUb2tlbjtcbiAgICAgICAgdGhpcy5yZWZUb2tlbnMgPSByZWZUb2tlbnM7XG4gICAgfVxuICAgIHJldHVybiBTdGF0aWNOb2RlRGVidWdJbmZvO1xufSgpKTtcbmV4cG9ydHMuU3RhdGljTm9kZURlYnVnSW5mbyA9IFN0YXRpY05vZGVEZWJ1Z0luZm87XG52YXIgRGVidWdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJ1Z0NvbnRleHQoX3ZpZXcsIF9ub2RlSW5kZXgsIF90cGxSb3csIF90cGxDb2wpIHtcbiAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSBfbm9kZUluZGV4O1xuICAgICAgICB0aGlzLl90cGxSb3cgPSBfdHBsUm93O1xuICAgICAgICB0aGlzLl90cGxDb2wgPSBfdHBsQ29sO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJfc3RhdGljTm9kZUluZm9cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX25vZGVJbmRleCkgPyB0aGlzLl92aWV3LnN0YXRpY05vZGVEZWJ1Z0luZm9zW3RoaXMuX25vZGVJbmRleF0gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmNvbnRleHQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykgJiYgbGFuZ18xLmlzUHJlc2VudChzdGF0aWNOb2RlSW5mby5jb21wb25lbnRUb2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5nZXQoc3RhdGljTm9kZUluZm8uY29tcG9uZW50VG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRWaWV3ID0gdGhpcy5fdmlldztcbiAgICAgICAgICAgIHdoaWxlIChsYW5nXzEuaXNQcmVzZW50KGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50KSAmJlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcudHlwZSAhPT0gdmlld190eXBlXzEuVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VmlldyA9IGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50LnBhcmVudFZpZXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChjb21wb25lbnRWaWV3LmRlY2xhcmF0aW9uQXBwRWxlbWVudCkgP1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50Lm5hdGl2ZUVsZW1lbnQgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmluamVjdG9yKHRoaXMuX25vZGVJbmRleCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInJlbmRlck5vZGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX25vZGVJbmRleCkgJiYgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl92aWV3LmFsbE5vZGVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmFsbE5vZGVzW3RoaXMuX25vZGVJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pID8gc3RhdGljTm9kZUluZm8ucHJvdmlkZXJUb2tlbnMgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmNvbXBvbmVudFR5cGUudGVtcGxhdGVVcmwgKyBcIjpcIiArIHRoaXMuX3RwbFJvdyArIFwiOlwiICsgdGhpcy5fdHBsQ29sO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHZhclZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmcyA9IHN0YXRpY05vZGVJbmZvLnJlZlRva2VucztcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHJlZnMsIGZ1bmN0aW9uIChyZWZUb2tlbiwgcmVmTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZWZUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhclZhbHVlID0gbGFuZ18xLmlzUHJlc2VudChfdGhpcy5fdmlldy5hbGxOb2RlcykgPyBfdGhpcy5fdmlldy5hbGxOb2Rlc1tfdGhpcy5fbm9kZUluZGV4XSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZSA9IF90aGlzLl92aWV3LmluamVjdG9yR2V0KHJlZlRva2VuLCBfdGhpcy5fbm9kZUluZGV4LCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZXNbcmVmTmFtZV0gPSB2YXJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YXJWYWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBEZWJ1Z0NvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5EZWJ1Z0NvbnRleHQgPSBEZWJ1Z0NvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Z19jb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29tcG9uZW50X3Jlc29sdmVyXzEgPSByZXF1aXJlKCcuL2NvbXBvbmVudF9yZXNvbHZlcicpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIHJlZmxlY3RpdmVfaW5qZWN0b3JfMSA9IHJlcXVpcmUoJy4uL2RpL3JlZmxlY3RpdmVfaW5qZWN0b3InKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKCcuLi9kaS9kZWNvcmF0b3JzJyk7XG4vKipcbiAqIFVzZSBDb21wb25lbnRSZXNvbHZlciBhbmQgVmlld0NvbnRhaW5lclJlZiBkaXJlY3RseS5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgRHluYW1pY0NvbXBvbmVudExvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHluYW1pY0NvbXBvbmVudExvYWRlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIER5bmFtaWNDb21wb25lbnRMb2FkZXI7XG59KCkpO1xuZXhwb3J0cy5EeW5hbWljQ29tcG9uZW50TG9hZGVyID0gRHluYW1pY0NvbXBvbmVudExvYWRlcjtcbnZhciBEeW5hbWljQ29tcG9uZW50TG9hZGVyXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKER5bmFtaWNDb21wb25lbnRMb2FkZXJfLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIER5bmFtaWNDb21wb25lbnRMb2FkZXJfKF9jb21waWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZXIgPSBfY29tcGlsZXI7XG4gICAgfVxuICAgIER5bmFtaWNDb21wb25lbnRMb2FkZXJfLnByb3RvdHlwZS5sb2FkQXNSb290ID0gZnVuY3Rpb24gKHR5cGUsIG92ZXJyaWRlU2VsZWN0b3JPck5vZGUsIGluamVjdG9yLCBvbkRpc3Bvc2UsIHByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVyLnJlc29sdmVDb21wb25lbnQodHlwZSkudGhlbihmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzLCBsYW5nXzEuaXNQcmVzZW50KG92ZXJyaWRlU2VsZWN0b3JPck5vZGUpID8gb3ZlcnJpZGVTZWxlY3Rvck9yTm9kZSA6IGNvbXBvbmVudEZhY3Rvcnkuc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQob25EaXNwb3NlKSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFJlZi5vbkRlc3Ryb3kob25EaXNwb3NlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRHluYW1pY0NvbXBvbmVudExvYWRlcl8ucHJvdG90eXBlLmxvYWROZXh0VG9Mb2NhdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBsb2NhdGlvbiwgcHJvdmlkZXJzLCBwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgIGlmIChwcm92aWRlcnMgPT09IHZvaWQgMCkgeyBwcm92aWRlcnMgPSBudWxsOyB9XG4gICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVyLnJlc29sdmVDb21wb25lbnQodHlwZSkudGhlbihmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHRJbmplY3RvciA9IGxvY2F0aW9uLnBhcmVudEluamVjdG9yO1xuICAgICAgICAgICAgdmFyIGNoaWxkSW5qZWN0b3IgPSBsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVycykgJiYgcHJvdmlkZXJzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgIHJlZmxlY3RpdmVfaW5qZWN0b3JfMS5SZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHByb3ZpZGVycywgY29udGV4dEluamVjdG9yKSA6XG4gICAgICAgICAgICAgICAgY29udGV4dEluamVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5LCBsb2NhdGlvbi5sZW5ndGgsIGNoaWxkSW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIER5bmFtaWNDb21wb25lbnRMb2FkZXJfLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogZGVjb3JhdG9yc18xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIER5bmFtaWNDb21wb25lbnRMb2FkZXJfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGNvbXBvbmVudF9yZXNvbHZlcl8xLkNvbXBvbmVudFJlc29sdmVyLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIER5bmFtaWNDb21wb25lbnRMb2FkZXJfO1xufShEeW5hbWljQ29tcG9uZW50TG9hZGVyKSk7XG5leHBvcnRzLkR5bmFtaWNDb21wb25lbnRMb2FkZXJfID0gRHluYW1pY0NvbXBvbmVudExvYWRlcl87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1keW5hbWljX2NvbXBvbmVudF9sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgdmlld190eXBlXzEgPSByZXF1aXJlKCcuL3ZpZXdfdHlwZScpO1xudmFyIGVsZW1lbnRfcmVmXzEgPSByZXF1aXJlKCcuL2VsZW1lbnRfcmVmJyk7XG52YXIgdmlld19jb250YWluZXJfcmVmXzEgPSByZXF1aXJlKCcuL3ZpZXdfY29udGFpbmVyX3JlZicpO1xuLyoqXG4gKiBBbiBBcHBFbGVtZW50IGlzIGNyZWF0ZWQgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIFZpZXdDb250YWluZXJSZWYsXG4gKiBhIG5lc3RlZCBjb21wb25lbnQgb3IgYSA8dGVtcGxhdGU+IGVsZW1lbnQgdG8ga2VlcCBkYXRhIGFyb3VuZFxuICogdGhhdCBpcyBuZWVkZWQgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25zLlxuICovXG52YXIgQXBwRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXBwRWxlbWVudChpbmRleCwgcGFyZW50SW5kZXgsIHBhcmVudFZpZXcsIG5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnBhcmVudEluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgIHRoaXMucGFyZW50VmlldyA9IHBhcmVudFZpZXc7XG4gICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmVzdGVkVmlld3MgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFZpZXcgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwRWxlbWVudC5wcm90b3R5cGUsIFwiZWxlbWVudFJlZlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IGVsZW1lbnRfcmVmXzEuRWxlbWVudFJlZih0aGlzLm5hdGl2ZUVsZW1lbnQpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwRWxlbWVudC5wcm90b3R5cGUsIFwidmNSZWZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyB2aWV3X2NvbnRhaW5lcl9yZWZfMS5WaWV3Q29udGFpbmVyUmVmXyh0aGlzKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQXBwRWxlbWVudC5wcm90b3R5cGUuaW5pdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGNvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXMsIHZpZXcpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcmllcyA9IGNvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IHZpZXc7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwRWxlbWVudC5wcm90b3R5cGUsIFwicGFyZW50SW5qZWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyZW50Vmlldy5pbmplY3Rvcih0aGlzLnBhcmVudEluZGV4KTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEVsZW1lbnQucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcmVudFZpZXcuaW5qZWN0b3IodGhpcy5pbmRleCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFwcEVsZW1lbnQucHJvdG90eXBlLm1hcE5lc3RlZFZpZXdzID0gZnVuY3Rpb24gKG5lc3RlZFZpZXdDbGFzcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLm5lc3RlZFZpZXdzKSkge1xuICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uIChuZXN0ZWRWaWV3KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXcuY2xhenogPT09IG5lc3RlZFZpZXdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjayhuZXN0ZWRWaWV3KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEFwcEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFZpZXcgPSBmdW5jdGlvbiAodmlldywgdmlld0luZGV4KSB7XG4gICAgICAgIGlmICh2aWV3LnR5cGUgPT09IHZpZXdfdHlwZV8xLlZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVzdGVkVmlld3MgPSB0aGlzLm5lc3RlZFZpZXdzO1xuICAgICAgICBpZiAobmVzdGVkVmlld3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmVzdGVkVmlld3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MgPSBuZXN0ZWRWaWV3cztcbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuaW5zZXJ0KG5lc3RlZFZpZXdzLCB2aWV3SW5kZXgsIHZpZXcpO1xuICAgICAgICB2YXIgcmVmUmVuZGVyTm9kZTtcbiAgICAgICAgaWYgKHZpZXdJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmV2VmlldyA9IG5lc3RlZFZpZXdzW3ZpZXdJbmRleCAtIDFdO1xuICAgICAgICAgICAgcmVmUmVuZGVyTm9kZSA9IHByZXZWaWV3Lmxhc3RSb290Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZlJlbmRlck5vZGUgPSB0aGlzLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmVmUmVuZGVyTm9kZSkpIHtcbiAgICAgICAgICAgIHZpZXcucmVuZGVyZXIuYXR0YWNoVmlld0FmdGVyKHJlZlJlbmRlck5vZGUsIHZpZXcuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5hZGRUb0NvbnRlbnRDaGlsZHJlbih0aGlzKTtcbiAgICB9O1xuICAgIEFwcEVsZW1lbnQucHJvdG90eXBlLmRldGFjaFZpZXcgPSBmdW5jdGlvbiAodmlld0luZGV4KSB7XG4gICAgICAgIHZhciB2aWV3ID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJlbW92ZUF0KHRoaXMubmVzdGVkVmlld3MsIHZpZXdJbmRleCk7XG4gICAgICAgIGlmICh2aWV3LnR5cGUgPT09IHZpZXdfdHlwZV8xLlZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJlbmRlcmVyLmRldGFjaFZpZXcodmlldy5mbGF0Um9vdE5vZGVzKTtcbiAgICAgICAgdmlldy5yZW1vdmVGcm9tQ29udGVudENoaWxkcmVuKHRoaXMpO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9O1xuICAgIHJldHVybiBBcHBFbGVtZW50O1xufSgpKTtcbmV4cG9ydHMuQXBwRWxlbWVudCA9IEFwcEVsZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaW5qZWN0b3JfMSA9IHJlcXVpcmUoJy4uL2RpL2luamVjdG9yJyk7XG52YXIgX1VOREVGSU5FRCA9IG5ldyBPYmplY3QoKTtcbnZhciBFbGVtZW50SW5qZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50SW5qZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudEluamVjdG9yKF92aWV3LCBfbm9kZUluZGV4KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgIHRoaXMuX25vZGVJbmRleCA9IF9ub2RlSW5kZXg7XG4gICAgfVxuICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IGluamVjdG9yXzEuVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBfVU5ERUZJTkVEO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl92aWV3LmluamVjdG9yR2V0KHRva2VuLCB0aGlzLl9ub2RlSW5kZXgsIF9VTkRFRklORUQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgPT09IF9VTkRFRklORUQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3ZpZXcucGFyZW50SW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRJbmplY3Rvcjtcbn0oaW5qZWN0b3JfMS5JbmplY3RvcikpO1xuZXhwb3J0cy5FbGVtZW50SW5qZWN0b3IgPSBFbGVtZW50SW5qZWN0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50X2luamVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4qIEEgd3JhcHBlciBhcm91bmQgYSBuYXRpdmUgZWxlbWVudCBpbnNpZGUgb2YgYSBWaWV3LlxuKlxuKiBBbiBgRWxlbWVudFJlZmAgaXMgYmFja2VkIGJ5IGEgcmVuZGVyLXNwZWNpZmljIGVsZW1lbnQuIEluIHRoZSBicm93c2VyLCB0aGlzIGlzIHVzdWFsbHkgYSBET01cbiogZWxlbWVudC5cbiovXG4vLyBOb3RlOiBXZSBkb24ndCBleHBvc2UgdGhpbmdzIGxpa2UgYEluamVjdG9yYCwgYFZpZXdDb250YWluZXJgLCAuLi4gaGVyZSxcbi8vIGkuZS4gdXNlcnMgaGF2ZSB0byBhc2sgZm9yIHdoYXQgdGhleSBuZWVkLiBXaXRoIHRoYXQsIHdlIGNhbiBidWlsZCBiZXR0ZXIgYW5hbHlzaXMgdG9vbHNcbi8vIGFuZCBjb3VsZCBkbyBiZXR0ZXIgY29kZWdlbiBpbiB0aGUgZnV0dXJlLlxudmFyIEVsZW1lbnRSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRSZWYobmF0aXZlRWxlbWVudCkge1xuICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBuYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gRWxlbWVudFJlZjtcbn0oKSk7XG5leHBvcnRzLkVsZW1lbnRSZWYgPSBFbGVtZW50UmVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudF9yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIGlmIGFwcGxpY2F0aW9uIGNoYW5nZXMgbW9kZWwgYnJlYWtpbmcgdGhlIHRvcC1kb3duIGRhdGEgZmxvdy5cbiAqXG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyBvbmx5IHRocm93biBpbiBkZXYgbW9kZS5cbiAqXG4gKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgb25jZSB0aGUgZGV2IG1vZGUgb3B0aW9uIGlzIGNvbmZpZ3VyYWJsZSAtLT5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ3BhcmVudCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGNoaWxkIFtwcm9wXT1cInBhcmVudFByb3BcIj48L2NoaWxkPlxuICogICBgLFxuICogICBkaXJlY3RpdmVzOiBbZm9yd2FyZFJlZigoKSA9PiBDaGlsZCldXG4gKiB9KVxuICogY2xhc3MgUGFyZW50IHtcbiAqICAgcGFyZW50UHJvcCA9IFwiaW5pdFwiO1xuICogfVxuICpcbiAqIEBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnY2hpbGQnLCBpbnB1dHM6IFsncHJvcCddfSlcbiAqIGNsYXNzIENoaWxkIHtcbiAqICAgY29uc3RydWN0b3IocHVibGljIHBhcmVudDogUGFyZW50KSB7fVxuICpcbiAqICAgc2V0IHByb3Aodikge1xuICogICAgIC8vIHRoaXMgdXBkYXRlcyB0aGUgcGFyZW50IHByb3BlcnR5LCB3aGljaCBpcyBkaXNhbGxvd2VkIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uXG4gKiAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvblxuICogICAgIHRoaXMucGFyZW50LnBhcmVudFByb3AgPSBcInVwZGF0ZWRcIjtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbnZhciBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXhjZXB0aW9uKG9sZFZhbHVlLCBjdXJyVmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJFeHByZXNzaW9uIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkLiBcIiArXG4gICAgICAgICAgICAoXCJQcmV2aW91cyB2YWx1ZTogJ1wiICsgb2xkVmFsdWUgKyBcIicuIEN1cnJlbnQgdmFsdWU6ICdcIiArIGN1cnJWYWx1ZSArIFwiJ1wiKSk7XG4gICAgfVxuICAgIHJldHVybiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbjtcbn0oZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pKTtcbmV4cG9ydHMuRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb24gPSBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbjtcbi8qKlxuICogVGhyb3duIHdoZW4gYW4gZXhjZXB0aW9uIHdhcyByYWlzZWQgZHVyaW5nIHZpZXcgY3JlYXRpb24sIGNoYW5nZSBkZXRlY3Rpb24gb3IgZGVzdHJ1Y3Rpb24uXG4gKlxuICogVGhpcyBlcnJvciB3cmFwcyB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIHRvIGF0dGFjaCBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdGhhdCBjYW5cbiAqIGJlIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICovXG52YXIgVmlld1dyYXBwZWRFeGNlcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3V3JhcHBlZEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3V3JhcHBlZEV4Y2VwdGlvbihvcmlnaW5hbEV4Y2VwdGlvbiwgb3JpZ2luYWxTdGFjaywgY29udGV4dCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkVycm9yIGluIFwiICsgY29udGV4dC5zb3VyY2UsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIFZpZXdXcmFwcGVkRXhjZXB0aW9uO1xufShleGNlcHRpb25zXzEuV3JhcHBlZEV4Y2VwdGlvbikpO1xuZXhwb3J0cy5WaWV3V3JhcHBlZEV4Y2VwdGlvbiA9IFZpZXdXcmFwcGVkRXhjZXB0aW9uO1xuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGRlc3Ryb3llZCB2aWV3IGlzIHVzZWQuXG4gKlxuICogVGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGZyYW1ld29yay5cbiAqXG4gKiBUaGlzIGlzIGFuIGludGVybmFsIEFuZ3VsYXIgZXJyb3IuXG4gKi9cbnZhciBWaWV3RGVzdHJveWVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlld0Rlc3Ryb3llZEV4Y2VwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3RGVzdHJveWVkRXhjZXB0aW9uKGRldGFpbHMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJBdHRlbXB0IHRvIHVzZSBhIGRlc3Ryb3llZCB2aWV3OiBcIiArIGRldGFpbHMpO1xuICAgIH1cbiAgICByZXR1cm4gVmlld0Rlc3Ryb3llZEV4Y2VwdGlvbjtcbn0oZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24pKTtcbmV4cG9ydHMuVmlld0Rlc3Ryb3llZEV4Y2VwdGlvbiA9IFZpZXdEZXN0cm95ZWRFeGNlcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNlcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG4vKipcbiAqIEFuIHVubW9kaWZpYWJsZSBsaXN0IG9mIGl0ZW1zIHRoYXQgQW5ndWxhciBrZWVwcyB1cCB0byBkYXRlIHdoZW4gdGhlIHN0YXRlXG4gKiBvZiB0aGUgYXBwbGljYXRpb24gY2hhbmdlcy5cbiAqXG4gKiBUaGUgdHlwZSBvZiBvYmplY3QgdGhhdCB7QGxpbmsgUXVlcnlNZXRhZGF0YX0gYW5kIHtAbGluayBWaWV3UXVlcnlNZXRhZGF0YX0gcHJvdmlkZS5cbiAqXG4gKiBJbXBsZW1lbnRzIGFuIGl0ZXJhYmxlIGludGVyZmFjZSwgdGhlcmVmb3JlIGl0IGNhbiBiZSB1c2VkIGluIGJvdGggRVM2XG4gKiBqYXZhc2NyaXB0IGBmb3IgKHZhciBpIG9mIGl0ZW1zKWAgbG9vcHMgYXMgd2VsbCBhcyBpbiBBbmd1bGFyIHRlbXBsYXRlcyB3aXRoXG4gKiBgKm5nRm9yPVwibGV0IGkgb2YgbXlMaXN0XCJgLlxuICpcbiAqIENoYW5nZXMgY2FuIGJlIG9ic2VydmVkIGJ5IHN1YnNjcmliaW5nIHRvIHRoZSBjaGFuZ2VzIGBPYnNlcnZhYmxlYC5cbiAqXG4gKiBOT1RFOiBJbiB0aGUgZnV0dXJlIHRoaXMgY2xhc3Mgd2lsbCBpbXBsZW1lbnQgYW4gYE9ic2VydmFibGVgIGludGVyZmFjZS5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvUlg4c0puUVlsOUZXdVNDV21lNXo/cD1wcmV2aWV3KSlcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBDb21wb25lbnQoey4uLn0pXG4gKiBjbGFzcyBDb250YWluZXIge1xuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoSXRlbSkgaXRlbXM6IFF1ZXJ5TGlzdDxJdGVtPikge1xuICogICAgIGl0ZW1zLmNoYW5nZXMuc3Vic2NyaWJlKF8gPT4gY29uc29sZS5sb2coaXRlbXMubGVuZ3RoKSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG52YXIgUXVlcnlMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeUxpc3QoKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xuICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IGFzeW5jXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImNoYW5nZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VtaXR0ZXI7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5sZW5ndGg7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlyc3QodGhpcy5fcmVzdWx0cyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImxhc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5sYXN0KHRoaXMuX3Jlc3VsdHMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIHBhc3NlZCBpbiBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggZWxlbWVudC5cbiAgICAgKi9cbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5tYXAoZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5maWx0ZXIoZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSByZWR1Y2VkIHZhbHVlLlxuICAgICAqL1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0KSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLnJlZHVjZShmbiwgaW5pdCk7IH07XG4gICAgLyoqXG4gICAgICogZXhlY3V0ZXMgZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBpbiBhIHF1ZXJ5LlxuICAgICAqL1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9yZXN1bHRzLmZvckVhY2goZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIFF1ZXJ5TGlzdCBpbnRvIGFuIGFycmF5XG4gICAgICovXG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsb25lKHRoaXMuX3Jlc3VsdHMpOyB9O1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGVbbGFuZ18xLmdldFN5bWJvbEl0ZXJhdG9yKCldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0c1tsYW5nXzEuZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTsgfTtcbiAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy50b1N0cmluZygpOyB9O1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdHMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmxhdHRlbihyZXMpO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9lbWl0dGVyLmVtaXQodGhpcyk7IH07XG4gICAgLyoqIGludGVybmFsICovXG4gICAgUXVlcnlMaXN0LnByb3RvdHlwZS5zZXREaXJ0eSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGlydHkgPSB0cnVlOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcbiAgICAgICAgLyoqIGludGVybmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlydHk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBRdWVyeUxpc3Q7XG59KCkpO1xuZXhwb3J0cy5RdWVyeUxpc3QgPSBRdWVyeUxpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeV9saXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vZmFjYWRlL2xhbmcnKTtcbnZhciBFTVBUWV9DT05URVhUID0gbmV3IE9iamVjdCgpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEVtYmVkZGVkIFRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MuXG4gKlxuICogWW91IGNhbiBhY2Nlc3MgYSBgVGVtcGxhdGVSZWZgLCBpbiB0d28gd2F5cy4gVmlhIGEgZGlyZWN0aXZlIHBsYWNlZCBvbiBhIGA8dGVtcGxhdGU+YCBlbGVtZW50IChvclxuICogZGlyZWN0aXZlIHByZWZpeGVkIHdpdGggYCpgKSBhbmQgaGF2ZSB0aGUgYFRlbXBsYXRlUmVmYCBmb3IgdGhpcyBFbWJlZGRlZCBWaWV3IGluamVjdGVkIGludG8gdGhlXG4gKiBjb25zdHJ1Y3RvciBvZiB0aGUgZGlyZWN0aXZlIHVzaW5nIHRoZSBgVGVtcGxhdGVSZWZgIFRva2VuLiBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gcXVlcnkgZm9yIHRoZVxuICogYFRlbXBsYXRlUmVmYCBmcm9tIGEgQ29tcG9uZW50IG9yIGEgRGlyZWN0aXZlIHZpYSB7QGxpbmsgUXVlcnl9LlxuICpcbiAqIFRvIGluc3RhbnRpYXRlIEVtYmVkZGVkIFZpZXdzIGJhc2VkIG9uIGEgVGVtcGxhdGUsIHVzZVxuICoge0BsaW5rIFZpZXdDb250YWluZXJSZWYjY3JlYXRlRW1iZWRkZWRWaWV3fSwgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIFZpZXcgYW5kIGF0dGFjaCBpdCB0byB0aGVcbiAqIFZpZXcgQ29udGFpbmVyLlxuICovXG52YXIgVGVtcGxhdGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUmVmKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVSZWYucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvY2F0aW9uIGluIHRoZSBWaWV3IHdoZXJlIHRoZSBFbWJlZGRlZCBWaWV3IGxvZ2ljYWxseSBiZWxvbmdzIHRvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZGF0YS1iaW5kaW5nIGFuZCBpbmplY3Rpb24gY29udGV4dHMgb2YgRW1iZWRkZWQgVmlld3MgY3JlYXRlZCBmcm9tIHRoaXMgYFRlbXBsYXRlUmVmYFxuICAgICAgICAgKiBpbmhlcml0IGZyb20gdGhlIGNvbnRleHRzIG9mIHRoaXMgbG9jYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFR5cGljYWxseSBuZXcgRW1iZWRkZWQgVmlld3MgYXJlIGF0dGFjaGVkIHRvIHRoZSBWaWV3IENvbnRhaW5lciBvZiB0aGlzIGxvY2F0aW9uLCBidXQgaW5cbiAgICAgICAgICogYWR2YW5jZWQgdXNlLWNhc2VzLCB0aGUgVmlldyBjYW4gYmUgYXR0YWNoZWQgdG8gYSBkaWZmZXJlbnQgY29udGFpbmVyIHdoaWxlIGtlZXBpbmcgdGhlXG4gICAgICAgICAqIGRhdGEtYmluZGluZyBhbmQgaW5qZWN0aW9uIGNvbnRleHQgZnJvbSB0aGUgb3JpZ2luYWwgbG9jYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPKGkpOiByZW5hbWUgdG8gYW5jaG9yIG9yIGxvY2F0aW9uXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRlbXBsYXRlUmVmO1xufSgpKTtcbmV4cG9ydHMuVGVtcGxhdGVSZWYgPSBUZW1wbGF0ZVJlZjtcbnZhciBUZW1wbGF0ZVJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZW1wbGF0ZVJlZl8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVSZWZfKF9hcHBFbGVtZW50LCBfdmlld0ZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FwcEVsZW1lbnQgPSBfYXBwRWxlbWVudDtcbiAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSBfdmlld0ZhY3Rvcnk7XG4gICAgfVxuICAgIFRlbXBsYXRlUmVmXy5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl92aWV3RmFjdG9yeSh0aGlzLl9hcHBFbGVtZW50LnBhcmVudFZpZXcudmlld1V0aWxzLCB0aGlzLl9hcHBFbGVtZW50LnBhcmVudEluamVjdG9yLCB0aGlzLl9hcHBFbGVtZW50KTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGNvbnRleHQpKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gRU1QVFlfQ09OVEVYVDtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmNyZWF0ZShjb250ZXh0LCBudWxsLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHZpZXcucmVmO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbXBsYXRlUmVmXy5wcm90b3R5cGUsIFwiZWxlbWVudFJlZlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYXBwRWxlbWVudC5lbGVtZW50UmVmOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGVtcGxhdGVSZWZfO1xufShUZW1wbGF0ZVJlZikpO1xuZXhwb3J0cy5UZW1wbGF0ZVJlZl8gPSBUZW1wbGF0ZVJlZl87XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZV9yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBlbGVtZW50XzEgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9hc3luYycpO1xudmFyIHZpZXdfcmVmXzEgPSByZXF1aXJlKCcuL3ZpZXdfcmVmJyk7XG52YXIgdmlld190eXBlXzEgPSByZXF1aXJlKCcuL3ZpZXdfdHlwZScpO1xudmFyIHZpZXdfdXRpbHNfMSA9IHJlcXVpcmUoJy4vdmlld191dGlscycpO1xudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xudmFyIHByb2ZpbGVfMSA9IHJlcXVpcmUoJy4uL3Byb2ZpbGUvcHJvZmlsZScpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4vZXhjZXB0aW9ucycpO1xudmFyIGRlYnVnX2NvbnRleHRfMSA9IHJlcXVpcmUoJy4vZGVidWdfY29udGV4dCcpO1xudmFyIGVsZW1lbnRfaW5qZWN0b3JfMSA9IHJlcXVpcmUoJy4vZWxlbWVudF9pbmplY3RvcicpO1xudmFyIF9zY29wZV9jaGVjayA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZShcIkFwcFZpZXcjY2hlY2soYXNjaWkgaWQpXCIpO1xuLyoqXG4gKiBDb3N0IG9mIG1ha2luZyBvYmplY3RzOiBodHRwOi8vanNwZXJmLmNvbS9pbnN0YW50aWF0ZS1zaXplLW9mLW9iamVjdFxuICpcbiAqL1xudmFyIEFwcFZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwcFZpZXcoY2xhenosIGNvbXBvbmVudFR5cGUsIHR5cGUsIHZpZXdVdGlscywgcGFyZW50SW5qZWN0b3IsIGRlY2xhcmF0aW9uQXBwRWxlbWVudCwgY2RNb2RlKSB7XG4gICAgICAgIHRoaXMuY2xhenogPSBjbGF6ejtcbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52aWV3VXRpbHMgPSB2aWV3VXRpbHM7XG4gICAgICAgIHRoaXMucGFyZW50SW5qZWN0b3IgPSBwYXJlbnRJbmplY3RvcjtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQgPSBkZWNsYXJhdGlvbkFwcEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY2RNb2RlID0gY2RNb2RlO1xuICAgICAgICB0aGlzLmNvbnRlbnRDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIG5hbWVzIG9mIHRoZSBiZWxvdyBmaWVsZHMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBjb2RlZ2VuX25hbWVfdXRpbC50cyBvclxuICAgICAgICAvLyBjaGFuZ2UgZGV0ZWN0aW9uIHdpbGwgZmFpbC5cbiAgICAgICAgdGhpcy5jZFN0YXRlID0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdG9yU3RhdGUuTmV2ZXJDaGVja2VkO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZiA9IG5ldyB2aWV3X3JlZl8xLlZpZXdSZWZfKHRoaXMpO1xuICAgICAgICBpZiAodHlwZSA9PT0gdmlld190eXBlXzEuVmlld1R5cGUuQ09NUE9ORU5UIHx8IHR5cGUgPT09IHZpZXdfdHlwZV8xLlZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSB2aWV3VXRpbHMucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IGRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3LnJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFwcFZpZXcucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBnaXZlblByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB2YXIgcHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugdmlld190eXBlXzEuVmlld1R5cGUuQ09NUE9ORU5UOlxuICAgICAgICAgICAgICAgIHByb2plY3RhYmxlTm9kZXMgPSB2aWV3X3V0aWxzXzEuZW5zdXJlU2xvdENvdW50KGdpdmVuUHJvamVjdGFibGVOb2RlcywgdGhpcy5jb21wb25lbnRUeXBlLnNsb3RDb3VudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHZpZXdfdHlwZV8xLlZpZXdUeXBlLkVNQkVEREVEOlxuICAgICAgICAgICAgICAgIHByb2plY3RhYmxlTm9kZXMgPSB0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3LnByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHZpZXdfdHlwZV8xLlZpZXdUeXBlLkhPU1Q6XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogRG9uJ3QgZW5zdXJlIHRoZSBzbG90IGNvdW50IGZvciB0aGUgcHJvamVjdGFibGVOb2RlcyBhcyB3ZSBzdG9yZVxuICAgICAgICAgICAgICAgIC8vIHRoZW0gb25seSBmb3IgdGhlIGNvbnRhaW5lZCBjb21wb25lbnQgdmlldyAod2hpY2ggd2lsbCBsYXRlciBjaGVjayB0aGUgc2xvdCBjb3VudC4uLilcbiAgICAgICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hhc0V4dGVybmFsSG9zdEVsZW1lbnQgPSBsYW5nXzEuaXNQcmVzZW50KHJvb3RTZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgIHRoaXMucHJvamVjdGFibGVOb2RlcyA9IHByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVybmFsKHJvb3RTZWxlY3Rvck9yTm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICogUmV0dXJucyB0aGUgQXBwRWxlbWVudCBmb3IgdGhlIGhvc3QgZWxlbWVudCBmb3IgVmlld1R5cGUuSE9TVC5cbiAgICAgKi9cbiAgICBBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGVJbnRlcm5hbCA9IGZ1bmN0aW9uIChyb290U2VsZWN0b3JPck5vZGUpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChyb290Tm9kZXNPckFwcEVsZW1lbnRzLCBhbGxOb2RlcywgZGlzcG9zYWJsZXMsIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzID0gcm9vdE5vZGVzT3JBcHBFbGVtZW50cztcbiAgICAgICAgdGhpcy5hbGxOb2RlcyA9IGFsbE5vZGVzO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gZGlzcG9zYWJsZXM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHZpZXdfdHlwZV8xLlZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlIHJlbmRlciBub2RlcyBoYXZlIGJlZW4gYXR0YWNoZWQgdG8gdGhlaXIgaG9zdCBlbGVtZW50XG4gICAgICAgICAgICAvLyBpbiB0aGUgVmlld0ZhY3RvcnkgYWxyZWFkeS5cbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25BcHBFbGVtZW50LnBhcmVudFZpZXcudmlld0NoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLnNlbGVjdE9yQ3JlYXRlSG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHJvb3RTZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKSB7XG4gICAgICAgIHZhciBob3N0RWxlbWVudDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocm9vdFNlbGVjdG9yT3JOb2RlKSkge1xuICAgICAgICAgICAgaG9zdEVsZW1lbnQgPSB0aGlzLnJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KHJvb3RTZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RFbGVtZW50ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KG51bGwsIGVsZW1lbnROYW1lLCBkZWJ1Z0luZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3N0RWxlbWVudDtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yR2V0SW50ZXJuYWwodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICovXG4gICAgQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3JHZXRJbnRlcm5hbCA9IGZ1bmN0aW9uICh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbm90Rm91bmRSZXN1bHQ7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvciA9IGZ1bmN0aW9uIChub2RlSW5kZXgpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobm9kZUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBlbGVtZW50X2luamVjdG9yXzEuRWxlbWVudEluamVjdG9yKHRoaXMsIG5vZGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRJbmplY3RvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0V4dGVybmFsSG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGV0YWNoVmlldyh0aGlzLmZsYXRSb290Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lckVsZW1lbnQuZGV0YWNoVmlldyh0aGlzLnZpZXdDb250YWluZXJFbGVtZW50Lm5lc3RlZFZpZXdzLmluZGV4T2YodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lSZWN1cnNlKCk7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5fZGVzdHJveVJlY3Vyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY29udGVudENoaWxkcmVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltpXS5fZGVzdHJveVJlY3Vyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IHRoaXMudmlld0NoaWxkcmVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltpXS5fZGVzdHJveVJlY3Vyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3lMb2NhbCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95TG9jYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBob3N0RWxlbWVudCA9IHRoaXMudHlwZSA9PT0gdmlld190eXBlXzEuVmlld1R5cGUuQ09NUE9ORU5UID8gdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQubmF0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXNwb3NhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlc1tpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhc3luY18xLk9ic2VydmFibGVXcmFwcGVyLmRpc3Bvc2UodGhpcy5zdWJzY3JpcHRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbCgpO1xuICAgICAgICBpZiAodGhpcy5faGFzRXh0ZXJuYWxIb3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kZXRhY2hWaWV3KHRoaXMuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLnZpZXdDb250YWluZXJFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudC5kZXRhY2hWaWV3KHRoaXMudmlld0NvbnRhaW5lckVsZW1lbnQubmVzdGVkVmlld3MuaW5kZXhPZih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgdGhpcy5hbGxOb2Rlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgKi9cbiAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95SW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcImNoYW5nZURldGVjdG9yUmVmXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlZjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQpID8gdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQucGFyZW50VmlldyA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJmbGF0Um9vdE5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2aWV3X3V0aWxzXzEuZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlcyh0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHMpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwVmlldy5wcm90b3R5cGUsIFwibGFzdFJvb3ROb2RlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSB0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzW3RoaXMucm9vdE5vZGVzT3JBcHBFbGVtZW50cy5sZW5ndGggLSAxXSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBfZmluZExhc3RSZW5kZXJOb2RlKGxhc3ROb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICovXG4gICAgQXBwVmlldy5wcm90b3R5cGUuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgIHZhciBzID0gX3Njb3BlX2NoZWNrKHRoaXMuY2xhenopO1xuICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZXRhY2hlZCB8fFxuICAgICAgICAgICAgdGhpcy5jZE1vZGUgPT09IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja2VkIHx8XG4gICAgICAgICAgICB0aGlzLmNkU3RhdGUgPT09IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvclN0YXRlLkVycm9yZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Rlc3Ryb3llZEVycm9yKCdkZXRlY3RDaGFuZ2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzSW50ZXJuYWwodGhyb3dPbkNoYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLmNkTW9kZSA9PT0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrT25jZSlcbiAgICAgICAgICAgIHRoaXMuY2RNb2RlID0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrZWQ7XG4gICAgICAgIHRoaXMuY2RTdGF0ZSA9IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3RvclN0YXRlLkNoZWNrZWRCZWZvcmU7XG4gICAgICAgIHByb2ZpbGVfMS53dGZMZWF2ZShzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAqL1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXNJbnRlcm5hbCA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuZGV0ZWN0Q29udGVudENoaWxkcmVuQ2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5kZXRlY3RWaWV3Q2hpbGRyZW5DaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q29udGVudENoaWxkcmVuQ2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Q2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudENoaWxkcmVuW2ldLmRldGVjdENoYW5nZXModGhyb3dPbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdFZpZXdDaGlsZHJlbkNoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmlld0NoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDaGlsZHJlbltpXS5kZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS5hZGRUb0NvbnRlbnRDaGlsZHJlbiA9IGZ1bmN0aW9uIChyZW5kZXJBcHBFbGVtZW50KSB7XG4gICAgICAgIHJlbmRlckFwcEVsZW1lbnQucGFyZW50Vmlldy5jb250ZW50Q2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCA9IHJlbmRlckFwcEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTtcbiAgICB9O1xuICAgIEFwcFZpZXcucHJvdG90eXBlLnJlbW92ZUZyb21Db250ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAocmVuZGVyQXBwRWxlbWVudCkge1xuICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHJlbmRlckFwcEVsZW1lbnQucGFyZW50Vmlldy5jb250ZW50Q2hpbGRyZW4sIHRoaXMpO1xuICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUubWFya0FzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmNkTW9kZSA9IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja09uY2U7IH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzO1xuICAgICAgICB3aGlsZSAobGFuZ18xLmlzUHJlc2VudChjKSAmJiBjLmNkTW9kZSAhPT0gY2hhbmdlX2RldGVjdGlvbl8xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRldGFjaGVkKSB7XG4gICAgICAgICAgICBpZiAoYy5jZE1vZGUgPT09IGNoYW5nZV9kZXRlY3Rpb25fMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5DaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgYy5jZE1vZGUgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuQ2hlY2tPbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gYy50eXBlID09PSB2aWV3X3R5cGVfMS5WaWV3VHlwZS5DT01QT05FTlQgPyBjLmRlY2xhcmF0aW9uQXBwRWxlbWVudCA6IGMudmlld0NvbnRhaW5lckVsZW1lbnQ7XG4gICAgICAgICAgICBjID0gbGFuZ18xLmlzUHJlc2VudChwYXJlbnRFbCkgPyBwYXJlbnRFbC5wYXJlbnRWaWV3IDogbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXBwVmlldy5wcm90b3R5cGUuZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYjsgfTtcbiAgICBBcHBWaWV3LnByb3RvdHlwZS50aHJvd0Rlc3Ryb3llZEVycm9yID0gZnVuY3Rpb24gKGRldGFpbHMpIHsgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5WaWV3RGVzdHJveWVkRXhjZXB0aW9uKGRldGFpbHMpOyB9O1xuICAgIHJldHVybiBBcHBWaWV3O1xufSgpKTtcbmV4cG9ydHMuQXBwVmlldyA9IEFwcFZpZXc7XG52YXIgRGVidWdBcHBWaWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVidWdBcHBWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYnVnQXBwVmlldyhjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRJbmplY3RvciwgZGVjbGFyYXRpb25BcHBFbGVtZW50LCBjZE1vZGUsIHN0YXRpY05vZGVEZWJ1Z0luZm9zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNsYXp6LCBjb21wb25lbnRUeXBlLCB0eXBlLCB2aWV3VXRpbHMsIHBhcmVudEluamVjdG9yLCBkZWNsYXJhdGlvbkFwcEVsZW1lbnQsIGNkTW9kZSk7XG4gICAgICAgIHRoaXMuc3RhdGljTm9kZURlYnVnSW5mb3MgPSBzdGF0aWNOb2RlRGVidWdJbmZvcztcbiAgICAgICAgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIGdpdmVuUHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNyZWF0ZS5jYWxsKHRoaXMsIGNvbnRleHQsIGdpdmVuUHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUsIGUuc3RhY2spO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvckdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCkge1xuICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pbmplY3RvckdldC5jYWxsKHRoaXMsIHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUsIGUuc3RhY2spO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95TG9jYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveUxvY2FsLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlLCBlLnN0YWNrKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcy5jYWxsKHRoaXMsIHRocm93T25DaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSwgZS5zdGFjayk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLl9yZXNldERlYnVnID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0ID0gbnVsbDsgfTtcbiAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgcm93TnVtLCBjb2xOdW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnREZWJ1Z0NvbnRleHQgPSBuZXcgZGVidWdfY29udGV4dF8xLkRlYnVnQ29udGV4dCh0aGlzLCBub2RlSW5kZXgsIHJvd051bSwgY29sTnVtKTtcbiAgICB9O1xuICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuX3JldGhyb3dXaXRoQ29udGV4dCA9IGZ1bmN0aW9uIChlLCBzdGFjaykge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgZXhjZXB0aW9uc18xLlZpZXdXcmFwcGVkRXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIGV4Y2VwdGlvbnNfMS5FeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNkU3RhdGUgPSBjaGFuZ2VfZGV0ZWN0aW9uXzEuQ2hhbmdlRGV0ZWN0b3JTdGF0ZS5FcnJvcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY3VycmVudERlYnVnQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLlZpZXdXcmFwcGVkRXhjZXB0aW9uKGUsIHN0YWNrLCB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5ldmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN1cGVySGFuZGxlciA9IF9zdXBlci5wcm90b3R5cGUuZXZlbnRIYW5kbGVyLmNhbGwodGhpcywgY2IpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlLCBlLnN0YWNrKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIERlYnVnQXBwVmlldztcbn0oQXBwVmlldykpO1xuZXhwb3J0cy5EZWJ1Z0FwcFZpZXcgPSBEZWJ1Z0FwcFZpZXc7XG5mdW5jdGlvbiBfZmluZExhc3RSZW5kZXJOb2RlKG5vZGUpIHtcbiAgICB2YXIgbGFzdE5vZGU7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBlbGVtZW50XzEuQXBwRWxlbWVudCkge1xuICAgICAgICB2YXIgYXBwRWwgPSBub2RlO1xuICAgICAgICBsYXN0Tm9kZSA9IGFwcEVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFwcEVsLm5lc3RlZFZpZXdzKSkge1xuICAgICAgICAgICAgLy8gTm90ZTogVmlld3MgbWlnaHQgaGF2ZSBubyByb290IG5vZGVzIGF0IGFsbCFcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcHBFbC5uZXN0ZWRWaWV3cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRWaWV3ID0gYXBwRWwubmVzdGVkVmlld3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gX2ZpbmRMYXN0UmVuZGVyTm9kZShuZXN0ZWRWaWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHNbbmVzdGVkVmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3ROb2RlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBwcm9maWxlXzEgPSByZXF1aXJlKCcuLi9wcm9maWxlL3Byb2ZpbGUnKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aGVyZSBvbmUgb3IgbW9yZSBWaWV3cyBjYW4gYmUgYXR0YWNoZWQuXG4gKlxuICogVGhlIGNvbnRhaW5lciBjYW4gY29udGFpbiB0d28ga2luZHMgb2YgVmlld3MuIEhvc3QgVmlld3MsIGNyZWF0ZWQgYnkgaW5zdGFudGlhdGluZyBhXG4gKiB7QGxpbmsgQ29tcG9uZW50fSB2aWEge0BsaW5rICNjcmVhdGVDb21wb25lbnR9LCBhbmQgRW1iZWRkZWQgVmlld3MsIGNyZWF0ZWQgYnkgaW5zdGFudGlhdGluZyBhblxuICoge0BsaW5rIFRlbXBsYXRlUmVmIEVtYmVkZGVkIFRlbXBsYXRlfSB2aWEge0BsaW5rICNjcmVhdGVFbWJlZGRlZFZpZXd9LlxuICpcbiAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgVmlldyBDb250YWluZXIgd2l0aGluIHRoZSBjb250YWluaW5nIFZpZXcgaXMgc3BlY2lmaWVkIGJ5IHRoZSBBbmNob3JcbiAqIGBlbGVtZW50YC4gRWFjaCBWaWV3IENvbnRhaW5lciBjYW4gaGF2ZSBvbmx5IG9uZSBBbmNob3IgRWxlbWVudCBhbmQgZWFjaCBBbmNob3IgRWxlbWVudCBjYW4gb25seVxuICogaGF2ZSBhIHNpbmdsZSBWaWV3IENvbnRhaW5lci5cbiAqXG4gKiBSb290IGVsZW1lbnRzIG9mIFZpZXdzIGF0dGFjaGVkIHRvIHRoaXMgY29udGFpbmVyIGJlY29tZSBzaWJsaW5ncyBvZiB0aGUgQW5jaG9yIEVsZW1lbnQgaW5cbiAqIHRoZSBSZW5kZXJlZCBWaWV3LlxuICpcbiAqIFRvIGFjY2VzcyBhIGBWaWV3Q29udGFpbmVyUmVmYCBvZiBhbiBFbGVtZW50LCB5b3UgY2FuIGVpdGhlciBwbGFjZSBhIHtAbGluayBEaXJlY3RpdmV9IGluamVjdGVkXG4gKiB3aXRoIGBWaWV3Q29udGFpbmVyUmVmYCBvbiB0aGUgRWxlbWVudCwgb3IgeW91IG9idGFpbiBpdCB2aWEgYSB7QGxpbmsgVmlld0NoaWxkfSBxdWVyeS5cbiAqL1xudmFyIFZpZXdDb250YWluZXJSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWYoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZSwgXCJlbGVtZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuY2hvciBlbGVtZW50IHRoYXQgc3BlY2lmaWVzIHRoZSBsb2NhdGlvbiBvZiB0aGlzIGNvbnRhaW5lciBpbiB0aGUgY29udGFpbmluZyBWaWV3LlxuICAgICAgICAgKiA8IS0tIFRPRE86IHJlbmFtZSB0byBhbmNob3JFbGVtZW50IC0tPlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgVmlld3MgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBleGNlcHRpb25zXzEudW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICA7XG4gICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWY7XG59KCkpO1xuZXhwb3J0cy5WaWV3Q29udGFpbmVyUmVmID0gVmlld0NvbnRhaW5lclJlZjtcbnZhciBWaWV3Q29udGFpbmVyUmVmXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0NvbnRhaW5lclJlZl8oX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2NyZWF0ZUNvbXBvbmVudEluQ29udGFpbmVyU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjY3JlYXRlQ29tcG9uZW50KCknKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9pbnNlcnRTY29wZSA9IHByb2ZpbGVfMS53dGZDcmVhdGVTY29wZSgnVmlld0NvbnRhaW5lclJlZiNpbnNlcnQoKScpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3JlbW92ZVNjb3BlID0gcHJvZmlsZV8xLnd0ZkNyZWF0ZVNjb3BlKCdWaWV3Q29udGFpbmVyUmVmI3JlbW92ZSgpJyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fZGV0YWNoU2NvcGUgPSBwcm9maWxlXzEud3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjZGV0YWNoKCknKTtcbiAgICB9XG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gdGhpcy5fZWxlbWVudC5uZXN0ZWRWaWV3c1tpbmRleF0ucmVmOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodmlld3MpID8gdmlld3MubGVuZ3RoIDogMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJlbGVtZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50LmVsZW1lbnRSZWY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQuaW5qZWN0b3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwicGFyZW50SW5qZWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFRPRE8ocmFkbyk6IHByb2ZpbGUgYW5kIGRlY2lkZSB3aGV0aGVyIGJvdW5kcyBjaGVja3Mgc2hvdWxkIGJlIGFkZGVkXG4gICAgLy8gdG8gdGhlIG1ldGhvZHMgYmVsb3cuXG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgIHZhciB2aWV3UmVmID0gdGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmluc2VydCh2aWV3UmVmLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB2aWV3UmVmO1xuICAgIH07XG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5LCBpbmRleCwgaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxuICAgICAgICBpZiAoaW5qZWN0b3IgPT09IHZvaWQgMCkgeyBpbmplY3RvciA9IG51bGw7IH1cbiAgICAgICAgaWYgKHByb2plY3RhYmxlTm9kZXMgPT09IHZvaWQgMCkgeyBwcm9qZWN0YWJsZU5vZGVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgcyA9IHRoaXMuX2NyZWF0ZUNvbXBvbmVudEluQ29udGFpbmVyU2NvcGUoKTtcbiAgICAgICAgdmFyIGNvbnRleHRJbmplY3RvciA9IGxhbmdfMS5pc1ByZXNlbnQoaW5qZWN0b3IpID8gaW5qZWN0b3IgOiB0aGlzLl9lbGVtZW50LnBhcmVudEluamVjdG9yO1xuICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUoY29udGV4dEluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoY29tcG9uZW50UmVmLmhvc3RWaWV3LCBpbmRleCk7XG4gICAgICAgIHJldHVybiBwcm9maWxlXzEud3RmTGVhdmUocywgY29tcG9uZW50UmVmKTtcbiAgICB9O1xuICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh2aWV3UmVmLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgIHZhciBzID0gdGhpcy5faW5zZXJ0U2NvcGUoKTtcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHZpZXdSZWZfID0gdmlld1JlZjtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5hdHRhY2hWaWV3KHZpZXdSZWZfLmludGVybmFsVmlldywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gcHJvZmlsZV8xLnd0ZkxlYXZlKHMsIHZpZXdSZWZfKTtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKHZpZXdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5pbmRleE9mKHRoaXMuX2VsZW1lbnQubmVzdGVkVmlld3MsIHZpZXdSZWYuaW50ZXJuYWxWaWV3KTtcbiAgICB9O1xuICAgIC8vIFRPRE8oaSk6IHJlbmFtZSB0byBkZXN0cm95XG4gICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgIHZhciBzID0gdGhpcy5fcmVtb3ZlU2NvcGUoKTtcbiAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZWxlbWVudC5kZXRhY2hWaWV3KGluZGV4KTtcbiAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgIC8vIHZpZXcgaXMgaW50ZW50aW9uYWxseSBub3QgcmV0dXJuZWQgdG8gdGhlIGNsaWVudC5cbiAgICAgICAgcHJvZmlsZV8xLnd0ZkxlYXZlKHMpO1xuICAgIH07XG4gICAgLy8gVE9ETyhpKTogcmVmYWN0b3IgaW5zZXJ0K3JlbW92ZSBpbnRvIG1vdmVcbiAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgdmFyIHMgPSB0aGlzLl9kZXRhY2hTY29wZSgpO1xuICAgICAgICBpZiAoaW5kZXggPT0gLTEpXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9lbGVtZW50LmRldGFjaFZpZXcoaW5kZXgpO1xuICAgICAgICByZXR1cm4gcHJvZmlsZV8xLnd0ZkxlYXZlKHMsIHZpZXcucmVmKTtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlld0NvbnRhaW5lclJlZl87XG59KCkpO1xuZXhwb3J0cy5WaWV3Q29udGFpbmVyUmVmXyA9IFZpZXdDb250YWluZXJSZWZfO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19jb250YWluZXJfcmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuLi9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cycpO1xudmFyIFZpZXdSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdSZWYoKSB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBWaWV3UmVmO1xufSgpKTtcbmV4cG9ydHMuVmlld1JlZiA9IFZpZXdSZWY7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gQW5ndWxhciBWaWV3LlxuICpcbiAqIDwhLS0gVE9ETzogbW92ZSB0aGUgbmV4dCB0d28gcGFyYWdyYXBocyB0byB0aGUgZGV2IGd1aWRlIC0tPlxuICogQSBWaWV3IGlzIGEgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIGFwcGxpY2F0aW9uIFVJLiBJdCBpcyB0aGUgc21hbGxlc3QgZ3JvdXBpbmcgb2ZcbiAqIEVsZW1lbnRzIHdoaWNoIGFyZSBjcmVhdGVkIGFuZCBkZXN0cm95ZWQgdG9nZXRoZXIuXG4gKlxuICogUHJvcGVydGllcyBvZiBlbGVtZW50cyBpbiBhIFZpZXcgY2FuIGNoYW5nZSwgYnV0IHRoZSBzdHJ1Y3R1cmUgKG51bWJlciBhbmQgb3JkZXIpIG9mIGVsZW1lbnRzIGluXG4gKiBhIFZpZXcgY2Fubm90LiBDaGFuZ2luZyB0aGUgc3RydWN0dXJlIG9mIEVsZW1lbnRzIGNhbiBvbmx5IGJlIGRvbmUgYnkgaW5zZXJ0aW5nLCBtb3Zpbmcgb3JcbiAqIHJlbW92aW5nIG5lc3RlZCBWaWV3cyB2aWEgYSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0uIEVhY2ggVmlldyBjYW4gY29udGFpbiBtYW55IFZpZXcgQ29udGFpbmVycy5cbiAqIDwhLS0gL1RPRE8gLS0+XG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBHaXZlbiB0aGlzIHRlbXBsYXRlLi4uXG4gKlxuICogYGBgXG4gKiBDb3VudDoge3tpdGVtcy5sZW5ndGh9fVxuICogPHVsPlxuICogICA8bGkgKm5nRm9yPVwibGV0ICBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX08L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqIC4uLiB3ZSBoYXZlIHR3byB7QGxpbmsgVGVtcGxhdGVSZWZ9czpcbiAqXG4gKiBPdXRlciB7QGxpbmsgVGVtcGxhdGVSZWZ9OlxuICogYGBgXG4gKiBDb3VudDoge3tpdGVtcy5sZW5ndGh9fVxuICogPHVsPlxuICogICA8dGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gW25nRm9yT2ZdPVwiaXRlbXNcIj48L3RlbXBsYXRlPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqIElubmVyIHtAbGluayBUZW1wbGF0ZVJlZn06XG4gKiBgYGBcbiAqICAgPGxpPnt7aXRlbX19PC9saT5cbiAqIGBgYFxuICpcbiAqIE5vdGljZSB0aGF0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBpcyBicm9rZW4gZG93biBpbnRvIHR3byBzZXBhcmF0ZSB7QGxpbmsgVGVtcGxhdGVSZWZ9cy5cbiAqXG4gKiBUaGUgb3V0ZXIvaW5uZXIge0BsaW5rIFRlbXBsYXRlUmVmfXMgYXJlIHRoZW4gYXNzZW1ibGVkIGludG8gdmlld3MgbGlrZSBzbzpcbiAqXG4gKiBgYGBcbiAqIDwhLS0gVmlld1JlZjogb3V0ZXItMCAtLT5cbiAqIENvdW50OiAyXG4gKiA8dWw+XG4gKiAgIDx0ZW1wbGF0ZSB2aWV3LWNvbnRhaW5lci1yZWY+PC90ZW1wbGF0ZT5cbiAqICAgPCEtLSBWaWV3UmVmOiBpbm5lci0xIC0tPjxsaT5maXJzdDwvbGk+PCEtLSAvVmlld1JlZjogaW5uZXItMSAtLT5cbiAqICAgPCEtLSBWaWV3UmVmOiBpbm5lci0yIC0tPjxsaT5zZWNvbmQ8L2xpPjwhLS0gL1ZpZXdSZWY6IGlubmVyLTIgLS0+XG4gKiA8L3VsPlxuICogPCEtLSAvVmlld1JlZjogb3V0ZXItMCAtLT5cbiAqIGBgYFxuICovXG52YXIgRW1iZWRkZWRWaWV3UmVmID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1iZWRkZWRWaWV3UmVmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtYmVkZGVkVmlld1JlZigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWJlZGRlZFZpZXdSZWYucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWJlZGRlZFZpZXdSZWYucHJvdG90eXBlLCBcInJvb3ROb2Rlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgO1xuICAgIHJldHVybiBFbWJlZGRlZFZpZXdSZWY7XG59KFZpZXdSZWYpKTtcbmV4cG9ydHMuRW1iZWRkZWRWaWV3UmVmID0gRW1iZWRkZWRWaWV3UmVmO1xudmFyIFZpZXdSZWZfID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3UmVmXyhfdmlldykge1xuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJpbnRlcm5hbFZpZXdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwicm9vdE5vZGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmZsYXRSb290Tm9kZXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5jb250ZXh0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5kZXN0cm95ZWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5tYXJrRm9yQ2hlY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcubWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZSgpOyB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcuY2RNb2RlID0gY29uc3RhbnRzXzEuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGV0YWNoZWQ7IH07XG4gICAgVmlld1JlZl8ucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcuZGV0ZWN0Q2hhbmdlcyhmYWxzZSk7IH07XG4gICAgVmlld1JlZl8ucHJvdG90eXBlLmNoZWNrTm9DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmRldGVjdENoYW5nZXModHJ1ZSk7IH07XG4gICAgVmlld1JlZl8ucHJvdG90eXBlLnJlYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92aWV3LmNkTW9kZSA9IGNvbnN0YW50c18xLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkNoZWNrQWx3YXlzO1xuICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgIH07XG4gICAgVmlld1JlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl92aWV3LmRpc3Bvc2FibGVzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgIFZpZXdSZWZfLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmRlc3Ryb3koKTsgfTtcbiAgICByZXR1cm4gVmlld1JlZl87XG59KCkpO1xuZXhwb3J0cy5WaWV3UmVmXyA9IFZpZXdSZWZfO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld19yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4oZnVuY3Rpb24gKFZpZXdUeXBlKSB7XG4gICAgLy8gQSB2aWV3IHRoYXQgY29udGFpbnMgdGhlIGhvc3QgZWxlbWVudCB3aXRoIGJvdW5kIGNvbXBvbmVudCBkaXJlY3RpdmUuXG4gICAgLy8gQ29udGFpbnMgYSBDT01QT05FTlQgdmlld1xuICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiSE9TVFwiXSA9IDBdID0gXCJIT1NUXCI7XG4gICAgLy8gVGhlIHZpZXcgb2YgdGhlIGNvbXBvbmVudFxuICAgIC8vIENhbiBjb250YWluIDAgdG8gbiBFTUJFRERFRCB2aWV3c1xuICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiQ09NUE9ORU5UXCJdID0gMV0gPSBcIkNPTVBPTkVOVFwiO1xuICAgIC8vIEEgdmlldyB0aGF0IGlzIGVtYmVkZGVkIGludG8gYW5vdGhlciBWaWV3IHZpYSBhIDx0ZW1wbGF0ZT4gZWxlbWVudFxuICAgIC8vIGluc2lkZSBvZiBhIENPTVBPTkVOVCB2aWV3XG4gICAgVmlld1R5cGVbVmlld1R5cGVbXCJFTUJFRERFRFwiXSA9IDJdID0gXCJFTUJFRERFRFwiO1xufSkoZXhwb3J0cy5WaWV3VHlwZSB8fCAoZXhwb3J0cy5WaWV3VHlwZSA9IHt9KSk7XG52YXIgVmlld1R5cGUgPSBleHBvcnRzLlZpZXdUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld190eXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHNlY3VyaXR5XzEgPSByZXF1aXJlKCcuLi9zZWN1cml0eScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGVsZW1lbnRfMSA9IHJlcXVpcmUoJy4vZWxlbWVudCcpO1xudmFyIGV4Y2VwdGlvbnNfMiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9ucycpO1xudmFyIGNoYW5nZV9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xudmFyIGFwaV8xID0gcmVxdWlyZSgnLi4vcmVuZGVyL2FwaScpO1xudmFyIGFwcGxpY2F0aW9uX3Rva2Vuc18xID0gcmVxdWlyZSgnLi4vYXBwbGljYXRpb25fdG9rZW5zJyk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZSgnLi4vZGkvZGVjb3JhdG9ycycpO1xudmFyIGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xID0gcmVxdWlyZShcIi4uL2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbl91dGlsXCIpO1xudmFyIFZpZXdVdGlscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld1V0aWxzKF9yZW5kZXJlciwgX2FwcElkLCBzYW5pdGl6ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2FwcElkID0gX2FwcElkO1xuICAgICAgICB0aGlzLl9uZXh0Q29tcFR5cGVJZCA9IDA7XG4gICAgICAgIHRoaXMuc2FuaXRpemVyID0gc2FuaXRpemVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAqL1xuICAgIFZpZXdVdGlscy5wcm90b3R5cGUuY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhcGlfMS5SZW5kZXJDb21wb25lbnRUeXBlKHRoaXMuX2FwcElkICsgXCItXCIgKyB0aGlzLl9uZXh0Q29tcFR5cGVJZCsrLCB0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFZpZXdVdGlscy5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKHJlbmRlckNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnJlbmRlckNvbXBvbmVudChyZW5kZXJDb21wb25lbnRUeXBlKTtcbiAgICB9O1xuICAgIFZpZXdVdGlscy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGRlY29yYXRvcnNfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBWaWV3VXRpbHMuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgIHsgdHlwZTogYXBpXzEuUm9vdFJlbmRlcmVyLCB9LFxuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogZGVjb3JhdG9yc18xLkluamVjdCwgYXJnczogW2FwcGxpY2F0aW9uX3Rva2Vuc18xLkFQUF9JRCxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IHNlY3VyaXR5XzEuU2FuaXRpemF0aW9uU2VydmljZSwgfSxcbiAgICBdO1xuICAgIHJldHVybiBWaWV3VXRpbHM7XG59KCkpO1xuZXhwb3J0cy5WaWV3VXRpbHMgPSBWaWV3VXRpbHM7XG5mdW5jdGlvbiBmbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIF9mbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzKG5vZGVzLCBbXSk7XG59XG5leHBvcnRzLmZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMgPSBmbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzO1xuZnVuY3Rpb24gX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMobm9kZXMsIHJlbmRlck5vZGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGVsZW1lbnRfMS5BcHBFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYXBwRWwgPSBub2RlO1xuICAgICAgICAgICAgcmVuZGVyTm9kZXMucHVzaChhcHBFbC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGFwcEVsLm5lc3RlZFZpZXdzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXBwRWwubmVzdGVkVmlld3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMoYXBwRWwubmVzdGVkVmlld3Nba10ucm9vdE5vZGVzT3JBcHBFbGVtZW50cywgcmVuZGVyTm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlck5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlck5vZGVzO1xufVxudmFyIEVNUFRZX0FSUiA9IFtdO1xuZnVuY3Rpb24gZW5zdXJlU2xvdENvdW50KHByb2plY3RhYmxlTm9kZXMsIGV4cGVjdGVkU2xvdENvdW50KSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsocHJvamVjdGFibGVOb2RlcykpIHtcbiAgICAgICAgcmVzID0gRU1QVFlfQVJSO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9qZWN0YWJsZU5vZGVzLmxlbmd0aCA8IGV4cGVjdGVkU2xvdENvdW50KSB7XG4gICAgICAgIHZhciBnaXZlblNsb3RDb3VudCA9IHByb2plY3RhYmxlTm9kZXMubGVuZ3RoO1xuICAgICAgICByZXMgPSBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplKGV4cGVjdGVkU2xvdENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFNsb3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSAoaSA8IGdpdmVuU2xvdENvdW50KSA/IHByb2plY3RhYmxlTm9kZXNbaV0gOiBFTVBUWV9BUlI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcyA9IHByb2plY3RhYmxlTm9kZXM7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVuc3VyZVNsb3RDb3VudCA9IGVuc3VyZVNsb3RDb3VudDtcbmV4cG9ydHMuTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTID0gOTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHZhbHVlQ291bnQsIGMwLCBhMSwgYzEsIGEyLCBjMiwgYTMsIGMzLCBhNCwgYzQsIGE1LCBjNSwgYTYsIGM2LCBhNywgYzcsIGE4LCBjOCwgYTksIGM5KSB7XG4gICAgc3dpdGNoICh2YWx1ZUNvdW50KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICBjMztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNDtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgIGM2O1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgIGM2ICsgX3RvU3RyaW5nV2l0aE51bGwoYTcpICsgYzc7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgIGMzICsgX3RvU3RyaW5nV2l0aE51bGwoYTQpICsgYzQgKyBfdG9TdHJpbmdXaXRoTnVsbChhNSkgKyBjNSArIF90b1N0cmluZ1dpdGhOdWxsKGE2KSArXG4gICAgICAgICAgICAgICAgYzYgKyBfdG9TdHJpbmdXaXRoTnVsbChhNykgKyBjNyArIF90b1N0cmluZ1dpdGhOdWxsKGE4KSArIGM4O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgIGM2ICsgX3RvU3RyaW5nV2l0aE51bGwoYTcpICsgYzcgKyBfdG9TdHJpbmdXaXRoTnVsbChhOCkgKyBjOCArIF90b1N0cmluZ1dpdGhOdWxsKGE5KSArXG4gICAgICAgICAgICAgICAgYzk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJEb2VzIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiA5IGV4cHJlc3Npb25zXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcbmZ1bmN0aW9uIF90b1N0cmluZ1dpdGhOdWxsKHYpIHtcbiAgICByZXR1cm4gdiAhPSBudWxsID8gdi50b1N0cmluZygpIDogJyc7XG59XG5mdW5jdGlvbiBjaGVja0JpbmRpbmcodGhyb3dPbkNoYW5nZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VfZGV0ZWN0aW9uXzEuZGV2TW9kZUVxdWFsKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzIuRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFeGNlcHRpb24ob2xkVmFsdWUsIG5ld1ZhbHVlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gIWxhbmdfMS5sb29zZUlkZW50aWNhbChvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tCaW5kaW5nID0gY2hlY2tCaW5kaW5nO1xuZnVuY3Rpb24gYXJyYXlMb29zZUlkZW50aWNhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghbGFuZ18xLmxvb3NlSWRlbnRpY2FsKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYXJyYXlMb29zZUlkZW50aWNhbCA9IGFycmF5TG9vc2VJZGVudGljYWw7XG5mdW5jdGlvbiBtYXBMb29zZUlkZW50aWNhbChtMSwgbTIpIHtcbiAgICB2YXIgazEgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5rZXlzKG0xKTtcbiAgICB2YXIgazIgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5rZXlzKG0yKTtcbiAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrMVtpXTtcbiAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwobTFba2V5XSwgbTJba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMubWFwTG9vc2VJZGVudGljYWwgPSBtYXBMb29zZUlkZW50aWNhbDtcbmZ1bmN0aW9uIGNhc3RCeVZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBpbnB1dDtcbn1cbmV4cG9ydHMuY2FzdEJ5VmFsdWUgPSBjYXN0QnlWYWx1ZTtcbmV4cG9ydHMuRU1QVFlfQVJSQVkgPSBbXTtcbmV4cG9ydHMuRU1QVFlfTUFQID0ge307XG5mdW5jdGlvbiBwdXJlUHJveHkxKGZuKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgdjA7XG4gICAgdjAgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS51bmluaXRpYWxpemVkO1xuICAgIHJldHVybiBmdW5jdGlvbiAocDApIHtcbiAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwodjAsIHAwKSkge1xuICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5leHBvcnRzLnB1cmVQcm94eTEgPSBwdXJlUHJveHkxO1xuZnVuY3Rpb24gcHVyZVByb3h5Mihmbikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHYwLCB2MTtcbiAgICB2MCA9IHYxID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEudW5pbml0aWFsaXplZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSkge1xuICAgICAgICBpZiAoIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjEsIHAxKSkge1xuICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMucHVyZVByb3h5MiA9IHB1cmVQcm94eTI7XG5mdW5jdGlvbiBwdXJlUHJveHkzKGZuKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgdjAsIHYxLCB2MjtcbiAgICB2MCA9IHYxID0gdjIgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS51bmluaXRpYWxpemVkO1xuICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMikge1xuICAgICAgICBpZiAoIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYyLCBwMikpIHtcbiAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMucHVyZVByb3h5MyA9IHB1cmVQcm94eTM7XG5mdW5jdGlvbiBwdXJlUHJveHk0KGZuKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgdjAsIHYxLCB2MiwgdjM7XG4gICAgdjAgPSB2MSA9IHYyID0gdjMgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS51bmluaXRpYWxpemVkO1xuICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcbiAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYzLCBwMykpIHtcbiAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0cy5wdXJlUHJveHk0ID0gcHVyZVByb3h5NDtcbmZ1bmN0aW9uIHB1cmVQcm94eTUoZm4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQ7XG4gICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLnVuaW5pdGlhbGl6ZWQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2NCwgcDQpKSB7XG4gICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0cy5wdXJlUHJveHk1ID0gcHVyZVByb3h5NTtcbmZ1bmN0aW9uIHB1cmVQcm94eTYoZm4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1O1xuICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IGNoYW5nZV9kZXRlY3Rpb25fdXRpbF8xLnVuaW5pdGlhbGl6ZWQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgcDQsIHA1KSB7XG4gICAgICAgIGlmICghbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHY1LCBwNSkpIHtcbiAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMucHVyZVByb3h5NiA9IHB1cmVQcm94eTY7XG5mdW5jdGlvbiBwdXJlUHJveHk3KGZuKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjY7XG4gICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS51bmluaXRpYWxpemVkO1xuICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYpIHtcbiAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2NiwgcDYpKSB7XG4gICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgIHY1ID0gcDU7XG4gICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMucHVyZVByb3h5NyA9IHB1cmVQcm94eTc7XG5mdW5jdGlvbiBwdXJlUHJveHk4KGZuKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3O1xuICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IHY2ID0gdjcgPSBjaGFuZ2VfZGV0ZWN0aW9uX3V0aWxfMS51bmluaXRpYWxpemVkO1xuICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3KSB7XG4gICAgICAgIGlmICghbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHY1LCBwNSkgfHxcbiAgICAgICAgICAgICFsYW5nXzEubG9vc2VJZGVudGljYWwodjYsIHA2KSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHY3LCBwNykpIHtcbiAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgIHY2ID0gcDY7XG4gICAgICAgICAgICB2NyA9IHA3O1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5leHBvcnRzLnB1cmVQcm94eTggPSBwdXJlUHJveHk4O1xuZnVuY3Rpb24gcHVyZVByb3h5OShmbikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2Nywgdjg7XG4gICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSB2NyA9IHY4ID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEudW5pbml0aWFsaXplZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgpIHtcbiAgICAgICAgaWYgKCFsYW5nXzEubG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2NiwgcDYpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjcsIHA3KSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHY4LCBwOCkpIHtcbiAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgIHY2ID0gcDY7XG4gICAgICAgICAgICB2NyA9IHA3O1xuICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMucHVyZVByb3h5OSA9IHB1cmVQcm94eTk7XG5mdW5jdGlvbiBwdXJlUHJveHkxMChmbikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIHY5O1xuICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IHY2ID0gdjcgPSB2OCA9IHY5ID0gY2hhbmdlX2RldGVjdGlvbl91dGlsXzEudW5pbml0aWFsaXplZDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgsIHA5KSB7XG4gICAgICAgIGlmICghbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsYW5nXzEubG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHY1LCBwNSkgfHxcbiAgICAgICAgICAgICFsYW5nXzEubG9vc2VJZGVudGljYWwodjYsIHA2KSB8fCAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHY3LCBwNykgfHwgIWxhbmdfMS5sb29zZUlkZW50aWNhbCh2OCwgcDgpIHx8XG4gICAgICAgICAgICAhbGFuZ18xLmxvb3NlSWRlbnRpY2FsKHY5LCBwOSkpIHtcbiAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgIHY2ID0gcDY7XG4gICAgICAgICAgICB2NyA9IHA3O1xuICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgIHY5ID0gcDk7XG4gICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcsIHA4LCBwOSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0cy5wdXJlUHJveHkxMCA9IHB1cmVQcm94eTEwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlld191dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuKiBUaGlzIGluZGlyZWN0aW9uIGlzIG5lZWRlZCB0byBmcmVlIHVwIENvbXBvbmVudCwgZXRjIHN5bWJvbHMgaW4gdGhlIHB1YmxpYyBBUElcbiogdG8gYmUgdXNlZCBieSB0aGUgZGVjb3JhdG9yIHZlcnNpb25zIG9mIHRoZXNlIGFubm90YXRpb25zLlxuKi9cbnZhciBkaV8xID0gcmVxdWlyZSgnLi9tZXRhZGF0YS9kaScpO1xuZXhwb3J0cy5RdWVyeU1ldGFkYXRhID0gZGlfMS5RdWVyeU1ldGFkYXRhO1xuZXhwb3J0cy5Db250ZW50Q2hpbGRyZW5NZXRhZGF0YSA9IGRpXzEuQ29udGVudENoaWxkcmVuTWV0YWRhdGE7XG5leHBvcnRzLkNvbnRlbnRDaGlsZE1ldGFkYXRhID0gZGlfMS5Db250ZW50Q2hpbGRNZXRhZGF0YTtcbmV4cG9ydHMuVmlld0NoaWxkcmVuTWV0YWRhdGEgPSBkaV8xLlZpZXdDaGlsZHJlbk1ldGFkYXRhO1xuZXhwb3J0cy5WaWV3UXVlcnlNZXRhZGF0YSA9IGRpXzEuVmlld1F1ZXJ5TWV0YWRhdGE7XG5leHBvcnRzLlZpZXdDaGlsZE1ldGFkYXRhID0gZGlfMS5WaWV3Q2hpbGRNZXRhZGF0YTtcbmV4cG9ydHMuQXR0cmlidXRlTWV0YWRhdGEgPSBkaV8xLkF0dHJpYnV0ZU1ldGFkYXRhO1xudmFyIGRpcmVjdGl2ZXNfMSA9IHJlcXVpcmUoJy4vbWV0YWRhdGEvZGlyZWN0aXZlcycpO1xuZXhwb3J0cy5Db21wb25lbnRNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5Db21wb25lbnRNZXRhZGF0YTtcbmV4cG9ydHMuRGlyZWN0aXZlTWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuRGlyZWN0aXZlTWV0YWRhdGE7XG5leHBvcnRzLlBpcGVNZXRhZGF0YSA9IGRpcmVjdGl2ZXNfMS5QaXBlTWV0YWRhdGE7XG5leHBvcnRzLklucHV0TWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuSW5wdXRNZXRhZGF0YTtcbmV4cG9ydHMuT3V0cHV0TWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuT3V0cHV0TWV0YWRhdGE7XG5leHBvcnRzLkhvc3RCaW5kaW5nTWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuSG9zdEJpbmRpbmdNZXRhZGF0YTtcbmV4cG9ydHMuSG9zdExpc3RlbmVyTWV0YWRhdGEgPSBkaXJlY3RpdmVzXzEuSG9zdExpc3RlbmVyTWV0YWRhdGE7XG52YXIgdmlld18xID0gcmVxdWlyZSgnLi9tZXRhZGF0YS92aWV3Jyk7XG5leHBvcnRzLlZpZXdNZXRhZGF0YSA9IHZpZXdfMS5WaWV3TWV0YWRhdGE7XG5leHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uID0gdmlld18xLlZpZXdFbmNhcHN1bGF0aW9uO1xudmFyIGRpXzIgPSByZXF1aXJlKCcuL21ldGFkYXRhL2RpJyk7XG52YXIgZGlyZWN0aXZlc18yID0gcmVxdWlyZSgnLi9tZXRhZGF0YS9kaXJlY3RpdmVzJyk7XG52YXIgdmlld18yID0gcmVxdWlyZSgnLi9tZXRhZGF0YS92aWV3Jyk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZSgnLi91dGlsL2RlY29yYXRvcnMnKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gQ29tcG9uZW50TWV0YWRhdGEuXG4vKipcbiAqIERlY2xhcmUgcmV1c2FibGUgVUkgYnVpbGRpbmcgYmxvY2tzIGZvciBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBFYWNoIEFuZ3VsYXIgY29tcG9uZW50IHJlcXVpcmVzIGEgc2luZ2xlIGBAQ29tcG9uZW50YCBhbm5vdGF0aW9uLiBUaGUgYEBDb21wb25lbnRgXG4gKiBhbm5vdGF0aW9uIHNwZWNpZmllcyB3aGVuIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgYW5kIHdoaWNoIHByb3BlcnRpZXMgYW5kIGhvc3RMaXN0ZW5lcnMgaXRcbiAqIGJpbmRzIHRvLlxuICpcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLCBBbmd1bGFyXG4gKiAtIGNyZWF0ZXMgYSBzaGFkb3cgRE9NIGZvciB0aGUgY29tcG9uZW50LlxuICogLSBsb2FkcyB0aGUgc2VsZWN0ZWQgdGVtcGxhdGUgaW50byB0aGUgc2hhZG93IERPTS5cbiAqIC0gY3JlYXRlcyBhbGwgdGhlIGluamVjdGFibGUgb2JqZWN0cyBjb25maWd1cmVkIHdpdGggYHByb3ZpZGVyc2AgYW5kIGB2aWV3UHJvdmlkZXJzYC5cbiAqXG4gKiBBbGwgdGVtcGxhdGUgZXhwcmVzc2lvbnMgYW5kIHN0YXRlbWVudHMgYXJlIHRoZW4gZXZhbHVhdGVkIGFnYWluc3QgdGhlIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqXG4gKiAjIyBMaWZlY3ljbGUgaG9va3NcbiAqXG4gKiBXaGVuIHRoZSBjb21wb25lbnQgY2xhc3MgaW1wbGVtZW50cyBzb21lIHtAbGluayAuLi8uLi9ndWlkZS9saWZlY3ljbGUtaG9va3MuaHRtbH0gdGhlIGNhbGxiYWNrc1xuICogYXJlIGNhbGxlZCBieSB0aGUgY2hhbmdlIGRldGVjdGlvbiBhdCBkZWZpbmVkIHBvaW50cyBpbiB0aW1lIGR1cmluZyB0aGUgbGlmZSBvZiB0aGUgY29tcG9uZW50LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbWV0YWRhdGEudHMgcmVnaW9uPSdjb21wb25lbnQnfVxuICovXG5leHBvcnRzLkNvbXBvbmVudCA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKGRpcmVjdGl2ZXNfMi5Db21wb25lbnRNZXRhZGF0YSwgZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbi5WaWV3ID0gVmlldzsgfSk7XG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIERpcmVjdGl2ZU1ldGFkYXRhLlxuLyoqXG4gKiBEaXJlY3RpdmVzIGFsbG93IHlvdSB0byBhdHRhY2ggYmVoYXZpb3IgdG8gZWxlbWVudHMgaW4gdGhlIERPTS5cbiAqXG4gKiB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9cyB3aXRoIGFuIGVtYmVkZGVkIHZpZXcgYXJlIGNhbGxlZCB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9cy5cbiAqXG4gKiBBIGRpcmVjdGl2ZSBjb25zaXN0cyBvZiBhIHNpbmdsZSBkaXJlY3RpdmUgYW5ub3RhdGlvbiBhbmQgYSBjb250cm9sbGVyIGNsYXNzLiBXaGVuIHRoZVxuICogZGlyZWN0aXZlJ3MgYHNlbGVjdG9yYCBtYXRjaGVzXG4gKiBlbGVtZW50cyBpbiB0aGUgRE9NLCB0aGUgZm9sbG93aW5nIHN0ZXBzIG9jY3VyOlxuICpcbiAqIDEuIEZvciBlYWNoIGRpcmVjdGl2ZSwgdGhlIGBFbGVtZW50SW5qZWN0b3JgIGF0dGVtcHRzIHRvIHJlc29sdmUgdGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gKiBhcmd1bWVudHMuXG4gKiAyLiBBbmd1bGFyIGluc3RhbnRpYXRlcyBkaXJlY3RpdmVzIGZvciBlYWNoIG1hdGNoZWQgZWxlbWVudCB1c2luZyBgRWxlbWVudEluamVjdG9yYCBpbiBhXG4gKiBkZXB0aC1maXJzdCBvcmRlcixcbiAqICAgIGFzIGRlY2xhcmVkIGluIHRoZSBIVE1MLlxuICpcbiAqICMjIFVuZGVyc3RhbmRpbmcgSG93IEluamVjdGlvbiBXb3Jrc1xuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgb2YgaW5qZWN0aW9uIHJlc29sdXRpb24uXG4gKiAtICpQcmUtZXhpc3RpbmcgSW5qZWN0b3JzKjpcbiAqICAgLSBUaGUgdGVybWluYWwge0BsaW5rIEluamVjdG9yfSBjYW5ub3QgcmVzb2x2ZSBkZXBlbmRlbmNpZXMuIEl0IGVpdGhlciB0aHJvd3MgYW4gZXJyb3Igb3IsIGlmXG4gKiB0aGUgZGVwZW5kZW5jeSB3YXNcbiAqICAgICBzcGVjaWZpZWQgYXMgYEBPcHRpb25hbGAsIHJldHVybnMgYG51bGxgLlxuICogICAtIFRoZSBwbGF0Zm9ybSBpbmplY3RvciByZXNvbHZlcyBicm93c2VyIHNpbmdsZXRvbiByZXNvdXJjZXMsIHN1Y2ggYXM6IGNvb2tpZXMsIHRpdGxlLFxuICogbG9jYXRpb24sIGFuZCBvdGhlcnMuXG4gKiAtICpDb21wb25lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGl0cyBvd24ge0BsaW5rIEluamVjdG9yfSwgYW5kIHRoZXkgZm9sbG93XG4gKiB0aGUgc2FtZSBwYXJlbnQtY2hpbGQgaGllcmFyY2h5XG4gKiAgICAgYXMgdGhlIGNvbXBvbmVudCBpbnN0YW5jZXMgaW4gdGhlIERPTS5cbiAqIC0gKkVsZW1lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGEgU2hhZG93IERPTS4gV2l0aGluIHRoZSBTaGFkb3cgRE9NIGVhY2hcbiAqIGVsZW1lbnQgaGFzIGFuIGBFbGVtZW50SW5qZWN0b3JgXG4gKiAgICAgd2hpY2ggZm9sbG93IHRoZSBzYW1lIHBhcmVudC1jaGlsZCBoaWVyYXJjaHkgYXMgdGhlIERPTSBlbGVtZW50cyB0aGVtc2VsdmVzLlxuICpcbiAqIFdoZW4gYSB0ZW1wbGF0ZSBpcyBpbnN0YW50aWF0ZWQsIGl0IGFsc28gbXVzdCBpbnN0YW50aWF0ZSB0aGUgY29ycmVzcG9uZGluZyBkaXJlY3RpdmVzIGluIGFcbiAqIGRlcHRoLWZpcnN0IG9yZGVyLiBUaGVcbiAqIGN1cnJlbnQgYEVsZW1lbnRJbmplY3RvcmAgcmVzb2x2ZXMgdGhlIGNvbnN0cnVjdG9yIGRlcGVuZGVuY2llcyBmb3IgZWFjaCBkaXJlY3RpdmUuXG4gKlxuICogQW5ndWxhciB0aGVuIHJlc29sdmVzIGRlcGVuZGVuY2llcyBhcyBmb2xsb3dzLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZVxuICoge0BsaW5rIFZpZXdNZXRhZGF0YX06XG4gKlxuICogMS4gRGVwZW5kZW5jaWVzIG9uIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAqIDIuIERlcGVuZGVuY2llcyBvbiBlbGVtZW50IGluamVjdG9ycyBhbmQgdGhlaXIgcGFyZW50cyB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgU2hhZG93IERPTSBib3VuZGFyeVxuICogMy4gRGVwZW5kZW5jaWVzIG9uIGNvbXBvbmVudCBpbmplY3RvcnMgYW5kIHRoZWlyIHBhcmVudHMgdW50aWwgaXQgZW5jb3VudGVycyB0aGUgcm9vdCBjb21wb25lbnRcbiAqIDQuIERlcGVuZGVuY2llcyBvbiBwcmUtZXhpc3RpbmcgaW5qZWN0b3JzXG4gKlxuICpcbiAqIFRoZSBgRWxlbWVudEluamVjdG9yYCBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMsIGVsZW1lbnQtc3BlY2lmaWMgc3BlY2lhbCBvYmplY3RzLCBvciBpdCBjYW5cbiAqIGRlbGVnYXRlIHRvIHRoZSBwYXJlbnRcbiAqIGluamVjdG9yLlxuICpcbiAqIFRvIGluamVjdCBvdGhlciBkaXJlY3RpdmVzLCBkZWNsYXJlIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgYXM6XG4gKiAtIGBkaXJlY3RpdmU6RGlyZWN0aXZlVHlwZWA6IGEgZGlyZWN0aXZlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQgb25seVxuICogLSBgQEhvc3QoKSBkaXJlY3RpdmU6RGlyZWN0aXZlVHlwZWA6IGFueSBkaXJlY3RpdmUgdGhhdCBtYXRjaGVzIHRoZSB0eXBlIGJldHdlZW4gdGhlIGN1cnJlbnRcbiAqIGVsZW1lbnQgYW5kIHRoZVxuICogICAgU2hhZG93IERPTSByb290LlxuICogLSBgQFF1ZXJ5KERpcmVjdGl2ZVR5cGUpIHF1ZXJ5OlF1ZXJ5TGlzdDxEaXJlY3RpdmVUeXBlPmA6IEEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRpcmVjdCBjaGlsZFxuICogZGlyZWN0aXZlcy5cbiAqIC0gYEBRdWVyeURlc2NlbmRhbnRzKERpcmVjdGl2ZVR5cGUpIHF1ZXJ5OlF1ZXJ5TGlzdDxEaXJlY3RpdmVUeXBlPmA6IEEgbGl2ZSBjb2xsZWN0aW9uIG9mIGFueVxuICogY2hpbGQgZGlyZWN0aXZlcy5cbiAqXG4gKiBUbyBpbmplY3QgZWxlbWVudC1zcGVjaWZpYyBzcGVjaWFsIG9iamVjdHMsIGRlY2xhcmUgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBhczpcbiAqIC0gYGVsZW1lbnQ6IEVsZW1lbnRSZWZgIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byBsb2dpY2FsIGVsZW1lbnQgaW4gdGhlIHZpZXcuXG4gKiAtIGB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmYCB0byBjb250cm9sIGNoaWxkIHRlbXBsYXRlIGluc3RhbnRpYXRpb24sIGZvclxuICoge0BsaW5rIERpcmVjdGl2ZU1ldGFkYXRhfSBkaXJlY3RpdmVzIG9ubHlcbiAqIC0gYGJpbmRpbmdQcm9wYWdhdGlvbjogQmluZGluZ1Byb3BhZ2F0aW9uYCB0byBjb250cm9sIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBtb3JlIGdyYW51bGFyIHdheS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZW1vbnN0cmF0ZXMgaG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uIHJlc29sdmVzIGNvbnN0cnVjdG9yIGFyZ3VtZW50cyBpblxuICogcHJhY3RpY2UuXG4gKlxuICpcbiAqIEFzc3VtZSB0aGlzIEhUTUwgdGVtcGxhdGU6XG4gKlxuICogYGBgXG4gKiA8ZGl2IGRlcGVuZGVuY3k9XCIxXCI+XG4gKiAgIDxkaXYgZGVwZW5kZW5jeT1cIjJcIj5cbiAqICAgICA8ZGl2IGRlcGVuZGVuY3k9XCIzXCIgbXktZGlyZWN0aXZlPlxuICogICAgICAgPGRpdiBkZXBlbmRlbmN5PVwiNFwiPlxuICogICAgICAgICA8ZGl2IGRlcGVuZGVuY3k9XCI1XCI+PC9kaXY+XG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjZcIj48L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIFdpdGggdGhlIGZvbGxvd2luZyBgZGVwZW5kZW5jeWAgZGVjb3JhdG9yIGFuZCBgU29tZVNlcnZpY2VgIGluamVjdGFibGUgY2xhc3MuXG4gKlxuICogYGBgXG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBTb21lU2VydmljZSB7XG4gKiB9XG4gKlxuICogQERpcmVjdGl2ZSh7XG4gKiAgIHNlbGVjdG9yOiAnW2RlcGVuZGVuY3ldJyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAgJ2lkOiBkZXBlbmRlbmN5J1xuICogICBdXG4gKiB9KVxuICogY2xhc3MgRGVwZW5kZW5jeSB7XG4gKiAgIGlkOnN0cmluZztcbiAqIH1cbiAqIGBgYFxuICpcbiAqIExldCdzIHN0ZXAgdGhyb3VnaCB0aGUgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggYE15RGlyZWN0aXZlYCBjb3VsZCBiZSBkZWNsYXJlZC4uLlxuICpcbiAqXG4gKiAjIyMgTm8gaW5qZWN0aW9uXG4gKlxuICogSGVyZSB0aGUgY29uc3RydWN0b3IgaXMgZGVjbGFyZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZXJlZm9yZSBub3RoaW5nIGlzIGluamVjdGVkIGludG9cbiAqIGBNeURpcmVjdGl2ZWAuXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIG5vIGRlcGVuZGVuY2llcy5cbiAqXG4gKlxuICogIyMjIENvbXBvbmVudC1sZXZlbCBpbmplY3Rpb25cbiAqXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3QgYW55IGluamVjdGFibGUgaW5zdGFuY2UgZnJvbSB0aGUgY2xvc2VzdCBjb21wb25lbnQgaW5qZWN0b3Igb3IgYW55IG9mIGl0c1xuICogcGFyZW50cy5cbiAqXG4gKiBIZXJlLCB0aGUgY29uc3RydWN0b3IgZGVjbGFyZXMgYSBwYXJhbWV0ZXIsIGBzb21lU2VydmljZWAsIGFuZCBpbmplY3RzIHRoZSBgU29tZVNlcnZpY2VgIHR5cGVcbiAqIGZyb20gdGhlIHBhcmVudFxuICogY29tcG9uZW50J3MgaW5qZWN0b3IuXG4gKiBgYGBcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xuICogICBjb25zdHJ1Y3Rvcihzb21lU2VydmljZTogU29tZVNlcnZpY2UpIHtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBkZXBlbmRlbmN5IG9uIGBTb21lU2VydmljZWAuXG4gKlxuICpcbiAqICMjIyBJbmplY3RpbmcgYSBkaXJlY3RpdmUgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gKlxuICogRGlyZWN0aXZlcyBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMgZGVjbGFyZWQgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqXG4gKiBgYGBcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xuICogICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XG4gKiAgICAgZXhwZWN0KGRlcGVuZGVuY3kuaWQpLnRvRXF1YWwoMyk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYERlcGVuZGVuY3lgIGRlY2xhcmVkIGF0IHRoZSBzYW1lIGVsZW1lbnQsIGluIHRoaXMgY2FzZVxuICogYGRlcGVuZGVuY3k9XCIzXCJgLlxuICpcbiAqICMjIyBJbmplY3RpbmcgYSBkaXJlY3RpdmUgZnJvbSBhbnkgYW5jZXN0b3IgZWxlbWVudHNcbiAqXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3Qgb3RoZXIgZGlyZWN0aXZlcyBkZWNsYXJlZCBvbiBhbnkgYW5jZXN0b3IgZWxlbWVudCAoaW4gdGhlIGN1cnJlbnQgU2hhZG93XG4gKiBET00pLCBpLmUuIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQsIHRoZVxuICogcGFyZW50IGVsZW1lbnQsIG9yIGl0cyBwYXJlbnRzLlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoQEhvc3QoKSBkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XG4gKiAgICAgZXhwZWN0KGRlcGVuZGVuY3kuaWQpLnRvRXF1YWwoMik7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIGBASG9zdGAgY2hlY2tzIHRoZSBjdXJyZW50IGVsZW1lbnQsIHRoZSBwYXJlbnQsIGFzIHdlbGwgYXMgaXRzIHBhcmVudHMgcmVjdXJzaXZlbHkuIElmXG4gKiBgZGVwZW5kZW5jeT1cIjJcImAgZGlkbid0XG4gKiBleGlzdCBvbiB0aGUgZGlyZWN0IHBhcmVudCwgdGhpcyBpbmplY3Rpb24gd291bGRcbiAqIGhhdmUgcmV0dXJuZWRcbiAqIGBkZXBlbmRlbmN5PVwiMVwiYC5cbiAqXG4gKlxuICogIyMjIEluamVjdGluZyBhIGxpdmUgY29sbGVjdGlvbiBvZiBkaXJlY3QgY2hpbGQgZGlyZWN0aXZlc1xuICpcbiAqXG4gKiBBIGRpcmVjdGl2ZSBjYW4gYWxzbyBxdWVyeSBmb3Igb3RoZXIgY2hpbGQgZGlyZWN0aXZlcy4gU2luY2UgcGFyZW50IGRpcmVjdGl2ZXMgYXJlIGluc3RhbnRpYXRlZFxuICogYmVmb3JlIGNoaWxkIGRpcmVjdGl2ZXMsIGEgZGlyZWN0aXZlIGNhbid0IHNpbXBseSBpbmplY3QgdGhlIGxpc3Qgb2YgY2hpbGQgZGlyZWN0aXZlcy4gSW5zdGVhZCxcbiAqIHRoZSBkaXJlY3RpdmUgaW5qZWN0cyBhIHtAbGluayBRdWVyeUxpc3R9LCB3aGljaCB1cGRhdGVzIGl0cyBjb250ZW50cyBhcyBjaGlsZHJlbiBhcmUgYWRkZWQsXG4gKiByZW1vdmVkLCBvciBtb3ZlZCBieSBhIGRpcmVjdGl2ZSB0aGF0IHVzZXMgYSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0gc3VjaCBhcyBhIGBuZ0ZvcmAsIGFuXG4gKiBgbmdJZmAsIG9yIGFuIGBuZ1N3aXRjaGAuXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KERlcGVuZGVuY3kpIGRlcGVuZGVuY2llczpRdWVyeUxpc3Q8RGVwZW5kZW5jeT4pIHtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSB7QGxpbmsgUXVlcnlMaXN0fSB3aGljaCBjb250YWlucyBgRGVwZW5kZW5jeWAgNCBhbmRcbiAqIDYuIEhlcmUsIGBEZXBlbmRlbmN5YCA1IHdvdWxkIG5vdCBiZSBpbmNsdWRlZCwgYmVjYXVzZSBpdCBpcyBub3QgYSBkaXJlY3QgY2hpbGQuXG4gKlxuICogIyMjIEluamVjdGluZyBhIGxpdmUgY29sbGVjdGlvbiBvZiBkZXNjZW5kYW50IGRpcmVjdGl2ZXNcbiAqXG4gKiBCeSBwYXNzaW5nIHRoZSBkZXNjZW5kYW50IGZsYWcgdG8gYEBRdWVyeWAgYWJvdmUsIHdlIGNhbiBpbmNsdWRlIHRoZSBjaGlsZHJlbiBvZiB0aGUgY2hpbGRcbiAqIGVsZW1lbnRzLlxuICpcbiAqIGBgYFxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShEZXBlbmRlbmN5LCB7ZGVzY2VuZGFudHM6IHRydWV9KSBkZXBlbmRlbmNpZXM6UXVlcnlMaXN0PERlcGVuZGVuY3k+KSB7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGEgUXVlcnkgd2hpY2ggd291bGQgY29udGFpbiBgRGVwZW5kZW5jeWAgNCwgNSBhbmQgNi5cbiAqXG4gKiAjIyMgT3B0aW9uYWwgaW5qZWN0aW9uXG4gKlxuICogVGhlIG5vcm1hbCBiZWhhdmlvciBvZiBkaXJlY3RpdmVzIGlzIHRvIHJldHVybiBhbiBlcnJvciB3aGVuIGEgc3BlY2lmaWVkIGRlcGVuZGVuY3kgY2Fubm90IGJlXG4gKiByZXNvbHZlZC4gSWYgeW91XG4gKiB3b3VsZCBsaWtlIHRvIGluamVjdCBgbnVsbGAgb24gdW5yZXNvbHZlZCBkZXBlbmRlbmN5IGluc3RlYWQsIHlvdSBjYW4gYW5ub3RhdGUgdGhhdCBkZXBlbmRlbmN5XG4gKiB3aXRoIGBAT3B0aW9uYWwoKWAuXG4gKiBUaGlzIGV4cGxpY2l0bHkgcGVybWl0cyB0aGUgYXV0aG9yIG9mIGEgdGVtcGxhdGUgdG8gdHJlYXQgc29tZSBvZiB0aGUgc3Vycm91bmRpbmcgZGlyZWN0aXZlcyBhc1xuICogb3B0aW9uYWwuXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgZGVwZW5kZW5jeTpEZXBlbmRlbmN5KSB7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIGEgYERlcGVuZGVuY3lgIGRpcmVjdGl2ZSBmb3VuZCBvbiB0aGUgY3VycmVudCBlbGVtZW50LlxuICogSWYgbm9uZSBjYW4gYmVcbiAqIGZvdW5kLCB0aGUgaW5qZWN0b3Igc3VwcGxpZXMgYG51bGxgIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBIZXJlIHdlIHVzZSBhIGRlY29yYXRvciBkaXJlY3RpdmUgdG8gc2ltcGx5IGRlZmluZSBiYXNpYyB0b29sLXRpcCBiZWhhdmlvci5cbiAqXG4gKiBgYGBcbiAqIEBEaXJlY3RpdmUoe1xuICogICBzZWxlY3RvcjogJ1t0b29sdGlwXScsXG4gKiAgIGlucHV0czogW1xuICogICAgICd0ZXh0OiB0b29sdGlwJ1xuICogICBdLFxuICogICBob3N0OiB7XG4gKiAgICAgJyhtb3VzZWVudGVyKSc6ICdvbk1vdXNlRW50ZXIoKScsXG4gKiAgICAgJyhtb3VzZWxlYXZlKSc6ICdvbk1vdXNlTGVhdmUoKSdcbiAqICAgfVxuICogfSlcbiAqIGNsYXNzIFRvb2x0aXB7XG4gKiAgIHRleHQ6c3RyaW5nO1xuICogICBvdmVybGF5Ok92ZXJsYXk7IC8vIE5PVCBZRVQgSU1QTEVNRU5URURcbiAqICAgb3ZlcmxheU1hbmFnZXI6T3ZlcmxheU1hbmFnZXI7IC8vIE5PVCBZRVQgSU1QTEVNRU5URURcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKG92ZXJsYXlNYW5hZ2VyOk92ZXJsYXlNYW5hZ2VyKSB7XG4gKiAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAqICAgfVxuICpcbiAqICAgb25Nb3VzZUVudGVyKCkge1xuICogICAgIC8vIGV4YWN0IHNpZ25hdHVyZSB0byBiZSBkZXRlcm1pbmVkXG4gKiAgICAgdGhpcy5vdmVybGF5ID0gdGhpcy5vdmVybGF5TWFuYWdlci5vcGVuKHRleHQsIC4uLik7XG4gKiAgIH1cbiAqXG4gKiAgIG9uTW91c2VMZWF2ZSgpIHtcbiAqICAgICB0aGlzLm92ZXJsYXkuY2xvc2UoKTtcbiAqICAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIEluIG91ciBIVE1MIHRlbXBsYXRlLCB3ZSBjYW4gdGhlbiBhZGQgdGhpcyBiZWhhdmlvciB0byBhIGA8ZGl2PmAgb3IgYW55IG90aGVyIGVsZW1lbnQgd2l0aCB0aGVcbiAqIGB0b29sdGlwYCBzZWxlY3RvcixcbiAqIGxpa2Ugc286XG4gKlxuICogYGBgXG4gKiA8ZGl2IHRvb2x0aXA9XCJzb21lIHRleHQgaGVyZVwiPjwvZGl2PlxuICogYGBgXG4gKlxuICogRGlyZWN0aXZlcyBjYW4gYWxzbyBjb250cm9sIHRoZSBpbnN0YW50aWF0aW9uLCBkZXN0cnVjdGlvbiwgYW5kIHBvc2l0aW9uaW5nIG9mIGlubGluZSB0ZW1wbGF0ZVxuICogZWxlbWVudHM6XG4gKlxuICogQSBkaXJlY3RpdmUgdXNlcyBhIHtAbGluayBWaWV3Q29udGFpbmVyUmVmfSB0byBpbnN0YW50aWF0ZSwgaW5zZXJ0LCBtb3ZlLCBhbmQgZGVzdHJveSB2aWV3cyBhdFxuICogcnVudGltZS5cbiAqIFRoZSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0gaXMgY3JlYXRlZCBhcyBhIHJlc3VsdCBvZiBgPHRlbXBsYXRlPmAgZWxlbWVudCwgYW5kIHJlcHJlc2VudHMgYVxuICogbG9jYXRpb24gaW4gdGhlIGN1cnJlbnQgdmlld1xuICogd2hlcmUgdGhlc2UgYWN0aW9ucyBhcmUgcGVyZm9ybWVkLlxuICpcbiAqIFZpZXdzIGFyZSBhbHdheXMgY3JlYXRlZCBhcyBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCB7QGxpbmsgVmlld01ldGFkYXRhfSwgYW5kIGFzIHNpYmxpbmdzIG9mIHRoZVxuICogYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuIFRodXMgYVxuICogZGlyZWN0aXZlIGluIGEgY2hpbGQgdmlldyBjYW5ub3QgaW5qZWN0IHRoZSBkaXJlY3RpdmUgdGhhdCBjcmVhdGVkIGl0LlxuICpcbiAqIFNpbmNlIGRpcmVjdGl2ZXMgdGhhdCBjcmVhdGUgdmlld3MgdmlhIFZpZXdDb250YWluZXJzIGFyZSBjb21tb24gaW4gQW5ndWxhciwgYW5kIHVzaW5nIHRoZSBmdWxsXG4gKiBgPHRlbXBsYXRlPmAgZWxlbWVudCBzeW50YXggaXMgd29yZHksIEFuZ3VsYXJcbiAqIGFsc28gc3VwcG9ydHMgYSBzaG9ydGhhbmQgbm90YXRpb246IGA8bGkgKmZvbz1cImJhclwiPmAgYW5kIGA8bGkgdGVtcGxhdGU9XCJmb286IGJhclwiPmAgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqIFRodXMsXG4gKlxuICogYGBgXG4gKiA8dWw+XG4gKiAgIDxsaSAqZm9vPVwiYmFyXCIgdGl0bGU9XCJ0ZXh0XCI+PC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBFeHBhbmRzIGluIHVzZSB0bzpcbiAqXG4gKiBgYGBcbiAqIDx1bD5cbiAqICAgPHRlbXBsYXRlIFtmb29dPVwiYmFyXCI+XG4gKiAgICAgPGxpIHRpdGxlPVwidGV4dFwiPjwvbGk+XG4gKiAgIDwvdGVtcGxhdGU+XG4gKiA8L3VsPlxuICogYGBgXG4gKlxuICogTm90aWNlIHRoYXQgYWx0aG91Z2ggdGhlIHNob3J0aGFuZCBwbGFjZXMgYCpmb289XCJiYXJcImAgd2l0aGluIHRoZSBgPGxpPmAgZWxlbWVudCwgdGhlIGJpbmRpbmcgZm9yXG4gKiB0aGUgZGlyZWN0aXZlXG4gKiBjb250cm9sbGVyIGlzIGNvcnJlY3RseSBpbnN0YW50aWF0ZWQgb24gdGhlIGA8dGVtcGxhdGU+YCBlbGVtZW50IHJhdGhlciB0aGFuIHRoZSBgPGxpPmAgZWxlbWVudC5cbiAqXG4gKiAjIyBMaWZlY3ljbGUgaG9va3NcbiAqXG4gKiBXaGVuIHRoZSBkaXJlY3RpdmUgY2xhc3MgaW1wbGVtZW50cyBzb21lIHtAbGluayAuLi8uLi9ndWlkZS9saWZlY3ljbGUtaG9va3MuaHRtbH0gdGhlIGNhbGxiYWNrc1xuICogYXJlIGNhbGxlZCBieSB0aGUgY2hhbmdlIGRldGVjdGlvbiBhdCBkZWZpbmVkIHBvaW50cyBpbiB0aW1lIGR1cmluZyB0aGUgbGlmZSBvZiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogTGV0J3Mgc3VwcG9zZSB3ZSB3YW50IHRvIGltcGxlbWVudCB0aGUgYHVubGVzc2AgYmVoYXZpb3IsIHRvIGNvbmRpdGlvbmFsbHkgaW5jbHVkZSBhIHRlbXBsYXRlLlxuICpcbiAqIEhlcmUgaXMgYSBzaW1wbGUgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcnMgb24gYW4gYHVubGVzc2Agc2VsZWN0b3I6XG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdbdW5sZXNzXScsXG4gKiAgIGlucHV0czogWyd1bmxlc3MnXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBVbmxlc3Mge1xuICogICB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmO1xuICogICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY7XG4gKiAgIHByZXZDb25kaXRpb246IGJvb2xlYW47XG4gKlxuICogICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWYpIHtcbiAqICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICogICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAqICAgICB0aGlzLnByZXZDb25kaXRpb24gPSBudWxsO1xuICogICB9XG4gKlxuICogICBzZXQgdW5sZXNzKG5ld0NvbmRpdGlvbikge1xuICogICAgIGlmIChuZXdDb25kaXRpb24gJiYgKGlzQmxhbmsodGhpcy5wcmV2Q29uZGl0aW9uKSB8fCAhdGhpcy5wcmV2Q29uZGl0aW9uKSkge1xuICogICAgICAgdGhpcy5wcmV2Q29uZGl0aW9uID0gdHJ1ZTtcbiAqICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICogICAgIH0gZWxzZSBpZiAoIW5ld0NvbmRpdGlvbiAmJiAoaXNCbGFuayh0aGlzLnByZXZDb25kaXRpb24pIHx8IHRoaXMucHJldkNvbmRpdGlvbikpIHtcbiAqICAgICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IGZhbHNlO1xuICogICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZSh0aGlzLnRlbXBsYXRlUmVmKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdlIGNhbiB0aGVuIHVzZSB0aGlzIGB1bmxlc3NgIHNlbGVjdG9yIGluIGEgdGVtcGxhdGU6XG4gKiBgYGBcbiAqIDx1bD5cbiAqICAgPGxpICp1bmxlc3M9XCJleHByXCI+PC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBPbmNlIHRoZSBkaXJlY3RpdmUgaW5zdGFudGlhdGVzIHRoZSBjaGlsZCB2aWV3LCB0aGUgc2hvcnRoYW5kIG5vdGF0aW9uIGZvciB0aGUgdGVtcGxhdGUgZXhwYW5kc1xuICogYW5kIHRoZSByZXN1bHQgaXM6XG4gKlxuICogYGBgXG4gKiA8dWw+XG4gKiAgIDx0ZW1wbGF0ZSBbdW5sZXNzXT1cImV4cFwiPlxuICogICAgIDxsaT48L2xpPlxuICogICA8L3RlbXBsYXRlPlxuICogICA8bGk+PC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBOb3RlIGFsc28gdGhhdCBhbHRob3VnaCB0aGUgYDxsaT48L2xpPmAgdGVtcGxhdGUgc3RpbGwgZXhpc3RzIGluc2lkZSB0aGUgYDx0ZW1wbGF0ZT48L3RlbXBsYXRlPmAsXG4gKiB0aGUgaW5zdGFudGlhdGVkXG4gKiB2aWV3IG9jY3VycyBvbiB0aGUgc2Vjb25kIGA8bGk+PC9saT5gIHdoaWNoIGlzIGEgc2libGluZyB0byB0aGUgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQuXG4gKi9cbmV4cG9ydHMuRGlyZWN0aXZlID0gZGVjb3JhdG9yc18xLm1ha2VEZWNvcmF0b3IoZGlyZWN0aXZlc18yLkRpcmVjdGl2ZU1ldGFkYXRhKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gVmlld01ldGFkYXRhLlxuLyoqXG4gKiBNZXRhZGF0YSBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBmb3IgY29uZmlndXJpbmcgVmlld3MuXG4gKlxuICogRWFjaCBBbmd1bGFyIGNvbXBvbmVudCByZXF1aXJlcyBhIHNpbmdsZSBgQENvbXBvbmVudGAgYW5kIGF0IGxlYXN0IG9uZSBgQFZpZXdgIGFubm90YXRpb24uIFRoZVxuICogYEBWaWV3YCBhbm5vdGF0aW9uIHNwZWNpZmllcyB0aGUgSFRNTCB0ZW1wbGF0ZSB0byB1c2UsIGFuZCBsaXN0cyB0aGUgZGlyZWN0aXZlcyB0aGF0IGFyZSBhY3RpdmVcbiAqIHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gKlxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQsIHRoZSB0ZW1wbGF0ZSBpcyBsb2FkZWQgaW50byB0aGUgY29tcG9uZW50J3Mgc2hhZG93IHJvb3QsIGFuZFxuICogdGhlIGV4cHJlc3Npb25zIGFuZCBzdGF0ZW1lbnRzIGluIHRoZSB0ZW1wbGF0ZSBhcmUgZXZhbHVhdGVkIGFnYWluc3QgdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgYEBDb21wb25lbnRgIGFubm90YXRpb24sIHNlZSB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdncmVldCcsXG4gKiAgIHRlbXBsYXRlOiAnSGVsbG8ge3tuYW1lfX0hJyxcbiAqICAgZGlyZWN0aXZlczogW0dyZWV0VXNlciwgQm9sZF1cbiAqIH0pXG4gKiBjbGFzcyBHcmVldCB7XG4gKiAgIG5hbWU6IHN0cmluZztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHRoaXMubmFtZSA9ICdXb3JsZCc7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG52YXIgVmlldyA9IGRlY29yYXRvcnNfMS5tYWtlRGVjb3JhdG9yKHZpZXdfMi5WaWV3TWV0YWRhdGEsIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4uVmlldyA9IFZpZXc7IH0pO1xuLyoqXG4gKiBTcGVjaWZpZXMgdGhhdCBhIGNvbnN0YW50IGF0dHJpYnV0ZSB2YWx1ZSBzaG91bGQgYmUgaW5qZWN0ZWQuXG4gKlxuICogVGhlIGRpcmVjdGl2ZSBjYW4gaW5qZWN0IGNvbnN0YW50IHN0cmluZyBsaXRlcmFscyBvZiBob3N0IGVsZW1lbnQgYXR0cmlidXRlcy5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFN1cHBvc2Ugd2UgaGF2ZSBhbiBgPGlucHV0PmAgZWxlbWVudCBhbmQgd2FudCB0byBrbm93IGl0cyBgdHlwZWAuXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IHR5cGU9XCJ0ZXh0XCI+XG4gKiBgYGBcbiAqXG4gKiBBIGRlY29yYXRvciBjYW4gaW5qZWN0IHN0cmluZyBsaXRlcmFsIGB0ZXh0YCBsaWtlIHNvOlxuICpcbiAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL21ldGFkYXRhLnRzIHJlZ2lvbj0nYXR0cmlidXRlTWV0YWRhdGEnfVxuICovXG5leHBvcnRzLkF0dHJpYnV0ZSA9IGRlY29yYXRvcnNfMS5tYWtlUGFyYW1EZWNvcmF0b3IoZGlfMi5BdHRyaWJ1dGVNZXRhZGF0YSk7XG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIFF1ZXJ5TWV0YWRhdGEuXG4vKipcbiAqIERlY2xhcmVzIGFuIGluamVjdGFibGUgcGFyYW1ldGVyIHRvIGJlIGEgbGl2ZSBsaXN0IG9mIGRpcmVjdGl2ZXMgb3IgdmFyaWFibGVcbiAqIGJpbmRpbmdzIGZyb20gdGhlIGNvbnRlbnQgY2hpbGRyZW4gb2YgYSBkaXJlY3RpdmUuXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2xZOW04SEx5N3owNnZEb1VhU04yP3A9cHJldmlldykpXG4gKlxuICogQXNzdW1lIHRoYXQgYDx0YWJzPmAgY29tcG9uZW50IHdvdWxkIGxpa2UgdG8gZ2V0IGEgbGlzdCBpdHMgY2hpbGRyZW4gYDxwYW5lPmBcbiAqIGNvbXBvbmVudHMgYXMgc2hvd24gaW4gdGhpcyBleGFtcGxlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDx0YWJzPlxuICogICA8cGFuZSB0aXRsZT1cIk92ZXJ2aWV3XCI+Li4uPC9wYW5lPlxuICogICA8cGFuZSAqbmdGb3I9XCJsZXQgbyBvZiBvYmplY3RzXCIgW3RpdGxlXT1cIm8udGl0bGVcIj57e28udGV4dH19PC9wYW5lPlxuICogPC90YWJzPlxuICogYGBgXG4gKlxuICogVGhlIHByZWZlcnJlZCBzb2x1dGlvbiBpcyB0byBxdWVyeSBmb3IgYFBhbmVgIGRpcmVjdGl2ZXMgdXNpbmcgdGhpcyBkZWNvcmF0b3IuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAncGFuZScsXG4gKiAgIGlucHV0czogWyd0aXRsZSddXG4gKiB9KVxuICogY2xhc3MgUGFuZSB7XG4gKiAgIHRpdGxlOnN0cmluZztcbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ3RhYnMnLFxuICogIHRlbXBsYXRlOiBgXG4gKiAgICA8dWw+XG4gKiAgICAgIDxsaSAqbmdGb3I9XCJsZXQgcGFuZSBvZiBwYW5lc1wiPnt7cGFuZS50aXRsZX19PC9saT5cbiAqICAgIDwvdWw+XG4gKiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gKiAgYFxuICogfSlcbiAqIGNsYXNzIFRhYnMge1xuICogICBwYW5lczogUXVlcnlMaXN0PFBhbmU+O1xuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoUGFuZSkgcGFuZXM6UXVlcnlMaXN0PFBhbmU+KSB7XG4gKiAgICAgdGhpcy5wYW5lcyA9IHBhbmVzO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBBIHF1ZXJ5IGNhbiBsb29rIGZvciB2YXJpYWJsZSBiaW5kaW5ncyBieSBwYXNzaW5nIGluIGEgc3RyaW5nIHdpdGggZGVzaXJlZCBiaW5kaW5nIHN5bWJvbC5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvc1QyajI1Y0gxZFVSQXlCUkNLeDE/cD1wcmV2aWV3KSlcbiAqIGBgYGh0bWxcbiAqIDxzZWVrZXI+XG4gKiAgIDxkaXYgI2ZpbmRtZT4uLi48L2Rpdj5cbiAqIDwvc2Vla2VyPlxuICpcbiAqIEBDb21wb25lbnQoeyBzZWxlY3RvcjogJ3NlZWtlcicgfSlcbiAqIGNsYXNzIHNlZWtlciB7XG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeSgnZmluZG1lJykgZWxMaXN0OiBRdWVyeUxpc3Q8RWxlbWVudFJlZj4pIHsuLi59XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJbiB0aGlzIGNhc2UgdGhlIG9iamVjdCB0aGF0IGlzIGluamVjdGVkIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiB0aGUgdmFyaWFibGVcbiAqIGJpbmRpbmcuIEl0IGNhbiBiZSBhbiBFbGVtZW50UmVmLCBhIGRpcmVjdGl2ZSBvciBhIGNvbXBvbmVudC5cbiAqXG4gKiBQYXNzaW5nIGluIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgdmFyaWFibGUgYmluZGluZ3Mgd2lsbCBxdWVyeSBmb3IgYWxsIG9mIHRoZW0uXG4gKlxuICogYGBgaHRtbFxuICogPHNlZWtlcj5cbiAqICAgPGRpdiAjZmluZE1lPi4uLjwvZGl2PlxuICogICA8ZGl2ICNmaW5kTWVUb28+Li4uPC9kaXY+XG4gKiA8L3NlZWtlcj5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnc2Vla2VyJ1xuICogfSlcbiAqIGNsYXNzIFNlZWtlciB7XG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeSgnZmluZE1lLCBmaW5kTWVUb28nKSBlbExpc3Q6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPikgey4uLn1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIENvbmZpZ3VyZSB3aGV0aGVyIHF1ZXJ5IGxvb2tzIGZvciBkaXJlY3QgY2hpbGRyZW4gb3IgYWxsIGRlc2NlbmRhbnRzXG4gKiBvZiB0aGUgcXVlcnlpbmcgZWxlbWVudCwgYnkgdXNpbmcgdGhlIGBkZXNjZW5kYW50c2AgcGFyYW1ldGVyLlxuICogSXQgaXMgc2V0IHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvd3RHZUI5NzdidjdxdkE1RlRZbDk/cD1wcmV2aWV3KSlcbiAqIGBgYGh0bWxcbiAqIDxjb250YWluZXIgI2ZpcnN0PlxuICogICA8aXRlbT5hPC9pdGVtPlxuICogICA8aXRlbT5iPC9pdGVtPlxuICogICA8Y29udGFpbmVyICNzZWNvbmQ+XG4gKiAgICAgPGl0ZW0+YzwvaXRlbT5cbiAqICAgPC9jb250YWluZXI+XG4gKiA8L2NvbnRhaW5lcj5cbiAqIGBgYFxuICpcbiAqIFdoZW4gcXVlcnlpbmcgZm9yIGl0ZW1zLCB0aGUgZmlyc3QgY29udGFpbmVyIHdpbGwgc2VlIG9ubHkgYGFgIGFuZCBgYmAgYnkgZGVmYXVsdCxcbiAqIGJ1dCB3aXRoIGBRdWVyeShUZXh0RGlyZWN0aXZlLCB7ZGVzY2VuZGFudHM6IHRydWV9KWAgaXQgd2lsbCBzZWUgYGNgIHRvby5cbiAqXG4gKiBUaGUgcXVlcmllZCBkaXJlY3RpdmVzIGFyZSBrZXB0IGluIGEgZGVwdGgtZmlyc3QgcHJlLW9yZGVyIHdpdGggcmVzcGVjdCB0byB0aGVpclxuICogcG9zaXRpb25zIGluIHRoZSBET00uXG4gKlxuICogUXVlcnkgZG9lcyBub3QgbG9vayBkZWVwIGludG8gYW55IHN1YmNvbXBvbmVudCB2aWV3cy5cbiAqXG4gKiBRdWVyeSBpcyB1cGRhdGVkIGFzIHBhcnQgb2YgdGhlIGNoYW5nZS1kZXRlY3Rpb24gY3ljbGUuIFNpbmNlIGNoYW5nZSBkZXRlY3Rpb25cbiAqIGhhcHBlbnMgYWZ0ZXIgY29uc3RydWN0aW9uIG9mIGEgZGlyZWN0aXZlLCBRdWVyeUxpc3Qgd2lsbCBhbHdheXMgYmUgZW1wdHkgd2hlbiBvYnNlcnZlZCBpbiB0aGVcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSBpbmplY3RlZCBvYmplY3QgaXMgYW4gdW5tb2RpZmlhYmxlIGxpdmUgbGlzdC5cbiAqIFNlZSB7QGxpbmsgUXVlcnlMaXN0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICovXG5leHBvcnRzLlF1ZXJ5ID0gZGVjb3JhdG9yc18xLm1ha2VQYXJhbURlY29yYXRvcihkaV8yLlF1ZXJ5TWV0YWRhdGEpO1xuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YS5cbi8qKlxuICogQ29uZmlndXJlcyBhIGNvbnRlbnQgcXVlcnkuXG4gKlxuICogQ29udGVudCBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgbmdBZnRlckNvbnRlbnRJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqIEBEaXJlY3RpdmUoe1xuICogICBzZWxlY3RvcjogJ3NvbWVEaXInXG4gKiB9KVxuICogY2xhc3MgU29tZURpciB7XG4gKiAgIEBDb250ZW50Q2hpbGRyZW4oQ2hpbGREaXJlY3RpdmUpIGNvbnRlbnRDaGlsZHJlbjogUXVlcnlMaXN0PENoaWxkRGlyZWN0aXZlPjtcbiAqXG4gKiAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAqICAgICAvLyBjb250ZW50Q2hpbGRyZW4gaXMgc2V0XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnRzLkNvbnRlbnRDaGlsZHJlbiA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaV8yLkNvbnRlbnRDaGlsZHJlbk1ldGFkYXRhKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gQ29udGVudENoaWxkTWV0YWRhdGEuXG4vKipcbiAqIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxuICpcbiAqIENvbnRlbnQgcXVlcmllcyBhcmUgc2V0IGJlZm9yZSB0aGUgYG5nQWZ0ZXJDb250ZW50SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJ1xuICogfSlcbiAqIGNsYXNzIFNvbWVEaXIge1xuICogICBAQ29udGVudENoaWxkKENoaWxkRGlyZWN0aXZlKSBjb250ZW50Q2hpbGQ7XG4gKlxuICogICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gKiAgICAgLy8gY29udGVudENoaWxkIGlzIHNldFxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5Db250ZW50Q2hpbGQgPSBkZWNvcmF0b3JzXzEubWFrZVByb3BEZWNvcmF0b3IoZGlfMi5Db250ZW50Q2hpbGRNZXRhZGF0YSk7XG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIFZpZXdDaGlsZHJlbk1ldGFkYXRhLlxuLyoqXG4gKiBEZWNsYXJlcyBhIGxpc3Qgb2YgY2hpbGQgZWxlbWVudCByZWZlcmVuY2VzLlxuICpcbiAqIEFuZ3VsYXIgYXV0b21hdGljYWxseSB1cGRhdGVzIHRoZSBsaXN0IHdoZW4gdGhlIERPTSBpcyB1cGRhdGVkLlxuICpcbiAqIGBWaWV3Q2hpbGRyZW5gIHRha2VzIGEgYXJndW1lbnQgdG8gc2VsZWN0IGVsZW1lbnRzLlxuICpcbiAqIC0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgdHlwZSwgZGlyZWN0aXZlcyBvciBjb21wb25lbnRzIHdpdGggdGhlIHR5cGUgd2lsbCBiZSBib3VuZC5cbiAqXG4gKiAtIElmIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZywgdGhlIHN0cmluZyBpcyBpbnRlcnByZXRlZCBhcyBhIGxpc3Qgb2YgY29tbWEtc2VwYXJhdGVkIHNlbGVjdG9ycy5cbiAqIEZvciBlYWNoIHNlbGVjdG9yLCBhbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIG1hdGNoaW5nIHRlbXBsYXRlIHZhcmlhYmxlIChlLmcuIGAjY2hpbGRgKSB3aWxsIGJlXG4gKiBib3VuZC5cbiAqXG4gKiBWaWV3IGNoaWxkcmVuIGFyZSBzZXQgYmVmb3JlIHRoZSBgbmdBZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBXaXRoIHR5cGUgc2VsZWN0b3I6XG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdjaGlsZC1jbXAnLFxuICogICB0ZW1wbGF0ZTogJzxwPmNoaWxkPC9wPidcbiAqIH0pXG4gKiBjbGFzcyBDaGlsZENtcCB7XG4gKiAgIGRvU29tZXRoaW5nKCkge31cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzb21lLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGNoaWxkLWNtcD48L2NoaWxkLWNtcD5cbiAqICAgICA8Y2hpbGQtY21wPjwvY2hpbGQtY21wPlxuICogICAgIDxjaGlsZC1jbXA+PC9jaGlsZC1jbXA+XG4gKiAgIGAsXG4gKiAgIGRpcmVjdGl2ZXM6IFtDaGlsZENtcF1cbiAqIH0pXG4gKiBjbGFzcyBTb21lQ21wIHtcbiAqICAgQFZpZXdDaGlsZHJlbihDaGlsZENtcCkgY2hpbGRyZW46UXVlcnlMaXN0PENoaWxkQ21wPjtcbiAqXG4gKiAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAqICAgICAvLyBjaGlsZHJlbiBhcmUgc2V0XG4gKiAgICAgdGhpcy5jaGlsZHJlbi50b0FycmF5KCkuZm9yRWFjaCgoY2hpbGQpPT5jaGlsZC5kb1NvbWV0aGluZygpKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogV2l0aCBzdHJpbmcgc2VsZWN0b3I6XG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdjaGlsZC1jbXAnLFxuICogICB0ZW1wbGF0ZTogJzxwPmNoaWxkPC9wPidcbiAqIH0pXG4gKiBjbGFzcyBDaGlsZENtcCB7XG4gKiAgIGRvU29tZXRoaW5nKCkge31cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzb21lLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGNoaWxkLWNtcCAjY2hpbGQxPjwvY2hpbGQtY21wPlxuICogICAgIDxjaGlsZC1jbXAgI2NoaWxkMj48L2NoaWxkLWNtcD5cbiAqICAgICA8Y2hpbGQtY21wICNjaGlsZDM+PC9jaGlsZC1jbXA+XG4gKiAgIGAsXG4gKiAgIGRpcmVjdGl2ZXM6IFtDaGlsZENtcF1cbiAqIH0pXG4gKiBjbGFzcyBTb21lQ21wIHtcbiAqICAgQFZpZXdDaGlsZHJlbignY2hpbGQxLGNoaWxkMixjaGlsZDMnKSBjaGlsZHJlbjpRdWVyeUxpc3Q8Q2hpbGRDbXA+O1xuICpcbiAqICAgbmdBZnRlclZpZXdJbml0KCkge1xuICogICAgIC8vIGNoaWxkcmVuIGFyZSBzZXRcbiAqICAgICB0aGlzLmNoaWxkcmVuLnRvQXJyYXkoKS5mb3JFYWNoKChjaGlsZCk9PmNoaWxkLmRvU29tZXRoaW5nKCkpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBTZWUgYWxzbzogW1ZpZXdDaGlsZHJlbk1ldGFkYXRhXVxuICovXG5leHBvcnRzLlZpZXdDaGlsZHJlbiA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaV8yLlZpZXdDaGlsZHJlbk1ldGFkYXRhKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gVmlld0NoaWxkTWV0YWRhdGEuXG4vKipcbiAqIERlY2xhcmVzIGEgcmVmZXJlbmNlIHRvIGEgY2hpbGQgZWxlbWVudC5cbiAqXG4gKiBgVmlld0NoaWxkcmVuYCB0YWtlcyBhIGFyZ3VtZW50IHRvIHNlbGVjdCBlbGVtZW50cy5cbiAqXG4gKiAtIElmIHRoZSBhcmd1bWVudCBpcyBhIHR5cGUsIGEgZGlyZWN0aXZlIG9yIGEgY29tcG9uZW50IHdpdGggdGhlIHR5cGUgd2lsbCBiZSBib3VuZC5cbiAqXG4gKiAtIElmIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZywgdGhlIHN0cmluZyBpcyBpbnRlcnByZXRlZCBhcyBhIHNlbGVjdG9yLiBBbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlXG4gKiBtYXRjaGluZyB0ZW1wbGF0ZSB2YXJpYWJsZSAoZS5nLiBgI2NoaWxkYCkgd2lsbCBiZSBib3VuZC5cbiAqXG4gKiBJbiBlaXRoZXIgY2FzZSwgYEBWaWV3Q2hpbGQoKWAgYXNzaWducyB0aGUgZmlyc3QgKGxvb2tpbmcgZnJvbSBhYm92ZSkgZWxlbWVudCBpZiB0aGVyZSBhcmVcbiAqIG11bHRpcGxlIG1hdGNoZXMuXG4gKlxuICogVmlldyBjaGlsZCBpcyBzZXQgYmVmb3JlIHRoZSBgbmdBZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBXaXRoIHR5cGUgc2VsZWN0b3I6XG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdjaGlsZC1jbXAnLFxuICogICB0ZW1wbGF0ZTogJzxwPmNoaWxkPC9wPidcbiAqIH0pXG4gKiBjbGFzcyBDaGlsZENtcCB7XG4gKiAgIGRvU29tZXRoaW5nKCkge31cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzb21lLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiAnPGNoaWxkLWNtcD48L2NoaWxkLWNtcD4nLFxuICogICBkaXJlY3RpdmVzOiBbQ2hpbGRDbXBdXG4gKiB9KVxuICogY2xhc3MgU29tZUNtcCB7XG4gKiAgIEBWaWV3Q2hpbGQoQ2hpbGRDbXApIGNoaWxkOkNoaWxkQ21wO1xuICpcbiAqICAgbmdBZnRlclZpZXdJbml0KCkge1xuICogICAgIC8vIGNoaWxkIGlzIHNldFxuICogICAgIHRoaXMuY2hpbGQuZG9Tb21ldGhpbmcoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogV2l0aCBzdHJpbmcgc2VsZWN0b3I6XG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdjaGlsZC1jbXAnLFxuICogICB0ZW1wbGF0ZTogJzxwPmNoaWxkPC9wPidcbiAqIH0pXG4gKiBjbGFzcyBDaGlsZENtcCB7XG4gKiAgIGRvU29tZXRoaW5nKCkge31cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzb21lLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiAnPGNoaWxkLWNtcCAjY2hpbGQ+PC9jaGlsZC1jbXA+JyxcbiAqICAgZGlyZWN0aXZlczogW0NoaWxkQ21wXVxuICogfSlcbiAqIGNsYXNzIFNvbWVDbXAge1xuICogICBAVmlld0NoaWxkKCdjaGlsZCcpIGNoaWxkOkNoaWxkQ21wO1xuICpcbiAqICAgbmdBZnRlclZpZXdJbml0KCkge1xuICogICAgIC8vIGNoaWxkIGlzIHNldFxuICogICAgIHRoaXMuY2hpbGQuZG9Tb21ldGhpbmcoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiBTZWUgYWxzbzogW1ZpZXdDaGlsZE1ldGFkYXRhXVxuICovXG5leHBvcnRzLlZpZXdDaGlsZCA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaV8yLlZpZXdDaGlsZE1ldGFkYXRhKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gVmlld1F1ZXJ5TWV0YWRhdGEuXG4vKipcbiAqIFNpbWlsYXIgdG8ge0BsaW5rIFF1ZXJ5TWV0YWRhdGF9LCBidXQgcXVlcnlpbmcgdGhlIGNvbXBvbmVudCB2aWV3LCBpbnN0ZWFkIG9mXG4gKiB0aGUgY29udGVudCBjaGlsZHJlbi5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZU5zRkhEZjdZanlNNkl6S3hNMWo/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBAQ29tcG9uZW50KHtcbiAqICAgLi4uLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxpdGVtPiBhIDwvaXRlbT5cbiAqICAgICA8aXRlbT4gYiA8L2l0ZW0+XG4gKiAgICAgPGl0ZW0+IGMgPC9pdGVtPlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgTXlDb21wb25lbnQge1xuICogICBzaG93bjogYm9vbGVhbjtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgQFF1ZXJ5KEl0ZW0pIGl0ZW1zOlF1ZXJ5TGlzdDxJdGVtPikge1xuICogICAgIGl0ZW1zLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IGNvbnNvbGUubG9nKGl0ZW1zLmxlbmd0aCkpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBTdXBwb3J0cyB0aGUgc2FtZSBxdWVyeWluZyBwYXJhbWV0ZXJzIGFzIHtAbGluayBRdWVyeU1ldGFkYXRhfSwgZXhjZXB0XG4gKiBgZGVzY2VuZGFudHNgLiBUaGlzIGFsd2F5cyBxdWVyaWVzIHRoZSB3aG9sZSB2aWV3LlxuICpcbiAqIEFzIGBzaG93bmAgaXMgZmxpcHBlZCBiZXR3ZWVuIHRydWUgYW5kIGZhbHNlLCBpdGVtcyB3aWxsIGNvbnRhaW4gemVybyBvZiBvbmVcbiAqIGl0ZW1zLlxuICpcbiAqIFNwZWNpZmllcyB0aGF0IGEge0BsaW5rIFF1ZXJ5TGlzdH0gc2hvdWxkIGJlIGluamVjdGVkLlxuICpcbiAqIFRoZSBpbmplY3RlZCBvYmplY3QgaXMgYW4gaXRlcmFibGUgYW5kIG9ic2VydmFibGUgbGl2ZSBsaXN0LlxuICogU2VlIHtAbGluayBRdWVyeUxpc3R9IGZvciBtb3JlIGRldGFpbHMuXG4gKi9cbmV4cG9ydHMuVmlld1F1ZXJ5ID0gZGVjb3JhdG9yc18xLm1ha2VQYXJhbURlY29yYXRvcihkaV8yLlZpZXdRdWVyeU1ldGFkYXRhKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gUGlwZU1ldGFkYXRhLlxuLyoqXG4gKiBEZWNsYXJlIHJldXNhYmxlIHBpcGUgZnVuY3Rpb24uXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9tZXRhZGF0YS50cyByZWdpb249J3BpcGUnfVxuICovXG5leHBvcnRzLlBpcGUgPSBkZWNvcmF0b3JzXzEubWFrZURlY29yYXRvcihkaXJlY3RpdmVzXzIuUGlwZU1ldGFkYXRhKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gSW5wdXRNZXRhZGF0YS5cbi8qKlxuICogRGVjbGFyZXMgYSBkYXRhLWJvdW5kIGlucHV0IHByb3BlcnR5LlxuICpcbiAqIEFuZ3VsYXIgYXV0b21hdGljYWxseSB1cGRhdGVzIGRhdGEtYm91bmQgcHJvcGVydGllcyBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbi5cbiAqXG4gKiBgSW5wdXRNZXRhZGF0YWAgdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lXG4gKiB1c2VkIHdoZW4gaW5zdGFudGlhdGluZyBhIGNvbXBvbmVudCBpbiB0aGUgdGVtcGxhdGUuIFdoZW4gbm90IHByb3ZpZGVkLFxuICogdGhlIG5hbWUgb2YgdGhlIGRlY29yYXRlZCBwcm9wZXJ0eSBpcyB1c2VkLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBjb21wb25lbnQgd2l0aCB0d28gaW5wdXQgcHJvcGVydGllcy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdiYW5rLWFjY291bnQnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIEJhbmsgTmFtZToge3tiYW5rTmFtZX19XG4gKiAgICAgQWNjb3VudCBJZDoge3tpZH19XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBCYW5rQWNjb3VudCB7XG4gKiAgIEBJbnB1dCgpIGJhbmtOYW1lOiBzdHJpbmc7XG4gKiAgIEBJbnB1dCgnYWNjb3VudC1pZCcpIGlkOiBzdHJpbmc7XG4gKlxuICogICAvLyB0aGlzIHByb3BlcnR5IGlzIG5vdCBib3VuZCwgYW5kIHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBieSBBbmd1bGFyXG4gKiAgIG5vcm1hbGl6ZWRCYW5rTmFtZTogc3RyaW5nO1xuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGJhbmstYWNjb3VudCBiYW5rLW5hbWU9XCJSQkNcIiBhY2NvdW50LWlkPVwiNDc0N1wiPjwvYmFuay1hY2NvdW50PlxuICogICBgLFxuICogICBkaXJlY3RpdmVzOiBbQmFua0FjY291bnRdXG4gKiB9KVxuICogY2xhc3MgQXBwIHt9XG4gKlxuICogYm9vdHN0cmFwKEFwcCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5JbnB1dCA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaXJlY3RpdmVzXzIuSW5wdXRNZXRhZGF0YSk7XG4vLyBUT0RPKGFsZXhlYWdsZSk6IHJlbW92ZSB0aGUgZHVwbGljYXRpb24gb2YgdGhpcyBkb2MuIEl0IGlzIGNvcGllZCBmcm9tIE91dHB1dE1ldGFkYXRhLlxuLyoqXG4gKiBEZWNsYXJlcyBhbiBldmVudC1ib3VuZCBvdXRwdXQgcHJvcGVydHkuXG4gKlxuICogV2hlbiBhbiBvdXRwdXQgcHJvcGVydHkgZW1pdHMgYW4gZXZlbnQsIGFuIGV2ZW50IGhhbmRsZXIgYXR0YWNoZWQgdG8gdGhhdCBldmVudFxuICogdGhlIHRlbXBsYXRlIGlzIGludm9rZWQuXG4gKlxuICogYE91dHB1dE1ldGFkYXRhYCB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWVcbiAqIHVzZWQgd2hlbiBpbnN0YW50aWF0aW5nIGEgY29tcG9uZW50IGluIHRoZSB0ZW1wbGF0ZS4gV2hlbiBub3QgcHJvdmlkZWQsXG4gKiB0aGUgbmFtZSBvZiB0aGUgZGVjb3JhdGVkIHByb3BlcnR5IGlzIHVzZWQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdpbnRlcnZhbC1kaXInLFxuICogfSlcbiAqIGNsYXNzIEludGVydmFsRGlyIHtcbiAqICAgQE91dHB1dCgpIGV2ZXJ5U2Vjb25kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICogICBAT3V0cHV0KCdldmVyeUZpdmVTZWNvbmRzJykgZml2ZTVTZWNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICpcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5ldmVyeVNlY29uZC5lbWl0KFwiZXZlbnRcIiksIDEwMDApO1xuICogICAgIHNldEludGVydmFsKCgpID0+IHRoaXMuZml2ZTVTZWNzLmVtaXQoXCJldmVudFwiKSwgNTAwMCk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdhcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxpbnRlcnZhbC1kaXIgKGV2ZXJ5U2Vjb25kKT1cImV2ZXJ5U2Vjb25kKClcIiAoZXZlcnlGaXZlU2Vjb25kcyk9XCJldmVyeUZpdmVTZWNvbmRzKClcIj5cbiAqICAgICA8L2ludGVydmFsLWRpcj5cbiAqICAgYCxcbiAqICAgZGlyZWN0aXZlczogW0ludGVydmFsRGlyXVxuICogfSlcbiAqIGNsYXNzIEFwcCB7XG4gKiAgIGV2ZXJ5U2Vjb25kKCkgeyBjb25zb2xlLmxvZygnc2Vjb25kJyk7IH1cbiAqICAgZXZlcnlGaXZlU2Vjb25kcygpIHsgY29uc29sZS5sb2coJ2ZpdmUgc2Vjb25kcycpOyB9XG4gKiB9XG4gKiBib290c3RyYXAoQXBwKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLk91dHB1dCA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaXJlY3RpdmVzXzIuT3V0cHV0TWV0YWRhdGEpO1xuLy8gVE9ETyhhbGV4ZWFnbGUpOiByZW1vdmUgdGhlIGR1cGxpY2F0aW9uIG9mIHRoaXMgZG9jLiBJdCBpcyBjb3BpZWQgZnJvbSBIb3N0QmluZGluZ01ldGFkYXRhLlxuLyoqXG4gKiBEZWNsYXJlcyBhIGhvc3QgcHJvcGVydHkgYmluZGluZy5cbiAqXG4gKiBBbmd1bGFyIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGhvc3QgcHJvcGVydHkgYmluZGluZ3MgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24uXG4gKiBJZiBhIGJpbmRpbmcgY2hhbmdlcywgaXQgd2lsbCB1cGRhdGUgdGhlIGhvc3QgZWxlbWVudCBvZiB0aGUgZGlyZWN0aXZlLlxuICpcbiAqIGBIb3N0QmluZGluZ01ldGFkYXRhYCB0YWtlcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIHByb3BlcnR5XG4gKiBuYW1lIG9mIHRoZSBob3N0IGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVwZGF0ZWQuIFdoZW4gbm90IHByb3ZpZGVkLFxuICogdGhlIGNsYXNzIHByb3BlcnR5IG5hbWUgaXMgdXNlZC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBjcmVhdGVzIGEgZGlyZWN0aXZlIHRoYXQgc2V0cyB0aGUgYHZhbGlkYCBhbmQgYGludmFsaWRgIGNsYXNzZXNcbiAqIG9uIHRoZSBET00gZWxlbWVudCB0aGF0IGhhcyBuZ01vZGVsIGRpcmVjdGl2ZSBvbiBpdC5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tuZ01vZGVsXSd9KVxuICogY2xhc3MgTmdNb2RlbFN0YXR1cyB7XG4gKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjb250cm9sOk5nTW9kZWwpIHt9XG4gKiAgIEBIb3N0QmluZGluZygnW2NsYXNzLnZhbGlkXScpIGdldCB2YWxpZCB7IHJldHVybiB0aGlzLmNvbnRyb2wudmFsaWQ7IH1cbiAqICAgQEhvc3RCaW5kaW5nKCdbY2xhc3MuaW52YWxpZF0nKSBnZXQgaW52YWxpZCB7IHJldHVybiB0aGlzLmNvbnRyb2wuaW52YWxpZDsgfVxuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHRlbXBsYXRlOiBgPGlucHV0IFsobmdNb2RlbCldPVwicHJvcFwiPmAsXG4gKiAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVMsIE5nTW9kZWxTdGF0dXNdXG4gKiB9KVxuICogY2xhc3MgQXBwIHtcbiAqICAgcHJvcDtcbiAqIH1cbiAqXG4gKiBib290c3RyYXAoQXBwKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLkhvc3RCaW5kaW5nID0gZGVjb3JhdG9yc18xLm1ha2VQcm9wRGVjb3JhdG9yKGRpcmVjdGl2ZXNfMi5Ib3N0QmluZGluZ01ldGFkYXRhKTtcbi8vIFRPRE8oYWxleGVhZ2xlKTogcmVtb3ZlIHRoZSBkdXBsaWNhdGlvbiBvZiB0aGlzIGRvYy4gSXQgaXMgY29waWVkIGZyb20gSG9zdExpc3RlbmVyTWV0YWRhdGEuXG4vKipcbiAqIERlY2xhcmVzIGEgaG9zdCBsaXN0ZW5lci5cbiAqXG4gKiBBbmd1bGFyIHdpbGwgaW52b2tlIHRoZSBkZWNvcmF0ZWQgbWV0aG9kIHdoZW4gdGhlIGhvc3QgZWxlbWVudCBlbWl0cyB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIElmIHRoZSBkZWNvcmF0ZWQgbWV0aG9kIHJldHVybnMgYGZhbHNlYCwgdGhlbiBgcHJldmVudERlZmF1bHRgIGlzIGFwcGxpZWQgb24gdGhlIERPTVxuICogZXZlbnQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVjbGFyZXMgYSBkaXJlY3RpdmUgdGhhdCBhdHRhY2hlcyBhIGNsaWNrIGxpc3RlbmVyIHRvIHRoZSBidXR0b24gYW5kXG4gKiBjb3VudHMgY2xpY2tzLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBEaXJlY3RpdmUoe3NlbGVjdG9yOiAnYnV0dG9uW2NvdW50aW5nXSd9KVxuICogY2xhc3MgQ291bnRDbGlja3Mge1xuICogICBudW1iZXJPZkNsaWNrcyA9IDA7XG4gKlxuICogICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LnRhcmdldCddKVxuICogICBvbkNsaWNrKGJ0bikge1xuICogICAgIGNvbnNvbGUubG9nKFwiYnV0dG9uXCIsIGJ0biwgXCJudW1iZXIgb2YgY2xpY2tzOlwiLCB0aGlzLm51bWJlck9mQ2xpY2tzKyspO1xuICogICB9XG4gKiB9XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcbiAqICAgdGVtcGxhdGU6IGA8YnV0dG9uIGNvdW50aW5nPkluY3JlbWVudDwvYnV0dG9uPmAsXG4gKiAgIGRpcmVjdGl2ZXM6IFtDb3VudENsaWNrc11cbiAqIH0pXG4gKiBjbGFzcyBBcHAge31cbiAqXG4gKiBib290c3RyYXAoQXBwKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLkhvc3RMaXN0ZW5lciA9IGRlY29yYXRvcnNfMS5tYWtlUHJvcERlY29yYXRvcihkaXJlY3RpdmVzXzIuSG9zdExpc3RlbmVyTWV0YWRhdGEpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBtZXRhZGF0YV8xID0gcmVxdWlyZSgnLi4vZGkvbWV0YWRhdGEnKTtcbnZhciBmb3J3YXJkX3JlZl8xID0gcmVxdWlyZSgnLi4vZGkvZm9yd2FyZF9yZWYnKTtcbi8qKlxuICogU3BlY2lmaWVzIHRoYXQgYSBjb25zdGFudCBhdHRyaWJ1dGUgdmFsdWUgc2hvdWxkIGJlIGluamVjdGVkLlxuICpcbiAqIFRoZSBkaXJlY3RpdmUgY2FuIGluamVjdCBjb25zdGFudCBzdHJpbmcgbGl0ZXJhbHMgb2YgaG9zdCBlbGVtZW50IGF0dHJpYnV0ZXMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBTdXBwb3NlIHdlIGhhdmUgYW4gYDxpbnB1dD5gIGVsZW1lbnQgYW5kIHdhbnQgdG8ga25vdyBpdHMgYHR5cGVgLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCB0eXBlPVwidGV4dFwiPlxuICogYGBgXG4gKlxuICogQSBkZWNvcmF0b3IgY2FuIGluamVjdCBzdHJpbmcgbGl0ZXJhbCBgdGV4dGAgbGlrZSBzbzpcbiAqXG4gKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9tZXRhZGF0YS50cyByZWdpb249J2F0dHJpYnV0ZU1ldGFkYXRhJ31cbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBBdHRyaWJ1dGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF0dHJpYnV0ZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZU1ldGFkYXRhKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdHRyaWJ1dGVNZXRhZGF0YS5wcm90b3R5cGUsIFwidG9rZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IG9uZSB3b3VsZCBkZWZhdWx0IGEgdG9rZW4gdG8gYSB0eXBlIG9mIGFuIGluamVjdGVkIHZhbHVlIGJ1dCBoZXJlXG4gICAgICAgICAgICAvLyB0aGUgdHlwZSBvZiBhIHZhcmlhYmxlIGlzIFwic3RyaW5nXCIgYW5kIHdlIGNhbid0IHVzZSBwcmltaXRpdmUgdHlwZSBhcyBhIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLy8gc28gd2UgdXNlIGluc3RhbmNlIG9mIEF0dHJpYnV0ZSBpbnN0ZWFkLiBUaGlzIGRvZXNuJ3QgbWF0dGVyIG11Y2ggaW4gcHJhY3RpY2UgYXMgYXJndW1lbnRzXG4gICAgICAgICAgICAvLyB3aXRoIEBBdHRyaWJ1dGUgYW5ub3RhdGlvbiBhcmUgaW5qZWN0ZWQgYnkgRWxlbWVudEluamVjdG9yIHRoYXQgZG9lc24ndCB0YWtlIHRva2VucyBpbnRvXG4gICAgICAgICAgICAvLyBhY2NvdW50LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEF0dHJpYnV0ZU1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQEF0dHJpYnV0ZShcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5hdHRyaWJ1dGVOYW1lKSArIFwiKVwiOyB9O1xuICAgIHJldHVybiBBdHRyaWJ1dGVNZXRhZGF0YTtcbn0obWV0YWRhdGFfMS5EZXBlbmRlbmN5TWV0YWRhdGEpKTtcbmV4cG9ydHMuQXR0cmlidXRlTWV0YWRhdGEgPSBBdHRyaWJ1dGVNZXRhZGF0YTtcbi8qKlxuICogRGVjbGFyZXMgYW4gaW5qZWN0YWJsZSBwYXJhbWV0ZXIgdG8gYmUgYSBsaXZlIGxpc3Qgb2YgZGlyZWN0aXZlcyBvciB2YXJpYWJsZVxuICogYmluZGluZ3MgZnJvbSB0aGUgY29udGVudCBjaGlsZHJlbiBvZiBhIGRpcmVjdGl2ZS5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvbFk5bThITHk3ejA2dkRvVWFTTjI/cD1wcmV2aWV3KSlcbiAqXG4gKiBBc3N1bWUgdGhhdCBgPHRhYnM+YCBjb21wb25lbnQgd291bGQgbGlrZSB0byBnZXQgYSBsaXN0IGl0cyBjaGlsZHJlbiBgPHBhbmU+YFxuICogY29tcG9uZW50cyBhcyBzaG93biBpbiB0aGlzIGV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPHRhYnM+XG4gKiAgIDxwYW5lIHRpdGxlPVwiT3ZlcnZpZXdcIj4uLi48L3BhbmU+XG4gKiAgIDxwYW5lICpuZ0Zvcj1cImxldCBvIG9mIG9iamVjdHNcIiBbdGl0bGVdPVwiby50aXRsZVwiPnt7by50ZXh0fX08L3BhbmU+XG4gKiA8L3RhYnM+XG4gKiBgYGBcbiAqXG4gKiBUaGUgcHJlZmVycmVkIHNvbHV0aW9uIGlzIHRvIHF1ZXJ5IGZvciBgUGFuZWAgZGlyZWN0aXZlcyB1c2luZyB0aGlzIGRlY29yYXRvci5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdwYW5lJyxcbiAqICAgaW5wdXRzOiBbJ3RpdGxlJ11cbiAqIH0pXG4gKiBjbGFzcyBQYW5lIHtcbiAqICAgdGl0bGU6c3RyaW5nO1xuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAndGFicycsXG4gKiAgdGVtcGxhdGU6IGBcbiAqICAgIDx1bD5cbiAqICAgICAgPGxpICpuZ0Zvcj1cImxldCBwYW5lIG9mIHBhbmVzXCI+e3twYW5lLnRpdGxlfX08L2xpPlxuICogICAgPC91bD5cbiAqICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAqICBgXG4gKiB9KVxuICogY2xhc3MgVGFicyB7XG4gKiAgIHBhbmVzOiBRdWVyeUxpc3Q8UGFuZT47XG4gKiAgIGNvbnN0cnVjdG9yKEBRdWVyeShQYW5lKSBwYW5lczpRdWVyeUxpc3Q8UGFuZT4pIHtcbiAgKiAgICB0aGlzLnBhbmVzID0gcGFuZXM7XG4gICogIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEEgcXVlcnkgY2FuIGxvb2sgZm9yIHZhcmlhYmxlIGJpbmRpbmdzIGJ5IHBhc3NpbmcgaW4gYSBzdHJpbmcgd2l0aCBkZXNpcmVkIGJpbmRpbmcgc3ltYm9sLlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9zVDJqMjVjSDFkVVJBeUJSQ0t4MT9wPXByZXZpZXcpKVxuICogYGBgaHRtbFxuICogPHNlZWtlcj5cbiAqICAgPGRpdiAjZmluZG1lPi4uLjwvZGl2PlxuICogPC9zZWVrZXI+XG4gKlxuICogQENvbXBvbmVudCh7IHNlbGVjdG9yOiAnc2Vla2VyJyB9KVxuICogY2xhc3MgU2Vla2VyIHtcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KCdmaW5kbWUnKSBlbExpc3Q6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPikgey4uLn1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEluIHRoaXMgY2FzZSB0aGUgb2JqZWN0IHRoYXQgaXMgaW5qZWN0ZWQgZGVwZW5kIG9uIHRoZSB0eXBlIG9mIHRoZSB2YXJpYWJsZVxuICogYmluZGluZy4gSXQgY2FuIGJlIGFuIEVsZW1lbnRSZWYsIGEgZGlyZWN0aXZlIG9yIGEgY29tcG9uZW50LlxuICpcbiAqIFBhc3NpbmcgaW4gYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiB2YXJpYWJsZSBiaW5kaW5ncyB3aWxsIHF1ZXJ5IGZvciBhbGwgb2YgdGhlbS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8c2Vla2VyPlxuICogICA8ZGl2ICNmaW5kLW1lPi4uLjwvZGl2PlxuICogICA8ZGl2ICNmaW5kLW1lLXRvbz4uLi48L2Rpdj5cbiAqIDwvc2Vla2VyPlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzZWVrZXInXG4gKiB9KVxuICogY2xhc3MgU2Vla2VyIHtcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KCdmaW5kTWUsIGZpbmRNZVRvbycpIGVsTGlzdDogUXVlcnlMaXN0PEVsZW1lbnRSZWY+KSB7Li4ufVxuICogfVxuICogYGBgXG4gKlxuICogQ29uZmlndXJlIHdoZXRoZXIgcXVlcnkgbG9va3MgZm9yIGRpcmVjdCBjaGlsZHJlbiBvciBhbGwgZGVzY2VuZGFudHNcbiAqIG9mIHRoZSBxdWVyeWluZyBlbGVtZW50LCBieSB1c2luZyB0aGUgYGRlc2NlbmRhbnRzYCBwYXJhbWV0ZXIuXG4gKiBJdCBpcyBzZXQgdG8gYGZhbHNlYCBieSBkZWZhdWx0LlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC93dEdlQjk3N2J2N3F2QTVGVFlsOT9wPXByZXZpZXcpKVxuICogYGBgaHRtbFxuICogPGNvbnRhaW5lciAjZmlyc3Q+XG4gKiAgIDxpdGVtPmE8L2l0ZW0+XG4gKiAgIDxpdGVtPmI8L2l0ZW0+XG4gKiAgIDxjb250YWluZXIgI3NlY29uZD5cbiAqICAgICA8aXRlbT5jPC9pdGVtPlxuICogICA8L2NvbnRhaW5lcj5cbiAqIDwvY29udGFpbmVyPlxuICogYGBgXG4gKlxuICogV2hlbiBxdWVyeWluZyBmb3IgaXRlbXMsIHRoZSBmaXJzdCBjb250YWluZXIgd2lsbCBzZWUgb25seSBgYWAgYW5kIGBiYCBieSBkZWZhdWx0LFxuICogYnV0IHdpdGggYFF1ZXJ5KFRleHREaXJlY3RpdmUsIHtkZXNjZW5kYW50czogdHJ1ZX0pYCBpdCB3aWxsIHNlZSBgY2AgdG9vLlxuICpcbiAqIFRoZSBxdWVyaWVkIGRpcmVjdGl2ZXMgYXJlIGtlcHQgaW4gYSBkZXB0aC1maXJzdCBwcmUtb3JkZXIgd2l0aCByZXNwZWN0IHRvIHRoZWlyXG4gKiBwb3NpdGlvbnMgaW4gdGhlIERPTS5cbiAqXG4gKiBRdWVyeSBkb2VzIG5vdCBsb29rIGRlZXAgaW50byBhbnkgc3ViY29tcG9uZW50IHZpZXdzLlxuICpcbiAqIFF1ZXJ5IGlzIHVwZGF0ZWQgYXMgcGFydCBvZiB0aGUgY2hhbmdlLWRldGVjdGlvbiBjeWNsZS4gU2luY2UgY2hhbmdlIGRldGVjdGlvblxuICogaGFwcGVucyBhZnRlciBjb25zdHJ1Y3Rpb24gb2YgYSBkaXJlY3RpdmUsIFF1ZXJ5TGlzdCB3aWxsIGFsd2F5cyBiZSBlbXB0eSB3aGVuIG9ic2VydmVkIGluIHRoZVxuICogY29uc3RydWN0b3IuXG4gKlxuICogVGhlIGluamVjdGVkIG9iamVjdCBpcyBhbiB1bm1vZGlmaWFibGUgbGl2ZSBsaXN0LlxuICogU2VlIHtAbGluayBRdWVyeUxpc3R9IGZvciBtb3JlIGRldGFpbHMuXG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgUXVlcnlNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1ZXJ5TWV0YWRhdGEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUXVlcnlNZXRhZGF0YShfc2VsZWN0b3IsIF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9iLmZpcnN0LCBmaXJzdCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBfZSA9IF9iLnJlYWQsIHJlYWQgPSBfZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9lO1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBfc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZGVzY2VuZGFudHMgPSBkZXNjZW5kYW50cztcbiAgICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgICAgICB0aGlzLnJlYWQgPSByZWFkO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlNZXRhZGF0YS5wcm90b3R5cGUsIFwiaXNWaWV3UXVlcnlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogYWx3YXlzIGBmYWxzZWAgdG8gZGlmZmVyZW50aWF0ZSBpdCB3aXRoIHtAbGluayBWaWV3UXVlcnlNZXRhZGF0YX0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlNZXRhZGF0YS5wcm90b3R5cGUsIFwic2VsZWN0b3JcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogd2hhdCB0aGlzIGlzIHF1ZXJ5aW5nIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZm9yd2FyZF9yZWZfMS5yZXNvbHZlRm9yd2FyZFJlZih0aGlzLl9zZWxlY3Rvcik7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpc1ZhckJpbmRpbmdRdWVyeVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIHRoaXMgaXMgcXVlcnlpbmcgZm9yIGEgdmFyaWFibGUgYmluZGluZyBvciBhIGRpcmVjdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzU3RyaW5nKHRoaXMuc2VsZWN0b3IpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlNZXRhZGF0YS5wcm90b3R5cGUsIFwidmFyQmluZGluZ3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyBhIGxpc3Qgb2YgdmFyaWFibGUgYmluZGluZ3MgdGhpcyBpcyBxdWVyeWluZyBmb3IuXG4gICAgICAgICAqIE9ubHkgYXBwbGljYWJsZSBpZiB0aGlzIGlzIGEgdmFyaWFibGUgYmluZGluZ3MgcXVlcnkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc2VsZWN0b3Iuc3BsaXQoJywnKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUXVlcnlNZXRhZGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkBRdWVyeShcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5zZWxlY3RvcikgKyBcIilcIjsgfTtcbiAgICByZXR1cm4gUXVlcnlNZXRhZGF0YTtcbn0obWV0YWRhdGFfMS5EZXBlbmRlbmN5TWV0YWRhdGEpKTtcbmV4cG9ydHMuUXVlcnlNZXRhZGF0YSA9IFF1ZXJ5TWV0YWRhdGE7XG4vLyBUT0RPOiBhZGQgYW4gZXhhbXBsZSBhZnRlciBDb250ZW50Q2hpbGRyZW4gYW5kIFZpZXdDaGlsZHJlbiBhcmUgaW4gbWFzdGVyXG4vKipcbiAqIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxuICpcbiAqIENvbnRlbnQgcXVlcmllcyBhcmUgc2V0IGJlZm9yZSB0aGUgYG5nQWZ0ZXJDb250ZW50SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdzb21lRGlyJ1xuICogfSlcbiAqIGNsYXNzIFNvbWVEaXIge1xuICogICBAQ29udGVudENoaWxkcmVuKENoaWxkRGlyZWN0aXZlKSBjb250ZW50Q2hpbGRyZW46IFF1ZXJ5TGlzdDxDaGlsZERpcmVjdGl2ZT47XG4gKlxuICogICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gKiAgICAgLy8gY29udGVudENoaWxkcmVuIGlzIHNldFxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRlbnRDaGlsZHJlbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRlbnRDaGlsZHJlbk1ldGFkYXRhKF9zZWxlY3RvciwgX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2IucmVhZCwgcmVhZCA9IF9kID09PSB2b2lkIDAgPyBudWxsIDogX2Q7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF9zZWxlY3RvciwgeyBkZXNjZW5kYW50czogZGVzY2VuZGFudHMsIHJlYWQ6IHJlYWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBDb250ZW50Q2hpbGRyZW5NZXRhZGF0YTtcbn0oUXVlcnlNZXRhZGF0YSkpO1xuZXhwb3J0cy5Db250ZW50Q2hpbGRyZW5NZXRhZGF0YSA9IENvbnRlbnRDaGlsZHJlbk1ldGFkYXRhO1xuLy8gVE9ETzogYWRkIGFuIGV4YW1wbGUgYWZ0ZXIgQ29udGVudENoaWxkIGFuZCBWaWV3Q2hpbGQgYXJlIGluIG1hc3RlclxuLyoqXG4gKiBDb25maWd1cmVzIGEgY29udGVudCBxdWVyeS5cbiAqXG4gKiBDb250ZW50IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBuZ0FmdGVyQ29udGVudEluaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogQERpcmVjdGl2ZSh7XG4gKiAgIHNlbGVjdG9yOiAnc29tZURpcidcbiAqIH0pXG4gKiBjbGFzcyBTb21lRGlyIHtcbiAqICAgQENvbnRlbnRDaGlsZChDaGlsZERpcmVjdGl2ZSkgY29udGVudENoaWxkO1xuICpcbiAqICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICogICAgIC8vIGNvbnRlbnRDaGlsZCBpcyBzZXRcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgQ29udGVudENoaWxkTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250ZW50Q2hpbGRNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250ZW50Q2hpbGRNZXRhZGF0YShfc2VsZWN0b3IsIF9hKSB7XG4gICAgICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkucmVhZCwgcmVhZCA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2I7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF9zZWxlY3RvciwgeyBkZXNjZW5kYW50czogdHJ1ZSwgZmlyc3Q6IHRydWUsIHJlYWQ6IHJlYWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBDb250ZW50Q2hpbGRNZXRhZGF0YTtcbn0oUXVlcnlNZXRhZGF0YSkpO1xuZXhwb3J0cy5Db250ZW50Q2hpbGRNZXRhZGF0YSA9IENvbnRlbnRDaGlsZE1ldGFkYXRhO1xuLyoqXG4gKiBTaW1pbGFyIHRvIHtAbGluayBRdWVyeU1ldGFkYXRhfSwgYnV0IHF1ZXJ5aW5nIHRoZSBjb21wb25lbnQgdmlldywgaW5zdGVhZCBvZlxuICogdGhlIGNvbnRlbnQgY2hpbGRyZW4uXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2VOc0ZIRGY3WWp5TTZJekt4TTFqP3A9cHJldmlldykpXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQENvbXBvbmVudCh7XG4gKiAgIC4uLixcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8aXRlbT4gYSA8L2l0ZW0+XG4gKiAgICAgPGl0ZW0+IGIgPC9pdGVtPlxuICogICAgIDxpdGVtPiBjIDwvaXRlbT5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgc2hvd246IGJvb2xlYW47XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIEBWaWV3UXVlcnkoSXRlbSkgaXRlbXM6UXVlcnlMaXN0PEl0ZW0+KSB7XG4gKiAgICAgaXRlbXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gY29uc29sZS5sb2coaXRlbXMubGVuZ3RoKSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFN1cHBvcnRzIHRoZSBzYW1lIHF1ZXJ5aW5nIHBhcmFtZXRlcnMgYXMge0BsaW5rIFF1ZXJ5TWV0YWRhdGF9LCBleGNlcHRcbiAqIGBkZXNjZW5kYW50c2AuIFRoaXMgYWx3YXlzIHF1ZXJpZXMgdGhlIHdob2xlIHZpZXcuXG4gKlxuICogQXMgYHNob3duYCBpcyBmbGlwcGVkIGJldHdlZW4gdHJ1ZSBhbmQgZmFsc2UsIGl0ZW1zIHdpbGwgY29udGFpbiB6ZXJvIG9mIG9uZVxuICogaXRlbXMuXG4gKlxuICogU3BlY2lmaWVzIHRoYXQgYSB7QGxpbmsgUXVlcnlMaXN0fSBzaG91bGQgYmUgaW5qZWN0ZWQuXG4gKlxuICogVGhlIGluamVjdGVkIG9iamVjdCBpcyBhbiBpdGVyYWJsZSBhbmQgb2JzZXJ2YWJsZSBsaXZlIGxpc3QuXG4gKiBTZWUge0BsaW5rIFF1ZXJ5TGlzdH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBWaWV3UXVlcnlNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZpZXdRdWVyeU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpZXdRdWVyeU1ldGFkYXRhKF9zZWxlY3RvciwgX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2IuZmlyc3QsIGZpcnN0ID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIF9lID0gX2IucmVhZCwgcmVhZCA9IF9lID09PSB2b2lkIDAgPyBudWxsIDogX2U7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF9zZWxlY3RvciwgeyBkZXNjZW5kYW50czogZGVzY2VuZGFudHMsIGZpcnN0OiBmaXJzdCwgcmVhZDogcmVhZCB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdRdWVyeU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpc1ZpZXdRdWVyeVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbHdheXMgYHRydWVgIHRvIGRpZmZlcmVudGlhdGUgaXQgd2l0aCB7QGxpbmsgUXVlcnlNZXRhZGF0YX0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFZpZXdRdWVyeU1ldGFkYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiQFZpZXdRdWVyeShcIiArIGxhbmdfMS5zdHJpbmdpZnkodGhpcy5zZWxlY3RvcikgKyBcIilcIjsgfTtcbiAgICByZXR1cm4gVmlld1F1ZXJ5TWV0YWRhdGE7XG59KFF1ZXJ5TWV0YWRhdGEpKTtcbmV4cG9ydHMuVmlld1F1ZXJ5TWV0YWRhdGEgPSBWaWV3UXVlcnlNZXRhZGF0YTtcbi8qKlxuICogRGVjbGFyZXMgYSBsaXN0IG9mIGNoaWxkIGVsZW1lbnQgcmVmZXJlbmNlcy5cbiAqXG4gKiBBbmd1bGFyIGF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgbGlzdCB3aGVuIHRoZSBET00gaXMgdXBkYXRlZC5cbiAqXG4gKiBgVmlld0NoaWxkcmVuYCB0YWtlcyBhbiBhcmd1bWVudCB0byBzZWxlY3QgZWxlbWVudHMuXG4gKlxuICogLSBJZiB0aGUgYXJndW1lbnQgaXMgYSB0eXBlLCBkaXJlY3RpdmVzIG9yIGNvbXBvbmVudHMgd2l0aCB0aGUgdHlwZSB3aWxsIGJlIGJvdW5kLlxuICpcbiAqIC0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0aGUgc3RyaW5nIGlzIGludGVycHJldGVkIGFzIGEgbGlzdCBvZiBjb21tYS1zZXBhcmF0ZWQgc2VsZWN0b3JzLlxuICogRm9yIGVhY2ggc2VsZWN0b3IsIGFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgbWF0Y2hpbmcgdGVtcGxhdGUgdmFyaWFibGUgKGUuZy4gYCNjaGlsZGApIHdpbGwgYmVcbiAqIGJvdW5kLlxuICpcbiAqIFZpZXcgY2hpbGRyZW4gYXJlIHNldCBiZWZvcmUgdGhlIGBuZ0FmdGVyVmlld0luaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFdpdGggdHlwZSBzZWxlY3RvcjpcbiAqXG4gKiBgYGBcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2NoaWxkLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiAnPHA+Y2hpbGQ8L3A+J1xuICogfSlcbiAqIGNsYXNzIENoaWxkQ21wIHtcbiAqICAgZG9Tb21ldGhpbmcoKSB7fVxuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ3NvbWUtY21wJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8Y2hpbGQtY21wPjwvY2hpbGQtY21wPlxuICogICAgIDxjaGlsZC1jbXA+PC9jaGlsZC1jbXA+XG4gKiAgICAgPGNoaWxkLWNtcD48L2NoaWxkLWNtcD5cbiAqICAgYCxcbiAqICAgZGlyZWN0aXZlczogW0NoaWxkQ21wXVxuICogfSlcbiAqIGNsYXNzIFNvbWVDbXAge1xuICogICBAVmlld0NoaWxkcmVuKENoaWxkQ21wKSBjaGlsZHJlbjpRdWVyeUxpc3Q8Q2hpbGRDbXA+O1xuICpcbiAqICAgbmdBZnRlclZpZXdJbml0KCkge1xuICogICAgIC8vIGNoaWxkcmVuIGFyZSBzZXRcbiAqICAgICB0aGlzLmNoaWxkcmVuLnRvQXJyYXkoKS5mb3JFYWNoKChjaGlsZCk9PmNoaWxkLmRvU29tZXRoaW5nKCkpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaXRoIHN0cmluZyBzZWxlY3RvcjpcbiAqXG4gKiBgYGBcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2NoaWxkLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiAnPHA+Y2hpbGQ8L3A+J1xuICogfSlcbiAqIGNsYXNzIENoaWxkQ21wIHtcbiAqICAgZG9Tb21ldGhpbmcoKSB7fVxuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ3NvbWUtY21wJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8Y2hpbGQtY21wICNjaGlsZDE+PC9jaGlsZC1jbXA+XG4gKiAgICAgPGNoaWxkLWNtcCAjY2hpbGQyPjwvY2hpbGQtY21wPlxuICogICAgIDxjaGlsZC1jbXAgI2NoaWxkMz48L2NoaWxkLWNtcD5cbiAqICAgYCxcbiAqICAgZGlyZWN0aXZlczogW0NoaWxkQ21wXVxuICogfSlcbiAqIGNsYXNzIFNvbWVDbXAge1xuICogICBAVmlld0NoaWxkcmVuKCdjaGlsZDEsY2hpbGQyLGNoaWxkMycpIGNoaWxkcmVuOlF1ZXJ5TGlzdDxDaGlsZENtcD47XG4gKlxuICogICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gKiAgICAgLy8gY2hpbGRyZW4gYXJlIHNldFxuICogICAgIHRoaXMuY2hpbGRyZW4udG9BcnJheSgpLmZvckVhY2goKGNoaWxkKT0+Y2hpbGQuZG9Tb21ldGhpbmcoKSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQHRzMmRhcnRfY29uc3RcbiAqL1xudmFyIFZpZXdDaGlsZHJlbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlld0NoaWxkcmVuTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld0NoaWxkcmVuTWV0YWRhdGEoX3NlbGVjdG9yLCBfYSkge1xuICAgICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnJlYWQsIHJlYWQgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iO1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfc2VsZWN0b3IsIHsgZGVzY2VuZGFudHM6IHRydWUsIHJlYWQ6IHJlYWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q2hpbGRyZW5NZXRhZGF0YTtcbn0oVmlld1F1ZXJ5TWV0YWRhdGEpKTtcbmV4cG9ydHMuVmlld0NoaWxkcmVuTWV0YWRhdGEgPSBWaWV3Q2hpbGRyZW5NZXRhZGF0YTtcbi8qKlxuICpcbiAqIERlY2xhcmVzIGEgcmVmZXJlbmNlIG9mIGNoaWxkIGVsZW1lbnQuXG4gKlxuICogYFZpZXdDaGlsZHJlbmAgdGFrZXMgYW4gYXJndW1lbnQgdG8gc2VsZWN0IGVsZW1lbnRzLlxuICpcbiAqIC0gSWYgdGhlIGFyZ3VtZW50IGlzIGEgdHlwZSwgYSBkaXJlY3RpdmUgb3IgYSBjb21wb25lbnQgd2l0aCB0aGUgdHlwZSB3aWxsIGJlIGJvdW5kLlxuICpcbiBJZiB0aGUgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHRoZSBzdHJpbmcgaXMgaW50ZXJwcmV0ZWQgYXMgYSBzZWxlY3Rvci4gQW4gZWxlbWVudCBjb250YWluaW5nIHRoZVxuIG1hdGNoaW5nIHRlbXBsYXRlIHZhcmlhYmxlIChlLmcuIGAjY2hpbGRgKSB3aWxsIGJlIGJvdW5kLlxuICpcbiAqIEluIGVpdGhlciBjYXNlLCBgQFZpZXdDaGlsZCgpYCBhc3NpZ25zIHRoZSBmaXJzdCAobG9va2luZyBmcm9tIGFib3ZlKSBlbGVtZW50IGlmIHRoZXJlIGFyZVxuIG11bHRpcGxlIG1hdGNoZXMuXG4gKlxuICogVmlldyBjaGlsZCBpcyBzZXQgYmVmb3JlIHRoZSBgbmdBZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBXaXRoIHR5cGUgc2VsZWN0b3I6XG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdjaGlsZC1jbXAnLFxuICogICB0ZW1wbGF0ZTogJzxwPmNoaWxkPC9wPidcbiAqIH0pXG4gKiBjbGFzcyBDaGlsZENtcCB7XG4gKiAgIGRvU29tZXRoaW5nKCkge31cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzb21lLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiAnPGNoaWxkLWNtcD48L2NoaWxkLWNtcD4nLFxuICogICBkaXJlY3RpdmVzOiBbQ2hpbGRDbXBdXG4gKiB9KVxuICogY2xhc3MgU29tZUNtcCB7XG4gKiAgIEBWaWV3Q2hpbGQoQ2hpbGRDbXApIGNoaWxkOkNoaWxkQ21wO1xuICpcbiAqICAgbmdBZnRlclZpZXdJbml0KCkge1xuICogICAgIC8vIGNoaWxkIGlzIHNldFxuICogICAgIHRoaXMuY2hpbGQuZG9Tb21ldGhpbmcoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogV2l0aCBzdHJpbmcgc2VsZWN0b3I6XG4gKlxuICogYGBgXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdjaGlsZC1jbXAnLFxuICogICB0ZW1wbGF0ZTogJzxwPmNoaWxkPC9wPidcbiAqIH0pXG4gKiBjbGFzcyBDaGlsZENtcCB7XG4gKiAgIGRvU29tZXRoaW5nKCkge31cbiAqIH1cbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdzb21lLWNtcCcsXG4gKiAgIHRlbXBsYXRlOiAnPGNoaWxkLWNtcCAjY2hpbGQ+PC9jaGlsZC1jbXA+JyxcbiAqICAgZGlyZWN0aXZlczogW0NoaWxkQ21wXVxuICogfSlcbiAqIGNsYXNzIFNvbWVDbXAge1xuICogICBAVmlld0NoaWxkKCdjaGlsZCcpIGNoaWxkOkNoaWxkQ21wO1xuICpcbiAqICAgbmdBZnRlclZpZXdJbml0KCkge1xuICogICAgIC8vIGNoaWxkIGlzIHNldFxuICogICAgIHRoaXMuY2hpbGQuZG9Tb21ldGhpbmcoKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgVmlld0NoaWxkTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3Q2hpbGRNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3Q2hpbGRNZXRhZGF0YShfc2VsZWN0b3IsIF9hKSB7XG4gICAgICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkucmVhZCwgcmVhZCA9IF9iID09PSB2b2lkIDAgPyBudWxsIDogX2I7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF9zZWxlY3RvciwgeyBkZXNjZW5kYW50czogdHJ1ZSwgZmlyc3Q6IHRydWUsIHJlYWQ6IHJlYWQgfSk7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q2hpbGRNZXRhZGF0YTtcbn0oVmlld1F1ZXJ5TWV0YWRhdGEpKTtcbmV4cG9ydHMuVmlld0NoaWxkTWV0YWRhdGEgPSBWaWV3Q2hpbGRNZXRhZGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgbWV0YWRhdGFfMSA9IHJlcXVpcmUoJy4uL2RpL21ldGFkYXRhJyk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKCcuLi9jaGFuZ2VfZGV0ZWN0aW9uL2NvbnN0YW50cycpO1xuLyoqXG4gKiBEaXJlY3RpdmVzIGFsbG93IHlvdSB0byBhdHRhY2ggYmVoYXZpb3IgdG8gZWxlbWVudHMgaW4gdGhlIERPTS5cbiAqXG4gKiB7QGxpbmsgRGlyZWN0aXZlTWV0YWRhdGF9cyB3aXRoIGFuIGVtYmVkZGVkIHZpZXcgYXJlIGNhbGxlZCB7QGxpbmsgQ29tcG9uZW50TWV0YWRhdGF9cy5cbiAqXG4gKiBBIGRpcmVjdGl2ZSBjb25zaXN0cyBvZiBhIHNpbmdsZSBkaXJlY3RpdmUgYW5ub3RhdGlvbiBhbmQgYSBjb250cm9sbGVyIGNsYXNzLiBXaGVuIHRoZVxuICogZGlyZWN0aXZlJ3MgYHNlbGVjdG9yYCBtYXRjaGVzXG4gKiBlbGVtZW50cyBpbiB0aGUgRE9NLCB0aGUgZm9sbG93aW5nIHN0ZXBzIG9jY3VyOlxuICpcbiAqIDEuIEZvciBlYWNoIGRpcmVjdGl2ZSwgdGhlIGBFbGVtZW50SW5qZWN0b3JgIGF0dGVtcHRzIHRvIHJlc29sdmUgdGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gKiBhcmd1bWVudHMuXG4gKiAyLiBBbmd1bGFyIGluc3RhbnRpYXRlcyBkaXJlY3RpdmVzIGZvciBlYWNoIG1hdGNoZWQgZWxlbWVudCB1c2luZyBgRWxlbWVudEluamVjdG9yYCBpbiBhXG4gKiBkZXB0aC1maXJzdCBvcmRlcixcbiAqICAgIGFzIGRlY2xhcmVkIGluIHRoZSBIVE1MLlxuICpcbiAqICMjIFVuZGVyc3RhbmRpbmcgSG93IEluamVjdGlvbiBXb3Jrc1xuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgb2YgaW5qZWN0aW9uIHJlc29sdXRpb24uXG4gKiAtICpQcmUtZXhpc3RpbmcgSW5qZWN0b3JzKjpcbiAqICAgLSBUaGUgdGVybWluYWwge0BsaW5rIEluamVjdG9yfSBjYW5ub3QgcmVzb2x2ZSBkZXBlbmRlbmNpZXMuIEl0IGVpdGhlciB0aHJvd3MgYW4gZXJyb3Igb3IsIGlmXG4gKiB0aGUgZGVwZW5kZW5jeSB3YXNcbiAqICAgICBzcGVjaWZpZWQgYXMgYEBPcHRpb25hbGAsIHJldHVybnMgYG51bGxgLlxuICogICAtIFRoZSBwbGF0Zm9ybSBpbmplY3RvciByZXNvbHZlcyBicm93c2VyIHNpbmdsZXRvbiByZXNvdXJjZXMsIHN1Y2ggYXM6IGNvb2tpZXMsIHRpdGxlLFxuICogbG9jYXRpb24sIGFuZCBvdGhlcnMuXG4gKiAtICpDb21wb25lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGl0cyBvd24ge0BsaW5rIEluamVjdG9yfSwgYW5kIHRoZXkgZm9sbG93XG4gKiB0aGUgc2FtZSBwYXJlbnQtY2hpbGQgaGllcmFyY2h5XG4gKiAgICAgYXMgdGhlIGNvbXBvbmVudCBpbnN0YW5jZXMgaW4gdGhlIERPTS5cbiAqIC0gKkVsZW1lbnQgSW5qZWN0b3JzKjogRWFjaCBjb21wb25lbnQgaW5zdGFuY2UgaGFzIGEgU2hhZG93IERPTS4gV2l0aGluIHRoZSBTaGFkb3cgRE9NIGVhY2hcbiAqIGVsZW1lbnQgaGFzIGFuIGBFbGVtZW50SW5qZWN0b3JgXG4gKiAgICAgd2hpY2ggZm9sbG93IHRoZSBzYW1lIHBhcmVudC1jaGlsZCBoaWVyYXJjaHkgYXMgdGhlIERPTSBlbGVtZW50cyB0aGVtc2VsdmVzLlxuICpcbiAqIFdoZW4gYSB0ZW1wbGF0ZSBpcyBpbnN0YW50aWF0ZWQsIGl0IGFsc28gbXVzdCBpbnN0YW50aWF0ZSB0aGUgY29ycmVzcG9uZGluZyBkaXJlY3RpdmVzIGluIGFcbiAqIGRlcHRoLWZpcnN0IG9yZGVyLiBUaGVcbiAqIGN1cnJlbnQgYEVsZW1lbnRJbmplY3RvcmAgcmVzb2x2ZXMgdGhlIGNvbnN0cnVjdG9yIGRlcGVuZGVuY2llcyBmb3IgZWFjaCBkaXJlY3RpdmUuXG4gKlxuICogQW5ndWxhciB0aGVuIHJlc29sdmVzIGRlcGVuZGVuY2llcyBhcyBmb2xsb3dzLCBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyIGluIHRoZVxuICoge0BsaW5rIFZpZXdNZXRhZGF0YX06XG4gKlxuICogMS4gRGVwZW5kZW5jaWVzIG9uIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAqIDIuIERlcGVuZGVuY2llcyBvbiBlbGVtZW50IGluamVjdG9ycyBhbmQgdGhlaXIgcGFyZW50cyB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgU2hhZG93IERPTSBib3VuZGFyeVxuICogMy4gRGVwZW5kZW5jaWVzIG9uIGNvbXBvbmVudCBpbmplY3RvcnMgYW5kIHRoZWlyIHBhcmVudHMgdW50aWwgaXQgZW5jb3VudGVycyB0aGUgcm9vdCBjb21wb25lbnRcbiAqIDQuIERlcGVuZGVuY2llcyBvbiBwcmUtZXhpc3RpbmcgaW5qZWN0b3JzXG4gKlxuICpcbiAqIFRoZSBgRWxlbWVudEluamVjdG9yYCBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMsIGVsZW1lbnQtc3BlY2lmaWMgc3BlY2lhbCBvYmplY3RzLCBvciBpdCBjYW5cbiAqIGRlbGVnYXRlIHRvIHRoZSBwYXJlbnRcbiAqIGluamVjdG9yLlxuICpcbiAqIFRvIGluamVjdCBvdGhlciBkaXJlY3RpdmVzLCBkZWNsYXJlIHRoZSBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgYXM6XG4gKiAtIGBkaXJlY3RpdmU6RGlyZWN0aXZlVHlwZWA6IGEgZGlyZWN0aXZlIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQgb25seVxuICogLSBgQEhvc3QoKSBkaXJlY3RpdmU6RGlyZWN0aXZlVHlwZWA6IGFueSBkaXJlY3RpdmUgdGhhdCBtYXRjaGVzIHRoZSB0eXBlIGJldHdlZW4gdGhlIGN1cnJlbnRcbiAqIGVsZW1lbnQgYW5kIHRoZVxuICogICAgU2hhZG93IERPTSByb290LlxuICogLSBgQFF1ZXJ5KERpcmVjdGl2ZVR5cGUpIHF1ZXJ5OlF1ZXJ5TGlzdDxEaXJlY3RpdmVUeXBlPmA6IEEgbGl2ZSBjb2xsZWN0aW9uIG9mIGRpcmVjdCBjaGlsZFxuICogZGlyZWN0aXZlcy5cbiAqIC0gYEBRdWVyeURlc2NlbmRhbnRzKERpcmVjdGl2ZVR5cGUpIHF1ZXJ5OlF1ZXJ5TGlzdDxEaXJlY3RpdmVUeXBlPmA6IEEgbGl2ZSBjb2xsZWN0aW9uIG9mIGFueVxuICogY2hpbGQgZGlyZWN0aXZlcy5cbiAqXG4gKiBUbyBpbmplY3QgZWxlbWVudC1zcGVjaWZpYyBzcGVjaWFsIG9iamVjdHMsIGRlY2xhcmUgdGhlIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBhczpcbiAqIC0gYGVsZW1lbnQ6IEVsZW1lbnRSZWZgIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byBsb2dpY2FsIGVsZW1lbnQgaW4gdGhlIHZpZXcuXG4gKiAtIGB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmYCB0byBjb250cm9sIGNoaWxkIHRlbXBsYXRlIGluc3RhbnRpYXRpb24sIGZvclxuICoge0BsaW5rIERpcmVjdGl2ZU1ldGFkYXRhfSBkaXJlY3RpdmVzIG9ubHlcbiAqIC0gYGJpbmRpbmdQcm9wYWdhdGlvbjogQmluZGluZ1Byb3BhZ2F0aW9uYCB0byBjb250cm9sIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBtb3JlIGdyYW51bGFyIHdheS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZW1vbnN0cmF0ZXMgaG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uIHJlc29sdmVzIGNvbnN0cnVjdG9yIGFyZ3VtZW50cyBpblxuICogcHJhY3RpY2UuXG4gKlxuICpcbiAqIEFzc3VtZSB0aGlzIEhUTUwgdGVtcGxhdGU6XG4gKlxuICogYGBgXG4gKiA8ZGl2IGRlcGVuZGVuY3k9XCIxXCI+XG4gKiAgIDxkaXYgZGVwZW5kZW5jeT1cIjJcIj5cbiAqICAgICA8ZGl2IGRlcGVuZGVuY3k9XCIzXCIgbXktZGlyZWN0aXZlPlxuICogICAgICAgPGRpdiBkZXBlbmRlbmN5PVwiNFwiPlxuICogICAgICAgICA8ZGl2IGRlcGVuZGVuY3k9XCI1XCI+PC9kaXY+XG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICAgIDxkaXYgZGVwZW5kZW5jeT1cIjZcIj48L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIFdpdGggdGhlIGZvbGxvd2luZyBgZGVwZW5kZW5jeWAgZGVjb3JhdG9yIGFuZCBgU29tZVNlcnZpY2VgIGluamVjdGFibGUgY2xhc3MuXG4gKlxuICogYGBgXG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBTb21lU2VydmljZSB7XG4gKiB9XG4gKlxuICogQERpcmVjdGl2ZSh7XG4gKiAgIHNlbGVjdG9yOiAnW2RlcGVuZGVuY3ldJyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAgJ2lkOiBkZXBlbmRlbmN5J1xuICogICBdXG4gKiB9KVxuICogY2xhc3MgRGVwZW5kZW5jeSB7XG4gKiAgIGlkOnN0cmluZztcbiAqIH1cbiAqIGBgYFxuICpcbiAqIExldCdzIHN0ZXAgdGhyb3VnaCB0aGUgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggYE15RGlyZWN0aXZlYCBjb3VsZCBiZSBkZWNsYXJlZC4uLlxuICpcbiAqXG4gKiAjIyMgTm8gaW5qZWN0aW9uXG4gKlxuICogSGVyZSB0aGUgY29uc3RydWN0b3IgaXMgZGVjbGFyZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZXJlZm9yZSBub3RoaW5nIGlzIGluamVjdGVkIGludG9cbiAqIGBNeURpcmVjdGl2ZWAuXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIHdvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIG5vIGRlcGVuZGVuY2llcy5cbiAqXG4gKlxuICogIyMjIENvbXBvbmVudC1sZXZlbCBpbmplY3Rpb25cbiAqXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3QgYW55IGluamVjdGFibGUgaW5zdGFuY2UgZnJvbSB0aGUgY2xvc2VzdCBjb21wb25lbnQgaW5qZWN0b3Igb3IgYW55IG9mIGl0c1xuICogcGFyZW50cy5cbiAqXG4gKiBIZXJlLCB0aGUgY29uc3RydWN0b3IgZGVjbGFyZXMgYSBwYXJhbWV0ZXIsIGBzb21lU2VydmljZWAsIGFuZCBpbmplY3RzIHRoZSBgU29tZVNlcnZpY2VgIHR5cGVcbiAqIGZyb20gdGhlIHBhcmVudFxuICogY29tcG9uZW50J3MgaW5qZWN0b3IuXG4gKiBgYGBcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xuICogICBjb25zdHJ1Y3Rvcihzb21lU2VydmljZTogU29tZVNlcnZpY2UpIHtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSBkZXBlbmRlbmN5IG9uIGBTb21lU2VydmljZWAuXG4gKlxuICpcbiAqICMjIyBJbmplY3RpbmcgYSBkaXJlY3RpdmUgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gKlxuICogRGlyZWN0aXZlcyBjYW4gaW5qZWN0IG90aGVyIGRpcmVjdGl2ZXMgZGVjbGFyZWQgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqXG4gKiBgYGBcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xuICogICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XG4gKiAgICAgZXhwZWN0KGRlcGVuZGVuY3kuaWQpLnRvRXF1YWwoMyk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYERlcGVuZGVuY3lgIGRlY2xhcmVkIGF0IHRoZSBzYW1lIGVsZW1lbnQsIGluIHRoaXMgY2FzZVxuICogYGRlcGVuZGVuY3k9XCIzXCJgLlxuICpcbiAqICMjIyBJbmplY3RpbmcgYSBkaXJlY3RpdmUgZnJvbSBhbnkgYW5jZXN0b3IgZWxlbWVudHNcbiAqXG4gKiBEaXJlY3RpdmVzIGNhbiBpbmplY3Qgb3RoZXIgZGlyZWN0aXZlcyBkZWNsYXJlZCBvbiBhbnkgYW5jZXN0b3IgZWxlbWVudCAoaW4gdGhlIGN1cnJlbnQgU2hhZG93XG4gKiBET00pLCBpLmUuIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQsIHRoZVxuICogcGFyZW50IGVsZW1lbnQsIG9yIGl0cyBwYXJlbnRzLlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoQEhvc3QoKSBkZXBlbmRlbmN5OiBEZXBlbmRlbmN5KSB7XG4gKiAgICAgZXhwZWN0KGRlcGVuZGVuY3kuaWQpLnRvRXF1YWwoMik7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIGBASG9zdGAgY2hlY2tzIHRoZSBjdXJyZW50IGVsZW1lbnQsIHRoZSBwYXJlbnQsIGFzIHdlbGwgYXMgaXRzIHBhcmVudHMgcmVjdXJzaXZlbHkuIElmXG4gKiBgZGVwZW5kZW5jeT1cIjJcImAgZGlkbid0XG4gKiBleGlzdCBvbiB0aGUgZGlyZWN0IHBhcmVudCwgdGhpcyBpbmplY3Rpb24gd291bGRcbiAqIGhhdmUgcmV0dXJuZWRcbiAqIGBkZXBlbmRlbmN5PVwiMVwiYC5cbiAqXG4gKlxuICogIyMjIEluamVjdGluZyBhIGxpdmUgY29sbGVjdGlvbiBvZiBkaXJlY3QgY2hpbGQgZGlyZWN0aXZlc1xuICpcbiAqXG4gKiBBIGRpcmVjdGl2ZSBjYW4gYWxzbyBxdWVyeSBmb3Igb3RoZXIgY2hpbGQgZGlyZWN0aXZlcy4gU2luY2UgcGFyZW50IGRpcmVjdGl2ZXMgYXJlIGluc3RhbnRpYXRlZFxuICogYmVmb3JlIGNoaWxkIGRpcmVjdGl2ZXMsIGEgZGlyZWN0aXZlIGNhbid0IHNpbXBseSBpbmplY3QgdGhlIGxpc3Qgb2YgY2hpbGQgZGlyZWN0aXZlcy4gSW5zdGVhZCxcbiAqIHRoZSBkaXJlY3RpdmUgaW5qZWN0cyBhIHtAbGluayBRdWVyeUxpc3R9LCB3aGljaCB1cGRhdGVzIGl0cyBjb250ZW50cyBhcyBjaGlsZHJlbiBhcmUgYWRkZWQsXG4gKiByZW1vdmVkLCBvciBtb3ZlZCBieSBhIGRpcmVjdGl2ZSB0aGF0IHVzZXMgYSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0gc3VjaCBhcyBhIGBuZ0ZvcmAsIGFuXG4gKiBgbmdJZmAsIG9yIGFuIGBuZ1N3aXRjaGAuXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbXktZGlyZWN0aXZlXScgfSlcbiAqIGNsYXNzIE15RGlyZWN0aXZlIHtcbiAqICAgY29uc3RydWN0b3IoQFF1ZXJ5KERlcGVuZGVuY3kpIGRlcGVuZGVuY2llczpRdWVyeUxpc3Q8RGVwZW5kZW5jeT4pIHtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgd291bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggYSB7QGxpbmsgUXVlcnlMaXN0fSB3aGljaCBjb250YWlucyBgRGVwZW5kZW5jeWAgNCBhbmRcbiAqIGBEZXBlbmRlbmN5YCA2LiBIZXJlLCBgRGVwZW5kZW5jeWAgNSB3b3VsZCBub3QgYmUgaW5jbHVkZWQsIGJlY2F1c2UgaXQgaXMgbm90IGEgZGlyZWN0IGNoaWxkLlxuICpcbiAqICMjIyBJbmplY3RpbmcgYSBsaXZlIGNvbGxlY3Rpb24gb2YgZGVzY2VuZGFudCBkaXJlY3RpdmVzXG4gKlxuICogQnkgcGFzc2luZyB0aGUgZGVzY2VuZGFudCBmbGFnIHRvIGBAUXVlcnlgIGFib3ZlLCB3ZSBjYW4gaW5jbHVkZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGNoaWxkXG4gKiBlbGVtZW50cy5cbiAqXG4gKiBgYGBcbiAqIEBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tteS1kaXJlY3RpdmVdJyB9KVxuICogY2xhc3MgTXlEaXJlY3RpdmUge1xuICogICBjb25zdHJ1Y3RvcihAUXVlcnkoRGVwZW5kZW5jeSwge2Rlc2NlbmRhbnRzOiB0cnVlfSkgZGVwZW5kZW5jaWVzOlF1ZXJ5TGlzdDxEZXBlbmRlbmN5Pikge1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIFF1ZXJ5IHdoaWNoIHdvdWxkIGNvbnRhaW4gYERlcGVuZGVuY3lgIDQsIDUgYW5kIDYuXG4gKlxuICogIyMjIE9wdGlvbmFsIGluamVjdGlvblxuICpcbiAqIFRoZSBub3JtYWwgYmVoYXZpb3Igb2YgZGlyZWN0aXZlcyBpcyB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBhIHNwZWNpZmllZCBkZXBlbmRlbmN5IGNhbm5vdCBiZVxuICogcmVzb2x2ZWQuIElmIHlvdVxuICogd291bGQgbGlrZSB0byBpbmplY3QgYG51bGxgIG9uIHVucmVzb2x2ZWQgZGVwZW5kZW5jeSBpbnN0ZWFkLCB5b3UgY2FuIGFubm90YXRlIHRoYXQgZGVwZW5kZW5jeVxuICogd2l0aCBgQE9wdGlvbmFsKClgLlxuICogVGhpcyBleHBsaWNpdGx5IHBlcm1pdHMgdGhlIGF1dGhvciBvZiBhIHRlbXBsYXRlIHRvIHRyZWF0IHNvbWUgb2YgdGhlIHN1cnJvdW5kaW5nIGRpcmVjdGl2ZXMgYXNcbiAqIG9wdGlvbmFsLlxuICpcbiAqIGBgYFxuICogQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW215LWRpcmVjdGl2ZV0nIH0pXG4gKiBjbGFzcyBNeURpcmVjdGl2ZSB7XG4gKiAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIGRlcGVuZGVuY3k6RGVwZW5kZW5jeSkge1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSB3b3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBhIGBEZXBlbmRlbmN5YCBkaXJlY3RpdmUgZm91bmQgb24gdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqIElmIG5vbmUgY2FuIGJlXG4gKiBmb3VuZCwgdGhlIGluamVjdG9yIHN1cHBsaWVzIGBudWxsYCBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogSGVyZSB3ZSB1c2UgYSBkZWNvcmF0b3IgZGlyZWN0aXZlIHRvIHNpbXBseSBkZWZpbmUgYmFzaWMgdG9vbC10aXAgYmVoYXZpb3IuXG4gKlxuICogYGBgXG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdbdG9vbHRpcF0nLFxuICogICBpbnB1dHM6IFtcbiAqICAgICAndGV4dDogdG9vbHRpcCdcbiAqICAgXSxcbiAqICAgaG9zdDoge1xuICogICAgICcobW91c2VlbnRlciknOiAnb25Nb3VzZUVudGVyKCknLFxuICogICAgICcobW91c2VsZWF2ZSknOiAnb25Nb3VzZUxlYXZlKCknXG4gKiAgIH1cbiAqIH0pXG4gKiBjbGFzcyBUb29sdGlwe1xuICogICB0ZXh0OnN0cmluZztcbiAqICAgb3ZlcmxheTpPdmVybGF5OyAvLyBOT1QgWUVUIElNUExFTUVOVEVEXG4gKiAgIG92ZXJsYXlNYW5hZ2VyOk92ZXJsYXlNYW5hZ2VyOyAvLyBOT1QgWUVUIElNUExFTUVOVEVEXG4gKlxuICogICBjb25zdHJ1Y3RvcihvdmVybGF5TWFuYWdlcjpPdmVybGF5TWFuYWdlcikge1xuICogICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gKiAgIH1cbiAqXG4gKiAgIG9uTW91c2VFbnRlcigpIHtcbiAqICAgICAvLyBleGFjdCBzaWduYXR1cmUgdG8gYmUgZGV0ZXJtaW5lZFxuICogICAgIHRoaXMub3ZlcmxheSA9IHRoaXMub3ZlcmxheU1hbmFnZXIub3Blbih0ZXh0LCAuLi4pO1xuICogICB9XG4gKlxuICogICBvbk1vdXNlTGVhdmUoKSB7XG4gKiAgICAgdGhpcy5vdmVybGF5LmNsb3NlKCk7XG4gKiAgICAgdGhpcy5vdmVybGF5ID0gbnVsbDtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiBJbiBvdXIgSFRNTCB0ZW1wbGF0ZSwgd2UgY2FuIHRoZW4gYWRkIHRoaXMgYmVoYXZpb3IgdG8gYSBgPGRpdj5gIG9yIGFueSBvdGhlciBlbGVtZW50IHdpdGggdGhlXG4gKiBgdG9vbHRpcGAgc2VsZWN0b3IsXG4gKiBsaWtlIHNvOlxuICpcbiAqIGBgYFxuICogPGRpdiB0b29sdGlwPVwic29tZSB0ZXh0IGhlcmVcIj48L2Rpdj5cbiAqIGBgYFxuICpcbiAqIERpcmVjdGl2ZXMgY2FuIGFsc28gY29udHJvbCB0aGUgaW5zdGFudGlhdGlvbiwgZGVzdHJ1Y3Rpb24sIGFuZCBwb3NpdGlvbmluZyBvZiBpbmxpbmUgdGVtcGxhdGVcbiAqIGVsZW1lbnRzOlxuICpcbiAqIEEgZGlyZWN0aXZlIHVzZXMgYSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0gdG8gaW5zdGFudGlhdGUsIGluc2VydCwgbW92ZSwgYW5kIGRlc3Ryb3kgdmlld3MgYXRcbiAqIHJ1bnRpbWUuXG4gKiBUaGUge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9IGlzIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQsIGFuZCByZXByZXNlbnRzIGFcbiAqIGxvY2F0aW9uIGluIHRoZSBjdXJyZW50IHZpZXdcbiAqIHdoZXJlIHRoZXNlIGFjdGlvbnMgYXJlIHBlcmZvcm1lZC5cbiAqXG4gKiBWaWV3cyBhcmUgYWx3YXlzIGNyZWF0ZWQgYXMgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQge0BsaW5rIFZpZXdNZXRhZGF0YX0sIGFuZCBhcyBzaWJsaW5ncyBvZiB0aGVcbiAqIGA8dGVtcGxhdGU+YCBlbGVtZW50LiBUaHVzIGFcbiAqIGRpcmVjdGl2ZSBpbiBhIGNoaWxkIHZpZXcgY2Fubm90IGluamVjdCB0aGUgZGlyZWN0aXZlIHRoYXQgY3JlYXRlZCBpdC5cbiAqXG4gKiBTaW5jZSBkaXJlY3RpdmVzIHRoYXQgY3JlYXRlIHZpZXdzIHZpYSBWaWV3Q29udGFpbmVycyBhcmUgY29tbW9uIGluIEFuZ3VsYXIsIGFuZCB1c2luZyB0aGUgZnVsbFxuICogYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgc3ludGF4IGlzIHdvcmR5LCBBbmd1bGFyXG4gKiBhbHNvIHN1cHBvcnRzIGEgc2hvcnRoYW5kIG5vdGF0aW9uOiBgPGxpICpmb289XCJiYXJcIj5gIGFuZCBgPGxpIHRlbXBsYXRlPVwiZm9vOiBiYXJcIj5gIGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiBUaHVzLFxuICpcbiAqIGBgYFxuICogPHVsPlxuICogICA8bGkgKmZvbz1cImJhclwiIHRpdGxlPVwidGV4dFwiPjwvbGk+XG4gKiA8L3VsPlxuICogYGBgXG4gKlxuICogRXhwYW5kcyBpbiB1c2UgdG86XG4gKlxuICogYGBgXG4gKiA8dWw+XG4gKiAgIDx0ZW1wbGF0ZSBbZm9vXT1cImJhclwiPlxuICogICAgIDxsaSB0aXRsZT1cInRleHRcIj48L2xpPlxuICogICA8L3RlbXBsYXRlPlxuICogPC91bD5cbiAqIGBgYFxuICpcbiAqIE5vdGljZSB0aGF0IGFsdGhvdWdoIHRoZSBzaG9ydGhhbmQgcGxhY2VzIGAqZm9vPVwiYmFyXCJgIHdpdGhpbiB0aGUgYDxsaT5gIGVsZW1lbnQsIHRoZSBiaW5kaW5nIGZvclxuICogdGhlIGRpcmVjdGl2ZVxuICogY29udHJvbGxlciBpcyBjb3JyZWN0bHkgaW5zdGFudGlhdGVkIG9uIHRoZSBgPHRlbXBsYXRlPmAgZWxlbWVudCByYXRoZXIgdGhhbiB0aGUgYDxsaT5gIGVsZW1lbnQuXG4gKlxuICogIyMgTGlmZWN5Y2xlIGhvb2tzXG4gKlxuICogV2hlbiB0aGUgZGlyZWN0aXZlIGNsYXNzIGltcGxlbWVudHMgc29tZSB7QGxpbmsgLi4vLi4vZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzLmh0bWx9IHRoZSBjYWxsYmFja3NcbiAqIGFyZSBjYWxsZWQgYnkgdGhlIGNoYW5nZSBkZXRlY3Rpb24gYXQgZGVmaW5lZCBwb2ludHMgaW4gdGltZSBkdXJpbmcgdGhlIGxpZmUgb2YgdGhlIGRpcmVjdGl2ZS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIExldCdzIHN1cHBvc2Ugd2Ugd2FudCB0byBpbXBsZW1lbnQgdGhlIGB1bmxlc3NgIGJlaGF2aW9yLCB0byBjb25kaXRpb25hbGx5IGluY2x1ZGUgYSB0ZW1wbGF0ZS5cbiAqXG4gKiBIZXJlIGlzIGEgc2ltcGxlIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJzIG9uIGFuIGB1bmxlc3NgIHNlbGVjdG9yOlxuICpcbiAqIGBgYFxuICogQERpcmVjdGl2ZSh7XG4gKiAgIHNlbGVjdG9yOiAnW3VubGVzc10nLFxuICogICBpbnB1dHM6IFsndW5sZXNzJ11cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgVW5sZXNzIHtcbiAqICAgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcbiAqICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmO1xuICogICBwcmV2Q29uZGl0aW9uOiBib29sZWFuO1xuICpcbiAqICAgY29uc3RydWN0b3Iodmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZiwgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmKSB7XG4gKiAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcbiAqICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gKiAgICAgdGhpcy5wcmV2Q29uZGl0aW9uID0gbnVsbDtcbiAqICAgfVxuICpcbiAqICAgc2V0IHVubGVzcyhuZXdDb25kaXRpb24pIHtcbiAqICAgICBpZiAobmV3Q29uZGl0aW9uICYmIChpc0JsYW5rKHRoaXMucHJldkNvbmRpdGlvbikgfHwgIXRoaXMucHJldkNvbmRpdGlvbikpIHtcbiAqICAgICAgIHRoaXMucHJldkNvbmRpdGlvbiA9IHRydWU7XG4gKiAgICAgICB0aGlzLnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAqICAgICB9IGVsc2UgaWYgKCFuZXdDb25kaXRpb24gJiYgKGlzQmxhbmsodGhpcy5wcmV2Q29uZGl0aW9uKSB8fCB0aGlzLnByZXZDb25kaXRpb24pKSB7XG4gKiAgICAgICB0aGlzLnByZXZDb25kaXRpb24gPSBmYWxzZTtcbiAqICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGUodGhpcy50ZW1wbGF0ZVJlZik7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXZSBjYW4gdGhlbiB1c2UgdGhpcyBgdW5sZXNzYCBzZWxlY3RvciBpbiBhIHRlbXBsYXRlOlxuICogYGBgXG4gKiA8dWw+XG4gKiAgIDxsaSAqdW5sZXNzPVwiZXhwclwiPjwvbGk+XG4gKiA8L3VsPlxuICogYGBgXG4gKlxuICogT25jZSB0aGUgZGlyZWN0aXZlIGluc3RhbnRpYXRlcyB0aGUgY2hpbGQgdmlldywgdGhlIHNob3J0aGFuZCBub3RhdGlvbiBmb3IgdGhlIHRlbXBsYXRlIGV4cGFuZHNcbiAqIGFuZCB0aGUgcmVzdWx0IGlzOlxuICpcbiAqIGBgYFxuICogPHVsPlxuICogICA8dGVtcGxhdGUgW3VubGVzc109XCJleHBcIj5cbiAqICAgICA8bGk+PC9saT5cbiAqICAgPC90ZW1wbGF0ZT5cbiAqICAgPGxpPjwvbGk+XG4gKiA8L3VsPlxuICogYGBgXG4gKlxuICogTm90ZSBhbHNvIHRoYXQgYWx0aG91Z2ggdGhlIGA8bGk+PC9saT5gIHRlbXBsYXRlIHN0aWxsIGV4aXN0cyBpbnNpZGUgdGhlIGA8dGVtcGxhdGU+PC90ZW1wbGF0ZT5gLFxuICogdGhlIGluc3RhbnRpYXRlZFxuICogdmlldyBvY2N1cnMgb24gdGhlIHNlY29uZCBgPGxpPjwvbGk+YCB3aGljaCBpcyBhIHNpYmxpbmcgdG8gdGhlIGA8dGVtcGxhdGU+YCBlbGVtZW50LlxuICogQHRzMmRhcnRfY29uc3RcbiAqL1xudmFyIERpcmVjdGl2ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlyZWN0aXZlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHNlbGVjdG9yID0gX2Iuc2VsZWN0b3IsIGlucHV0cyA9IF9iLmlucHV0cywgb3V0cHV0cyA9IF9iLm91dHB1dHMsIHByb3BlcnRpZXMgPSBfYi5wcm9wZXJ0aWVzLCBldmVudHMgPSBfYi5ldmVudHMsIGhvc3QgPSBfYi5ob3N0LCBiaW5kaW5ncyA9IF9iLmJpbmRpbmdzLCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIHF1ZXJpZXMgPSBfYi5xdWVyaWVzO1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLl9pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLl9vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gZXZlbnRzO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLmV4cG9ydEFzID0gZXhwb3J0QXM7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IHF1ZXJpZXM7XG4gICAgICAgIHRoaXMuX3Byb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJpbnB1dHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bWVyYXRlcyB0aGUgc2V0IG9mIGRhdGEtYm91bmQgaW5wdXQgcHJvcGVydGllcyBmb3IgYSBkaXJlY3RpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQW5ndWxhciBhdXRvbWF0aWNhbGx5IHVwZGF0ZXMgaW5wdXQgcHJvcGVydGllcyBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBpbnB1dHNgIHByb3BlcnR5IGRlZmluZXMgYSBzZXQgb2YgYGRpcmVjdGl2ZVByb3BlcnR5YCB0byBgYmluZGluZ1Byb3BlcnR5YFxuICAgICAgICAgKiBjb25maWd1cmF0aW9uOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGBkaXJlY3RpdmVQcm9wZXJ0eWAgc3BlY2lmaWVzIHRoZSBjb21wb25lbnQgcHJvcGVydHkgd2hlcmUgdGhlIHZhbHVlIGlzIHdyaXR0ZW4uXG4gICAgICAgICAqIC0gYGJpbmRpbmdQcm9wZXJ0eWAgc3BlY2lmaWVzIHRoZSBET00gcHJvcGVydHkgd2hlcmUgdGhlIHZhbHVlIGlzIHJlYWQgZnJvbS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBgYmluZGluZ1Byb3BlcnR5YCBpcyBub3QgcHJvdmlkZWQsIGl0IGlzIGFzc3VtZWQgdG8gYmUgZXF1YWwgdG8gYGRpcmVjdGl2ZVByb3BlcnR5YC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2l2aGZYWT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGNvbXBvbmVudCB3aXRoIHR3byBkYXRhLWJvdW5kIHByb3BlcnRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQENvbXBvbmVudCh7XG4gICAgICAgICAqICAgc2VsZWN0b3I6ICdiYW5rLWFjY291bnQnLFxuICAgICAgICAgKiAgIGlucHV0czogWydiYW5rTmFtZScsICdpZDogYWNjb3VudC1pZCddLFxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICAgICBCYW5rIE5hbWU6IHt7YmFua05hbWV9fVxuICAgICAgICAgKiAgICAgQWNjb3VudCBJZDoge3tpZH19XG4gICAgICAgICAqICAgYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBCYW5rQWNjb3VudCB7XG4gICAgICAgICAqICAgYmFua05hbWU6IHN0cmluZztcbiAgICAgICAgICogICBpZDogc3RyaW5nO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgIC8vIHRoaXMgcHJvcGVydHkgaXMgbm90IGJvdW5kLCBhbmQgd29uJ3QgYmUgYXV0b21hdGljYWxseSB1cGRhdGVkIGJ5IEFuZ3VsYXJcbiAgICAgICAgICogICBub3JtYWxpemVkQmFua05hbWU6IHN0cmluZztcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2FwcCcsXG4gICAgICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICogICAgIDxiYW5rLWFjY291bnQgYmFuay1uYW1lPVwiUkJDXCIgYWNjb3VudC1pZD1cIjQ3NDdcIj48L2JhbmstYWNjb3VudD5cbiAgICAgICAgICogICBgLFxuICAgICAgICAgKiAgIGRpcmVjdGl2ZXM6IFtCYW5rQWNjb3VudF1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgQXBwIHt9XG4gICAgICAgICAqXG4gICAgICAgICAqIGJvb3RzdHJhcChBcHApO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcHJvcGVydGllcykgJiYgdGhpcy5fcHJvcGVydGllcy5sZW5ndGggPiAwID8gdGhpcy5fcHJvcGVydGllcyA6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcInByb3BlcnRpZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5wdXRzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcIm91dHB1dHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bWVyYXRlcyB0aGUgc2V0IG9mIGV2ZW50LWJvdW5kIG91dHB1dCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIGFuIG91dHB1dCBwcm9wZXJ0eSBlbWl0cyBhbiBldmVudCwgYW4gZXZlbnQgaGFuZGxlciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50XG4gICAgICAgICAqIHRoZSB0ZW1wbGF0ZSBpcyBpbnZva2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYG91dHB1dHNgIHByb3BlcnR5IGRlZmluZXMgYSBzZXQgb2YgYGRpcmVjdGl2ZVByb3BlcnR5YCB0byBgYmluZGluZ1Byb3BlcnR5YFxuICAgICAgICAgKiBjb25maWd1cmF0aW9uOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGBkaXJlY3RpdmVQcm9wZXJ0eWAgc3BlY2lmaWVzIHRoZSBjb21wb25lbnQgcHJvcGVydHkgdGhhdCBlbWl0cyBldmVudHMuXG4gICAgICAgICAqIC0gYGJpbmRpbmdQcm9wZXJ0eWAgc3BlY2lmaWVzIHRoZSBET00gcHJvcGVydHkgdGhlIGV2ZW50IGhhbmRsZXIgaXMgYXR0YWNoZWQgdG8uXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9kNUNOcTc/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBARGlyZWN0aXZlKHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2ludGVydmFsLWRpcicsXG4gICAgICAgICAqICAgb3V0cHV0czogWydldmVyeVNlY29uZCcsICdmaXZlNVNlY3M6IGV2ZXJ5Rml2ZVNlY29uZHMnXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBJbnRlcnZhbERpciB7XG4gICAgICAgICAqICAgZXZlcnlTZWNvbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAqICAgZml2ZTVTZWNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5ldmVyeVNlY29uZC5lbWl0KFwiZXZlbnRcIiksIDEwMDApO1xuICAgICAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5maXZlNVNlY3MuZW1pdChcImV2ZW50XCIpLCA1MDAwKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQENvbXBvbmVudCh7XG4gICAgICAgICAqICAgc2VsZWN0b3I6ICdhcHAnLFxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICAgICA8aW50ZXJ2YWwtZGlyIChldmVyeVNlY29uZCk9XCJldmVyeVNlY29uZCgpXCIgKGV2ZXJ5Rml2ZVNlY29uZHMpPVwiZXZlcnlGaXZlU2Vjb25kcygpXCI+XG4gICAgICAgICAqICAgICA8L2ludGVydmFsLWRpcj5cbiAgICAgICAgICogICBgLFxuICAgICAgICAgKiAgIGRpcmVjdGl2ZXM6IFtJbnRlcnZhbERpcl1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgQXBwIHtcbiAgICAgICAgICogICBldmVyeVNlY29uZCgpIHsgY29uc29sZS5sb2coJ3NlY29uZCcpOyB9XG4gICAgICAgICAqICAgZXZlcnlGaXZlU2Vjb25kcygpIHsgY29uc29sZS5sb2coJ2ZpdmUgc2Vjb25kcycpOyB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYm9vdHN0cmFwKEFwcCk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9ldmVudHMpICYmIHRoaXMuX2V2ZW50cy5sZW5ndGggPiAwID8gdGhpcy5fZXZlbnRzIDogdGhpcy5fb3V0cHV0cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJldmVudHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMub3V0cHV0czsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJwcm92aWRlcnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB0aGUgc2V0IG9mIGluamVjdGFibGUgb2JqZWN0cyB0aGF0IGFyZSB2aXNpYmxlIHRvIGEgRGlyZWN0aXZlIGFuZCBpdHMgbGlnaHQgRE9NXG4gICAgICAgICAqIGNoaWxkcmVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyBTaW1wbGUgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBjbGFzcyB0aGF0IGNhbiBiZSBpbmplY3RlZDpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNsYXNzIEdyZWV0ZXIge1xuICAgICAgICAgKiAgICBncmVldChuYW1lOnN0cmluZykge1xuICAgICAgICAgKiAgICAgIHJldHVybiAnSGVsbG8gJyArIG5hbWUgKyAnISc7XG4gICAgICAgICAqICAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBARGlyZWN0aXZlKHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2dyZWV0JyxcbiAgICAgICAgICogICBiaW5kaW5nczogW1xuICAgICAgICAgKiAgICAgR3JlZXRlclxuICAgICAgICAgKiAgIF1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgSGVsbG9Xb3JsZCB7XG4gICAgICAgICAqICAgZ3JlZXRlcjpHcmVldGVyO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKGdyZWV0ZXI6R3JlZXRlcikge1xuICAgICAgICAgKiAgICAgdGhpcy5ncmVldGVyID0gZ3JlZXRlcjtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2JpbmRpbmdzKSAmJiB0aGlzLl9iaW5kaW5ncy5sZW5ndGggPiAwID8gdGhpcy5fYmluZGluZ3MgOlxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3ZpZGVycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJiaW5kaW5nc1wiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJvdmlkZXJzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGlyZWN0aXZlTWV0YWRhdGE7XG59KG1ldGFkYXRhXzEuSW5qZWN0YWJsZU1ldGFkYXRhKSk7XG5leHBvcnRzLkRpcmVjdGl2ZU1ldGFkYXRhID0gRGlyZWN0aXZlTWV0YWRhdGE7XG4vKipcbiAqIERlY2xhcmUgcmV1c2FibGUgVUkgYnVpbGRpbmcgYmxvY2tzIGZvciBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBFYWNoIEFuZ3VsYXIgY29tcG9uZW50IHJlcXVpcmVzIGEgc2luZ2xlIGBAQ29tcG9uZW50YCBhbm5vdGF0aW9uLiBUaGVcbiAqIGBAQ29tcG9uZW50YFxuICogYW5ub3RhdGlvbiBzcGVjaWZpZXMgd2hlbiBhIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQsIGFuZCB3aGljaCBwcm9wZXJ0aWVzIGFuZCBob3N0TGlzdGVuZXJzIGl0XG4gKiBiaW5kcyB0by5cbiAqXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCwgQW5ndWxhclxuICogLSBjcmVhdGVzIGEgc2hhZG93IERPTSBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIC0gbG9hZHMgdGhlIHNlbGVjdGVkIHRlbXBsYXRlIGludG8gdGhlIHNoYWRvdyBET00uXG4gKiAtIGNyZWF0ZXMgYWxsIHRoZSBpbmplY3RhYmxlIG9iamVjdHMgY29uZmlndXJlZCB3aXRoIGBwcm92aWRlcnNgIGFuZCBgdmlld1Byb3ZpZGVyc2AuXG4gKlxuICogQWxsIHRlbXBsYXRlIGV4cHJlc3Npb25zIGFuZCBzdGF0ZW1lbnRzIGFyZSB0aGVuIGV2YWx1YXRlZCBhZ2FpbnN0IHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gKlxuICogRm9yIGRldGFpbHMgb24gdGhlIGBAVmlld2AgYW5ub3RhdGlvbiwgc2VlIHtAbGluayBWaWV3TWV0YWRhdGF9LlxuICpcbiAqICMjIExpZmVjeWNsZSBob29rc1xuICpcbiAqIFdoZW4gdGhlIGNvbXBvbmVudCBjbGFzcyBpbXBsZW1lbnRzIHNvbWUge0BsaW5rIC4uLy4uL2d1aWRlL2xpZmVjeWNsZS1ob29rcy5odG1sfSB0aGUgY2FsbGJhY2tzXG4gKiBhcmUgY2FsbGVkIGJ5IHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGF0IGRlZmluZWQgcG9pbnRzIGluIHRpbWUgZHVyaW5nIHRoZSBsaWZlIG9mIHRoZSBjb21wb25lbnQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9tZXRhZGF0YS50cyByZWdpb249J2NvbXBvbmVudCd9XG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgQ29tcG9uZW50TWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgcHJvcGVydGllcyA9IF9iLnByb3BlcnRpZXMsIGV2ZW50cyA9IF9iLmV2ZW50cywgaG9zdCA9IF9iLmhvc3QsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIG1vZHVsZUlkID0gX2IubW9kdWxlSWQsIGJpbmRpbmdzID0gX2IuYmluZGluZ3MsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgdmlld0JpbmRpbmdzID0gX2Iudmlld0JpbmRpbmdzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgX2MgPSBfYi5jaGFuZ2VEZXRlY3Rpb24sIGNoYW5nZURldGVjdGlvbiA9IF9jID09PSB2b2lkIDAgPyBjb25zdGFudHNfMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0IDogX2MsIHF1ZXJpZXMgPSBfYi5xdWVyaWVzLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCBzdHlsZVVybHMgPSBfYi5zdHlsZVVybHMsIHN0eWxlcyA9IF9iLnN0eWxlcywgZGlyZWN0aXZlcyA9IF9iLmRpcmVjdGl2ZXMsIHBpcGVzID0gX2IucGlwZXMsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uO1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBpbnB1dHM6IGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHMsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgZXhwb3J0QXM6IGV4cG9ydEFzLFxuICAgICAgICAgICAgYmluZGluZ3M6IGJpbmRpbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICBxdWVyaWVzOiBxdWVyaWVzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvbiA9IGNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgdGhpcy5fdmlld1Byb3ZpZGVycyA9IHZpZXdQcm92aWRlcnM7XG4gICAgICAgIHRoaXMuX3ZpZXdCaW5kaW5ncyA9IHZpZXdCaW5kaW5ncztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gc3R5bGVVcmxzO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xuICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBlbmNhcHN1bGF0aW9uO1xuICAgICAgICB0aGlzLm1vZHVsZUlkID0gbW9kdWxlSWQ7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRNZXRhZGF0YS5wcm90b3R5cGUsIFwidmlld1Byb3ZpZGVyc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSBzZXQgb2YgaW5qZWN0YWJsZSBvYmplY3RzIHRoYXQgYXJlIHZpc2libGUgdG8gaXRzIHZpZXcgRE9NIGNoaWxkcmVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyBTaW1wbGUgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBjbGFzcyB0aGF0IGNhbiBiZSBpbmplY3RlZDpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNsYXNzIEdyZWV0ZXIge1xuICAgICAgICAgKiAgICBncmVldChuYW1lOnN0cmluZykge1xuICAgICAgICAgKiAgICAgIHJldHVybiAnSGVsbG8gJyArIG5hbWUgKyAnISc7XG4gICAgICAgICAqICAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBARGlyZWN0aXZlKHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ25lZWRzLWdyZWV0ZXInXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIE5lZWRzR3JlZXRlciB7XG4gICAgICAgICAqICAgZ3JlZXRlcjpHcmVldGVyO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKGdyZWV0ZXI6R3JlZXRlcikge1xuICAgICAgICAgKiAgICAgdGhpcy5ncmVldGVyID0gZ3JlZXRlcjtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogQENvbXBvbmVudCh7XG4gICAgICAgICAqICAgc2VsZWN0b3I6ICdncmVldCcsXG4gICAgICAgICAqICAgdmlld1Byb3ZpZGVyczogW1xuICAgICAgICAgKiAgICAgR3JlZXRlclxuICAgICAgICAgKiAgIF0sXG4gICAgICAgICAqICAgdGVtcGxhdGU6IGA8bmVlZHMtZ3JlZXRlcj48L25lZWRzLWdyZWV0ZXI+YCxcbiAgICAgICAgICogICBkaXJlY3RpdmVzOiBbTmVlZHNHcmVldGVyXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBIZWxsb1dvcmxkIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fdmlld0JpbmRpbmdzKSAmJiB0aGlzLl92aWV3QmluZGluZ3MubGVuZ3RoID4gMCA/IHRoaXMuX3ZpZXdCaW5kaW5ncyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld1Byb3ZpZGVycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudE1ldGFkYXRhLnByb3RvdHlwZSwgXCJ2aWV3QmluZGluZ3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmlld1Byb3ZpZGVyczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbXBvbmVudE1ldGFkYXRhO1xufShEaXJlY3RpdmVNZXRhZGF0YSkpO1xuZXhwb3J0cy5Db21wb25lbnRNZXRhZGF0YSA9IENvbXBvbmVudE1ldGFkYXRhO1xuLyoqXG4gKiBEZWNsYXJlIHJldXNhYmxlIHBpcGUgZnVuY3Rpb24uXG4gKlxuICogQSBcInB1cmVcIiBwaXBlIGlzIG9ubHkgcmUtZXZhbHVhdGVkIHdoZW4gZWl0aGVyIHRoZSBpbnB1dCBvciBhbnkgb2YgdGhlIGFyZ3VtZW50cyBjaGFuZ2UuXG4gKlxuICogV2hlbiBub3Qgc3BlY2lmaWVkLCBwaXBlcyBkZWZhdWx0IHRvIGJlaW5nIHB1cmUuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9tZXRhZGF0YS50cyByZWdpb249J3BpcGUnfVxuICogQHRzMmRhcnRfY29uc3RcbiAqL1xudmFyIFBpcGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBpcGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQaXBlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBwdXJlID0gX2EucHVyZTtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3B1cmUgPSBwdXJlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGlwZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJwdXJlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3B1cmUpID8gdGhpcy5fcHVyZSA6IHRydWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBQaXBlTWV0YWRhdGE7XG59KG1ldGFkYXRhXzEuSW5qZWN0YWJsZU1ldGFkYXRhKSk7XG5leHBvcnRzLlBpcGVNZXRhZGF0YSA9IFBpcGVNZXRhZGF0YTtcbi8qKlxuICogRGVjbGFyZXMgYSBkYXRhLWJvdW5kIGlucHV0IHByb3BlcnR5LlxuICpcbiAqIEFuZ3VsYXIgYXV0b21hdGljYWxseSB1cGRhdGVzIGRhdGEtYm91bmQgcHJvcGVydGllcyBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbi5cbiAqXG4gKiBgSW5wdXRNZXRhZGF0YWAgdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lXG4gKiB1c2VkIHdoZW4gaW5zdGFudGlhdGluZyBhIGNvbXBvbmVudCBpbiB0aGUgdGVtcGxhdGUuIFdoZW4gbm90IHByb3ZpZGVkLFxuICogdGhlIG5hbWUgb2YgdGhlIGRlY29yYXRlZCBwcm9wZXJ0eSBpcyB1c2VkLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYSBjb21wb25lbnQgd2l0aCB0d28gaW5wdXQgcHJvcGVydGllcy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdiYW5rLWFjY291bnQnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIEJhbmsgTmFtZToge3tiYW5rTmFtZX19XG4gKiAgICAgQWNjb3VudCBJZDoge3tpZH19XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBCYW5rQWNjb3VudCB7XG4gKiAgIEBJbnB1dCgpIGJhbmtOYW1lOiBzdHJpbmc7XG4gKiAgIEBJbnB1dCgnYWNjb3VudC1pZCcpIGlkOiBzdHJpbmc7XG4gKlxuICogICAvLyB0aGlzIHByb3BlcnR5IGlzIG5vdCBib3VuZCwgYW5kIHdvbid0IGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBieSBBbmd1bGFyXG4gKiAgIG5vcm1hbGl6ZWRCYW5rTmFtZTogc3RyaW5nO1xuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGJhbmstYWNjb3VudCBiYW5rLW5hbWU9XCJSQkNcIiBhY2NvdW50LWlkPVwiNDc0N1wiPjwvYmFuay1hY2NvdW50PlxuICogICBgLFxuICogICBkaXJlY3RpdmVzOiBbQmFua0FjY291bnRdXG4gKiB9KVxuICogY2xhc3MgQXBwIHt9XG4gKlxuICogYm9vdHN0cmFwKEFwcCk7XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBJbnB1dE1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnB1dE1ldGFkYXRhKFxuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSB1c2VkIHdoZW4gaW5zdGFudGlhdGluZyBhIGNvbXBvbmVudCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1Byb3BlcnR5TmFtZSA9IGJpbmRpbmdQcm9wZXJ0eU5hbWU7XG4gICAgfVxuICAgIHJldHVybiBJbnB1dE1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuSW5wdXRNZXRhZGF0YSA9IElucHV0TWV0YWRhdGE7XG4vKipcbiAqIERlY2xhcmVzIGFuIGV2ZW50LWJvdW5kIG91dHB1dCBwcm9wZXJ0eS5cbiAqXG4gKiBXaGVuIGFuIG91dHB1dCBwcm9wZXJ0eSBlbWl0cyBhbiBldmVudCwgYW4gZXZlbnQgaGFuZGxlciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50XG4gKiB0aGUgdGVtcGxhdGUgaXMgaW52b2tlZC5cbiAqXG4gKiBgT3V0cHV0TWV0YWRhdGFgIHRha2VzIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZVxuICogdXNlZCB3aGVuIGluc3RhbnRpYXRpbmcgYSBjb21wb25lbnQgaW4gdGhlIHRlbXBsYXRlLiBXaGVuIG5vdCBwcm92aWRlZCxcbiAqIHRoZSBuYW1lIG9mIHRoZSBkZWNvcmF0ZWQgcHJvcGVydHkgaXMgdXNlZC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBEaXJlY3RpdmUoe1xuICogICBzZWxlY3RvcjogJ2ludGVydmFsLWRpcicsXG4gKiB9KVxuICogY2xhc3MgSW50ZXJ2YWxEaXIge1xuICogICBAT3V0cHV0KCkgZXZlcnlTZWNvbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gKiAgIEBPdXRwdXQoJ2V2ZXJ5Rml2ZVNlY29uZHMnKSBmaXZlNVNlY3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gKlxuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmV2ZXJ5U2Vjb25kLmVtaXQoXCJldmVudFwiKSwgMTAwMCk7XG4gKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5maXZlNVNlY3MuZW1pdChcImV2ZW50XCIpLCA1MDAwKTtcbiAqICAgfVxuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGludGVydmFsLWRpciAoZXZlcnlTZWNvbmQpPVwiZXZlcnlTZWNvbmQoKVwiIChldmVyeUZpdmVTZWNvbmRzKT1cImV2ZXJ5Rml2ZVNlY29uZHMoKVwiPlxuICogICAgIDwvaW50ZXJ2YWwtZGlyPlxuICogICBgLFxuICogICBkaXJlY3RpdmVzOiBbSW50ZXJ2YWxEaXJdXG4gKiB9KVxuICogY2xhc3MgQXBwIHtcbiAqICAgZXZlcnlTZWNvbmQoKSB7IGNvbnNvbGUubG9nKCdzZWNvbmQnKTsgfVxuICogICBldmVyeUZpdmVTZWNvbmRzKCkgeyBjb25zb2xlLmxvZygnZml2ZSBzZWNvbmRzJyk7IH1cbiAqIH1cbiAqIGJvb3RzdHJhcChBcHApO1xuICogYGBgXG4gKiBAdHMyZGFydF9jb25zdFxuICovXG52YXIgT3V0cHV0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE91dHB1dE1ldGFkYXRhKGJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nUHJvcGVydHlOYW1lID0gYmluZGluZ1Byb3BlcnR5TmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIE91dHB1dE1ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuT3V0cHV0TWV0YWRhdGEgPSBPdXRwdXRNZXRhZGF0YTtcbi8qKlxuICogRGVjbGFyZXMgYSBob3N0IHByb3BlcnR5IGJpbmRpbmcuXG4gKlxuICogQW5ndWxhciBhdXRvbWF0aWNhbGx5IGNoZWNrcyBob3N0IHByb3BlcnR5IGJpbmRpbmdzIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uLlxuICogSWYgYSBiaW5kaW5nIGNoYW5nZXMsIGl0IHdpbGwgdXBkYXRlIHRoZSBob3N0IGVsZW1lbnQgb2YgdGhlIGRpcmVjdGl2ZS5cbiAqXG4gKiBgSG9zdEJpbmRpbmdNZXRhZGF0YWAgdGFrZXMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBwcm9wZXJ0eVxuICogbmFtZSBvZiB0aGUgaG9zdCBlbGVtZW50IHRoYXQgd2lsbCBiZSB1cGRhdGVkLiBXaGVuIG5vdCBwcm92aWRlZCxcbiAqIHRoZSBjbGFzcyBwcm9wZXJ0eSBuYW1lIGlzIHVzZWQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGRpcmVjdGl2ZSB0aGF0IHNldHMgdGhlIGB2YWxpZGAgYW5kIGBpbnZhbGlkYCBjbGFzc2VzXG4gKiBvbiB0aGUgRE9NIGVsZW1lbnQgdGhhdCBoYXMgbmdNb2RlbCBkaXJlY3RpdmUgb24gaXQuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbbmdNb2RlbF0nfSlcbiAqIGNsYXNzIE5nTW9kZWxTdGF0dXMge1xuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgY29udHJvbDpOZ01vZGVsKSB7fVxuICogICBASG9zdEJpbmRpbmcoJ2NsYXNzLnZhbGlkJykgZ2V0IHZhbGlkIHsgcmV0dXJuIHRoaXMuY29udHJvbC52YWxpZDsgfVxuICogICBASG9zdEJpbmRpbmcoJ2NsYXNzLmludmFsaWQnKSBnZXQgaW52YWxpZCB7IHJldHVybiB0aGlzLmNvbnRyb2wuaW52YWxpZDsgfVxuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHRlbXBsYXRlOiBgPGlucHV0IFsobmdNb2RlbCldPVwicHJvcFwiPmAsXG4gKiAgIGRpcmVjdGl2ZXM6IFtGT1JNX0RJUkVDVElWRVMsIE5nTW9kZWxTdGF0dXNdXG4gKiB9KVxuICogY2xhc3MgQXBwIHtcbiAqICAgcHJvcDtcbiAqIH1cbiAqXG4gKiBib290c3RyYXAoQXBwKTtcbiAqIGBgYFxuICogQHRzMmRhcnRfY29uc3RcbiAqL1xudmFyIEhvc3RCaW5kaW5nTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhvc3RCaW5kaW5nTWV0YWRhdGEoaG9zdFByb3BlcnR5TmFtZSkge1xuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0eU5hbWUgPSBob3N0UHJvcGVydHlOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gSG9zdEJpbmRpbmdNZXRhZGF0YTtcbn0oKSk7XG5leHBvcnRzLkhvc3RCaW5kaW5nTWV0YWRhdGEgPSBIb3N0QmluZGluZ01ldGFkYXRhO1xuLyoqXG4gKiBEZWNsYXJlcyBhIGhvc3QgbGlzdGVuZXIuXG4gKlxuICogQW5ndWxhciB3aWxsIGludm9rZSB0aGUgZGVjb3JhdGVkIG1ldGhvZCB3aGVuIHRoZSBob3N0IGVsZW1lbnQgZW1pdHMgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBJZiB0aGUgZGVjb3JhdGVkIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAsIHRoZW4gYHByZXZlbnREZWZhdWx0YCBpcyBhcHBsaWVkIG9uIHRoZSBET01cbiAqIGV2ZW50LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGRlY2xhcmVzIGEgZGlyZWN0aXZlIHRoYXQgYXR0YWNoZXMgYSBjbGljayBsaXN0ZW5lciB0byB0aGUgYnV0dG9uIGFuZFxuICogY291bnRzIGNsaWNrcy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBARGlyZWN0aXZlKHtzZWxlY3RvcjogJ2J1dHRvbltjb3VudGluZ10nfSlcbiAqIGNsYXNzIENvdW50Q2xpY2tzIHtcbiAqICAgbnVtYmVyT2ZDbGlja3MgPSAwO1xuICpcbiAqICAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcbiAqICAgb25DbGljayhidG4pIHtcbiAqICAgICBjb25zb2xlLmxvZyhcImJ1dHRvblwiLCBidG4sIFwibnVtYmVyIG9mIGNsaWNrczpcIiwgdGhpcy5udW1iZXJPZkNsaWNrcysrKTtcbiAqICAgfVxuICogfVxuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHRlbXBsYXRlOiBgPGJ1dHRvbiBjb3VudGluZz5JbmNyZW1lbnQ8L2J1dHRvbj5gLFxuICogICBkaXJlY3RpdmVzOiBbQ291bnRDbGlja3NdXG4gKiB9KVxuICogY2xhc3MgQXBwIHt9XG4gKlxuICogYm9vdHN0cmFwKEFwcCk7XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBIb3N0TGlzdGVuZXJNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSG9zdExpc3RlbmVyTWV0YWRhdGEoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICByZXR1cm4gSG9zdExpc3RlbmVyTWV0YWRhdGE7XG59KCkpO1xuZXhwb3J0cy5Ib3N0TGlzdGVuZXJNZXRhZGF0YSA9IEhvc3RMaXN0ZW5lck1ldGFkYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbihmdW5jdGlvbiAoTGlmZWN5Y2xlSG9va3MpIHtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uSW5pdFwiXSA9IDBdID0gXCJPbkluaXRcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uRGVzdHJveVwiXSA9IDFdID0gXCJPbkRlc3Ryb3lcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkRvQ2hlY2tcIl0gPSAyXSA9IFwiRG9DaGVja1wiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25DaGFuZ2VzXCJdID0gM10gPSBcIk9uQ2hhbmdlc1wiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJDb250ZW50SW5pdFwiXSA9IDRdID0gXCJBZnRlckNvbnRlbnRJbml0XCI7XG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlckNvbnRlbnRDaGVja2VkXCJdID0gNV0gPSBcIkFmdGVyQ29udGVudENoZWNrZWRcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0luaXRcIl0gPSA2XSA9IFwiQWZ0ZXJWaWV3SW5pdFwiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJWaWV3Q2hlY2tlZFwiXSA9IDddID0gXCJBZnRlclZpZXdDaGVja2VkXCI7XG59KShleHBvcnRzLkxpZmVjeWNsZUhvb2tzIHx8IChleHBvcnRzLkxpZmVjeWNsZUhvb2tzID0ge30pKTtcbnZhciBMaWZlY3ljbGVIb29rcyA9IGV4cG9ydHMuTGlmZWN5Y2xlSG9va3M7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnRzLkxJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBbXG4gICAgTGlmZWN5Y2xlSG9va3MuT25Jbml0LFxuICAgIExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSxcbiAgICBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrLFxuICAgIExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcyxcbiAgICBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0LFxuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQsXG4gICAgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCxcbiAgICBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlmZWN5Y2xlX2hvb2tzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBEZWZpbmVzIHRlbXBsYXRlIGFuZCBzdHlsZSBlbmNhcHN1bGF0aW9uIG9wdGlvbnMgYXZhaWxhYmxlIGZvciBDb21wb25lbnQncyB7QGxpbmsgVmlld30uXG4gKlxuICogU2VlIHtAbGluayBWaWV3TWV0YWRhdGEjZW5jYXBzdWxhdGlvbn0uXG4gKi9cbihmdW5jdGlvbiAoVmlld0VuY2Fwc3VsYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBFbXVsYXRlIGBOYXRpdmVgIHNjb3Bpbmcgb2Ygc3R5bGVzIGJ5IGFkZGluZyBhbiBhdHRyaWJ1dGUgY29udGFpbmluZyBzdXJyb2dhdGUgaWQgdG8gdGhlIEhvc3RcbiAgICAgKiBFbGVtZW50IGFuZCBwcmUtcHJvY2Vzc2luZyB0aGUgc3R5bGUgcnVsZXMgcHJvdmlkZWQgdmlhXG4gICAgICoge0BsaW5rIFZpZXdNZXRhZGF0YSNzdHlsZXN9IG9yIHtAbGluayBWaWV3TWV0YWRhdGEjc3R5bGVzVXJsc30sIGFuZCBhZGRpbmcgdGhlIG5ldyBIb3N0IEVsZW1lbnRcbiAgICAgKiBhdHRyaWJ1dGUgdG8gYWxsIHNlbGVjdG9ycy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgb3B0aW9uLlxuICAgICAqL1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiRW11bGF0ZWRcIl0gPSAwXSA9IFwiRW11bGF0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIG5hdGl2ZSBlbmNhcHN1bGF0aW9uIG1lY2hhbmlzbSBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICpcbiAgICAgKiBGb3IgdGhlIERPTSB0aGlzIG1lYW5zIHVzaW5nIFtTaGFkb3cgRE9NXShodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL3NoYWRvdy8pIGFuZFxuICAgICAqIGNyZWF0aW5nIGEgU2hhZG93Um9vdCBmb3IgQ29tcG9uZW50J3MgSG9zdCBFbGVtZW50LlxuICAgICAqL1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTmF0aXZlXCJdID0gMV0gPSBcIk5hdGl2ZVwiO1xuICAgIC8qKlxuICAgICAqIERvbid0IHByb3ZpZGUgYW55IHRlbXBsYXRlIG9yIHN0eWxlIGVuY2Fwc3VsYXRpb24uXG4gICAgICovXG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJOb25lXCJdID0gMl0gPSBcIk5vbmVcIjtcbn0pKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gfHwgKGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24gPSB7fSkpO1xudmFyIFZpZXdFbmNhcHN1bGF0aW9uID0gZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbjtcbmV4cG9ydHMuVklFV19FTkNBUFNVTEFUSU9OX1ZBTFVFUyA9IFtWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlLCBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXTtcbi8qKlxuICogTWV0YWRhdGEgcHJvcGVydGllcyBhdmFpbGFibGUgZm9yIGNvbmZpZ3VyaW5nIFZpZXdzLlxuICpcbiAqIEVhY2ggQW5ndWxhciBjb21wb25lbnQgcmVxdWlyZXMgYSBzaW5nbGUgYEBDb21wb25lbnRgIGFuZCBhdCBsZWFzdCBvbmUgYEBWaWV3YCBhbm5vdGF0aW9uLiBUaGVcbiAqIGBAVmlld2AgYW5ub3RhdGlvbiBzcGVjaWZpZXMgdGhlIEhUTUwgdGVtcGxhdGUgdG8gdXNlLCBhbmQgbGlzdHMgdGhlIGRpcmVjdGl2ZXMgdGhhdCBhcmUgYWN0aXZlXG4gKiB3aXRoaW4gdGhlIHRlbXBsYXRlLlxuICpcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkLCB0aGUgdGVtcGxhdGUgaXMgbG9hZGVkIGludG8gdGhlIGNvbXBvbmVudCdzIHNoYWRvdyByb290LCBhbmRcbiAqIHRoZSBleHByZXNzaW9ucyBhbmQgc3RhdGVtZW50cyBpbiB0aGUgdGVtcGxhdGUgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0IHRoZSBjb21wb25lbnQuXG4gKlxuICogRm9yIGRldGFpbHMgb24gdGhlIGBAQ29tcG9uZW50YCBhbm5vdGF0aW9uLCBzZWUge0BsaW5rIENvbXBvbmVudE1ldGFkYXRhfS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxuICogICB0ZW1wbGF0ZTogJ0hlbGxvIHt7bmFtZX19IScsXG4gKiAgIGRpcmVjdGl2ZXM6IFtHcmVldFVzZXIsIEJvbGRdXG4gKiB9KVxuICogY2xhc3MgR3JlZXQge1xuICogICBuYW1lOiBzdHJpbmc7XG4gKlxuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICB0aGlzLm5hbWUgPSAnV29ybGQnO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqIEB0czJkYXJ0X2NvbnN0XG4gKi9cbnZhciBWaWV3TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdGVtcGxhdGVVcmwgPSBfYi50ZW1wbGF0ZVVybCwgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgZGlyZWN0aXZlcyA9IF9iLmRpcmVjdGl2ZXMsIHBpcGVzID0gX2IucGlwZXMsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gc3R5bGVVcmxzO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xuICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBlbmNhcHN1bGF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gVmlld01ldGFkYXRhO1xufSgpKTtcbmV4cG9ydHMuVmlld01ldGFkYXRhID0gVmlld01ldGFkYXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlldy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25zb2xlXzEgPSByZXF1aXJlKCcuL2NvbnNvbGUnKTtcbnZhciByZWZsZWN0aW9uXzEgPSByZXF1aXJlKCcuL3JlZmxlY3Rpb24vcmVmbGVjdGlvbicpO1xudmFyIHJlZmxlY3Rvcl9yZWFkZXJfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdGlvbi9yZWZsZWN0b3JfcmVhZGVyJyk7XG52YXIgdGVzdGFiaWxpdHlfMSA9IHJlcXVpcmUoJy4vdGVzdGFiaWxpdHkvdGVzdGFiaWxpdHknKTtcbnZhciBhcHBsaWNhdGlvbl9yZWZfMSA9IHJlcXVpcmUoJy4vYXBwbGljYXRpb25fcmVmJyk7XG5mdW5jdGlvbiBfcmVmbGVjdG9yKCkge1xuICAgIHJldHVybiByZWZsZWN0aW9uXzEucmVmbGVjdG9yO1xufVxudmFyIF9fdW51c2VkOyAvLyBwcmV2ZW50IG1pc3NpbmcgdXNlIERhcnQgd2FybmluZy5cbi8qKlxuICogQSBkZWZhdWx0IHNldCBvZiBwcm92aWRlcnMgd2hpY2ggc2hvdWxkIGJlIGluY2x1ZGVkIGluIGFueSBBbmd1bGFyIHBsYXRmb3JtLlxuICovXG5leHBvcnRzLlBMQVRGT1JNX0NPTU1PTl9QUk9WSURFUlMgPSBbXG4gICAgYXBwbGljYXRpb25fcmVmXzEuUExBVEZPUk1fQ09SRV9QUk9WSURFUlMsXG4gICAgLypAdHMyZGFydF9Qcm92aWRlciovIHsgcHJvdmlkZTogcmVmbGVjdGlvbl8xLlJlZmxlY3RvciwgdXNlRmFjdG9yeTogX3JlZmxlY3RvciwgZGVwczogW10gfSxcbiAgICAvKkB0czJkYXJ0X1Byb3ZpZGVyKi8geyBwcm92aWRlOiByZWZsZWN0b3JfcmVhZGVyXzEuUmVmbGVjdG9yUmVhZGVyLCB1c2VFeGlzdGluZzogcmVmbGVjdGlvbl8xLlJlZmxlY3RvciB9LFxuICAgIHRlc3RhYmlsaXR5XzEuVGVzdGFiaWxpdHlSZWdpc3RyeSxcbiAgICBjb25zb2xlXzEuQ29uc29sZVxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtX2NvbW1vbl9wcm92aWRlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZGlfMSA9IHJlcXVpcmUoJy4vZGknKTtcbi8qKlxuICogQSB0b2tlbiB0aGF0IGNhbiBiZSBwcm92aWRlZCB3aGVuIGJvb3RzdHJhcGluZyBhbiBhcHBsaWNhdGlvbiB0byBtYWtlIGFuIGFycmF5IG9mIGRpcmVjdGl2ZXNcbiAqIGF2YWlsYWJsZSBpbiBldmVyeSBjb21wb25lbnQgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtQTEFURk9STV9ESVJFQ1RJVkVTfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7T3RoZXJEaXJlY3RpdmV9IGZyb20gJy4vbXlEaXJlY3RpdmVzJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1jb21wb25lbnQnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDwhLS0gY2FuIHVzZSBvdGhlciBkaXJlY3RpdmUgZXZlbiB0aG91Z2ggdGhlIGNvbXBvbmVudCBkb2VzIG5vdCBsaXN0IGl0IGluIGBkaXJlY3RpdmVzYCAtLT5cbiAqICAgICA8b3RoZXItZGlyZWN0aXZlPjwvb3RoZXItZGlyZWN0aXZlPlxuICogICBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgLi4uXG4gKiB9XG4gKlxuICogYm9vdHN0cmFwKE15Q29tcG9uZW50LCBbcHJvdmlkZShQTEFURk9STV9ESVJFQ1RJVkVTLCB7dXNlVmFsdWU6IFtPdGhlckRpcmVjdGl2ZV0sIG11bHRpOnRydWV9KV0pO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuUExBVEZPUk1fRElSRUNUSVZFUyA9IFxuLypAdHMyZGFydF9jb25zdCovIG5ldyBkaV8xLk9wYXF1ZVRva2VuKFwiUGxhdGZvcm0gRGlyZWN0aXZlc1wiKTtcbi8qKlxuICogQSB0b2tlbiB0aGF0IGNhbiBiZSBwcm92aWRlZCB3aGVuIGJvb3RzdHJhcGluZyBhbiBhcHBsaWNhdGlvbiB0byBtYWtlIGFuIGFycmF5IG9mIHBpcGVzXG4gKiBhdmFpbGFibGUgaW4gZXZlcnkgY29tcG9uZW50IG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7UExBVEZPUk1fUElQRVN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtPdGhlclBpcGV9IGZyb20gJy4vbXlQaXBlJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1jb21wb25lbnQnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIHt7MTIzIHwgb3RoZXItcGlwZX19XG4gKiAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQge1xuICogICAuLi5cbiAqIH1cbiAqXG4gKiBib290c3RyYXAoTXlDb21wb25lbnQsIFtwcm92aWRlKFBMQVRGT1JNX1BJUEVTLCB7dXNlVmFsdWU6IFtPdGhlclBpcGVdLCBtdWx0aTp0cnVlfSldKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLlBMQVRGT1JNX1BJUEVTID0gbmV3IGRpXzEuT3BhcXVlVG9rZW4oXCJQbGF0Zm9ybSBQaXBlc1wiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtX2RpcmVjdGl2ZXNfYW5kX3BpcGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGltcGwgPSByZXF1aXJlKCcuL3d0Zl9pbXBsJyk7XG4vLyBDaGFuZ2UgZXhwb3J0cyB0byBjb25zdCBvbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3RzMmRhcnQvaXNzdWVzLzE1MFxuLyoqXG4gKiBUcnVlIGlmIFdURiBpcyBlbmFibGVkLlxuICovXG5leHBvcnRzLnd0ZkVuYWJsZWQgPSBpbXBsLmRldGVjdFdURigpO1xuZnVuY3Rpb24gbm9vcFNjb3BlKGFyZzAsIGFyZzEpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ3JlYXRlIHRyYWNlIHNjb3BlLlxuICpcbiAqIFNjb3BlcyBtdXN0IGJlIHN0cmljdGx5IG5lc3RlZCBhbmQgYXJlIGFuYWxvZ291cyB0byBzdGFjayBmcmFtZXMsIGJ1dFxuICogZG8gbm90IGhhdmUgdG8gZm9sbG93IHRoZSBzdGFjayBmcmFtZXMuIEluc3RlYWQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB0aGV5IGZvbGxvdyBsb2dpY2FsXG4gKiBuZXN0aW5nLiBZb3UgbWF5IHdhbnQgdG8gdXNlXG4gKiBbRXZlbnRcbiAqIFNpZ25hdHVyZXNdKGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL3RyYWNpbmctZnJhbWV3b3JrL2luc3RydW1lbnRpbmctY29kZS5odG1sI2N1c3RvbS1ldmVudHMpXG4gKiBhcyB0aGV5IGFyZSBkZWZpbmVkIGluIFdURi5cbiAqXG4gKiBVc2VkIHRvIG1hcmsgc2NvcGUgZW50cnkuIFRoZSByZXR1cm4gdmFsdWUgaXMgdXNlZCB0byBsZWF2ZSB0aGUgc2NvcGUuXG4gKlxuICogICAgIHZhciBteVNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ015Q2xhc3MjbXlNZXRob2QoYXNjaWkgc29tZVZhbCknKTtcbiAqXG4gKiAgICAgc29tZU1ldGhvZCgpIHtcbiAqICAgICAgICB2YXIgcyA9IG15U2NvcGUoJ0ZvbycpOyAvLyAnRm9vJyBnZXRzIHN0b3JlZCBpbiB0cmFjaW5nIFVJXG4gKiAgICAgICAgLy8gRE8gU09NRSBXT1JLIEhFUkVcbiAqICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgMTIzKTsgLy8gUmV0dXJuIHZhbHVlIDEyM1xuICogICAgIH1cbiAqXG4gKiBOb3RlLCBhZGRpbmcgdHJ5LWZpbmFsbHkgYmxvY2sgYXJvdW5kIHRoZSB3b3JrIHRvIGVuc3VyZSB0aGF0IGB3dGZMZWF2ZWAgZ2V0cyBjYWxsZWQgY2FuXG4gKiBuZWdhdGl2ZWx5IGltcGFjdCB0aGUgcGVyZm9ybWFuY2Ugb2YgeW91ciBhcHBsaWNhdGlvbi4gRm9yIHRoaXMgcmVhc29uIHdlIHJlY29tbWVuZCB0aGF0XG4gKiB5b3UgZG9uJ3QgYWRkIHRoZW0gdG8gZW5zdXJlIHRoYXQgYHd0ZkxlYXZlYCBnZXRzIGNhbGxlZC4gSW4gcHJvZHVjdGlvbiBgd3RmTGVhdmVgIGlzIGEgbm9vcCBhbmRcbiAqIHNvIHRyeS1maW5hbGx5IGJsb2NrIGhhcyBubyB2YWx1ZS4gV2hlbiBkZWJ1Z2dpbmcgcGVyZiBpc3N1ZXMsIHNraXBwaW5nIGB3dGZMZWF2ZWAsIGRvIHRvXG4gKiBleGNlcHRpb24sIHdpbGwgcHJvZHVjZSBpbmNvcnJlY3QgdHJhY2UsIGJ1dCBwcmVzZW5jZSBvZiBleGNlcHRpb24gc2lnbmlmaWVzIGxvZ2ljIGVycm9yIHdoaWNoXG4gKiBuZWVkcyB0byBiZSBmaXhlZCBiZWZvcmUgdGhlIGFwcCBzaG91bGQgYmUgcHJvZmlsZWQuIEFkZCB0cnktZmluYWxseSBvbmx5IHdoZW4geW91IGV4cGVjdCB0aGF0XG4gKiBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWQgZHVyaW5nIG5vcm1hbCBleGVjdXRpb24gd2hpbGUgcHJvZmlsaW5nLlxuICpcbiAqL1xuZXhwb3J0cy53dGZDcmVhdGVTY29wZSA9IGV4cG9ydHMud3RmRW5hYmxlZCA/IGltcGwuY3JlYXRlU2NvcGUgOiBmdW5jdGlvbiAoc2lnbmF0dXJlLCBmbGFncykgeyByZXR1cm4gbm9vcFNjb3BlOyB9O1xuLyoqXG4gKiBVc2VkIHRvIG1hcmsgZW5kIG9mIFNjb3BlLlxuICpcbiAqIC0gYHNjb3BlYCB0byBlbmQuXG4gKiAtIGByZXR1cm5WYWx1ZWAgKG9wdGlvbmFsKSB0byBiZSBwYXNzZWQgdG8gdGhlIFdURi5cbiAqXG4gKiBSZXR1cm5zIHRoZSBgcmV0dXJuVmFsdWUgZm9yIGVhc3kgY2hhaW5pbmcuXG4gKi9cbmV4cG9ydHMud3RmTGVhdmUgPSBleHBvcnRzLnd0ZkVuYWJsZWQgPyBpbXBsLmxlYXZlIDogZnVuY3Rpb24gKHMsIHIpIHsgcmV0dXJuIHI7IH07XG4vKipcbiAqIFVzZWQgdG8gbWFyayBBc3luYyBzdGFydC4gQXN5bmMgYXJlIHNpbWlsYXIgdG8gc2NvcGUgYnV0IHRoZXkgZG9uJ3QgaGF2ZSB0byBiZSBzdHJpY3RseSBuZXN0ZWQuXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW4gdGhlIGNhbGwgdG8gW2VuZEFzeW5jXS4gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cbiAqIGVuYWJsZWQuXG4gKlxuICogICAgIHNvbWVNZXRob2QoKSB7XG4gKiAgICAgICAgdmFyIHMgPSB3dGZTdGFydFRpbWVSYW5nZSgnSFRUUDpHRVQnLCAnc29tZS51cmwnKTtcbiAqICAgICAgICB2YXIgZnV0dXJlID0gbmV3IEZ1dHVyZS5kZWxheSg1KS50aGVuKChfKSB7XG4gKiAgICAgICAgICB3dGZFbmRUaW1lUmFuZ2Uocyk7XG4gKiAgICAgICAgfSk7XG4gKiAgICAgfVxuICovXG5leHBvcnRzLnd0ZlN0YXJ0VGltZVJhbmdlID0gZXhwb3J0cy53dGZFbmFibGVkID8gaW1wbC5zdGFydFRpbWVSYW5nZSA6IGZ1bmN0aW9uIChyYW5nZVR5cGUsIGFjdGlvbikgeyByZXR1cm4gbnVsbDsgfTtcbi8qKlxuICogRW5kcyBhIGFzeW5jIHRpbWUgcmFuZ2Ugb3BlcmF0aW9uLlxuICogW3JhbmdlXSBpcyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gW3d0ZlN0YXJ0VGltZVJhbmdlXSBBc3luYyByYW5nZXMgb25seSB3b3JrIGlmIFdURiBoYXMgYmVlblxuICogZW5hYmxlZC5cbiAqL1xuZXhwb3J0cy53dGZFbmRUaW1lUmFuZ2UgPSBleHBvcnRzLnd0ZkVuYWJsZWQgPyBpbXBsLmVuZFRpbWVSYW5nZSA6IGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvZmlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciB0cmFjZTtcbnZhciBldmVudHM7XG5mdW5jdGlvbiBkZXRlY3RXVEYoKSB7XG4gICAgdmFyIHd0ZiA9IGxhbmdfMS5nbG9iYWxbJ3d0ZiddO1xuICAgIGlmICh3dGYpIHtcbiAgICAgICAgdHJhY2UgPSB3dGZbJ3RyYWNlJ107XG4gICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgZXZlbnRzID0gdHJhY2VbJ2V2ZW50cyddO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5kZXRlY3RXVEYgPSBkZXRlY3RXVEY7XG5mdW5jdGlvbiBjcmVhdGVTY29wZShzaWduYXR1cmUsIGZsYWdzKSB7XG4gICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSBudWxsOyB9XG4gICAgcmV0dXJuIGV2ZW50cy5jcmVhdGVTY29wZShzaWduYXR1cmUsIGZsYWdzKTtcbn1cbmV4cG9ydHMuY3JlYXRlU2NvcGUgPSBjcmVhdGVTY29wZTtcbmZ1bmN0aW9uIGxlYXZlKHNjb3BlLCByZXR1cm5WYWx1ZSkge1xuICAgIHRyYWNlLmxlYXZlU2NvcGUoc2NvcGUsIHJldHVyblZhbHVlKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5leHBvcnRzLmxlYXZlID0gbGVhdmU7XG5mdW5jdGlvbiBzdGFydFRpbWVSYW5nZShyYW5nZVR5cGUsIGFjdGlvbikge1xuICAgIHJldHVybiB0cmFjZS5iZWdpblRpbWVSYW5nZShyYW5nZVR5cGUsIGFjdGlvbik7XG59XG5leHBvcnRzLnN0YXJ0VGltZVJhbmdlID0gc3RhcnRUaW1lUmFuZ2U7XG5mdW5jdGlvbiBlbmRUaW1lUmFuZ2UocmFuZ2UpIHtcbiAgICB0cmFjZS5lbmRUaW1lUmFuZ2UocmFuZ2UpO1xufVxuZXhwb3J0cy5lbmRUaW1lUmFuZ2UgPSBlbmRUaW1lUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13dGZfaW1wbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuKiBUaGlzIGlzIGhlcmUgYmVjYXVzZSBEQVJUIHJlcXVpcmVzIGl0LiBJdCBpcyBub29wIGluIEpTLlxuKi9cbmZ1bmN0aW9uIHd0ZkluaXQoKSB7IH1cbmV4cG9ydHMud3RmSW5pdCA9IHd0ZkluaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13dGZfaW5pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByZWZsZWN0b3JfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdG9yJyk7XG52YXIgcmVmbGVjdG9yXzIgPSByZXF1aXJlKCcuL3JlZmxlY3RvcicpO1xuZXhwb3J0cy5SZWZsZWN0b3IgPSByZWZsZWN0b3JfMi5SZWZsZWN0b3I7XG5leHBvcnRzLlJlZmxlY3Rpb25JbmZvID0gcmVmbGVjdG9yXzIuUmVmbGVjdGlvbkluZm87XG52YXIgcmVmbGVjdGlvbl9jYXBhYmlsaXRpZXNfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdGlvbl9jYXBhYmlsaXRpZXMnKTtcbi8qKlxuICogVGhlIHtAbGluayBSZWZsZWN0b3J9IHVzZWQgaW50ZXJuYWxseSBpbiBBbmd1bGFyIHRvIGFjY2VzcyBtZXRhZGF0YVxuICogYWJvdXQgc3ltYm9scy5cbiAqL1xuZXhwb3J0cy5yZWZsZWN0b3IgPSBuZXcgcmVmbGVjdG9yXzEuUmVmbGVjdG9yKG5ldyByZWZsZWN0aW9uX2NhcGFiaWxpdGllc18xLlJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMocmVmbGVjdCkge1xuICAgICAgICB0aGlzLl9yZWZsZWN0ID0gbGFuZ18xLmlzUHJlc2VudChyZWZsZWN0KSA/IHJlZmxlY3QgOiBsYW5nXzEuZ2xvYmFsLlJlZmxlY3Q7XG4gICAgfVxuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmlzUmVmbGVjdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmZhY3RvcnkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBzd2l0Y2ggKHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyB0KCk7IH07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSkgeyByZXR1cm4gbmV3IHQoYTEpOyB9O1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyKSB7IHJldHVybiBuZXcgdChhMSwgYTIpOyB9O1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMykgeyByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMyk7IH07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkgeyByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQpOyB9O1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7IHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUpOyB9O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2LCBhMTcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2LCBhMTcsIGExOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2LCBhMTcsIGExOCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNywgYTE4LCBhMTkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0KGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTksIGExMCwgYTExLCBhMTIsIGExMywgYTE0LCBhMTUsIGExNiwgYTE3LCBhMTgsIGExOSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTAsIGExMSwgYTEyLCBhMTMsIGExNCwgYTE1LCBhMTYsIGExNywgYTE4LCBhMTksIGEyMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHQoYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwLCBhMTEsIGExMiwgYTEzLCBhMTQsIGExNSwgYTE2LCBhMTcsIGExOCwgYTE5LCBhMjApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEgZmFjdG9yeSBmb3IgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeSh0KSArIFwiJyBiZWNhdXNlIGl0cyBjb25zdHJ1Y3RvciBoYXMgbW9yZSB0aGFuIDIwIGFyZ3VtZW50c1wiKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5femlwVHlwZXNBbmRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChwYXJhbVR5cGVzLCBwYXJhbUFubm90YXRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShwYXJhbUFubm90YXRpb25zLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkocGFyYW1UeXBlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBUUyBvdXRwdXRzIE9iamVjdCBmb3IgcGFyYW1ldGVycyB3aXRob3V0IHR5cGVzLCB3aGlsZSBUcmFjZXVyIG9taXRzXG4gICAgICAgICAgICAvLyB0aGUgYW5ub3RhdGlvbnMuIEZvciBub3cgd2UgcHJlc2VydmUgdGhlIFRyYWNldXIgYmVoYXZpb3IgdG8gYWlkXG4gICAgICAgICAgICAvLyBtaWdyYXRpb24sIGJ1dCB0aGlzIGNhbiBiZSByZXZpc2l0ZWQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtVHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbVR5cGVzW2ldICE9IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtwYXJhbVR5cGVzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyYW1Bbm5vdGF0aW9ucykgJiYgbGFuZ18xLmlzUHJlc2VudChwYXJhbUFubm90YXRpb25zW2ldKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXS5jb25jYXQocGFyYW1Bbm5vdGF0aW9uc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVPckZ1bmMucGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlT3JGdW5jLnBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVPckZ1bmMuY3RvclBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICB2YXIgY3RvclBhcmFtZXRlcnMgPSB0eXBlT3JGdW5jLmN0b3JQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgdmFyIHBhcmFtVHlwZXNfMSA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtKSB7IHJldHVybiBjdG9yUGFyYW0gJiYgY3RvclBhcmFtLnR5cGU7IH0pO1xuICAgICAgICAgICAgdmFyIHBhcmFtQW5ub3RhdGlvbnNfMSA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtKSB7IHJldHVybiBjdG9yUGFyYW0gJiYgY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEoY3RvclBhcmFtLmRlY29yYXRvcnMpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96aXBUeXBlc0FuZEFubm90YXRpb25zKHBhcmFtVHlwZXNfMSwgcGFyYW1Bbm5vdGF0aW9uc18xKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QpICYmIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncGFyYW1ldGVycycsIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgdmFyIHBhcmFtVHlwZXMgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocGFyYW1UeXBlcykgfHwgbGFuZ18xLmlzUHJlc2VudChwYXJhbUFubm90YXRpb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96aXBUeXBlc0FuZEFubm90YXRpb25zKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBhcnJheSBoYXMgdG8gYmUgZmlsbGVkIHdpdGggYHVuZGVmaW5lZGAgYmVjYXVzZSBob2xlcyB3b3VsZCBiZSBza2lwcGVkIGJ5IGBzb21lYFxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IG5ldyBBcnJheSh0eXBlT3JGdW5jLmxlbmd0aCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0eXBlT3JGdW5jLmFubm90YXRpb25zKSkge1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb25zID0gdHlwZU9yRnVuYy5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihhbm5vdGF0aW9ucykgJiYgYW5ub3RhdGlvbnMuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmFubm90YXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFQSSBvZiB0c2lja2xlIGZvciBsb3dlcmluZyBkZWNvcmF0b3JzIHRvIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLlxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0eXBlT3JGdW5jLmRlY29yYXRvcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEodHlwZU9yRnVuYy5kZWNvcmF0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QpICYmIGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Fubm90YXRpb25zJywgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhbm5vdGF0aW9ucykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIC8vIFByZWZlciB0aGUgZGlyZWN0IEFQSS5cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodHlwZU9yRnVuYy5wcm9wTWV0YWRhdGEpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdHlwZU9yRnVuYy5wcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzRnVuY3Rpb24ocHJvcE1ldGFkYXRhKSAmJiBwcm9wTWV0YWRhdGEucHJvcE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhID0gcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHR5cGVPckZ1bmMucHJvcERlY29yYXRvcnMpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcERlY29yYXRvcnNfMSA9IHR5cGVPckZ1bmMucHJvcERlY29yYXRvcnM7XG4gICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhXzEgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BEZWNvcmF0b3JzXzEpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBwcm9wTWV0YWRhdGFfMVtwcm9wXSA9IGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKHByb3BEZWNvcmF0b3JzXzFbcHJvcF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhXzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwcm9wTWV0YWRhdGEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaW50ZXJmYWNlcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIkphdmFTY3JpcHQgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcmZhY2VzXCIpO1xuICAgIH07XG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuZ2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICdyZXR1cm4gby4nICsgbmFtZSArICc7Jyk7IH07XG4gICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICd2JywgJ3JldHVybiBvLicgKyBuYW1lICsgJyA9IHY7Jyk7XG4gICAgfTtcbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZnVuY3Rpb25Cb2R5ID0gXCJpZiAoIW8uXCIgKyBuYW1lICsgXCIpIHRocm93IG5ldyBFcnJvcignXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyB1bmRlZmluZWQnKTtcXG4gICAgICAgIHJldHVybiBvLlwiICsgbmFtZSArIFwiLmFwcGx5KG8sIGFyZ3MpO1wiO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ2FyZ3MnLCBmdW5jdGlvbkJvZHkpO1xuICAgIH07XG4gICAgLy8gVGhlcmUgaXMgbm90IGEgY29uY2VwdCBvZiBpbXBvcnQgdXJpIGluIEpzLCBidXQgdGhpcyBpcyB1c2VmdWwgaW4gZGV2ZWxvcGluZyBEYXJ0IGFwcGxpY2F0aW9ucy5cbiAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gXCIuL1wiICsgbGFuZ18xLnN0cmluZ2lmeSh0eXBlKTsgfTtcbiAgICByZXR1cm4gUmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbn0oKSk7XG5leHBvcnRzLlJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xuZnVuY3Rpb24gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEoZGVjb3JhdG9ySW52b2NhdGlvbnMpIHtcbiAgICBpZiAoIWRlY29yYXRvckludm9jYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRvckludm9jYXRpb25zLm1hcChmdW5jdGlvbiAoZGVjb3JhdG9ySW52b2NhdGlvbikge1xuICAgICAgICB2YXIgZGVjb3JhdG9yVHlwZSA9IGRlY29yYXRvckludm9jYXRpb24udHlwZTtcbiAgICAgICAgdmFyIGFubm90YXRpb25DbHMgPSBkZWNvcmF0b3JUeXBlLmFubm90YXRpb25DbHM7XG4gICAgICAgIHZhciBhbm5vdGF0aW9uQXJncyA9IGRlY29yYXRvckludm9jYXRpb24uYXJncyA/IGRlY29yYXRvckludm9jYXRpb24uYXJncyA6IFtdO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IE9iamVjdC5jcmVhdGUoYW5ub3RhdGlvbkNscy5wcm90b3R5cGUpO1xuICAgICAgICBhbm5vdGF0aW9uQ2xzLmFwcGx5KGFubm90YXRpb24sIGFubm90YXRpb25BcmdzKTtcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0aW9uX2NhcGFiaWxpdGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIHJlZmxlY3Rvcl9yZWFkZXJfMSA9IHJlcXVpcmUoJy4vcmVmbGVjdG9yX3JlYWRlcicpO1xuLyoqXG4gKiBSZWZsZWN0aXZlIGluZm9ybWF0aW9uIGFib3V0IGEgc3ltYm9sLCBpbmNsdWRpbmcgYW5ub3RhdGlvbnMsIGludGVyZmFjZXMsIGFuZCBvdGhlciBtZXRhZGF0YS5cbiAqL1xudmFyIFJlZmxlY3Rpb25JbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZsZWN0aW9uSW5mbyhhbm5vdGF0aW9ucywgcGFyYW1ldGVycywgZmFjdG9yeSwgaW50ZXJmYWNlcywgcHJvcE1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5pbnRlcmZhY2VzID0gaW50ZXJmYWNlcztcbiAgICAgICAgdGhpcy5wcm9wTWV0YWRhdGEgPSBwcm9wTWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0aW9uSW5mbztcbn0oKSk7XG5leHBvcnRzLlJlZmxlY3Rpb25JbmZvID0gUmVmbGVjdGlvbkluZm87XG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byByZWZsZWN0aW9uIGRhdGEgYWJvdXQgc3ltYm9scy4gVXNlZCBpbnRlcm5hbGx5IGJ5IEFuZ3VsYXJcbiAqIHRvIHBvd2VyIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGFuZCBjb21waWxhdGlvbi5cbiAqL1xudmFyIFJlZmxlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZmxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZsZWN0b3IocmVmbGVjdGlvbkNhcGFiaWxpdGllcykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9pbmplY3RhYmxlSW5mbyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fZ2V0dGVycyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fc2V0dGVycyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbWV0aG9kcyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIHRoaXMuX3VzZWRLZXlzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gcmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbiAgICB9XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5pc1JlZmxlY3Rpb25FbmFibGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmlzUmVmbGVjdGlvbkVuYWJsZWQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBDYXVzZXMgYHRoaXNgIHJlZmxlY3RvciB0byB0cmFjayBrZXlzIHVzZWQgdG8gYWNjZXNzXG4gICAgICoge0BsaW5rIFJlZmxlY3Rpb25JbmZvfSBvYmplY3RzLlxuICAgICAqL1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUudHJhY2tVc2FnZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdXNlZEtleXMgPSBuZXcgY29sbGVjdGlvbl8xLlNldCgpOyB9O1xuICAgIC8qKlxuICAgICAqIExpc3RzIHR5cGVzIGZvciB3aGljaCByZWZsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBub3QgcmVxdWVzdGVkIHNpbmNlXG4gICAgICoge0BsaW5rICN0cmFja1VzYWdlfSB3YXMgY2FsbGVkLiBUaGlzIGxpc3QgY291bGQgbGF0ZXIgYmUgYXVkaXRlZCBhc1xuICAgICAqIHBvdGVudGlhbCBkZWFkIGNvZGUuXG4gICAgICovXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5saXN0VW51c2VkS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3VzZWRLZXlzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignVXNhZ2UgdHJhY2tpbmcgaXMgZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsVHlwZXMgPSBjb2xsZWN0aW9uXzEuTWFwV3JhcHBlci5rZXlzKHRoaXMuX2luamVjdGFibGVJbmZvKTtcbiAgICAgICAgcmV0dXJuIGFsbFR5cGVzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhY29sbGVjdGlvbl8xLlNldFdyYXBwZXIuaGFzKF90aGlzLl91c2VkS2V5cywga2V5KTsgfSk7XG4gICAgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlZ2lzdGVyRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYywgZnVuY0luZm8pIHtcbiAgICAgICAgdGhpcy5faW5qZWN0YWJsZUluZm8uc2V0KGZ1bmMsIGZ1bmNJbmZvKTtcbiAgICB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJUeXBlID0gZnVuY3Rpb24gKHR5cGUsIHR5cGVJbmZvKSB7XG4gICAgICAgIHRoaXMuX2luamVjdGFibGVJbmZvLnNldCh0eXBlLCB0eXBlSW5mbyk7XG4gICAgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlZ2lzdGVyR2V0dGVycyA9IGZ1bmN0aW9uIChnZXR0ZXJzKSB7IF9tZXJnZU1hcHModGhpcy5fZ2V0dGVycywgZ2V0dGVycyk7IH07XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5yZWdpc3RlclNldHRlcnMgPSBmdW5jdGlvbiAoc2V0dGVycykgeyBfbWVyZ2VNYXBzKHRoaXMuX3NldHRlcnMsIHNldHRlcnMpOyB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZHMpIHsgX21lcmdlTWFwcyh0aGlzLl9tZXRob2RzLCBtZXRob2RzKTsgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLmZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZWZsZWN0aW9uSW5mbyh0eXBlKSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGUpLmZhY3Rvcnk7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZmFjdG9yeSh0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luamVjdGFibGVJbmZvLmhhcyh0eXBlT3JGdW5jKSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGVPckZ1bmMpLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICBpZiAodGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGVPckZ1bmMpKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fZ2V0UmVmbGVjdGlvbkluZm8odHlwZU9yRnVuYykuYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmFubm90YXRpb25zKHR5cGVPckZ1bmMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbmplY3RhYmxlSW5mby5oYXModHlwZU9yRnVuYykpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRSZWZsZWN0aW9uSW5mbyh0eXBlT3JGdW5jKS5wcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3BNZXRhZGF0YSh0eXBlT3JGdW5jKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luamVjdGFibGVJbmZvLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGUpLmludGVyZmFjZXM7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChyZXMpID8gcmVzIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmludGVyZmFjZXModHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZ2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldHRlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0dGVycy5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmdldHRlcihuYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fc2V0dGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXR0ZXJzLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuc2V0dGVyKG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9tZXRob2RzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHMuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5tZXRob2QobmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBSZWZsZWN0b3IucHJvdG90eXBlLl9nZXRSZWZsZWN0aW9uSW5mbyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX3VzZWRLZXlzKSkge1xuICAgICAgICAgICAgdGhpcy5fdXNlZEtleXMuYWRkKHR5cGVPckZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmplY3RhYmxlSW5mby5nZXQodHlwZU9yRnVuYyk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5fY29udGFpbnNSZWZsZWN0aW9uSW5mbyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7IHJldHVybiB0aGlzLl9pbmplY3RhYmxlSW5mby5oYXModHlwZU9yRnVuYyk7IH07XG4gICAgUmVmbGVjdG9yLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmltcG9ydFVyaSh0eXBlKTsgfTtcbiAgICByZXR1cm4gUmVmbGVjdG9yO1xufShyZWZsZWN0b3JfcmVhZGVyXzEuUmVmbGVjdG9yUmVhZGVyKSk7XG5leHBvcnRzLlJlZmxlY3RvciA9IFJlZmxlY3RvcjtcbmZ1bmN0aW9uIF9tZXJnZU1hcHModGFyZ2V0LCBjb25maWcpIHtcbiAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKGNvbmZpZywgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHRhcmdldC5zZXQoaywgdik7IH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmbGVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4qIFByb3ZpZGVzIHJlYWQtb25seSBhY2Nlc3MgdG8gcmVmbGVjdGlvbiBkYXRhIGFib3V0IHN5bWJvbHMuIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyXG4qIHRvIHBvd2VyIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGFuZCBjb21waWxhdGlvbi5cbiovXG52YXIgUmVmbGVjdG9yUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZsZWN0b3JSZWFkZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0b3JSZWFkZXI7XG59KCkpO1xuZXhwb3J0cy5SZWZsZWN0b3JSZWFkZXIgPSBSZWZsZWN0b3JSZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWZsZWN0b3JfcmVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gUHVibGljIEFQSSBmb3IgcmVuZGVyXG52YXIgYXBpXzEgPSByZXF1aXJlKCcuL3JlbmRlci9hcGknKTtcbmV4cG9ydHMuUm9vdFJlbmRlcmVyID0gYXBpXzEuUm9vdFJlbmRlcmVyO1xuZXhwb3J0cy5SZW5kZXJlciA9IGFwaV8xLlJlbmRlcmVyO1xuZXhwb3J0cy5SZW5kZXJDb21wb25lbnRUeXBlID0gYXBpXzEuUmVuZGVyQ29tcG9uZW50VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBSZW5kZXJDb21wb25lbnRUeXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJDb21wb25lbnRUeXBlKGlkLCB0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgIHRoaXMuc2xvdENvdW50ID0gc2xvdENvdW50O1xuICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBlbmNhcHN1bGF0aW9uO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICB9XG4gICAgcmV0dXJuIFJlbmRlckNvbXBvbmVudFR5cGU7XG59KCkpO1xuZXhwb3J0cy5SZW5kZXJDb21wb25lbnRUeXBlID0gUmVuZGVyQ29tcG9uZW50VHlwZTtcbnZhciBSZW5kZXJEZWJ1Z0luZm8gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlckRlYnVnSW5mbygpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcImNvbXBvbmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4Y2VwdGlvbnNfMS51bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhjZXB0aW9uc18xLnVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlbmRlckRlYnVnSW5mbztcbn0oKSk7XG5leHBvcnRzLlJlbmRlckRlYnVnSW5mbyA9IFJlbmRlckRlYnVnSW5mbztcbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oKSk7XG5leHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XG4vKipcbiAqIEluamVjdGFibGUgc2VydmljZSB0aGF0IHByb3ZpZGVzIGEgbG93LWxldmVsIGludGVyZmFjZSBmb3IgbW9kaWZ5aW5nIHRoZSBVSS5cbiAqXG4gKiBVc2UgdGhpcyBzZXJ2aWNlIHRvIGJ5cGFzcyBBbmd1bGFyJ3MgdGVtcGxhdGluZyBhbmQgbWFrZSBjdXN0b20gVUkgY2hhbmdlcyB0aGF0IGNhbid0IGJlXG4gKiBleHByZXNzZWQgZGVjbGFyYXRpdmVseS4gRm9yIGV4YW1wbGUgaWYgeW91IG5lZWQgdG8gc2V0IGEgcHJvcGVydHkgb3IgYW4gYXR0cmlidXRlIHdob3NlIG5hbWUgaXNcbiAqIG5vdCBzdGF0aWNhbGx5IGtub3duLCB1c2Uge0BsaW5rICNzZXRFbGVtZW50UHJvcGVydHl9IG9yIHtAbGluayAjc2V0RWxlbWVudEF0dHJpYnV0ZX1cbiAqIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBJZiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGN1c3RvbSByZW5kZXJlciwgeW91IG11c3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxuICpcbiAqIFRoZSBkZWZhdWx0IFJlbmRlcmVyIGltcGxlbWVudGF0aW9uIGlzIGBEb21SZW5kZXJlcmAuIEFsc28gYXZhaWxhYmxlIGlzIGBXZWJXb3JrZXJSZW5kZXJlcmAuXG4gKi9cbnZhciBSb290UmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvb3RSZW5kZXJlcigpIHtcbiAgICB9XG4gICAgcmV0dXJuIFJvb3RSZW5kZXJlcjtcbn0oKSk7XG5leHBvcnRzLlJvb3RSZW5kZXJlciA9IFJvb3RSZW5kZXJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuKiBBIFNlY3VyaXR5Q29udGV4dCBtYXJrcyBhIGxvY2F0aW9uIHRoYXQgaGFzIGRhbmdlcm91cyBzZWN1cml0eSBpbXBsaWNhdGlvbnMsIGUuZy4gYSBET00gcHJvcGVydHlcbiogbGlrZSBgaW5uZXJIVE1MYCB0aGF0IGNvdWxkIGNhdXNlIENyb3NzIFNpdGUgU2NyaXB0aW5nIChYU1MpIHNlY3VyaXR5IGJ1Z3Mgd2hlbiBpbXByb3Blcmx5XG4qIGhhbmRsZWQuXG4qXG4qIFNlZSBEb21TYW5pdGl6YXRpb25TZXJ2aWNlIGZvciBtb3JlIGRldGFpbHMgb24gc2VjdXJpdHkgaW4gQW5ndWxhciBhcHBsaWNhdGlvbnMuXG4qL1xuKGZ1bmN0aW9uIChTZWN1cml0eUNvbnRleHQpIHtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIkhUTUxcIl0gPSAxXSA9IFwiSFRNTFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTVFlMRVwiXSA9IDJdID0gXCJTVFlMRVwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlVSTFwiXSA9IDRdID0gXCJVUkxcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiUkVTT1VSQ0VfVVJMXCJdID0gNV0gPSBcIlJFU09VUkNFX1VSTFwiO1xufSkoZXhwb3J0cy5TZWN1cml0eUNvbnRleHQgfHwgKGV4cG9ydHMuU2VjdXJpdHlDb250ZXh0ID0ge30pKTtcbnZhciBTZWN1cml0eUNvbnRleHQgPSBleHBvcnRzLlNlY3VyaXR5Q29udGV4dDtcbi8qKlxuICogU2FuaXRpemF0aW9uU2VydmljZSBpcyB1c2VkIGJ5IHRoZSB2aWV3cyB0byBzYW5pdGl6ZSBwb3RlbnRpYWxseSBkYW5nZXJvdXMgdmFsdWVzLiBUaGlzIGlzIGFcbiAqIHByaXZhdGUgQVBJLCB1c2UgY29kZSBzaG91bGQgb25seSByZWZlciB0byBEb21TYW5pdGl6YXRpb25TZXJ2aWNlLlxuICovXG52YXIgU2FuaXRpemF0aW9uU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FuaXRpemF0aW9uU2VydmljZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNhbml0aXphdGlvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5TYW5pdGl6YXRpb25TZXJ2aWNlID0gU2FuaXRpemF0aW9uU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3VyaXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIG5nX3pvbmVfMSA9IHJlcXVpcmUoJy4uL3pvbmUvbmdfem9uZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZSgnLi4vZGkvZGVjb3JhdG9ycycpO1xudmFyIFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXN0YWJpbGl0eShfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9pc1pvbmVTdGFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBhbnkgd29yayB3YXMgZG9uZSBzaW5jZSB0aGUgbGFzdCAnd2hlblN0YWJsZScgY2FsbGJhY2suIFRoaXMgaXNcbiAgICAgICAgICogdXNlZnVsIHRvIGRldGVjdCBpZiB0aGlzIGNvdWxkIGhhdmUgcG90ZW50aWFsbHkgZGVzdGFiaWxpemVkIGFub3RoZXJcbiAgICAgICAgICogY29tcG9uZW50IHdoaWxlIGl0IGlzIHN0YWJpbGl6aW5nLlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RpZFdvcmsgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5fd2F0Y2hBbmd1bGFyRXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX3dhdGNoQW5ndWxhckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5zdWJzY3JpYmUodGhpcy5fbmdab25lLm9uVW5zdGFibGUsIGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBfdGhpcy5fZGlkV29yayA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5faXNab25lU3RhYmxlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXN5bmNfMS5PYnNlcnZhYmxlV3JhcHBlci5zdWJzY3JpYmUoX3RoaXMuX25nWm9uZS5vblN0YWJsZSwgZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICBuZ196b25lXzEuTmdab25lLmFzc2VydE5vdEluQW5ndWxhclpvbmUoKTtcbiAgICAgICAgICAgICAgICBsYW5nXzEuc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNab25lU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5pbmNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCArPSAxO1xuICAgICAgICB0aGlzLl9kaWRXb3JrID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICB9O1xuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5kZWNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdwZW5kaW5nIGFzeW5jIHJlcXVlc3RzIGJlbG93IHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7XG4gICAgfTtcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuaXNTdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1pvbmVTdGFibGUgJiYgdGhpcy5fcGVuZGluZ0NvdW50ID09IDAgJiYgIXRoaXMuX25nWm9uZS5oYXNQZW5kaW5nTWFjcm90YXNrcztcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX3J1bkNhbGxiYWNrc0lmUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlcyB0aGUgY2FsbCBiYWNrcyBpbiBhIG5ldyBmcmFtZSBzbyB0aGF0IGl0IGlzIGFsd2F5cyBhc3luYy5cbiAgICAgICAgICAgIGxhbmdfMS5zY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKF90aGlzLl9jYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIChfdGhpcy5fY2FsbGJhY2tzLnBvcCgpKShfdGhpcy5fZGlkV29yayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9kaWRXb3JrID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vdCBSZWFkeVxuICAgICAgICAgICAgdGhpcy5fZGlkV29yayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS53aGVuU3RhYmxlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xuICAgIH07XG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmdldFBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7IH07XG4gICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRCaW5kaW5ncyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFByb3ZpZGVycyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBUZXN0YWJpbGl0eS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGRlY29yYXRvcnNfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBUZXN0YWJpbGl0eS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBuZ196b25lXzEuTmdab25lLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIFRlc3RhYmlsaXR5O1xufSgpKTtcbmV4cG9ydHMuVGVzdGFiaWxpdHkgPSBUZXN0YWJpbGl0eTtcbnZhciBUZXN0YWJpbGl0eVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXN0YWJpbGl0eVJlZ2lzdHJ5KCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucyA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIF90ZXN0YWJpbGl0eUdldHRlci5hZGRUb1dpbmRvdyh0aGlzKTtcbiAgICB9XG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uICh0b2tlbiwgdGVzdGFiaWxpdHkpIHtcbiAgICAgICAgdGhpcy5fYXBwbGljYXRpb25zLnNldCh0b2tlbiwgdGVzdGFiaWxpdHkpO1xuICAgIH07XG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0VGVzdGFiaWxpdHkgPSBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25zLmdldChlbGVtKTsgfTtcbiAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBbGxUZXN0YWJpbGl0aWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FwcGxpY2F0aW9ucyk7IH07XG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsUm9vdEVsZW1lbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIua2V5cyh0aGlzLl9hcHBsaWNhdGlvbnMpOyB9O1xuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgaWYgKGZpbmRJbkFuY2VzdG9ycyA9PT0gdm9pZCAwKSB7IGZpbmRJbkFuY2VzdG9ycyA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIF90ZXN0YWJpbGl0eUdldHRlci5maW5kVGVzdGFiaWxpdHlJblRyZWUodGhpcywgZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcbiAgICB9O1xuICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBkZWNvcmF0b3JzXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgIHJldHVybiBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xufSgpKTtcbmV4cG9ydHMuVGVzdGFiaWxpdHlSZWdpc3RyeSA9IFRlc3RhYmlsaXR5UmVnaXN0cnk7XG4vKiBAdHMyZGFydF9jb25zdCAqL1xudmFyIF9Ob29wR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9Ob29wR2V0VGVzdGFiaWxpdHkoKSB7XG4gICAgfVxuICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZFRvV2luZG93ID0gZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7IH07XG4gICAgX05vb3BHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFRlc3RhYmlsaXR5SW5UcmVlID0gZnVuY3Rpb24gKHJlZ2lzdHJ5LCBlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gX05vb3BHZXRUZXN0YWJpbGl0eTtcbn0oKSk7XG4vKipcbiAqIFNldCB0aGUge0BsaW5rIEdldFRlc3RhYmlsaXR5fSBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoZSBBbmd1bGFyIHRlc3RpbmcgZnJhbWV3b3JrLlxuICovXG5mdW5jdGlvbiBzZXRUZXN0YWJpbGl0eUdldHRlcihnZXR0ZXIpIHtcbiAgICBfdGVzdGFiaWxpdHlHZXR0ZXIgPSBnZXR0ZXI7XG59XG5leHBvcnRzLnNldFRlc3RhYmlsaXR5R2V0dGVyID0gc2V0VGVzdGFiaWxpdHlHZXR0ZXI7XG52YXIgX3Rlc3RhYmlsaXR5R2V0dGVyID0gbmV3IF9Ob29wR2V0VGVzdGFiaWxpdHkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RhYmlsaXR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gUHVibGljIEFQSSBmb3IgdXRpbFxudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoJy4vdXRpbC9kZWNvcmF0b3JzJyk7XG5leHBvcnRzLkNsYXNzID0gZGVjb3JhdG9yc18xLkNsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBfbmV4dENsYXNzSWQgPSAwO1xuZnVuY3Rpb24gZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihhbm5vdGF0aW9uKSAmJiBhbm5vdGF0aW9uLmhhc093blByb3BlcnR5KCdhbm5vdGF0aW9uJykpIHtcbiAgICAgICAgLy8gaXQgaXMgYSBkZWNvcmF0b3IsIGV4dHJhY3QgYW5ub3RhdGlvblxuICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbjtcbn1cbmZ1bmN0aW9uIGFwcGx5UGFyYW1zKGZuT3JBcnJheSwga2V5KSB7XG4gICAgaWYgKGZuT3JBcnJheSA9PT0gT2JqZWN0IHx8IGZuT3JBcnJheSA9PT0gU3RyaW5nIHx8IGZuT3JBcnJheSA9PT0gRnVuY3Rpb24gfHxcbiAgICAgICAgZm5PckFycmF5ID09PSBOdW1iZXIgfHwgZm5PckFycmF5ID09PSBBcnJheSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVzZSBuYXRpdmUgXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGZuT3JBcnJheSkgKyBcIiBhcyBjb25zdHJ1Y3RvclwiKTtcbiAgICB9XG4gICAgaWYgKGxhbmdfMS5pc0Z1bmN0aW9uKGZuT3JBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZuT3JBcnJheTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm5PckFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gZm5PckFycmF5O1xuICAgICAgICB2YXIgZm4gPSBmbk9yQXJyYXlbZm5PckFycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWxhbmdfMS5pc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGFzdCBwb3NpdGlvbiBvZiBDbGFzcyBtZXRob2QgYXJyYXkgbXVzdCBiZSBGdW5jdGlvbiBpbiBrZXkgXCIgKyBrZXkgKyBcIiB3YXMgJ1wiICsgbGFuZ18xLnN0cmluZ2lmeShmbikgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm9MZW5ndGggPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoYW5ub0xlbmd0aCAhPSBmbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBhbm5vdGF0aW9ucyAoXCIgKyBhbm5vTGVuZ3RoICsgXCIpIGRvZXMgbm90IG1hdGNoIG51bWJlciBvZiBhcmd1bWVudHMgKFwiICsgZm4ubGVuZ3RoICsgXCIpIGluIHRoZSBmdW5jdGlvbjogXCIgKyBsYW5nXzEuc3RyaW5naWZ5KGZuKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmFtc0Fubm90YXRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFubm90YXRpb25zLmxlbmd0aCAtIDE7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1Bbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgcGFyYW1zQW5ub3RhdGlvbnMucHVzaChwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbm5vdGF0aW9uLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtQW5ub3RhdGlvbnMucHVzaChleHRyYWN0QW5ub3RhdGlvbihhbm5vdGF0aW9uW2pdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZ18xLmlzRnVuY3Rpb24oYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBwYXJhbUFubm90YXRpb25zLnB1c2goZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbXNBbm5vdGF0aW9ucywgZm4pO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IEZ1bmN0aW9uIG9yIEFycmF5IGlzIHN1cHBvcnRlZCBpbiBDbGFzcyBkZWZpbml0aW9uIGZvciBrZXkgJ1wiICsga2V5ICsgXCInIGlzICdcIiArIGxhbmdfMS5zdHJpbmdpZnkoZm5PckFycmF5KSArIFwiJ1wiKTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVzIGEgd2F5IGZvciBleHByZXNzaW5nIEVTNiBjbGFzc2VzIHdpdGggcGFyYW1ldGVyIGFubm90YXRpb25zIGluIEVTNS5cbiAqXG4gKiAjIyBCYXNpYyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiB2YXIgR3JlZXRlciA9IG5nLkNsYXNzKHtcbiAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAqICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICogICB9LFxuICpcbiAqICAgZ3JlZXQ6IGZ1bmN0aW9uKCkge1xuICogICAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcbiAqXG4gKiBgYGBcbiAqIGNsYXNzIEdyZWV0ZXIge1xuICogICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAqICAgfVxuICpcbiAqICAgZ3JlZXQoKSB7XG4gKiAgICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBvciBlcXVpdmFsZW50IHRvIEVTNTpcbiAqXG4gKiBgYGBcbiAqIHZhciBHcmVldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAqICAgdGhpcy5uYW1lID0gbmFtZTtcbiAqIH1cbiAqXG4gKiBHcmVldGVyLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uICgpIHtcbiAqICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xuICogfVxuICogYGBgXG4gKlxuICogIyMjIEV4YW1wbGUgd2l0aCBwYXJhbWV0ZXIgYW5ub3RhdGlvbnNcbiAqXG4gKiBgYGBcbiAqIHZhciBNeVNlcnZpY2UgPSBuZy5DbGFzcyh7XG4gKiAgIGNvbnN0cnVjdG9yOiBbU3RyaW5nLCBbbmV3IFF1ZXJ5KCksIFF1ZXJ5TGlzdF0sIGZ1bmN0aW9uKG5hbWUsIHF1ZXJ5TGlzdCkge1xuICogICAgIC4uLlxuICogICB9XVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcbiAqXG4gKiBgYGBcbiAqIGNsYXNzIE15U2VydmljZSB7XG4gKiAgIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgQFF1ZXJ5KCkgcXVlcnlMaXN0OiBRdWVyeUxpc3QpIHtcbiAqICAgICAuLi5cbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMjIEV4YW1wbGUgd2l0aCBpbmhlcml0YW5jZVxuICpcbiAqIGBgYFxuICogdmFyIFNoYXBlID0gbmcuQ2xhc3Moe1xuICogICBjb25zdHJ1Y3RvcjogKGNvbG9yKSB7XG4gKiAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICogICB9XG4gKiB9KTtcbiAqXG4gKiB2YXIgU3F1YXJlID0gbmcuQ2xhc3Moe1xuICogICBleHRlbmRzOiBTaGFwZSxcbiAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGNvbG9yLCBzaXplKSB7XG4gKiAgICAgU2hhcGUuY2FsbCh0aGlzLCBjb2xvcik7XG4gKiAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gQ2xhc3MoY2xzRGVmKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXBwbHlQYXJhbXMoY2xzRGVmLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpID8gY2xzRGVmLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLCAnY29uc3RydWN0b3InKTtcbiAgICB2YXIgcHJvdG8gPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgaWYgKGNsc0RlZi5oYXNPd25Qcm9wZXJ0eSgnZXh0ZW5kcycpKSB7XG4gICAgICAgIGlmIChsYW5nXzEuaXNGdW5jdGlvbihjbHNEZWYuZXh0ZW5kcykpIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHByb3RvID1cbiAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGNsc0RlZi5leHRlbmRzLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGFzcyBkZWZpbml0aW9uICdleHRlbmRzJyBwcm9wZXJ0eSBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gd2FzOiBcIiArIGxhbmdfMS5zdHJpbmdpZnkoY2xzRGVmLmV4dGVuZHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gY2xzRGVmKSB7XG4gICAgICAgIGlmIChrZXkgIT0gJ2V4dGVuZHMnICYmIGtleSAhPSAncHJvdG90eXBlJyAmJiBjbHNEZWYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgcHJvdG9ba2V5XSA9IGFwcGx5UGFyYW1zKGNsc0RlZltrZXldLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzICYmIHRoaXMuYW5ub3RhdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHRoaXMuYW5ub3RhdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgaWYgKCFjb25zdHJ1Y3RvclsnbmFtZSddKSB7XG4gICAgICAgIGNvbnN0cnVjdG9yWydvdmVycmlkZGVuTmFtZSddID0gXCJjbGFzc1wiICsgX25leHRDbGFzc0lkKys7XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn1cbmV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbnZhciBSZWZsZWN0ID0gbGFuZ18xLmdsb2JhbC5SZWZsZWN0O1xuLy8gVGhyb3cgc3RhdGVtZW50IGF0IHRvcC1sZXZlbCBpcyBkaXNhbGxvd2VkIGJ5IGNsb3N1cmUgY29tcGlsZXIgaW4gRVM2IGlucHV0LlxuLy8gV3JhcCBpbiBhbiBJSUZFIGFzIGEgd29yay1hcm91bmQuXG4oZnVuY3Rpb24gY2hlY2tSZWZsZWN0KCkge1xuICAgIGlmICghKFJlZmxlY3QgJiYgUmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgJ3JlZmxlY3QtbWV0YWRhdGEgc2hpbSBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIGNsYXNzIGRlY29yYXRvcnMnO1xuICAgIH1cbn0pKCk7XG5mdW5jdGlvbiBtYWtlRGVjb3JhdG9yKGFubm90YXRpb25DbHMsIGNoYWluRm4pIHtcbiAgICBpZiAoY2hhaW5GbiA9PT0gdm9pZCAwKSB7IGNoYWluRm4gPSBudWxsOyB9XG4gICAgZnVuY3Rpb24gRGVjb3JhdG9yRmFjdG9yeShvYmpPclR5cGUpIHtcbiAgICAgICAgdmFyIGFubm90YXRpb25JbnN0YW5jZSA9IG5ldyBhbm5vdGF0aW9uQ2xzKG9iak9yVHlwZSk7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYW5ub3RhdGlvbkNscykge1xuICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25JbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFubm90YXRpb24gPSBsYW5nXzEuaXNGdW5jdGlvbih0aGlzKSAmJiB0aGlzLmFubm90YXRpb25zIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLmFubm90YXRpb25zIDogW107XG4gICAgICAgICAgICBjaGFpbkFubm90YXRpb24ucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgdmFyIFR5cGVEZWNvcmF0b3IgPSBmdW5jdGlvbiBUeXBlRGVjb3JhdG9yKGNscykge1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgY2xzKTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIGFubm90YXRpb25zLCBjbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVHlwZURlY29yYXRvci5hbm5vdGF0aW9ucyA9IGNoYWluQW5ub3RhdGlvbjtcbiAgICAgICAgICAgIFR5cGVEZWNvcmF0b3IuQ2xhc3MgPSBDbGFzcztcbiAgICAgICAgICAgIGlmIChjaGFpbkZuKVxuICAgICAgICAgICAgICAgIGNoYWluRm4oVHlwZURlY29yYXRvcik7XG4gICAgICAgICAgICByZXR1cm4gVHlwZURlY29yYXRvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW5ub3RhdGlvbkNscy5wcm90b3R5cGUpO1xuICAgIERlY29yYXRvckZhY3RvcnkuYW5ub3RhdGlvbkNscyA9IGFubm90YXRpb25DbHM7XG4gICAgcmV0dXJuIERlY29yYXRvckZhY3Rvcnk7XG59XG5leHBvcnRzLm1ha2VEZWNvcmF0b3IgPSBtYWtlRGVjb3JhdG9yO1xuZnVuY3Rpb24gbWFrZVBhcmFtRGVjb3JhdG9yKGFubm90YXRpb25DbHMpIHtcbiAgICBmdW5jdGlvbiBQYXJhbURlY29yYXRvckZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uSW5zdGFuY2UgPSBPYmplY3QuY3JlYXRlKGFubm90YXRpb25DbHMucHJvdG90eXBlKTtcbiAgICAgICAgYW5ub3RhdGlvbkNscy5hcHBseShhbm5vdGF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGFubm90YXRpb25DbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9uSW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBQYXJhbURlY29yYXRvci5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbkluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFBhcmFtRGVjb3JhdG9yKGNscywgdW51c2VkS2V5LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgY2xzKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IFtdO1xuICAgICAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgZ2FwcyBpZiBzb21lIGluIGJldHdlZW4gcGFyYW1ldGVycyBkbyBub3QgaGF2ZSBhbm5vdGF0aW9ucy5cbiAgICAgICAgICAgIC8vIHdlIHBhZCB3aXRoIG51bGxzLlxuICAgICAgICAgICAgd2hpbGUgKHBhcmFtZXRlcnMubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1ldGVyc1tpbmRleF0gPSBwYXJhbWV0ZXJzW2luZGV4XSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uc0ZvclBhcmFtID0gcGFyYW1ldGVyc1tpbmRleF07XG4gICAgICAgICAgICBhbm5vdGF0aW9uc0ZvclBhcmFtLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbWV0ZXJzLCBjbHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJhbURlY29yYXRvckZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbm5vdGF0aW9uQ2xzLnByb3RvdHlwZSk7XG4gICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBhbm5vdGF0aW9uQ2xzO1xuICAgIHJldHVybiBQYXJhbURlY29yYXRvckZhY3Rvcnk7XG59XG5leHBvcnRzLm1ha2VQYXJhbURlY29yYXRvciA9IG1ha2VQYXJhbURlY29yYXRvcjtcbmZ1bmN0aW9uIG1ha2VQcm9wRGVjb3JhdG9yKGFubm90YXRpb25DbHMpIHtcbiAgICBmdW5jdGlvbiBQcm9wRGVjb3JhdG9yRmFjdG9yeSgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlY29yYXRvckluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZShhbm5vdGF0aW9uQ2xzLnByb3RvdHlwZSk7XG4gICAgICAgIGFubm90YXRpb25DbHMuYXBwbHkoZGVjb3JhdG9ySW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGFubm90YXRpb25DbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3JJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBQcm9wRGVjb3JhdG9yKHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRhID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICBtZXRhID0gbWV0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICBtZXRhW25hbWVdID0gbWV0YVtuYW1lXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBtZXRhW25hbWVdLnVuc2hpZnQoZGVjb3JhdG9ySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3Byb3BNZXRhZGF0YScsIG1ldGEsIHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW5ub3RhdGlvbkNscy5wcm90b3R5cGUpO1xuICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBhbm5vdGF0aW9uQ2xzO1xuICAgIHJldHVybiBQcm9wRGVjb3JhdG9yRmFjdG9yeTtcbn1cbmV4cG9ydHMubWFrZVByb3BEZWNvcmF0b3IgPSBtYWtlUHJvcERlY29yYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29yYXRvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBQdWJsaWMgQVBJIGZvciBab25lXG52YXIgbmdfem9uZV8xID0gcmVxdWlyZSgnLi96b25lL25nX3pvbmUnKTtcbmV4cG9ydHMuTmdab25lID0gbmdfem9uZV8xLk5nWm9uZTtcbmV4cG9ydHMuTmdab25lRXJyb3IgPSBuZ196b25lXzEuTmdab25lRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16b25lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2FzeW5jJyk7XG52YXIgbmdfem9uZV9pbXBsXzEgPSByZXF1aXJlKCcuL25nX3pvbmVfaW1wbCcpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIG5nX3pvbmVfaW1wbF8yID0gcmVxdWlyZSgnLi9uZ196b25lX2ltcGwnKTtcbmV4cG9ydHMuTmdab25lRXJyb3IgPSBuZ196b25lX2ltcGxfMi5OZ1pvbmVFcnJvcjtcbi8qKlxuICogQW4gaW5qZWN0YWJsZSBzZXJ2aWNlIGZvciBleGVjdXRpbmcgd29yayBpbnNpZGUgb3Igb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lLlxuICpcbiAqIFRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgdGhpcyBzZXJ2aWNlIGlzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIHdoZW4gc3RhcnRpbmcgYSB3b3JrIGNvbnNpc3Rpbmcgb2ZcbiAqIG9uZSBvciBtb3JlIGFzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IHJlcXVpcmUgVUkgdXBkYXRlcyBvciBlcnJvciBoYW5kbGluZyB0byBiZSBoYW5kbGVkIGJ5XG4gKiBBbmd1bGFyLiBTdWNoIHRhc2tzIGNhbiBiZSBraWNrZWQgb2ZmIHZpYSB7QGxpbmsgI3J1bk91dHNpZGVBbmd1bGFyfSBhbmQgaWYgbmVlZGVkLCB0aGVzZSB0YXNrc1xuICogY2FuIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSB2aWEge0BsaW5rICNydW59LlxuICpcbiAqIDwhLS0gVE9ETzogYWRkL2ZpeCBsaW5rcyB0bzpcbiAqICAgLSBkb2NzIGV4cGxhaW5pbmcgem9uZXMgYW5kIHRoZSB1c2Ugb2Ygem9uZXMgaW4gQW5ndWxhciBhbmQgY2hhbmdlLWRldGVjdGlvblxuICogICAtIGxpbmsgdG8gcnVuT3V0c2lkZUFuZ3VsYXIvcnVuICh0aHJvdWdob3V0IHRoaXMgZmlsZSEpXG4gKiAgIC0tPlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9sWTltOEhMeTd6MDZ2RG9VYVNOMj9wPXByZXZpZXcpKVxuICogYGBgXG4gKiBpbXBvcnQge0NvbXBvbmVudCwgVmlldywgTmdab25lfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7TmdJZn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICduZy16b25lLWRlbW8nLlxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxoMj5EZW1vOiBOZ1pvbmU8L2gyPlxuICpcbiAqICAgICA8cD5Qcm9ncmVzczoge3twcm9ncmVzc319JTwvcD5cbiAqICAgICA8cCAqbmdJZj1cInByb2dyZXNzID49IDEwMFwiPkRvbmUgcHJvY2Vzc2luZyB7e2xhYmVsfX0gb2YgQW5ndWxhciB6b25lITwvcD5cbiAqXG4gKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc1dpdGhpbkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIHdpdGhpbiBBbmd1bGFyIHpvbmU8L2J1dHRvbj5cbiAqICAgICA8YnV0dG9uIChjbGljayk9XCJwcm9jZXNzT3V0c2lkZU9mQW5ndWxhclpvbmUoKVwiPlByb2Nlc3Mgb3V0c2lkZSBvZiBBbmd1bGFyIHpvbmU8L2J1dHRvbj5cbiAqICAgYCxcbiAqICAgZGlyZWN0aXZlczogW05nSWZdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIE5nWm9uZURlbW8ge1xuICogICBwcm9ncmVzczogbnVtYmVyID0gMDtcbiAqICAgbGFiZWw6IHN0cmluZztcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nWm9uZTogTmdab25lKSB7fVxuICpcbiAqICAgLy8gTG9vcCBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZVxuICogICAvLyBzbyB0aGUgVUkgRE9FUyByZWZyZXNoIGFmdGVyIGVhY2ggc2V0VGltZW91dCBjeWNsZVxuICogICBwcm9jZXNzV2l0aGluQW5ndWxhclpvbmUoKSB7XG4gKiAgICAgdGhpcy5sYWJlbCA9ICdpbnNpZGUnO1xuICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICogICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4gY29uc29sZS5sb2coJ0luc2lkZSBEb25lIScpKTtcbiAqICAgfVxuICpcbiAqICAgLy8gTG9vcCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmVcbiAqICAgLy8gc28gdGhlIFVJIERPRVMgTk9UIHJlZnJlc2ggYWZ0ZXIgZWFjaCBzZXRUaW1lb3V0IGN5Y2xlXG4gKiAgIHByb2Nlc3NPdXRzaWRlT2ZBbmd1bGFyWm9uZSgpIHtcbiAqICAgICB0aGlzLmxhYmVsID0gJ291dHNpZGUnO1xuICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICogICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gKiAgICAgICB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKCgpID0+IHtcbiAqICAgICAgIC8vIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZGlzcGxheSBkb25lXG4gKiAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHtjb25zb2xlLmxvZygnT3V0c2lkZSBEb25lIScpIH0pO1xuICogICAgIH19KSk7XG4gKiAgIH1cbiAqXG4gKlxuICogICBfaW5jcmVhc2VQcm9ncmVzcyhkb25lQ2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAqICAgICB0aGlzLnByb2dyZXNzICs9IDE7XG4gKiAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgcHJvZ3Jlc3M6ICR7dGhpcy5wcm9ncmVzc30lYCk7XG4gKlxuICogICAgIGlmICh0aGlzLnByb2dyZXNzIDwgMTAwKSB7XG4gKiAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjaykpLCAxMClcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgZG9uZUNhbGxiYWNrKCk7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIE5nWm9uZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sfSBlbmFibGVMb25nU3RhY2tUcmFjZSB3aGV0aGVyIHRvIGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlLiBUaGV5IHNob3VsZCBvbmx5IGJlXG4gICAgICogICAgICAgICAgICAgICBlbmFibGVkIGluIGRldmVsb3BtZW50IG1vZGUgYXMgdGhleSBzaWduaWZpY2FudGx5IGltcGFjdCBwZXJmLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nWm9uZShfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IgPSBfYS5lbmFibGVMb25nU3RhY2tUcmFjZSwgZW5hYmxlTG9uZ1N0YWNrVHJhY2UgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ01hY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fbmVzdGluZyA9IDA7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fb25VbnN0YWJsZSA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fb25NaWNyb3Rhc2tFbXB0eSA9IG5ldyBhc3luY18xLkV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fb25TdGFibGUgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX29uRXJyb3JFdmVudHMgPSBuZXcgYXN5bmNfMS5FdmVudEVtaXR0ZXIoZmFsc2UpO1xuICAgICAgICB0aGlzLl96b25lSW1wbCA9IG5ldyBuZ196b25lX2ltcGxfMS5OZ1pvbmVJbXBsKHtcbiAgICAgICAgICAgIHRyYWNlOiBlbmFibGVMb25nU3RhY2tUcmFjZSxcbiAgICAgICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWk9ORS5lbnRlcicsIHRoaXMuX25lc3RpbmcsIHRoaXMuX2lzU3RhYmxlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmVzdGluZysrO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNTdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vblVuc3RhYmxlLmVtaXQobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbmVzdGluZy0tO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdaT05FLmxlYXZlJywgdGhpcy5fbmVzdGluZywgdGhpcy5faXNTdGFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja1N0YWJsZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldE1pY3JvdGFzazogZnVuY3Rpb24gKGhhc01pY3JvdGFza3MpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgPSBoYXNNaWNyb3Rhc2tzO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja1N0YWJsZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldE1hY3JvdGFzazogZnVuY3Rpb24gKGhhc01hY3JvdGFza3MpIHsgX3RoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzID0gaGFzTWFjcm90YXNrczsgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX3RoaXMuX29uRXJyb3JFdmVudHMuZW1pdChlcnJvcik7IH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE5nWm9uZS5pc0luQW5ndWxhclpvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZ196b25lX2ltcGxfMS5OZ1pvbmVJbXBsLmlzSW5Bbmd1bGFyWm9uZSgpOyB9O1xuICAgIE5nWm9uZS5hc3NlcnRJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIW5nX3pvbmVfaW1wbF8xLk5nWm9uZUltcGwuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignRXhwZWN0ZWQgdG8gYmUgaW4gQW5ndWxhciBab25lLCBidXQgaXQgaXMgbm90IScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5nX3pvbmVfaW1wbF8xLk5nWm9uZUltcGwuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignRXhwZWN0ZWQgdG8gbm90IGJlIGluIEFuZ3VsYXIgWm9uZSwgYnV0IGl0IGlzIScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOZ1pvbmUucHJvdG90eXBlLl9jaGVja1N0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX25lc3RpbmcgPT0gMCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNQZW5kaW5nTWljcm90YXNrcyAmJiAhdGhpcy5faXNTdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWk9ORS5taWNyb3Rhc2tFbXB0eScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXN0aW5nKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTWljcm90YXNrRW1wdHkuZW1pdChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25lc3RpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNQZW5kaW5nTWljcm90YXNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWk9ORS5zdGFibGUnLCB0aGlzLl9uZXN0aW5nLCB0aGlzLl9pc1N0YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25TdGFibGUuZW1pdChudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvblVuc3RhYmxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGlmaWVzIHdoZW4gY29kZSBlbnRlcnMgQW5ndWxhciBab25lLiBUaGlzIGdldHMgZmlyZWQgZmlyc3Qgb24gVk0gVHVybi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25VbnN0YWJsZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwib25NaWNyb3Rhc2tFbXB0eVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3RpZmllcyB3aGVuIHRoZXJlIGlzIG5vIG1vcmUgbWljcm90YXNrcyBlbnF1ZXVlIGluIHRoZSBjdXJyZW50IFZNIFR1cm4uXG4gICAgICAgICAqIFRoaXMgaXMgYSBoaW50IGZvciBBbmd1bGFyIHRvIGRvIGNoYW5nZSBkZXRlY3Rpb24sIHdoaWNoIG1heSBlbnF1ZXVlIG1vcmUgbWljcm90YXNrcy5cbiAgICAgICAgICogRm9yIHRoaXMgcmVhc29uIHRoaXMgZXZlbnQgY2FuIGZpcmUgbXVsdGlwbGUgdGltZXMgcGVyIFZNIFR1cm4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uTWljcm90YXNrRW1wdHk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcIm9uU3RhYmxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGlmaWVzIHdoZW4gdGhlIGxhc3QgYG9uTWljcm90YXNrRW1wdHlgIGhhcyBydW4gYW5kIHRoZXJlIGFyZSBubyBtb3JlIG1pY3JvdGFza3MsIHdoaWNoXG4gICAgICAgICAqIGltcGxpZXMgd2UgYXJlIGFib3V0IHRvIHJlbGlucXVpc2ggVk0gdHVybi5cbiAgICAgICAgICogVGhpcyBldmVudCBnZXRzIGNhbGxlZCBqdXN0IG9uY2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uU3RhYmxlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvbkVycm9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGlmeSB0aGF0IGFuIGVycm9yIGhhcyBiZWVuIGRlbGl2ZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25FcnJvckV2ZW50czsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaGFzUGVuZGluZ01pY3JvdGFza3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIG1pY3JvdGFza3MuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJoYXNQZW5kaW5nTWFjcm90YXNrc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZXJlIGFyZSBhbnkgb3V0c3RhbmRpbmcgbWljcm90YXNrcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGFzUGVuZGluZ01hY3JvdGFza3M7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUgYW5kIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgKiB0aGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bmAgYWxsb3dzIHlvdSB0byByZWVudGVyIEFuZ3VsYXIgem9uZSBmcm9tIGEgdGFzayB0aGF0IHdhcyBleGVjdXRlZFxuICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZSAodHlwaWNhbGx5IHN0YXJ0ZWQgdmlhIHtAbGluayAjcnVuT3V0c2lkZUFuZ3VsYXJ9KS5cbiAgICAgKlxuICAgICAqIEFueSBmdXR1cmUgdGFza3Mgb3IgbWljcm90YXNrcyBzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIGV4ZWN1dGluZyBmcm9tXG4gICAgICogd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICpcbiAgICAgKiBJZiBhIHN5bmNocm9ub3VzIGVycm9yIGhhcHBlbnMgaXQgd2lsbCBiZSByZXRocm93biBhbmQgbm90IHJlcG9ydGVkIHZpYSBgb25FcnJvcmAuXG4gICAgICovXG4gICAgTmdab25lLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuX3pvbmVJbXBsLnJ1bklubmVyKGZuKTsgfTtcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzICNydW4sIGV4Y2VwdCB0aGF0IHN5bmNocm9ub3VzIGVycm9ycyBhcmUgY2F1Z2h0IGFuZCBmb3J3YXJkZWRcbiAgICAgKiB2aWEgYG9uRXJyb3JgIGFuZCBub3QgcmV0aHJvd24uXG4gICAgICovXG4gICAgTmdab25lLnByb3RvdHlwZS5ydW5HdWFyZGVkID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLl96b25lSW1wbC5ydW5Jbm5lckd1YXJkZWQoZm4pOyB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgaW4gQW5ndWxhcidzIHBhcmVudCB6b25lIGFuZCByZXR1cm5zIHZhbHVlIHJldHVybmVkIGJ5XG4gICAgICogdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogUnVubmluZyBmdW5jdGlvbnMgdmlhIGBydW5PdXRzaWRlQW5ndWxhcmAgYWxsb3dzIHlvdSB0byBlc2NhcGUgQW5ndWxhcidzIHpvbmUgYW5kIGRvIHdvcmsgdGhhdFxuICAgICAqIGRvZXNuJ3QgdHJpZ2dlciBBbmd1bGFyIGNoYW5nZS1kZXRlY3Rpb24gb3IgaXMgc3ViamVjdCB0byBBbmd1bGFyJ3MgZXJyb3IgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAqIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgKlxuICAgICAqIFVzZSB7QGxpbmsgI3J1bn0gdG8gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIGFuZCBkbyB3b3JrIHRoYXQgdXBkYXRlcyB0aGUgYXBwbGljYXRpb24gbW9kZWwuXG4gICAgICovXG4gICAgTmdab25lLnByb3RvdHlwZS5ydW5PdXRzaWRlQW5ndWxhciA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fem9uZUltcGwucnVuT3V0ZXIoZm4pOyB9O1xuICAgIHJldHVybiBOZ1pvbmU7XG59KCkpO1xuZXhwb3J0cy5OZ1pvbmUgPSBOZ1pvbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ196b25lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4qIFN0b3JlcyBlcnJvciBpbmZvcm1hdGlvbjsgZGVsaXZlcmVkIHZpYSBbTmdab25lLm9uRXJyb3JdIHN0cmVhbS5cbiovXG52YXIgTmdab25lRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nWm9uZUVycm9yKGVycm9yLCBzdGFja1RyYWNlKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5zdGFja1RyYWNlID0gc3RhY2tUcmFjZTtcbiAgICB9XG4gICAgcmV0dXJuIE5nWm9uZUVycm9yO1xufSgpKTtcbmV4cG9ydHMuTmdab25lRXJyb3IgPSBOZ1pvbmVFcnJvcjtcbnZhciBOZ1pvbmVJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ1pvbmVJbXBsKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0cmFjZSA9IF9hLnRyYWNlLCBvbkVudGVyID0gX2Eub25FbnRlciwgb25MZWF2ZSA9IF9hLm9uTGVhdmUsIHNldE1pY3JvdGFzayA9IF9hLnNldE1pY3JvdGFzaywgc2V0TWFjcm90YXNrID0gX2Euc2V0TWFjcm90YXNrLCBvbkVycm9yID0gX2Eub25FcnJvcjtcbiAgICAgICAgdGhpcy5vbkVudGVyID0gb25FbnRlcjtcbiAgICAgICAgdGhpcy5vbkxlYXZlID0gb25MZWF2ZTtcbiAgICAgICAgdGhpcy5zZXRNaWNyb3Rhc2sgPSBzZXRNaWNyb3Rhc2s7XG4gICAgICAgIHRoaXMuc2V0TWFjcm90YXNrID0gc2V0TWFjcm90YXNrO1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgICBpZiAoWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5vdXRlciA9IHRoaXMuaW5uZXIgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoWm9uZVsnd3RmWm9uZVNwZWMnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIgPSB0aGlzLmlubmVyLmZvcmsoWm9uZVsnd3RmWm9uZVNwZWMnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2UgJiYgWm9uZVsnbG9uZ1N0YWNrVHJhY2Vab25lU3BlYyddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayhab25lWydsb25nU3RhY2tUcmFjZVpvbmVTcGVjJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2FuZ3VsYXInLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgJ2lzQW5ndWxhclpvbmUnOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgb25JbnZva2VUYXNrOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5pbnZva2VUYXNrKHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkludm9rZTogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuaW52b2tlKHRhcmdldCwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkhhc1Rhc2s6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCBoYXNUYXNrU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGUuaGFzVGFzayh0YXJnZXQsIGhhc1Rhc2tTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBoYXNUYXNrIGV2ZW50cyB3aGljaCBvcmlnaW5hdGUgZnJvbSBvdXIgem9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKEEgY2hpbGQgaGFzVGFzayBldmVudCBpcyBub3QgaW50ZXJlc3RpbmcgdG8gdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVGFza1N0YXRlLmNoYW5nZSA9PSAnbWljcm9UYXNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE1pY3JvdGFzayhoYXNUYXNrU3RhdGUubWljcm9UYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc1Rhc2tTdGF0ZS5jaGFuZ2UgPT0gJ21hY3JvVGFzaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRNYWNyb3Rhc2soaGFzVGFza1N0YXRlLm1hY3JvVGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uSGFuZGxlRXJyb3I6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5oYW5kbGVFcnJvcih0YXJnZXQsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25FcnJvcihuZXcgTmdab25lRXJyb3IoZXJyb3IsIGVycm9yLnN0YWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW5ndWxhciByZXF1aXJlcyBab25lLmpzIHBvbHlmaWxsLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE5nWm9uZUltcGwuaXNJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gWm9uZS5jdXJyZW50LmdldCgnaXNBbmd1bGFyWm9uZScpID09PSB0cnVlOyB9O1xuICAgIE5nWm9uZUltcGwucHJvdG90eXBlLnJ1bklubmVyID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLmlubmVyLnJ1bihmbik7IH07XG4gICAgO1xuICAgIE5nWm9uZUltcGwucHJvdG90eXBlLnJ1bklubmVyR3VhcmRlZCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5pbm5lci5ydW5HdWFyZGVkKGZuKTsgfTtcbiAgICA7XG4gICAgTmdab25lSW1wbC5wcm90b3R5cGUucnVuT3V0ZXIgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMub3V0ZXIucnVuKGZuKTsgfTtcbiAgICA7XG4gICAgcmV0dXJuIE5nWm9uZUltcGw7XG59KCkpO1xuZXhwb3J0cy5OZ1pvbmVJbXBsID0gTmdab25lSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nX3pvbmVfaW1wbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuKiBAbW9kdWxlXG4qIEBkZXNjcmlwdGlvblxuKiBUaGUgaHR0cCBtb2R1bGUgcHJvdmlkZXMgc2VydmljZXMgdG8gcGVyZm9ybSBodHRwIHJlcXVlc3RzLiBUbyBnZXQgc3RhcnRlZCwgc2VlIHRoZSB7QGxpbmsgSHR0cH1cbiogY2xhc3MuXG4qL1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBodHRwXzEgPSByZXF1aXJlKCcuL3NyYy9odHRwJyk7XG52YXIgeGhyX2JhY2tlbmRfMSA9IHJlcXVpcmUoJy4vc3JjL2JhY2tlbmRzL3hocl9iYWNrZW5kJyk7XG52YXIganNvbnBfYmFja2VuZF8xID0gcmVxdWlyZSgnLi9zcmMvYmFja2VuZHMvanNvbnBfYmFja2VuZCcpO1xudmFyIGJyb3dzZXJfeGhyXzEgPSByZXF1aXJlKCcuL3NyYy9iYWNrZW5kcy9icm93c2VyX3hocicpO1xudmFyIGJyb3dzZXJfanNvbnBfMSA9IHJlcXVpcmUoJy4vc3JjL2JhY2tlbmRzL2Jyb3dzZXJfanNvbnAnKTtcbnZhciBiYXNlX3JlcXVlc3Rfb3B0aW9uc18xID0gcmVxdWlyZSgnLi9zcmMvYmFzZV9yZXF1ZXN0X29wdGlvbnMnKTtcbnZhciBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMSA9IHJlcXVpcmUoJy4vc3JjL2Jhc2VfcmVzcG9uc2Vfb3B0aW9ucycpO1xudmFyIHN0YXRpY19yZXF1ZXN0XzEgPSByZXF1aXJlKCcuL3NyYy9zdGF0aWNfcmVxdWVzdCcpO1xuZXhwb3J0cy5SZXF1ZXN0ID0gc3RhdGljX3JlcXVlc3RfMS5SZXF1ZXN0O1xudmFyIHN0YXRpY19yZXNwb25zZV8xID0gcmVxdWlyZSgnLi9zcmMvc3RhdGljX3Jlc3BvbnNlJyk7XG5leHBvcnRzLlJlc3BvbnNlID0gc3RhdGljX3Jlc3BvbnNlXzEuUmVzcG9uc2U7XG52YXIgaW50ZXJmYWNlc18xID0gcmVxdWlyZSgnLi9zcmMvaW50ZXJmYWNlcycpO1xuZXhwb3J0cy5Db25uZWN0aW9uID0gaW50ZXJmYWNlc18xLkNvbm5lY3Rpb247XG5leHBvcnRzLkNvbm5lY3Rpb25CYWNrZW5kID0gaW50ZXJmYWNlc18xLkNvbm5lY3Rpb25CYWNrZW5kO1xudmFyIGJyb3dzZXJfeGhyXzIgPSByZXF1aXJlKCcuL3NyYy9iYWNrZW5kcy9icm93c2VyX3hocicpO1xuZXhwb3J0cy5Ccm93c2VyWGhyID0gYnJvd3Nlcl94aHJfMi5Ccm93c2VyWGhyO1xudmFyIGJhc2VfcmVxdWVzdF9vcHRpb25zXzIgPSByZXF1aXJlKCcuL3NyYy9iYXNlX3JlcXVlc3Rfb3B0aW9ucycpO1xuZXhwb3J0cy5CYXNlUmVxdWVzdE9wdGlvbnMgPSBiYXNlX3JlcXVlc3Rfb3B0aW9uc18yLkJhc2VSZXF1ZXN0T3B0aW9ucztcbmV4cG9ydHMuUmVxdWVzdE9wdGlvbnMgPSBiYXNlX3JlcXVlc3Rfb3B0aW9uc18yLlJlcXVlc3RPcHRpb25zO1xudmFyIGJhc2VfcmVzcG9uc2Vfb3B0aW9uc18yID0gcmVxdWlyZSgnLi9zcmMvYmFzZV9yZXNwb25zZV9vcHRpb25zJyk7XG5leHBvcnRzLkJhc2VSZXNwb25zZU9wdGlvbnMgPSBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMi5CYXNlUmVzcG9uc2VPcHRpb25zO1xuZXhwb3J0cy5SZXNwb25zZU9wdGlvbnMgPSBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMi5SZXNwb25zZU9wdGlvbnM7XG52YXIgeGhyX2JhY2tlbmRfMiA9IHJlcXVpcmUoJy4vc3JjL2JhY2tlbmRzL3hocl9iYWNrZW5kJyk7XG5leHBvcnRzLlhIUkJhY2tlbmQgPSB4aHJfYmFja2VuZF8yLlhIUkJhY2tlbmQ7XG5leHBvcnRzLlhIUkNvbm5lY3Rpb24gPSB4aHJfYmFja2VuZF8yLlhIUkNvbm5lY3Rpb247XG52YXIganNvbnBfYmFja2VuZF8yID0gcmVxdWlyZSgnLi9zcmMvYmFja2VuZHMvanNvbnBfYmFja2VuZCcpO1xuZXhwb3J0cy5KU09OUEJhY2tlbmQgPSBqc29ucF9iYWNrZW5kXzIuSlNPTlBCYWNrZW5kO1xuZXhwb3J0cy5KU09OUENvbm5lY3Rpb24gPSBqc29ucF9iYWNrZW5kXzIuSlNPTlBDb25uZWN0aW9uO1xudmFyIGh0dHBfMiA9IHJlcXVpcmUoJy4vc3JjL2h0dHAnKTtcbmV4cG9ydHMuSHR0cCA9IGh0dHBfMi5IdHRwO1xuZXhwb3J0cy5Kc29ucCA9IGh0dHBfMi5Kc29ucDtcbnZhciBoZWFkZXJzXzEgPSByZXF1aXJlKCcuL3NyYy9oZWFkZXJzJyk7XG5leHBvcnRzLkhlYWRlcnMgPSBoZWFkZXJzXzEuSGVhZGVycztcbnZhciBlbnVtc18xID0gcmVxdWlyZSgnLi9zcmMvZW51bXMnKTtcbmV4cG9ydHMuUmVzcG9uc2VUeXBlID0gZW51bXNfMS5SZXNwb25zZVR5cGU7XG5leHBvcnRzLlJlYWR5U3RhdGUgPSBlbnVtc18xLlJlYWR5U3RhdGU7XG5leHBvcnRzLlJlcXVlc3RNZXRob2QgPSBlbnVtc18xLlJlcXVlc3RNZXRob2Q7XG52YXIgdXJsX3NlYXJjaF9wYXJhbXNfMSA9IHJlcXVpcmUoJy4vc3JjL3VybF9zZWFyY2hfcGFyYW1zJyk7XG5leHBvcnRzLlVSTFNlYXJjaFBhcmFtcyA9IHVybF9zZWFyY2hfcGFyYW1zXzEuVVJMU2VhcmNoUGFyYW1zO1xuLyoqXG4gKiBQcm92aWRlcyBhIGJhc2ljIHNldCBvZiBpbmplY3RhYmxlcyB0byB1c2UgdGhlIHtAbGluayBIdHRwfSBzZXJ2aWNlIGluIGFueSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBUaGUgYEhUVFBfUFJPVklERVJTYCBzaG91bGQgYmUgaW5jbHVkZWQgZWl0aGVyIGluIGEgY29tcG9uZW50J3MgaW5qZWN0b3IsXG4gKiBvciBpbiB0aGUgcm9vdCBpbmplY3RvciB3aGVuIGJvb3RzdHJhcHBpbmcgYW4gYXBwbGljYXRpb24uXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3NuajdOdj9wPXByZXZpZXcpKVxuICpcbiAqIGBgYFxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtib290c3RyYXB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnJvd3Nlcic7XG4gKiBpbXBvcnQge05nRm9yfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICogaW1wb3J0IHtIVFRQX1BST1ZJREVSUywgSHR0cH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnYXBwJyxcbiAqICAgcHJvdmlkZXJzOiBbSFRUUF9QUk9WSURFUlNdLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8aDE+UGVvcGxlPC9oMT5cbiAqICAgICAgIDx1bD5cbiAqICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBwZXJzb24gb2YgcGVvcGxlXCI+XG4gKiAgICAgICAgICAge3twZXJzb24ubmFtZX19XG4gKiAgICAgICAgIDwvbGk+XG4gKiAgICAgICA8L3VsPlxuICogICAgIDwvZGl2PlxuICogICBgLFxuICogICBkaXJlY3RpdmVzOiBbTmdGb3JdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcCB7XG4gKiAgIHBlb3BsZTogT2JqZWN0W107XG4gKiAgIGNvbnN0cnVjdG9yKGh0dHA6SHR0cCkge1xuICogICAgIGh0dHAuZ2V0KCdwZW9wbGUuanNvbicpLnN1YnNjcmliZShyZXMgPT4ge1xuICogICAgICAgdGhpcy5wZW9wbGUgPSByZXMuanNvbigpO1xuICogICAgIH0pO1xuICogICB9XG4gKiAgIGFjdGl2ZTpib29sZWFuID0gZmFsc2U7XG4gKiAgIHRvZ2dsZUFjdGl2ZVN0YXRlKCkge1xuICogICAgIHRoaXMuYWN0aXZlID0gIXRoaXMuYWN0aXZlO1xuICogICB9XG4gKiB9XG4gKlxuICogYm9vdHN0cmFwKEFwcClcbiAqICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICogYGBgXG4gKlxuICogVGhlIHByaW1hcnkgcHVibGljIEFQSSBpbmNsdWRlZCBpbiBgSFRUUF9QUk9WSURFUlNgIGlzIHRoZSB7QGxpbmsgSHR0cH0gY2xhc3MuXG4gKiBIb3dldmVyLCBvdGhlciBwcm92aWRlcnMgcmVxdWlyZWQgYnkgYEh0dHBgIGFyZSBpbmNsdWRlZCxcbiAqIHdoaWNoIG1heSBiZSBiZW5lZmljaWFsIHRvIG92ZXJyaWRlIGluIGNlcnRhaW4gY2FzZXMuXG4gKlxuICogVGhlIHByb3ZpZGVycyBpbmNsdWRlZCBpbiBgSFRUUF9QUk9WSURFUlNgIGluY2x1ZGU6XG4gKiAgKiB7QGxpbmsgSHR0cH1cbiAqICAqIHtAbGluayBYSFJCYWNrZW5kfVxuICogICogYEJyb3dzZXJYSFJgIC0gUHJpdmF0ZSBmYWN0b3J5IHRvIGNyZWF0ZSBgWE1MSHR0cFJlcXVlc3RgIGluc3RhbmNlc1xuICogICoge0BsaW5rIFJlcXVlc3RPcHRpb25zfSAtIEJvdW5kIHRvIHtAbGluayBCYXNlUmVxdWVzdE9wdGlvbnN9IGNsYXNzXG4gKiAgKiB7QGxpbmsgUmVzcG9uc2VPcHRpb25zfSAtIEJvdW5kIHRvIHtAbGluayBCYXNlUmVzcG9uc2VPcHRpb25zfSBjbGFzc1xuICpcbiAqIFRoZXJlIG1heSBiZSBjYXNlcyB3aGVyZSBpdCBtYWtlcyBzZW5zZSB0byBleHRlbmQgdGhlIGJhc2UgcmVxdWVzdCBvcHRpb25zLFxuICogc3VjaCBhcyB0byBhZGQgYSBzZWFyY2ggc3RyaW5nIHRvIGJlIGFwcGVuZGVkIHRvIGFsbCBVUkxzLlxuICogVG8gYWNjb21wbGlzaCB0aGlzLCBhIG5ldyBwcm92aWRlciBmb3Ige0BsaW5rIFJlcXVlc3RPcHRpb25zfSBzaG91bGRcbiAqIGJlIGFkZGVkIGluIHRoZSBzYW1lIGluamVjdG9yIGFzIGBIVFRQX1BST1ZJREVSU2AuXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2FDTUVYaT9wPXByZXZpZXcpKVxuICpcbiAqIGBgYFxuICogaW1wb3J0IHtwcm92aWRlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7Ym9vdHN0cmFwfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2Jyb3dzZXInO1xuICogaW1wb3J0IHtIVFRQX1BST1ZJREVSUywgQmFzZVJlcXVlc3RPcHRpb25zLCBSZXF1ZXN0T3B0aW9uc30gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG4gKlxuICogY2xhc3MgTXlPcHRpb25zIGV4dGVuZHMgQmFzZVJlcXVlc3RPcHRpb25zIHtcbiAqICAgc2VhcmNoOiBzdHJpbmcgPSAnY29yZVRlYW09dHJ1ZSc7XG4gKiB9XG4gKlxuICogYm9vdHN0cmFwKEFwcCwgW0hUVFBfUFJPVklERVJTLCBwcm92aWRlKFJlcXVlc3RPcHRpb25zLCB7dXNlQ2xhc3M6IE15T3B0aW9uc30pXSlcbiAqICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICogYGBgXG4gKlxuICogTGlrZXdpc2UsIHRvIHVzZSBhIG1vY2sgYmFja2VuZCBmb3IgdW5pdCB0ZXN0cywgdGhlIHtAbGluayBYSFJCYWNrZW5kfVxuICogcHJvdmlkZXIgc2hvdWxkIGJlIGJvdW5kIHRvIHtAbGluayBNb2NrQmFja2VuZH0uXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzdMV0FMRD9wPXByZXZpZXcpKVxuICpcbiAqIGBgYFxuICogaW1wb3J0IHtwcm92aWRlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7Ym9vdHN0cmFwfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2Jyb3dzZXInO1xuICogaW1wb3J0IHtIVFRQX1BST1ZJREVSUywgSHR0cCwgUmVzcG9uc2UsIFhIUkJhY2tlbmR9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICogaW1wb3J0IHtNb2NrQmFja2VuZH0gZnJvbSAnQGFuZ3VsYXIvaHR0cC90ZXN0aW5nJztcbiAqXG4gKiB2YXIgcGVvcGxlID0gW3tuYW1lOiAnSmVmZid9LCB7bmFtZTogJ1RvYmlhcyd9XTtcbiAqXG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAqICAgSFRUUF9QUk9WSURFUlMsXG4gKiAgIE1vY2tCYWNrZW5kLFxuICogICBwcm92aWRlKFhIUkJhY2tlbmQsIHt1c2VFeGlzdGluZzogTW9ja0JhY2tlbmR9KVxuICogXSk7XG4gKiB2YXIgaHR0cCA9IGluamVjdG9yLmdldChIdHRwKTtcbiAqIHZhciBiYWNrZW5kID0gaW5qZWN0b3IuZ2V0KE1vY2tCYWNrZW5kKTtcbiAqXG4gKiAvLyBMaXN0ZW4gZm9yIGFueSBuZXcgcmVxdWVzdHNcbiAqIGJhY2tlbmQuY29ubmVjdGlvbnMub2JzZXJ2ZXIoe1xuICogICBuZXh0OiBjb25uZWN0aW9uID0+IHtcbiAqICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2Uoe2JvZHk6IHBlb3BsZX0pO1xuICogICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICogICAgICAgLy8gU2VuZCBhIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0XG4gKiAgICAgICBjb25uZWN0aW9uLm1vY2tSZXNwb25kKHJlc3BvbnNlKTtcbiAqICAgICB9KTtcbiAqICAgfVxuICogfSk7XG4gKlxuICogaHR0cC5nZXQoJ3Blb3BsZS5qc29uJykub2JzZXJ2ZXIoe1xuICogICBuZXh0OiByZXMgPT4ge1xuICogICAgIC8vIFJlc3BvbnNlIGNhbWUgZnJvbSBtb2NrIGJhY2tlbmRcbiAqICAgICBjb25zb2xlLmxvZygnZmlyc3QgcGVyc29uJywgcmVzLmpzb24oKVswXS5uYW1lKTtcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5IVFRQX1BST1ZJREVSUyA9IFtcbiAgICAvLyBUT0RPKHBhc2NhbCk6IHVzZSBmYWN0b3J5IHR5cGUgYW5ub3RhdGlvbnMgb25jZSBzdXBwb3J0ZWQgaW4gRElcbiAgICAvLyBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzE4M1xuICAgIGNvcmVfMS5wcm92aWRlKGh0dHBfMS5IdHRwLCB7XG4gICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uICh4aHJCYWNrZW5kLCByZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBodHRwXzEuSHR0cCh4aHJCYWNrZW5kLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlcHM6IFt4aHJfYmFja2VuZF8xLlhIUkJhY2tlbmQsIGJhc2VfcmVxdWVzdF9vcHRpb25zXzEuUmVxdWVzdE9wdGlvbnNdXG4gICAgfSksXG4gICAgYnJvd3Nlcl94aHJfMS5Ccm93c2VyWGhyLFxuICAgIGNvcmVfMS5wcm92aWRlKGJhc2VfcmVxdWVzdF9vcHRpb25zXzEuUmVxdWVzdE9wdGlvbnMsIHsgdXNlQ2xhc3M6IGJhc2VfcmVxdWVzdF9vcHRpb25zXzEuQmFzZVJlcXVlc3RPcHRpb25zIH0pLFxuICAgIGNvcmVfMS5wcm92aWRlKGJhc2VfcmVzcG9uc2Vfb3B0aW9uc18xLlJlc3BvbnNlT3B0aW9ucywgeyB1c2VDbGFzczogYmFzZV9yZXNwb25zZV9vcHRpb25zXzEuQmFzZVJlc3BvbnNlT3B0aW9ucyB9KSxcbiAgICB4aHJfYmFja2VuZF8xLlhIUkJhY2tlbmRcbl07XG4vKipcbiAqIFNlZSB7QGxpbmsgSFRUUF9QUk9WSURFUlN9IGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5IVFRQX0JJTkRJTkdTID0gZXhwb3J0cy5IVFRQX1BST1ZJREVSUztcbi8qKlxuICogUHJvdmlkZXMgYSBiYXNpYyBzZXQgb2YgcHJvdmlkZXJzIHRvIHVzZSB0aGUge0BsaW5rIEpzb25wfSBzZXJ2aWNlIGluIGFueSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBUaGUgYEpTT05QX1BST1ZJREVSU2Agc2hvdWxkIGJlIGluY2x1ZGVkIGVpdGhlciBpbiBhIGNvbXBvbmVudCdzIGluamVjdG9yLFxuICogb3IgaW4gdGhlIHJvb3QgaW5qZWN0b3Igd2hlbiBib290c3RyYXBwaW5nIGFuIGFwcGxpY2F0aW9uLlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC92bWVONEY/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7TmdGb3J9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gKiBpbXBvcnQge0pTT05QX1BST1ZJREVSUywgSnNvbnB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcCcsXG4gKiAgIHByb3ZpZGVyczogW0pTT05QX1BST1ZJREVSU10sXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxoMT5QZW9wbGU8L2gxPlxuICogICAgICAgPHVsPlxuICogICAgICAgICA8bGkgKm5nRm9yPVwibGV0IHBlcnNvbiBvZiBwZW9wbGVcIj5cbiAqICAgICAgICAgICB7e3BlcnNvbi5uYW1lfX1cbiAqICAgICAgICAgPC9saT5cbiAqICAgICAgIDwvdWw+XG4gKiAgICAgPC9kaXY+XG4gKiAgIGAsXG4gKiAgIGRpcmVjdGl2ZXM6IFtOZ0Zvcl1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwIHtcbiAqICAgcGVvcGxlOiBBcnJheTxPYmplY3Q+O1xuICogICBjb25zdHJ1Y3Rvcihqc29ucDpKc29ucCkge1xuICogICAgIGpzb25wLnJlcXVlc3QoJ3Blb3BsZS5qc29uJykuc3Vic2NyaWJlKHJlcyA9PiB7XG4gKiAgICAgICB0aGlzLnBlb3BsZSA9IHJlcy5qc29uKCk7XG4gKiAgICAgfSlcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogVGhlIHByaW1hcnkgcHVibGljIEFQSSBpbmNsdWRlZCBpbiBgSlNPTlBfUFJPVklERVJTYCBpcyB0aGUge0BsaW5rIEpzb25wfSBjbGFzcy5cbiAqIEhvd2V2ZXIsIG90aGVyIHByb3ZpZGVycyByZXF1aXJlZCBieSBgSnNvbnBgIGFyZSBpbmNsdWRlZCxcbiAqIHdoaWNoIG1heSBiZSBiZW5lZmljaWFsIHRvIG92ZXJyaWRlIGluIGNlcnRhaW4gY2FzZXMuXG4gKlxuICogVGhlIHByb3ZpZGVycyBpbmNsdWRlZCBpbiBgSlNPTlBfUFJPVklERVJTYCBpbmNsdWRlOlxuICogICoge0BsaW5rIEpzb25wfVxuICogICoge0BsaW5rIEpTT05QQmFja2VuZH1cbiAqICAqIGBCcm93c2VySnNvbnBgIC0gUHJpdmF0ZSBmYWN0b3J5XG4gKiAgKiB7QGxpbmsgUmVxdWVzdE9wdGlvbnN9IC0gQm91bmQgdG8ge0BsaW5rIEJhc2VSZXF1ZXN0T3B0aW9uc30gY2xhc3NcbiAqICAqIHtAbGluayBSZXNwb25zZU9wdGlvbnN9IC0gQm91bmQgdG8ge0BsaW5rIEJhc2VSZXNwb25zZU9wdGlvbnN9IGNsYXNzXG4gKlxuICogVGhlcmUgbWF5IGJlIGNhc2VzIHdoZXJlIGl0IG1ha2VzIHNlbnNlIHRvIGV4dGVuZCB0aGUgYmFzZSByZXF1ZXN0IG9wdGlvbnMsXG4gKiBzdWNoIGFzIHRvIGFkZCBhIHNlYXJjaCBzdHJpbmcgdG8gYmUgYXBwZW5kZWQgdG8gYWxsIFVSTHMuXG4gKiBUbyBhY2NvbXBsaXNoIHRoaXMsIGEgbmV3IHByb3ZpZGVyIGZvciB7QGxpbmsgUmVxdWVzdE9wdGlvbnN9IHNob3VsZFxuICogYmUgYWRkZWQgaW4gdGhlIHNhbWUgaW5qZWN0b3IgYXMgYEpTT05QX1BST1ZJREVSU2AuXG4gKlxuICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1RGdWc3eD9wPXByZXZpZXcpKVxuICpcbiAqIGBgYFxuICogaW1wb3J0IHtwcm92aWRlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7Ym9vdHN0cmFwfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2Jyb3dzZXInO1xuICogaW1wb3J0IHtKU09OUF9QUk9WSURFUlMsIEJhc2VSZXF1ZXN0T3B0aW9ucywgUmVxdWVzdE9wdGlvbnN9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIGNsYXNzIE15T3B0aW9ucyBleHRlbmRzIEJhc2VSZXF1ZXN0T3B0aW9ucyB7XG4gKiAgIHNlYXJjaDogc3RyaW5nID0gJ2NvcmVUZWFtPXRydWUnO1xuICogfVxuICpcbiAqIGJvb3RzdHJhcChBcHAsIFtKU09OUF9QUk9WSURFUlMsIHByb3ZpZGUoUmVxdWVzdE9wdGlvbnMsIHt1c2VDbGFzczogTXlPcHRpb25zfSldKVxuICogICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG4gKiBgYGBcbiAqXG4gKiBMaWtld2lzZSwgdG8gdXNlIGEgbW9jayBiYWNrZW5kIGZvciB1bml0IHRlc3RzLCB0aGUge0BsaW5rIEpTT05QQmFja2VuZH1cbiAqIHByb3ZpZGVyIHNob3VsZCBiZSBib3VuZCB0byB7QGxpbmsgTW9ja0JhY2tlbmR9LlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9IRHFaV0w/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGBcbiAqIGltcG9ydCB7cHJvdmlkZSwgSW5qZWN0b3J9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHtKU09OUF9QUk9WSURFUlMsIEpzb25wLCBSZXNwb25zZSwgSlNPTlBCYWNrZW5kfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAqIGltcG9ydCB7TW9ja0JhY2tlbmR9IGZyb20gJ0Bhbmd1bGFyL2h0dHAvdGVzdGluZyc7XG4gKlxuICogdmFyIHBlb3BsZSA9IFt7bmFtZTogJ0plZmYnfSwge25hbWU6ICdUb2JpYXMnfV07XG4gKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAqICAgSlNPTlBfUFJPVklERVJTLFxuICogICBNb2NrQmFja2VuZCxcbiAqICAgcHJvdmlkZShKU09OUEJhY2tlbmQsIHt1c2VFeGlzdGluZzogTW9ja0JhY2tlbmR9KVxuICogXSk7XG4gKiB2YXIganNvbnAgPSBpbmplY3Rvci5nZXQoSnNvbnApO1xuICogdmFyIGJhY2tlbmQgPSBpbmplY3Rvci5nZXQoTW9ja0JhY2tlbmQpO1xuICpcbiAqIC8vIExpc3RlbiBmb3IgYW55IG5ldyByZXF1ZXN0c1xuICogYmFja2VuZC5jb25uZWN0aW9ucy5vYnNlcnZlcih7XG4gKiAgIG5leHQ6IGNvbm5lY3Rpb24gPT4ge1xuICogICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZSh7Ym9keTogcGVvcGxlfSk7XG4gKiAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gKiAgICAgICAvLyBTZW5kIGEgcmVzcG9uc2UgdG8gdGhlIHJlcXVlc3RcbiAqICAgICAgIGNvbm5lY3Rpb24ubW9ja1Jlc3BvbmQocmVzcG9uc2UpO1xuICogICAgIH0pO1xuICogICB9XG4gKiB9KTtcblxuICoganNvbnAuZ2V0KCdwZW9wbGUuanNvbicpLm9ic2VydmVyKHtcbiAqICAgbmV4dDogcmVzID0+IHtcbiAqICAgICAvLyBSZXNwb25zZSBjYW1lIGZyb20gbW9jayBiYWNrZW5kXG4gKiAgICAgY29uc29sZS5sb2coJ2ZpcnN0IHBlcnNvbicsIHJlcy5qc29uKClbMF0ubmFtZSk7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuSlNPTlBfUFJPVklERVJTID0gW1xuICAgIC8vIFRPRE8ocGFzY2FsKTogdXNlIGZhY3RvcnkgdHlwZSBhbm5vdGF0aW9ucyBvbmNlIHN1cHBvcnRlZCBpbiBESVxuICAgIC8vIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMTgzXG4gICAgY29yZV8xLnByb3ZpZGUoaHR0cF8xLkpzb25wLCB7XG4gICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChqc29ucEJhY2tlbmQsIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGh0dHBfMS5Kc29ucChqc29ucEJhY2tlbmQsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVwczogW2pzb25wX2JhY2tlbmRfMS5KU09OUEJhY2tlbmQsIGJhc2VfcmVxdWVzdF9vcHRpb25zXzEuUmVxdWVzdE9wdGlvbnNdXG4gICAgfSksXG4gICAgYnJvd3Nlcl9qc29ucF8xLkJyb3dzZXJKc29ucCxcbiAgICBjb3JlXzEucHJvdmlkZShiYXNlX3JlcXVlc3Rfb3B0aW9uc18xLlJlcXVlc3RPcHRpb25zLCB7IHVzZUNsYXNzOiBiYXNlX3JlcXVlc3Rfb3B0aW9uc18xLkJhc2VSZXF1ZXN0T3B0aW9ucyB9KSxcbiAgICBjb3JlXzEucHJvdmlkZShiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMS5SZXNwb25zZU9wdGlvbnMsIHsgdXNlQ2xhc3M6IGJhc2VfcmVzcG9uc2Vfb3B0aW9uc18xLkJhc2VSZXNwb25zZU9wdGlvbnMgfSksXG4gICAgY29yZV8xLnByb3ZpZGUoanNvbnBfYmFja2VuZF8xLkpTT05QQmFja2VuZCwgeyB1c2VDbGFzczoganNvbnBfYmFja2VuZF8xLkpTT05QQmFja2VuZF8gfSlcbl07XG4vKipcbiAqIFNlZSB7QGxpbmsgSlNPTlBfUFJPVklERVJTfSBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuSlNPTl9CSU5ESU5HUyA9IGV4cG9ydHMuSlNPTlBfUFJPVklERVJTO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5fX2V4cG9ydChyZXF1aXJlKCcuL2h0dHAnKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgX25leHRSZXF1ZXN0SWQgPSAwO1xuZXhwb3J0cy5KU09OUF9IT01FID0gJ19fbmdfanNvbnBfXyc7XG52YXIgX2pzb25wQ29ubmVjdGlvbnMgPSBudWxsO1xuZnVuY3Rpb24gX2dldEpzb25wQ29ubmVjdGlvbnMoKSB7XG4gICAgaWYgKF9qc29ucENvbm5lY3Rpb25zID09PSBudWxsKSB7XG4gICAgICAgIF9qc29ucENvbm5lY3Rpb25zID0gbGFuZ18xLmdsb2JhbFtleHBvcnRzLkpTT05QX0hPTUVdID0ge307XG4gICAgfVxuICAgIHJldHVybiBfanNvbnBDb25uZWN0aW9ucztcbn1cbnZhciBCcm93c2VySnNvbnAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJKc29ucCgpIHtcbiAgICB9XG4gICAgLy8gQ29uc3RydWN0IGEgPHNjcmlwdD4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQgVVJMXG4gICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgbm9kZS5zcmMgPSB1cmw7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5uZXh0UmVxdWVzdElEID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJfX3JlcVwiICsgX25leHRSZXF1ZXN0SWQrKzsgfTtcbiAgICBCcm93c2VySnNvbnAucHJvdG90eXBlLnJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gZXhwb3J0cy5KU09OUF9IT01FICsgXCIuXCIgKyBpZCArIFwiLmZpbmlzaGVkXCI7IH07XG4gICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5leHBvc2VDb25uZWN0aW9uID0gZnVuY3Rpb24gKGlkLCBjb25uZWN0aW9uKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9ucyA9IF9nZXRKc29ucENvbm5lY3Rpb25zKCk7XG4gICAgICAgIGNvbm5lY3Rpb25zW2lkXSA9IGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBCcm93c2VySnNvbnAucHJvdG90eXBlLnJlbW92ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25zID0gX2dldEpzb25wQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgY29ubmVjdGlvbnNbaWRdID0gbnVsbDtcbiAgICB9O1xuICAgIC8vIEF0dGFjaCB0aGUgPHNjcmlwdD4gZWxlbWVudCB0byB0aGUgRE9NXG4gICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG5vZGUpIHsgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCgobm9kZSkpOyB9O1xuICAgIC8vIFJlbW92ZSA8c2NyaXB0PiBlbGVtZW50IGZyb20gdGhlIERPTVxuICAgIEJyb3dzZXJKc29ucC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCgobm9kZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCcm93c2VySnNvbnAuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgcmV0dXJuIEJyb3dzZXJKc29ucDtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJKc29ucCA9IEJyb3dzZXJKc29ucDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJfanNvbnAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIEJyb3dzZXJYaHIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJYaHIoKSB7XG4gICAgfVxuICAgIEJyb3dzZXJYaHIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKG5ldyBYTUxIdHRwUmVxdWVzdCgpKTsgfTtcbiAgICBCcm93c2VyWGhyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIEJyb3dzZXJYaHIuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICByZXR1cm4gQnJvd3Nlclhocjtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJYaHIgPSBCcm93c2VyWGhyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl94aHIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKCcuLi9pbnRlcmZhY2VzJyk7XG52YXIgZW51bXNfMSA9IHJlcXVpcmUoJy4uL2VudW1zJyk7XG52YXIgc3RhdGljX3Jlc3BvbnNlXzEgPSByZXF1aXJlKCcuLi9zdGF0aWNfcmVzcG9uc2UnKTtcbnZhciBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMSA9IHJlcXVpcmUoJy4uL2Jhc2VfcmVzcG9uc2Vfb3B0aW9ucycpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBicm93c2VyX2pzb25wXzEgPSByZXF1aXJlKCcuL2Jyb3dzZXJfanNvbnAnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBKU09OUF9FUlJfTk9fQ0FMTEJBQ0sgPSAnSlNPTlAgaW5qZWN0ZWQgc2NyaXB0IGRpZCBub3QgaW52b2tlIGNhbGxiYWNrLic7XG52YXIgSlNPTlBfRVJSX1dST05HX01FVEhPRCA9ICdKU09OUCByZXF1ZXN0cyBtdXN0IHVzZSBHRVQgcmVxdWVzdCBtZXRob2QuJztcbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYW4gaW4tZmxpZ2h0IEpTT05QIHJlcXVlc3QuXG4gKi9cbnZhciBKU09OUENvbm5lY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05QQ29ubmVjdGlvbigpIHtcbiAgICB9XG4gICAgcmV0dXJuIEpTT05QQ29ubmVjdGlvbjtcbn0oKSk7XG5leHBvcnRzLkpTT05QQ29ubmVjdGlvbiA9IEpTT05QQ29ubmVjdGlvbjtcbnZhciBKU09OUENvbm5lY3Rpb25fID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNPTlBDb25uZWN0aW9uXywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OUENvbm5lY3Rpb25fKHJlcSwgX2RvbSwgYmFzZVJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZG9tID0gX2RvbTtcbiAgICAgICAgdGhpcy5iYXNlUmVzcG9uc2VPcHRpb25zID0gYmFzZVJlc3BvbnNlT3B0aW9ucztcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlcS5tZXRob2QgIT09IGVudW1zXzEuUmVxdWVzdE1ldGhvZC5HZXQpIHtcbiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbnNfMS5tYWtlVHlwZUVycm9yKEpTT05QX0VSUl9XUk9OR19NRVRIT0QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAocmVzcG9uc2VPYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMucmVhZHlTdGF0ZSA9IGVudW1zXzEuUmVhZHlTdGF0ZS5Mb2FkaW5nO1xuICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMuX2lkID0gX2RvbS5uZXh0UmVxdWVzdElEKCk7XG4gICAgICAgICAgICBfZG9tLmV4cG9zZUNvbm5lY3Rpb24oaWQsIF90aGlzKTtcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgRGFydFxuICAgICAgICAgICAgLy8gdXJsID0gdXJsLnJlcGxhY2UoLz1KU09OUF9DQUxMQkFDSygmfCQpLywgYGdlbmVyYXRlZCBtZXRob2RgKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9kb20ucmVxdWVzdENhbGxiYWNrKF90aGlzLl9pZCk7XG4gICAgICAgICAgICB2YXIgdXJsID0gcmVxLnVybDtcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignPUpTT05QX0NBTExCQUNLJicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlKHVybCwgJz1KU09OUF9DQUxMQkFDSyYnLCBcIj1cIiArIGNhbGxiYWNrICsgXCImXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXJsLmxhc3RJbmRleE9mKCc9SlNPTlBfQ0FMTEJBQ0snKSA9PT0gdXJsLmxlbmd0aCAtICc9SlNPTlBfQ0FMTEJBQ0snLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtICc9SlNPTlBfQ0FMTEJBQ0snLmxlbmd0aCkgKyAoXCI9XCIgKyBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gX3RoaXMuX3NjcmlwdCA9IF9kb20uYnVpbGQodXJsKTtcbiAgICAgICAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVhZHlTdGF0ZSA9PT0gZW51bXNfMS5SZWFkeVN0YXRlLkNhbmNlbGxlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlYWR5U3RhdGUgPSBlbnVtc18xLlJlYWR5U3RhdGUuRG9uZTtcbiAgICAgICAgICAgICAgICBfZG9tLmNsZWFudXAoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VPcHRpb25zXzEgPSBuZXcgYmFzZV9yZXNwb25zZV9vcHRpb25zXzEuUmVzcG9uc2VPcHRpb25zKHsgYm9keTogSlNPTlBfRVJSX05PX0NBTExCQUNLLCB0eXBlOiBlbnVtc18xLlJlc3BvbnNlVHlwZS5FcnJvciwgdXJsOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGJhc2VSZXNwb25zZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnNfMSA9IGJhc2VSZXNwb25zZU9wdGlvbnMubWVyZ2UocmVzcG9uc2VPcHRpb25zXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2ZXIuZXJyb3IobmV3IHN0YXRpY19yZXNwb25zZV8xLlJlc3BvbnNlKHJlc3BvbnNlT3B0aW9uc18xKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlT3B0aW9ucyA9IG5ldyBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMS5SZXNwb25zZU9wdGlvbnMoeyBib2R5OiBfdGhpcy5fcmVzcG9uc2VEYXRhLCB1cmw6IHVybCB9KTtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChfdGhpcy5iYXNlUmVzcG9uc2VPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBfdGhpcy5iYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2ZXIubmV4dChuZXcgc3RhdGljX3Jlc3BvbnNlXzEuUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlYWR5U3RhdGUgPT09IGVudW1zXzEuUmVhZHlTdGF0ZS5DYW5jZWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkeVN0YXRlID0gZW51bXNfMS5SZWFkeVN0YXRlLkRvbmU7XG4gICAgICAgICAgICAgICAgX2RvbS5jbGVhbnVwKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlT3B0aW9ucyA9IG5ldyBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMS5SZXNwb25zZU9wdGlvbnMoeyBib2R5OiBlcnJvci5tZXNzYWdlLCB0eXBlOiBlbnVtc18xLlJlc3BvbnNlVHlwZS5FcnJvciB9KTtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChiYXNlUmVzcG9uc2VPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBiYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2ZXIuZXJyb3IobmV3IHN0YXRpY19yZXNwb25zZV8xLlJlc3BvbnNlKHJlc3BvbnNlT3B0aW9ucykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgX2RvbS5zZW5kKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlYWR5U3RhdGUgPSBlbnVtc18xLlJlYWR5U3RhdGUuQ2FuY2VsbGVkO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzY3JpcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kb20uY2xlYW51cChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBKU09OUENvbm5lY3Rpb25fLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIERvbid0IGxlYWsgY29ubmVjdGlvbnNcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kb20ucmVtb3ZlQ29ubmVjdGlvbih0aGlzLl9pZCk7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IGVudW1zXzEuUmVhZHlTdGF0ZS5DYW5jZWxsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlRGF0YSA9IGRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTlBDb25uZWN0aW9uXztcbn0oSlNPTlBDb25uZWN0aW9uKSk7XG5leHBvcnRzLkpTT05QQ29ubmVjdGlvbl8gPSBKU09OUENvbm5lY3Rpb25fO1xuLyoqXG4gKiBBIHtAbGluayBDb25uZWN0aW9uQmFja2VuZH0gdGhhdCB1c2VzIHRoZSBKU09OUCBzdHJhdGVneSBvZiBtYWtpbmcgcmVxdWVzdHMuXG4gKi9cbnZhciBKU09OUEJhY2tlbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKU09OUEJhY2tlbmQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNPTlBCYWNrZW5kKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT05QQmFja2VuZDtcbn0oaW50ZXJmYWNlc18xLkNvbm5lY3Rpb25CYWNrZW5kKSk7XG5leHBvcnRzLkpTT05QQmFja2VuZCA9IEpTT05QQmFja2VuZDtcbnZhciBKU09OUEJhY2tlbmRfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNPTlBCYWNrZW5kXywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OUEJhY2tlbmRfKF9icm93c2VySlNPTlAsIF9iYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9icm93c2VySlNPTlAgPSBfYnJvd3NlckpTT05QO1xuICAgICAgICB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zID0gX2Jhc2VSZXNwb25zZU9wdGlvbnM7XG4gICAgfVxuICAgIEpTT05QQmFja2VuZF8ucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IEpTT05QQ29ubmVjdGlvbl8ocmVxdWVzdCwgdGhpcy5fYnJvd3NlckpTT05QLCB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zKTtcbiAgICB9O1xuICAgIEpTT05QQmFja2VuZF8uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgSlNPTlBCYWNrZW5kXy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBicm93c2VyX2pzb25wXzEuQnJvd3Nlckpzb25wLCB9LFxuICAgICAgICB7IHR5cGU6IGJhc2VfcmVzcG9uc2Vfb3B0aW9uc18xLlJlc3BvbnNlT3B0aW9ucywgfSxcbiAgICBdO1xuICAgIHJldHVybiBKU09OUEJhY2tlbmRfO1xufShKU09OUEJhY2tlbmQpKTtcbmV4cG9ydHMuSlNPTlBCYWNrZW5kXyA9IEpTT05QQmFja2VuZF87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29ucF9iYWNrZW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKCcuLi9lbnVtcycpO1xudmFyIHN0YXRpY19yZXNwb25zZV8xID0gcmVxdWlyZSgnLi4vc3RhdGljX3Jlc3BvbnNlJyk7XG52YXIgaGVhZGVyc18xID0gcmVxdWlyZSgnLi4vaGVhZGVycycpO1xudmFyIGJhc2VfcmVzcG9uc2Vfb3B0aW9uc18xID0gcmVxdWlyZSgnLi4vYmFzZV9yZXNwb25zZV9vcHRpb25zJyk7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGJyb3dzZXJfeGhyXzEgPSByZXF1aXJlKCcuL2Jyb3dzZXJfeGhyJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgaHR0cF91dGlsc18xID0gcmVxdWlyZSgnLi4vaHR0cF91dGlscycpO1xuLyoqXG4qIENyZWF0ZXMgY29ubmVjdGlvbnMgdXNpbmcgYFhNTEh0dHBSZXF1ZXN0YC4gR2l2ZW4gYSBmdWxseS1xdWFsaWZpZWRcbiogcmVxdWVzdCwgYW4gYFhIUkNvbm5lY3Rpb25gIHdpbGwgaW1tZWRpYXRlbHkgY3JlYXRlIGFuIGBYTUxIdHRwUmVxdWVzdGAgb2JqZWN0IGFuZCBzZW5kIHRoZVxuKiByZXF1ZXN0LlxuKlxuKiBUaGlzIGNsYXNzIHdvdWxkIHR5cGljYWxseSBub3QgYmUgY3JlYXRlZCBvciBpbnRlcmFjdGVkIHdpdGggZGlyZWN0bHkgaW5zaWRlIGFwcGxpY2F0aW9ucywgdGhvdWdoXG4qIHRoZSB7QGxpbmsgTW9ja0Nvbm5lY3Rpb259IG1heSBiZSBpbnRlcmFjdGVkIHdpdGggaW4gdGVzdHMuXG4qL1xudmFyIFhIUkNvbm5lY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhIUkNvbm5lY3Rpb24ocmVxLCBicm93c2VyWEhSLCBiYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZShmdW5jdGlvbiAocmVzcG9uc2VPYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIF94aHIgPSBicm93c2VyWEhSLmJ1aWxkKCk7XG4gICAgICAgICAgICBfeGhyLm9wZW4oZW51bXNfMS5SZXF1ZXN0TWV0aG9kW3JlcS5tZXRob2RdLnRvVXBwZXJDYXNlKCksIHJlcS51cmwpO1xuICAgICAgICAgICAgLy8gbG9hZCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICB2YXIgb25Mb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlVGV4dCBpcyB0aGUgb2xkLXNjaG9vbCB3YXkgb2YgcmV0cmlldmluZyByZXNwb25zZSAoc3VwcG9ydGVkIGJ5IElFOCAmIDkpXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UvcmVzcG9uc2VUeXBlIHByb3BlcnRpZXMgd2VyZSBpbnRyb2R1Y2VkIGluIFhIUiBMZXZlbDIgc3BlYyAoc3VwcG9ydGVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gSUUxMClcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGxhbmdfMS5pc1ByZXNlbnQoX3hoci5yZXNwb25zZSkgPyBfeGhyLnJlc3BvbnNlIDogX3hoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBoZWFkZXJzXzEuSGVhZGVycy5mcm9tUmVzcG9uc2VIZWFkZXJTdHJpbmcoX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IGh0dHBfdXRpbHNfMS5nZXRSZXNwb25zZVVSTChfeGhyKTtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MClcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gX3hoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiBfeGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgcmV0cmlldmluZyBmaWxlcyBmcm9tIGFwcGxpY2F0aW9uIGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gYm9keSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZU9wdGlvbnMgPSBuZXcgYmFzZV9yZXNwb25zZV9vcHRpb25zXzEuUmVzcG9uc2VPcHRpb25zKHsgYm9keTogYm9keSwgc3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IGhlYWRlcnMsIHVybDogdXJsIH0pO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGJhc2VSZXNwb25zZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucyA9IGJhc2VSZXNwb25zZU9wdGlvbnMubWVyZ2UocmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IHN0YXRpY19yZXNwb25zZV8xLlJlc3BvbnNlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKGh0dHBfdXRpbHNfMS5pc1N1Y2Nlc3Moc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLm5leHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGdkaTIyOTApOiBkZWZlciBjb21wbGV0ZSBpZiBhcnJheSBidWZmZXIgdW50aWwgZG9uZVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXJyb3IgZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlT3B0aW9ucyA9IG5ldyBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMS5SZXNwb25zZU9wdGlvbnMoeyBib2R5OiBlcnIsIHR5cGU6IGVudW1zXzEuUmVzcG9uc2VUeXBlLkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGJhc2VSZXNwb25zZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucyA9IGJhc2VSZXNwb25zZU9wdGlvbnMubWVyZ2UocmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5lcnJvcihuZXcgc3RhdGljX3Jlc3BvbnNlXzEuUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmVxLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgcmVxLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBuYW1lKSB7IHJldHVybiBfeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWVzLmpvaW4oJywnKSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3hoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgICAgICAgIF94aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgIF94aHIuc2VuZChfdGhpcy5yZXF1ZXN0LnRleHQoKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF94aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgX3hoci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIF94aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gWEhSQ29ubmVjdGlvbjtcbn0oKSk7XG5leHBvcnRzLlhIUkNvbm5lY3Rpb24gPSBYSFJDb25uZWN0aW9uO1xudmFyIFhIUkJhY2tlbmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhIUkJhY2tlbmQoX2Jyb3dzZXJYSFIsIF9iYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Jyb3dzZXJYSFIgPSBfYnJvd3NlclhIUjtcbiAgICAgICAgdGhpcy5fYmFzZVJlc3BvbnNlT3B0aW9ucyA9IF9iYXNlUmVzcG9uc2VPcHRpb25zO1xuICAgIH1cbiAgICBYSFJCYWNrZW5kLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYSFJDb25uZWN0aW9uKHJlcXVlc3QsIHRoaXMuX2Jyb3dzZXJYSFIsIHRoaXMuX2Jhc2VSZXNwb25zZU9wdGlvbnMpO1xuICAgIH07XG4gICAgWEhSQmFja2VuZC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBYSFJCYWNrZW5kLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGJyb3dzZXJfeGhyXzEuQnJvd3NlclhociwgfSxcbiAgICAgICAgeyB0eXBlOiBiYXNlX3Jlc3BvbnNlX29wdGlvbnNfMS5SZXNwb25zZU9wdGlvbnMsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gWEhSQmFja2VuZDtcbn0oKSk7XG5leHBvcnRzLlhIUkJhY2tlbmQgPSBYSFJCYWNrZW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyX2JhY2tlbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBoZWFkZXJzXzEgPSByZXF1aXJlKCcuL2hlYWRlcnMnKTtcbnZhciBlbnVtc18xID0gcmVxdWlyZSgnLi9lbnVtcycpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciB1cmxfc2VhcmNoX3BhcmFtc18xID0gcmVxdWlyZSgnLi91cmxfc2VhcmNoX3BhcmFtcycpO1xudmFyIGh0dHBfdXRpbHNfMSA9IHJlcXVpcmUoJy4vaHR0cF91dGlscycpO1xuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdCBvcHRpb25zIG9iamVjdCB0byBiZSBvcHRpb25hbGx5IHByb3ZpZGVkIHdoZW4gaW5zdGFudGlhdGluZyBhXG4gKiB7QGxpbmsgUmVxdWVzdH0uXG4gKlxuICogVGhpcyBjbGFzcyBpcyBiYXNlZCBvbiB0aGUgYFJlcXVlc3RJbml0YCBkZXNjcmlwdGlvbiBpbiB0aGUgW0ZldGNoXG4gKiBTcGVjXShodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluaXQpLlxuICpcbiAqIEFsbCB2YWx1ZXMgYXJlIG51bGwgYnkgZGVmYXVsdC4gVHlwaWNhbCBkZWZhdWx0cyBjYW4gYmUgZm91bmQgaW4gdGhlIHtAbGluayBCYXNlUmVxdWVzdE9wdGlvbnN9XG4gKiBjbGFzcywgd2hpY2ggc3ViLWNsYXNzZXMgYFJlcXVlc3RPcHRpb25zYC5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvN1d2aTNsZkxxNDFhUVBLbHhCNE8/cD1wcmV2aWV3KSlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1JlcXVlc3RPcHRpb25zLCBSZXF1ZXN0LCBSZXF1ZXN0TWV0aG9kfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAqXG4gKiB2YXIgb3B0aW9ucyA9IG5ldyBSZXF1ZXN0T3B0aW9ucyh7XG4gKiAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5Qb3N0LFxuICogICB1cmw6ICdodHRwczovL2dvb2dsZS5jb20nXG4gKiB9KTtcbiAqIHZhciByZXEgPSBuZXcgUmVxdWVzdChvcHRpb25zKTtcbiAqIGNvbnNvbGUubG9nKCdyZXEubWV0aG9kOicsIFJlcXVlc3RNZXRob2RbcmVxLm1ldGhvZF0pOyAvLyBQb3N0XG4gKiBjb25zb2xlLmxvZygnb3B0aW9ucy51cmw6Jywgb3B0aW9ucy51cmwpOyAvLyBodHRwczovL2dvb2dsZS5jb21cbiAqIGBgYFxuICovXG52YXIgUmVxdWVzdE9wdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3RPcHRpb25zKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtZXRob2QgPSBfYi5tZXRob2QsIGhlYWRlcnMgPSBfYi5oZWFkZXJzLCBib2R5ID0gX2IuYm9keSwgdXJsID0gX2IudXJsLCBzZWFyY2ggPSBfYi5zZWFyY2g7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbGFuZ18xLmlzUHJlc2VudChtZXRob2QpID8gaHR0cF91dGlsc18xLm5vcm1hbGl6ZU1ldGhvZE5hbWUobWV0aG9kKSA6IG51bGw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGxhbmdfMS5pc1ByZXNlbnQoaGVhZGVycykgPyBoZWFkZXJzIDogbnVsbDtcbiAgICAgICAgdGhpcy5ib2R5ID0gbGFuZ18xLmlzUHJlc2VudChib2R5KSA/IGJvZHkgOiBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IGxhbmdfMS5pc1ByZXNlbnQodXJsKSA/IHVybCA6IG51bGw7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gbGFuZ18xLmlzUHJlc2VudChzZWFyY2gpID8gKGxhbmdfMS5pc1N0cmluZyhzZWFyY2gpID8gbmV3IHVybF9zZWFyY2hfcGFyYW1zXzEuVVJMU2VhcmNoUGFyYW1zKChzZWFyY2gpKSA6XG4gICAgICAgICAgICAoc2VhcmNoKSkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGBSZXF1ZXN0T3B0aW9uc2AgaW5zdGFuY2UsIHVzaW5nIHRoZSBvcHRpb25hbCBpbnB1dCBhcyB2YWx1ZXMgdG8gb3ZlcnJpZGVcbiAgICAgKiBleGlzdGluZyB2YWx1ZXMuIFRoaXMgbWV0aG9kIHdpbGwgbm90IGNoYW5nZSB0aGUgdmFsdWVzIG9mIHRoZSBpbnN0YW5jZSBvbiB3aGljaCBpdCBpcyBiZWluZ1xuICAgICAqIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBgaGVhZGVyc2AgYW5kIGBzZWFyY2hgIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmcgdmFsdWVzIGNvbXBsZXRlbHkgaWYgcHJlc2VudCBpblxuICAgICAqIHRoZSBgb3B0aW9uc2Agb2JqZWN0LiBJZiB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIG1lcmdlZCwgaXQgc2hvdWxkIGJlIGRvbmUgcHJpb3IgdG8gY2FsbGluZ1xuICAgICAqIGBtZXJnZWAgb24gdGhlIGBSZXF1ZXN0T3B0aW9uc2AgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvNnc4WEE4WVRrRFJjUFlwZEI5ZGs/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQge1JlcXVlc3RPcHRpb25zLCBSZXF1ZXN0LCBSZXF1ZXN0TWV0aG9kfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0gbmV3IFJlcXVlc3RPcHRpb25zKHtcbiAgICAgKiAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5Qb3N0XG4gICAgICogfSk7XG4gICAgICogdmFyIHJlcSA9IG5ldyBSZXF1ZXN0KG9wdGlvbnMubWVyZ2Uoe1xuICAgICAqICAgdXJsOiAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuICAgICAqIH0pKTtcbiAgICAgKiBjb25zb2xlLmxvZygncmVxLm1ldGhvZDonLCBSZXF1ZXN0TWV0aG9kW3JlcS5tZXRob2RdKTsgLy8gUG9zdFxuICAgICAqIGNvbnNvbGUubG9nKCdvcHRpb25zLnVybDonLCBvcHRpb25zLnVybCk7IC8vIG51bGxcbiAgICAgKiBjb25zb2xlLmxvZygncmVxLnVybDonLCByZXEudXJsKTsgLy8gaHR0cHM6Ly9nb29nbGUuY29tXG4gICAgICogYGBgXG4gICAgICovXG4gICAgUmVxdWVzdE9wdGlvbnMucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0T3B0aW9ucyh7XG4gICAgICAgICAgICBtZXRob2Q6IGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucykgJiYgbGFuZ18xLmlzUHJlc2VudChvcHRpb25zLm1ldGhvZCkgPyBvcHRpb25zLm1ldGhvZCA6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogbGFuZ18xLmlzUHJlc2VudChvcHRpb25zKSAmJiBsYW5nXzEuaXNQcmVzZW50KG9wdGlvbnMuaGVhZGVycykgPyBvcHRpb25zLmhlYWRlcnMgOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBsYW5nXzEuaXNQcmVzZW50KG9wdGlvbnMpICYmIGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucy5ib2R5KSA/IG9wdGlvbnMuYm9keSA6IHRoaXMuYm9keSxcbiAgICAgICAgICAgIHVybDogbGFuZ18xLmlzUHJlc2VudChvcHRpb25zKSAmJiBsYW5nXzEuaXNQcmVzZW50KG9wdGlvbnMudXJsKSA/IG9wdGlvbnMudXJsIDogdGhpcy51cmwsXG4gICAgICAgICAgICBzZWFyY2g6IGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucykgJiYgbGFuZ18xLmlzUHJlc2VudChvcHRpb25zLnNlYXJjaCkgP1xuICAgICAgICAgICAgICAgIChsYW5nXzEuaXNTdHJpbmcob3B0aW9ucy5zZWFyY2gpID8gbmV3IHVybF9zZWFyY2hfcGFyYW1zXzEuVVJMU2VhcmNoUGFyYW1zKChvcHRpb25zLnNlYXJjaCkpIDpcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMuc2VhcmNoKS5jbG9uZSgpKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnM7XG59KCkpO1xuZXhwb3J0cy5SZXF1ZXN0T3B0aW9ucyA9IFJlcXVlc3RPcHRpb25zO1xudmFyIEJhc2VSZXF1ZXN0T3B0aW9ucyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VSZXF1ZXN0T3B0aW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlUmVxdWVzdE9wdGlvbnMoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHsgbWV0aG9kOiBlbnVtc18xLlJlcXVlc3RNZXRob2QuR2V0LCBoZWFkZXJzOiBuZXcgaGVhZGVyc18xLkhlYWRlcnMoKSB9KTtcbiAgICB9XG4gICAgQmFzZVJlcXVlc3RPcHRpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIEJhc2VSZXF1ZXN0T3B0aW9ucy5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgIHJldHVybiBCYXNlUmVxdWVzdE9wdGlvbnM7XG59KFJlcXVlc3RPcHRpb25zKSk7XG5leHBvcnRzLkJhc2VSZXF1ZXN0T3B0aW9ucyA9IEJhc2VSZXF1ZXN0T3B0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VfcmVxdWVzdF9vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGhlYWRlcnNfMSA9IHJlcXVpcmUoJy4vaGVhZGVycycpO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKCcuL2VudW1zJyk7XG4vKipcbiAqIENyZWF0ZXMgYSByZXNwb25zZSBvcHRpb25zIG9iamVjdCB0byBiZSBvcHRpb25hbGx5IHByb3ZpZGVkIHdoZW4gaW5zdGFudGlhdGluZyBhXG4gKiB7QGxpbmsgUmVzcG9uc2V9LlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgYmFzZWQgb24gdGhlIGBSZXNwb25zZUluaXRgIGRlc2NyaXB0aW9uIGluIHRoZSBbRmV0Y2hcbiAqIFNwZWNdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZWluaXQpLlxuICpcbiAqIEFsbCB2YWx1ZXMgYXJlIG51bGwgYnkgZGVmYXVsdC4gVHlwaWNhbCBkZWZhdWx0cyBjYW4gYmUgZm91bmQgaW4gdGhlXG4gKiB7QGxpbmsgQmFzZVJlc3BvbnNlT3B0aW9uc30gY2xhc3MsIHdoaWNoIHN1Yi1jbGFzc2VzIGBSZXNwb25zZU9wdGlvbnNgLlxuICpcbiAqIFRoaXMgY2xhc3MgbWF5IGJlIHVzZWQgaW4gdGVzdHMgdG8gYnVpbGQge0BsaW5rIFJlc3BvbnNlIFJlc3BvbnNlc30gZm9yXG4gKiBtb2NrIHJlc3BvbnNlcyAoc2VlIHtAbGluayBNb2NrQmFja2VuZH0pLlxuICpcbiAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9QOUprazhlOGN6Nk5WemJjeEVzRD9wPXByZXZpZXcpKVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7UmVzcG9uc2VPcHRpb25zLCBSZXNwb25zZX0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG4gKlxuICogdmFyIG9wdGlvbnMgPSBuZXcgUmVzcG9uc2VPcHRpb25zKHtcbiAqICAgYm9keTogJ3tcIm5hbWVcIjpcIkplZmZcIn0nXG4gKiB9KTtcbiAqIHZhciByZXMgPSBuZXcgUmVzcG9uc2Uob3B0aW9ucyk7XG4gKlxuICogY29uc29sZS5sb2coJ3Jlcy5qc29uKCk6JywgcmVzLmpzb24oKSk7IC8vIE9iamVjdCB7bmFtZTogXCJKZWZmXCJ9XG4gKiBgYGBcbiAqL1xudmFyIFJlc3BvbnNlT3B0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzcG9uc2VPcHRpb25zKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBib2R5ID0gX2IuYm9keSwgc3RhdHVzID0gX2Iuc3RhdHVzLCBoZWFkZXJzID0gX2IuaGVhZGVycywgc3RhdHVzVGV4dCA9IF9iLnN0YXR1c1RleHQsIHR5cGUgPSBfYi50eXBlLCB1cmwgPSBfYi51cmw7XG4gICAgICAgIHRoaXMuYm9keSA9IGxhbmdfMS5pc1ByZXNlbnQoYm9keSkgPyBib2R5IDogbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBsYW5nXzEuaXNQcmVzZW50KHN0YXR1cykgPyBzdGF0dXMgOiBudWxsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBsYW5nXzEuaXNQcmVzZW50KGhlYWRlcnMpID8gaGVhZGVycyA6IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IGxhbmdfMS5pc1ByZXNlbnQoc3RhdHVzVGV4dCkgPyBzdGF0dXNUZXh0IDogbnVsbDtcbiAgICAgICAgdGhpcy50eXBlID0gbGFuZ18xLmlzUHJlc2VudCh0eXBlKSA/IHR5cGUgOiBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IGxhbmdfMS5pc1ByZXNlbnQodXJsKSA/IHVybCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBgUmVzcG9uc2VPcHRpb25zYCBpbnN0YW5jZSwgdXNpbmcgdGhlIG9wdGlvbmFsIGlucHV0IGFzIHZhbHVlcyB0b1xuICAgICAqIG92ZXJyaWRlXG4gICAgICogZXhpc3RpbmcgdmFsdWVzLiBUaGlzIG1ldGhvZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgaXMgYmVpbmdcbiAgICAgKiBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSB1c2VmdWwgd2hlbiBzaGFyaW5nIGEgYmFzZSBgUmVzcG9uc2VPcHRpb25zYCBvYmplY3QgaW5zaWRlIHRlc3RzLFxuICAgICAqIHdoZXJlIGNlcnRhaW4gcHJvcGVydGllcyBtYXkgY2hhbmdlIGZyb20gdGVzdCB0byB0ZXN0LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzFsWHF1cUZmZ2R1VEZCV2pOb1JFP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHtSZXNwb25zZU9wdGlvbnMsIFJlc3BvbnNlfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0gbmV3IFJlc3BvbnNlT3B0aW9ucyh7XG4gICAgICogICBib2R5OiB7bmFtZTogJ0plZmYnfVxuICAgICAqIH0pO1xuICAgICAqIHZhciByZXMgPSBuZXcgUmVzcG9uc2Uob3B0aW9ucy5tZXJnZSh7XG4gICAgICogICB1cmw6ICdodHRwczovL2dvb2dsZS5jb20nXG4gICAgICogfSkpO1xuICAgICAqIGNvbnNvbGUubG9nKCdvcHRpb25zLnVybDonLCBvcHRpb25zLnVybCk7IC8vIG51bGxcbiAgICAgKiBjb25zb2xlLmxvZygncmVzLmpzb24oKTonLCByZXMuanNvbigpKTsgLy8gT2JqZWN0IHtuYW1lOiBcIkplZmZcIn1cbiAgICAgKiBjb25zb2xlLmxvZygncmVzLnVybDonLCByZXMudXJsKTsgLy8gaHR0cHM6Ly9nb29nbGUuY29tXG4gICAgICogYGBgXG4gICAgICovXG4gICAgUmVzcG9uc2VPcHRpb25zLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VPcHRpb25zKHtcbiAgICAgICAgICAgIGJvZHk6IGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucykgJiYgbGFuZ18xLmlzUHJlc2VudChvcHRpb25zLmJvZHkpID8gb3B0aW9ucy5ib2R5IDogdGhpcy5ib2R5LFxuICAgICAgICAgICAgc3RhdHVzOiBsYW5nXzEuaXNQcmVzZW50KG9wdGlvbnMpICYmIGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucy5zdGF0dXMpID8gb3B0aW9ucy5zdGF0dXMgOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucykgJiYgbGFuZ18xLmlzUHJlc2VudChvcHRpb25zLmhlYWRlcnMpID8gb3B0aW9ucy5oZWFkZXJzIDogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogbGFuZ18xLmlzUHJlc2VudChvcHRpb25zKSAmJiBsYW5nXzEuaXNQcmVzZW50KG9wdGlvbnMuc3RhdHVzVGV4dCkgPyBvcHRpb25zLnN0YXR1c1RleHQgOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHR5cGU6IGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucykgJiYgbGFuZ18xLmlzUHJlc2VudChvcHRpb25zLnR5cGUpID8gb3B0aW9ucy50eXBlIDogdGhpcy50eXBlLFxuICAgICAgICAgICAgdXJsOiBsYW5nXzEuaXNQcmVzZW50KG9wdGlvbnMpICYmIGxhbmdfMS5pc1ByZXNlbnQob3B0aW9ucy51cmwpID8gb3B0aW9ucy51cmwgOiB0aGlzLnVybCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzcG9uc2VPcHRpb25zO1xufSgpKTtcbmV4cG9ydHMuUmVzcG9uc2VPcHRpb25zID0gUmVzcG9uc2VPcHRpb25zO1xudmFyIEJhc2VSZXNwb25zZU9wdGlvbnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlUmVzcG9uc2VPcHRpb25zLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VSZXNwb25zZU9wdGlvbnMoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHsgc3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICdPaycsIHR5cGU6IGVudW1zXzEuUmVzcG9uc2VUeXBlLkRlZmF1bHQsIGhlYWRlcnM6IG5ldyBoZWFkZXJzXzEuSGVhZGVycygpIH0pO1xuICAgIH1cbiAgICBCYXNlUmVzcG9uc2VPcHRpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIEJhc2VSZXNwb25zZU9wdGlvbnMuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICByZXR1cm4gQmFzZVJlc3BvbnNlT3B0aW9ucztcbn0oUmVzcG9uc2VPcHRpb25zKSk7XG5leHBvcnRzLkJhc2VSZXNwb25zZU9wdGlvbnMgPSBCYXNlUmVzcG9uc2VPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZV9yZXNwb25zZV9vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4qIFN1cHBvcnRlZCBodHRwIG1ldGhvZHMuXG4qL1xuKGZ1bmN0aW9uIChSZXF1ZXN0TWV0aG9kKSB7XG4gICAgUmVxdWVzdE1ldGhvZFtSZXF1ZXN0TWV0aG9kW1wiR2V0XCJdID0gMF0gPSBcIkdldFwiO1xuICAgIFJlcXVlc3RNZXRob2RbUmVxdWVzdE1ldGhvZFtcIlBvc3RcIl0gPSAxXSA9IFwiUG9zdFwiO1xuICAgIFJlcXVlc3RNZXRob2RbUmVxdWVzdE1ldGhvZFtcIlB1dFwiXSA9IDJdID0gXCJQdXRcIjtcbiAgICBSZXF1ZXN0TWV0aG9kW1JlcXVlc3RNZXRob2RbXCJEZWxldGVcIl0gPSAzXSA9IFwiRGVsZXRlXCI7XG4gICAgUmVxdWVzdE1ldGhvZFtSZXF1ZXN0TWV0aG9kW1wiT3B0aW9uc1wiXSA9IDRdID0gXCJPcHRpb25zXCI7XG4gICAgUmVxdWVzdE1ldGhvZFtSZXF1ZXN0TWV0aG9kW1wiSGVhZFwiXSA9IDVdID0gXCJIZWFkXCI7XG4gICAgUmVxdWVzdE1ldGhvZFtSZXF1ZXN0TWV0aG9kW1wiUGF0Y2hcIl0gPSA2XSA9IFwiUGF0Y2hcIjtcbn0pKGV4cG9ydHMuUmVxdWVzdE1ldGhvZCB8fCAoZXhwb3J0cy5SZXF1ZXN0TWV0aG9kID0ge30pKTtcbnZhciBSZXF1ZXN0TWV0aG9kID0gZXhwb3J0cy5SZXF1ZXN0TWV0aG9kO1xuLyoqXG4gKiBBbGwgcG9zc2libGUgc3RhdGVzIGluIHdoaWNoIGEgY29ubmVjdGlvbiBjYW4gYmUsIGJhc2VkIG9uXG4gKiBbU3RhdGVzXShodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jc3RhdGVzKSBmcm9tIHRoZSBgWE1MSHR0cFJlcXVlc3RgIHNwZWMsIGJ1dCB3aXRoIGFuXG4gKiBhZGRpdGlvbmFsIFwiQ0FOQ0VMTEVEXCIgc3RhdGUuXG4gKi9cbihmdW5jdGlvbiAoUmVhZHlTdGF0ZSkge1xuICAgIFJlYWR5U3RhdGVbUmVhZHlTdGF0ZVtcIlVuc2VudFwiXSA9IDBdID0gXCJVbnNlbnRcIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGVbXCJPcGVuXCJdID0gMV0gPSBcIk9wZW5cIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGVbXCJIZWFkZXJzUmVjZWl2ZWRcIl0gPSAyXSA9IFwiSGVhZGVyc1JlY2VpdmVkXCI7XG4gICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlW1wiTG9hZGluZ1wiXSA9IDNdID0gXCJMb2FkaW5nXCI7XG4gICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlW1wiRG9uZVwiXSA9IDRdID0gXCJEb25lXCI7XG4gICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlW1wiQ2FuY2VsbGVkXCJdID0gNV0gPSBcIkNhbmNlbGxlZFwiO1xufSkoZXhwb3J0cy5SZWFkeVN0YXRlIHx8IChleHBvcnRzLlJlYWR5U3RhdGUgPSB7fSkpO1xudmFyIFJlYWR5U3RhdGUgPSBleHBvcnRzLlJlYWR5U3RhdGU7XG4vKipcbiAqIEFjY2VwdGFibGUgcmVzcG9uc2UgdHlwZXMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIGEge0BsaW5rIFJlc3BvbnNlfSwgYmFzZWQgb25cbiAqIFtSZXNwb25zZVR5cGVdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZXR5cGUpIGZyb20gdGhlIEZldGNoIHNwZWMuXG4gKi9cbihmdW5jdGlvbiAoUmVzcG9uc2VUeXBlKSB7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIkJhc2ljXCJdID0gMF0gPSBcIkJhc2ljXCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZVtcIkNvcnNcIl0gPSAxXSA9IFwiQ29yc1wiO1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGVbXCJEZWZhdWx0XCJdID0gMl0gPSBcIkRlZmF1bHRcIjtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlW1wiT3BhcXVlXCJdID0gNF0gPSBcIk9wYXF1ZVwiO1xufSkoZXhwb3J0cy5SZXNwb25zZVR5cGUgfHwgKGV4cG9ydHMuUmVzcG9uc2VUeXBlID0ge30pKTtcbnZhciBSZXNwb25zZVR5cGUgPSBleHBvcnRzLlJlc3BvbnNlVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW1zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgZ2xvYmFsU2NvcGU7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBhbnkgd2l0aCBXb3JrZXJHbG9iYWxTY29wZSBmcm9tIGxpYi53ZWJ3b3JrZXIuZC50cyAjMzQ5MlxuICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICB9XG59XG5lbHNlIHtcbiAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGZuKSB7XG4gICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdzY2hlZHVsZU1pY3JvdGFzaycsIGZuKTtcbn1cbmV4cG9ydHMuc2NoZWR1bGVNaWNyb1Rhc2sgPSBzY2hlZHVsZU1pY3JvVGFzaztcbmV4cG9ydHMuSVNfREFSVCA9IGZhbHNlO1xuLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4vLyBleHBvcnRzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgc3ltYm9sLlxudmFyIF9nbG9iYWwgPSBnbG9iYWxTY29wZTtcbmV4cG9ydHMuZ2xvYmFsID0gX2dsb2JhbDtcbmV4cG9ydHMuVHlwZSA9IEZ1bmN0aW9uO1xuZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgIGlmICh0eXBlWyduYW1lJ10pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVbJ25hbWUnXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlO1xufVxuZXhwb3J0cy5nZXRUeXBlTmFtZUZvckRlYnVnZ2luZyA9IGdldFR5cGVOYW1lRm9yRGVidWdnaW5nO1xuZXhwb3J0cy5NYXRoID0gX2dsb2JhbC5NYXRoO1xuZXhwb3J0cy5EYXRlID0gX2dsb2JhbC5EYXRlO1xudmFyIF9kZXZNb2RlID0gdHJ1ZTtcbnZhciBfbW9kZUxvY2tlZCA9IGZhbHNlO1xuZnVuY3Rpb24gbG9ja01vZGUoKSB7XG4gICAgX21vZGVMb2NrZWQgPSB0cnVlO1xufVxuZXhwb3J0cy5sb2NrTW9kZSA9IGxvY2tNb2RlO1xuLyoqXG4gKiBEaXNhYmxlIEFuZ3VsYXIncyBkZXZlbG9wbWVudCBtb2RlLCB3aGljaCB0dXJucyBvZmYgYXNzZXJ0aW9ucyBhbmQgb3RoZXJcbiAqIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yay5cbiAqXG4gKiBPbmUgaW1wb3J0YW50IGFzc2VydGlvbiB0aGlzIGRpc2FibGVzIHZlcmlmaWVzIHRoYXQgYSBjaGFuZ2UgZGV0ZWN0aW9uIHBhc3NcbiAqIGRvZXMgbm90IHJlc3VsdCBpbiBhZGRpdGlvbmFsIGNoYW5nZXMgdG8gYW55IGJpbmRpbmdzIChhbHNvIGtub3duIGFzXG4gKiB1bmlkaXJlY3Rpb25hbCBkYXRhIGZsb3cpLlxuICovXG5mdW5jdGlvbiBlbmFibGVQcm9kTW9kZSgpIHtcbiAgICBpZiAoX21vZGVMb2NrZWQpIHtcbiAgICAgICAgLy8gQ2Fubm90IHVzZSBCYXNlRXhjZXB0aW9uIGFzIHRoYXQgZW5kcyB1cCBpbXBvcnRpbmcgZnJvbSBmYWNhZGUvbGFuZy5cbiAgICAgICAgdGhyb3cgJ0Nhbm5vdCBlbmFibGUgcHJvZCBtb2RlIGFmdGVyIHBsYXRmb3JtIHNldHVwLic7XG4gICAgfVxuICAgIF9kZXZNb2RlID0gZmFsc2U7XG59XG5leHBvcnRzLmVuYWJsZVByb2RNb2RlID0gZW5hYmxlUHJvZE1vZGU7XG5mdW5jdGlvbiBhc3NlcnRpb25zRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gX2Rldk1vZGU7XG59XG5leHBvcnRzLmFzc2VydGlvbnNFbmFibGVkID0gYXNzZXJ0aW9uc0VuYWJsZWQ7XG4vLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbi8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbl9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgIC8vIFRPRE86IHRvIGJlIGZpeGVkIHByb3Blcmx5IHZpYSAjMjgzMCwgbm9vcCBmb3Igbm93XG59O1xuZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGw7XG59XG5leHBvcnRzLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbmZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNCbGFuayA9IGlzQmxhbms7XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiYm9vbGVhblwiO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIjtcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmZ1bmN0aW9uIGlzVHlwZShvYmopIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvYmopO1xufVxuZXhwb3J0cy5pc1R5cGUgPSBpc1R5cGU7XG5mdW5jdGlvbiBpc1N0cmluZ01hcChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1N0cmluZ01hcCA9IGlzU3RyaW5nTWFwO1xudmFyIFNUUklOR19NQVBfUFJPVE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuZnVuY3Rpb24gaXNTdHJpY3RTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nTWFwKG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IFNUUklOR19NQVBfUFJPVE87XG59XG5leHBvcnRzLmlzU3RyaWN0U3RyaW5nTWFwID0gaXNTdHJpY3RTdHJpbmdNYXA7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIF9nbG9iYWwuUHJvbWlzZTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgZXhwb3J0cy5EYXRlICYmICFpc05hTihvYmoudmFsdWVPZigpKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZXhwb3J0cy5ub29wID0gbm9vcDtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xuICAgIH1cbiAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgIH1cbiAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoXCJcXG5cIik7XG4gICAgcmV0dXJuIChuZXdMaW5lSW5kZXggPT09IC0xKSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuLy8gc2VyaWFsaXplIC8gZGVzZXJpYWxpemUgZW51bSBleGlzdCBvbmx5IGZvciBjb25zaXN0ZW5jeSB3aXRoIGRhcnQgQVBJXG4vLyBlbnVtcyBpbiB0eXBlc2NyaXB0IGRvbid0IG5lZWQgdG8gYmUgc2VyaWFsaXplZFxuZnVuY3Rpb24gc2VyaWFsaXplRW51bSh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0cy5zZXJpYWxpemVFbnVtID0gc2VyaWFsaXplRW51bTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRW51bSh2YWwsIHZhbHVlcykge1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplRW51bSA9IGRlc2VyaWFsaXplRW51bTtcbmZ1bmN0aW9uIHJlc29sdmVFbnVtVG9rZW4oZW51bVZhbHVlLCB2YWwpIHtcbiAgICByZXR1cm4gZW51bVZhbHVlW3ZhbF07XG59XG5leHBvcnRzLnJlc29sdmVFbnVtVG9rZW4gPSByZXNvbHZlRW51bVRva2VuO1xudmFyIFN0cmluZ1dyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ1dyYXBwZXIoKSB7XG4gICAgfVxuICAgIFN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7IH07XG4gICAgU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0ID0gZnVuY3Rpb24gKHMsIGluZGV4KSB7IHJldHVybiBzLmNoYXJDb2RlQXQoaW5kZXgpOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3BsaXQgPSBmdW5jdGlvbiAocywgcmVnRXhwKSB7IHJldHVybiBzLnNwbGl0KHJlZ0V4cCk7IH07XG4gICAgU3RyaW5nV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAocywgczIpIHsgcmV0dXJuIHMgPT09IHMyOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBMZWZ0ID0gZnVuY3Rpb24gKHMsIGNoYXJWYWwpIHtcbiAgICAgICAgaWYgKHMgJiYgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT0gY2hhclZhbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcocG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBSaWdodCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHMuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQgPSBmdW5jdGlvbiAocywgZnJvbSwgY2IpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9mZnNldCAmIHN0cmluZyBmcm9tIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKC0yLCAyKTtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayByZWNlaXZlcyBtYXRjaCwgcDEsIC4uLiwgcG5cbiAgICAgICAgICAgIHJldHVybiBjYihtYXRjaGVzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKHMsIHN1YnN0cikgeyByZXR1cm4gcy5pbmRleE9mKHN1YnN0cikgIT0gLTE7IH07XG4gICAgU3RyaW5nV3JhcHBlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nV3JhcHBlciA9IFN0cmluZ1dyYXBwZXI7XG52YXIgU3RyaW5nSm9pbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdKb2luZXIocGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHsgcGFydHMgPSBbXTsgfVxuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgfVxuICAgIFN0cmluZ0pvaW5lci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHBhcnQpIHsgdGhpcy5wYXJ0cy5wdXNoKHBhcnQpOyB9O1xuICAgIFN0cmluZ0pvaW5lci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnRzLmpvaW4oXCJcIik7IH07XG4gICAgcmV0dXJuIFN0cmluZ0pvaW5lcjtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ0pvaW5lciA9IFN0cmluZ0pvaW5lcjtcbnZhciBOdW1iZXJQYXJzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVtYmVyUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJQYXJzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIE51bWJlclBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9O1xuICAgIHJldHVybiBOdW1iZXJQYXJzZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5OdW1iZXJQYXJzZUVycm9yID0gTnVtYmVyUGFyc2VFcnJvcjtcbnZhciBOdW1iZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgIH1cbiAgICBOdW1iZXJXcmFwcGVyLnRvRml4ZWQgPSBmdW5jdGlvbiAobiwgZnJhY3Rpb25EaWdpdHMpIHsgcmV0dXJuIG4udG9GaXhlZChmcmFjdGlvbkRpZ2l0cyk7IH07XG4gICAgTnVtYmVyV3JhcHBlci5lcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09PSBiOyB9O1xuICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50ID0gZnVuY3Rpb24gKHRleHQsIHJhZGl4KSB7XG4gICAgICAgIGlmIChyYWRpeCA9PSAxMCkge1xuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTldKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhZGl4ID09IDE2KSB7XG4gICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOUFCQ0RFRmFiY2RlZl0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQgKyBcIiBpbiBiYXNlIFwiICtcbiAgICAgICAgICAgIHJhZGl4KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IE5hTiBpcyBhIHZhbGlkIGxpdGVyYWwgYnV0IGlzIHJldHVybmVkIGJ5IHBhcnNlRmxvYXQgdG8gaW5kaWNhdGUgYW4gZXJyb3IuXG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUZsb2F0ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGV4dCk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIFwiTmFOXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOYU47IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE51bWJlcldyYXBwZXIuaXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzTmFOKHZhbHVlKTsgfTtcbiAgICBOdW1iZXJXcmFwcGVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7IH07XG4gICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5OdW1iZXJXcmFwcGVyID0gTnVtYmVyV3JhcHBlcjtcbmV4cG9ydHMuUmVnRXhwID0gX2dsb2JhbC5SZWdFeHA7XG52YXIgUmVnRXhwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnRXhwV3JhcHBlcigpIHtcbiAgICB9XG4gICAgUmVnRXhwV3JhcHBlci5jcmVhdGUgPSBmdW5jdGlvbiAocmVnRXhwU3RyLCBmbGFncykge1xuICAgICAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9ICcnOyB9XG4gICAgICAgIGZsYWdzID0gZmxhZ3MucmVwbGFjZSgvZy9nLCAnJyk7XG4gICAgICAgIHJldHVybiBuZXcgX2dsb2JhbC5SZWdFeHAocmVnRXhwU3RyLCBmbGFncyArICdnJyk7XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2ggPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xuICAgICAgICAvLyBSZXNldCBtdWx0aW1hdGNoIHJlZ2V4IHN0YXRlXG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci50ZXN0ID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiByZWdFeHAudGVzdChpbnB1dCk7XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLm1hdGNoZXIgPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xuICAgICAgICAvLyBSZXNldCByZWdleCBzdGF0ZSBmb3IgdGhlIGNhc2VcbiAgICAgICAgLy8gc29tZW9uZSBkaWQgbm90IGxvb3Agb3ZlciBhbGwgbWF0Y2hlc1xuICAgICAgICAvLyBsYXN0IHRpbWUuXG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4geyByZTogcmVnRXhwLCBpbnB1dDogaW5wdXQgfTtcbiAgICB9O1xuICAgIFJlZ0V4cFdyYXBwZXIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0LCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBjID0gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgICAgICB2YXIgcmVzID0gJyc7XG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcHJldiA9IDA7XG4gICAgICAgIHdoaWxlIChjKSB7XG4gICAgICAgICAgICByZXMgKz0gaW5wdXQuc3Vic3RyaW5nKHByZXYsIGMuaW5kZXgpO1xuICAgICAgICAgICAgcmVzICs9IHJlcGxhY2UoYyk7XG4gICAgICAgICAgICBwcmV2ID0gYy5pbmRleCArIGNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IHByZXY7XG4gICAgICAgICAgICBjID0gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBpbnB1dC5zdWJzdHJpbmcocHJldik7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnRXhwV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlJlZ0V4cFdyYXBwZXIgPSBSZWdFeHBXcmFwcGVyO1xudmFyIFJlZ0V4cE1hdGNoZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdFeHBNYXRjaGVyV3JhcHBlcigpIHtcbiAgICB9XG4gICAgUmVnRXhwTWF0Y2hlcldyYXBwZXIubmV4dCA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLnJlLmV4ZWMobWF0Y2hlci5pbnB1dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnRXhwTWF0Y2hlcldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5SZWdFeHBNYXRjaGVyV3JhcHBlciA9IFJlZ0V4cE1hdGNoZXJXcmFwcGVyO1xudmFyIEZ1bmN0aW9uV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25XcmFwcGVyKCkge1xuICAgIH1cbiAgICBGdW5jdGlvbldyYXBwZXIuYXBwbHkgPSBmdW5jdGlvbiAoZm4sIHBvc0FyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KG51bGwsIHBvc0FyZ3MpOyB9O1xuICAgIHJldHVybiBGdW5jdGlvbldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5GdW5jdGlvbldyYXBwZXIgPSBGdW5jdGlvbldyYXBwZXI7XG4vLyBKUyBoYXMgTmFOICE9PSBOYU5cbmZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbn1cbmV4cG9ydHMubG9vc2VJZGVudGljYWwgPSBsb29zZUlkZW50aWNhbDtcbi8vIEpTIGNvbnNpZGVycyBOYU4gaXMgdGhlIHNhbWUgYXMgTmFOIGZvciBtYXAgS2V5ICh3aGlsZSBOYU4gIT09IE5hTiBvdGhlcndpc2UpXG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwXG5mdW5jdGlvbiBnZXRNYXBLZXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLmdldE1hcEtleSA9IGdldE1hcEtleTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsYW5rKG9iaikge1xuICAgIHJldHVybiBpc0JsYW5rKG9iaikgPyBudWxsIDogb2JqO1xufVxuZXhwb3J0cy5ub3JtYWxpemVCbGFuayA9IG5vcm1hbGl6ZUJsYW5rO1xuZnVuY3Rpb24gbm9ybWFsaXplQm9vbChvYmopIHtcbiAgICByZXR1cm4gaXNCbGFuayhvYmopID8gZmFsc2UgOiBvYmo7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUJvb2wgPSBub3JtYWxpemVCb29sO1xuZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIpO1xufVxuZXhwb3J0cy5pc0pzT2JqZWN0ID0gaXNKc09iamVjdDtcbmZ1bmN0aW9uIHByaW50KG9iaikge1xuICAgIGNvbnNvbGUubG9nKG9iaik7XG59XG5leHBvcnRzLnByaW50ID0gcHJpbnQ7XG5mdW5jdGlvbiB3YXJuKG9iaikge1xuICAgIGNvbnNvbGUud2FybihvYmopO1xufVxuZXhwb3J0cy53YXJuID0gd2Fybjtcbi8vIENhbid0IGJlIGFsbCB1cHBlcmNhc2UgYXMgb3VyIHRyYW5zcGlsZXIgd291bGQgdGhpbmsgaXQgaXMgYSBzcGVjaWFsIGRpcmVjdGl2ZS4uLlxudmFyIEpzb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb24oKSB7XG4gICAgfVxuICAgIEpzb24ucGFyc2UgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gX2dsb2JhbC5KU09OLnBhcnNlKHMpOyB9O1xuICAgIEpzb24uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gRGFydCBkb2Vzbid0IHRha2UgMyBhcmd1bWVudHNcbiAgICAgICAgcmV0dXJuIF9nbG9iYWwuSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvbjtcbn0oKSk7XG5leHBvcnRzLkpzb24gPSBKc29uO1xudmFyIERhdGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlV3JhcHBlcigpIHtcbiAgICB9XG4gICAgRGF0ZVdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcykge1xuICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IDE7IH1cbiAgICAgICAgaWYgKGRheSA9PT0gdm9pZCAwKSB7IGRheSA9IDE7IH1cbiAgICAgICAgaWYgKGhvdXIgPT09IHZvaWQgMCkgeyBob3VyID0gMDsgfVxuICAgICAgICBpZiAobWludXRlcyA9PT0gdm9pZCAwKSB7IG1pbnV0ZXMgPSAwOyB9XG4gICAgICAgIGlmIChzZWNvbmRzID09PSB2b2lkIDApIHsgc2Vjb25kcyA9IDA7IH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdm9pZCAwKSB7IG1pbGxpc2Vjb25kcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XG4gICAgfTtcbiAgICBEYXRlV3JhcHBlci5mcm9tSVNPU3RyaW5nID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gbmV3IGV4cG9ydHMuRGF0ZShzdHIpOyB9O1xuICAgIERhdGVXcmFwcGVyLmZyb21NaWxsaXMgPSBmdW5jdGlvbiAobXMpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUobXMpOyB9O1xuICAgIERhdGVXcmFwcGVyLnRvTWlsbGlzID0gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpOyB9O1xuICAgIERhdGVXcmFwcGVyLm5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoKTsgfTtcbiAgICBEYXRlV3JhcHBlci50b0pzb24gPSBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS50b0pTT04oKTsgfTtcbiAgICByZXR1cm4gRGF0ZVdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5EYXRlV3JhcHBlciA9IERhdGVXcmFwcGVyO1xuZnVuY3Rpb24gc2V0VmFsdWVPblBhdGgoZ2xvYmFsLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgb2JqID0gZ2xvYmFsO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1ByZXNlbnQob2JqW25hbWVdKSkge1xuICAgICAgICAgICAgb2JqID0gb2JqW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb2JqW25hbWVdID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICB9XG4gICAgb2JqW3BhcnRzLnNoaWZ0KCldID0gdmFsdWU7XG59XG5leHBvcnRzLnNldFZhbHVlT25QYXRoID0gc2V0VmFsdWVPblBhdGg7XG52YXIgX3N5bWJvbEl0ZXJhdG9yID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICAgIGlmIChpc0JsYW5rKF9zeW1ib2xJdGVyYXRvcikpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChnbG9iYWxTY29wZS5TeW1ib2wpICYmIGlzUHJlc2VudChTeW1ib2wuaXRlcmF0b3IpKSB7XG4gICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJlxuICAgICAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW2tleV0gPT09IE1hcC5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfc3ltYm9sSXRlcmF0b3I7XG59XG5leHBvcnRzLmdldFN5bWJvbEl0ZXJhdG9yID0gZ2V0U3ltYm9sSXRlcmF0b3I7XG5mdW5jdGlvbiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwsIGV4cHIsIGRlY2xhcmF0aW9ucywgdmFycykge1xuICAgIHZhciBmbkJvZHkgPSBkZWNsYXJhdGlvbnMgKyBcIlxcbnJldHVybiBcIiArIGV4cHIgKyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBzb3VyY2VVcmw7XG4gICAgdmFyIGZuQXJnTmFtZXMgPSBbXTtcbiAgICB2YXIgZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgZm5BcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICBmbkFyZ1ZhbHVlcy5wdXNoKHZhcnNbYXJnTmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBbdm9pZCAwXS5jb25jYXQoZm5BcmdOYW1lcy5jb25jYXQoZm5Cb2R5KSkpKSgpLmFwcGx5KHZvaWQgMCwgZm5BcmdWYWx1ZXMpO1xufVxuZXhwb3J0cy5ldmFsRXhwcmVzc2lvbiA9IGV2YWxFeHByZXNzaW9uO1xuZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgcmV0dXJuICFpc0pzT2JqZWN0KG9iaik7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5mdW5jdGlvbiBoYXNDb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSkge1xuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gdHlwZTtcbn1cbmV4cG9ydHMuaGFzQ29uc3RydWN0b3IgPSBoYXNDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGJpdFdpc2VPcih2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSB8IGI7IH0pO1xufVxuZXhwb3J0cy5iaXRXaXNlT3IgPSBiaXRXaXNlT3I7XG5mdW5jdGlvbiBiaXRXaXNlQW5kKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XG59XG5leHBvcnRzLmJpdFdpc2VBbmQgPSBiaXRXaXNlQW5kO1xuZnVuY3Rpb24gZXNjYXBlKHMpIHtcbiAgICByZXR1cm4gX2dsb2JhbC5lbmNvZGVVUkkocyk7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG4vKipcbiAqIFBvbHlmaWxsIGZvciBbSGVhZGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hlYWRlcnMvSGVhZGVycyksIGFzXG4gKiBzcGVjaWZpZWQgaW4gdGhlIFtGZXRjaCBTcGVjXShodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVycy1jbGFzcykuXG4gKlxuICogVGhlIG9ubHkga25vd24gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgYEhlYWRlcnNgIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgc3BlYyBpcyB0aGVcbiAqIGxhY2sgb2YgYW4gYGVudHJpZXNgIG1ldGhvZC5cbiAqXG4gKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvTVRkd1Q2P3A9cHJldmlldykpXG4gKlxuICogYGBgXG4gKiBpbXBvcnQge0hlYWRlcnN9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuICpcbiAqIHZhciBmaXJzdEhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICogZmlyc3RIZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgJ2ltYWdlL2pwZWcnKTtcbiAqIGNvbnNvbGUubG9nKGZpcnN0SGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpKSAvLydpbWFnZS9qcGVnJ1xuICpcbiAqIC8vIENyZWF0ZSBoZWFkZXJzIGZyb20gUGxhaW4gT2xkIEphdmFTY3JpcHQgT2JqZWN0XG4gKiB2YXIgc2Vjb25kSGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAqICAgJ1gtTXktQ3VzdG9tLUhlYWRlcic6ICdBbmd1bGFyJ1xuICogfSk7XG4gKiBjb25zb2xlLmxvZyhzZWNvbmRIZWFkZXJzLmdldCgnWC1NeS1DdXN0b20tSGVhZGVyJykpOyAvLydBbmd1bGFyJ1xuICpcbiAqIHZhciB0aGlyZEhlYWRlcnMgPSBuZXcgSGVhZGVycyhzZWNvbmRIZWFkZXJzKTtcbiAqIGNvbnNvbGUubG9nKHRoaXJkSGVhZGVycy5nZXQoJ1gtTXktQ3VzdG9tLUhlYWRlcicpKTsgLy8nQW5ndWxhcidcbiAqIGBgYFxuICovXG52YXIgSGVhZGVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyc01hcCA9IGhlYWRlcnMuX2hlYWRlcnNNYXA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZGVyc01hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhoZWFkZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhlYWRlcnMgaW5zdGFuY2VvZiBTdHJpbmdNYXBcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgX3RoaXMuX2hlYWRlcnNNYXAuc2V0KGssIGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUodikgPyB2IDogW3ZdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgSGVhZGVycyBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBET01TdHJpbmcgb2YgUmVzcG9uc2UgSGVhZGVyc1xuICAgICAqL1xuICAgIEhlYWRlcnMuZnJvbVJlc3BvbnNlSGVhZGVyU3RyaW5nID0gZnVuY3Rpb24gKGhlYWRlcnNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNTdHJpbmcudHJpbSgpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbC5zcGxpdCgnOicpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgcGFydHMgPSBfYS5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiAoW2tleS50cmltKCksIHBhcnRzLmpvaW4oJzonKS50cmltKCldKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGhlYWRlcnMsIF9hKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gIWhlYWRlcnMuc2V0KGtleSwgdmFsdWUpICYmIGhlYWRlcnM7XG4gICAgICAgIH0sIG5ldyBIZWFkZXJzKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIGhlYWRlciB0byBleGlzdGluZyBsaXN0IG9mIGhlYWRlciB2YWx1ZXMgZm9yIGEgZ2l2ZW4gaGVhZGVyIG5hbWUuXG4gICAgICovXG4gICAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBtYXBOYW1lID0gdGhpcy5faGVhZGVyc01hcC5nZXQobmFtZSk7XG4gICAgICAgIHZhciBsaXN0ID0gY29sbGVjdGlvbl8xLmlzTGlzdExpa2VJdGVyYWJsZShtYXBOYW1lKSA/IG1hcE5hbWUgOiBbXTtcbiAgICAgICAgbGlzdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faGVhZGVyc01hcC5zZXQobmFtZSwgbGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFsbCBoZWFkZXIgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBIZWFkZXJzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLl9oZWFkZXJzTWFwLmRlbGV0ZShuYW1lKTsgfTtcbiAgICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNNYXAuZm9yRWFjaChmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IGhlYWRlciB0aGF0IG1hdGNoZXMgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaGVhZGVyKSB7IHJldHVybiBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuZmlyc3QodGhpcy5faGVhZGVyc01hcC5nZXQoaGVhZGVyKSk7IH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGV4aXN0ZW5jZSBvZiBoZWFkZXIgYnkgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoaGVhZGVyKSB7IHJldHVybiB0aGlzLl9oZWFkZXJzTWFwLmhhcyhoZWFkZXIpOyB9O1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIG5hbWVzIG9mIHNldCBoZWFkZXJzXG4gICAgICovXG4gICAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb25fMS5NYXBXcmFwcGVyLmtleXModGhpcy5faGVhZGVyc01hcCk7IH07XG4gICAgLyoqXG4gICAgICogU2V0cyBvciBvdmVycmlkZXMgaGVhZGVyIHZhbHVlIGZvciBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChoZWFkZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIGlmIChjb2xsZWN0aW9uXzEuaXNMaXN0TGlrZUl0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIHB1c2hWYWx1ZSA9IHZhbHVlLmpvaW4oJywnKTtcbiAgICAgICAgICAgIGxpc3QucHVzaChwdXNoVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkZXJzTWFwLnNldChoZWFkZXIsIGxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMuXG4gICAgICovXG4gICAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbl8xLk1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2hlYWRlcnNNYXApOyB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIG9mIGFsbCBoZWFkZXJzLlxuICAgICAqL1xuICAgIEhlYWRlcnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6YWJsZUhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5faGVhZGVyc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZXMsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgICAgICBjb2xsZWN0aW9uXzEuaXRlcmF0ZUxpc3RMaWtlKHZhbHVlcywgZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbGlzdCA9IGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jb25jYXQobGlzdCwgdmFsLnNwbGl0KCcsJykpOyB9KTtcbiAgICAgICAgICAgIHNlcmlhbGl6YWJsZUhlYWRlcnNbbmFtZV0gPSBsaXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZUhlYWRlcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgaGVhZGVyIHZhbHVlcyBmb3IgYSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIEhlYWRlcnMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLl9oZWFkZXJzTWFwLmdldChoZWFkZXIpO1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLmlzTGlzdExpa2VJdGVyYWJsZShoZWFkZXJzKSA/IGhlYWRlcnMgOiBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oJ1wiZW50cmllc1wiIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgb24gSGVhZGVycyBjbGFzcycpOyB9O1xuICAgIHJldHVybiBIZWFkZXJzO1xufSgpKTtcbmV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGludGVyZmFjZXNfMSA9IHJlcXVpcmUoJy4vaW50ZXJmYWNlcycpO1xudmFyIHN0YXRpY19yZXF1ZXN0XzEgPSByZXF1aXJlKCcuL3N0YXRpY19yZXF1ZXN0Jyk7XG52YXIgYmFzZV9yZXF1ZXN0X29wdGlvbnNfMSA9IHJlcXVpcmUoJy4vYmFzZV9yZXF1ZXN0X29wdGlvbnMnKTtcbnZhciBlbnVtc18xID0gcmVxdWlyZSgnLi9lbnVtcycpO1xuZnVuY3Rpb24gaHR0cFJlcXVlc3QoYmFja2VuZCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBiYWNrZW5kLmNyZWF0ZUNvbm5lY3Rpb24ocmVxdWVzdCkucmVzcG9uc2U7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdHMsIHByb3ZpZGVkT3B0cywgbWV0aG9kLCB1cmwpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IGRlZmF1bHRPcHRzO1xuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHByb3ZpZGVkT3B0cykpIHtcbiAgICAgICAgLy8gSGFjayBzbyBEYXJ0IGNhbiB1c2VkIG5hbWVkIHBhcmFtZXRlcnNcbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnMubWVyZ2UobmV3IGJhc2VfcmVxdWVzdF9vcHRpb25zXzEuUmVxdWVzdE9wdGlvbnMoe1xuICAgICAgICAgICAgbWV0aG9kOiBwcm92aWRlZE9wdHMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogcHJvdmlkZWRPcHRzLnVybCB8fCB1cmwsXG4gICAgICAgICAgICBzZWFyY2g6IHByb3ZpZGVkT3B0cy5zZWFyY2gsXG4gICAgICAgICAgICBoZWFkZXJzOiBwcm92aWRlZE9wdHMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IHByb3ZpZGVkT3B0cy5ib2R5XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gbmV3T3B0aW9ucy5tZXJnZShuZXcgYmFzZV9yZXF1ZXN0X29wdGlvbnNfMS5SZXF1ZXN0T3B0aW9ucyh7IG1ldGhvZDogbWV0aG9kLCB1cmw6IHVybCB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3T3B0aW9ucy5tZXJnZShuZXcgYmFzZV9yZXF1ZXN0X29wdGlvbnNfMS5SZXF1ZXN0T3B0aW9ucyh7IHVybDogdXJsIH0pKTtcbiAgICB9XG59XG52YXIgSHR0cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cChfYmFja2VuZCwgX2RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2JhY2tlbmQgPSBfYmFja2VuZDtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSBfZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFueSB0eXBlIG9mIGh0dHAgcmVxdWVzdC4gRmlyc3QgYXJndW1lbnQgaXMgcmVxdWlyZWQsIGFuZCBjYW4gZWl0aGVyIGJlIGEgdXJsIG9yXG4gICAgICogYSB7QGxpbmsgUmVxdWVzdH0gaW5zdGFuY2UuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHVybCwgYW4gb3B0aW9uYWwge0BsaW5rIFJlcXVlc3RPcHRpb25zfVxuICAgICAqIG9iamVjdCBjYW4gYmUgcHJvdmlkZWQgYXMgdGhlIDJuZCBhcmd1bWVudC4gVGhlIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIHZhbHVlc1xuICAgICAqIG9mIHtAbGluayBCYXNlUmVxdWVzdE9wdGlvbnN9IGJlZm9yZSBwZXJmb3JtaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIEh0dHAucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXNwb25zZU9ic2VydmFibGU7XG4gICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmcodXJsKSkge1xuICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZhYmxlID0gaHR0cFJlcXVlc3QodGhpcy5fYmFja2VuZCwgbmV3IHN0YXRpY19yZXF1ZXN0XzEuUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIGVudW1zXzEuUmVxdWVzdE1ldGhvZC5HZXQsIHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cmwgaW5zdGFuY2VvZiBzdGF0aWNfcmVxdWVzdF8xLlJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlT2JzZXJ2YWJsZSA9IGh0dHBSZXF1ZXN0KHRoaXMuX2JhY2tlbmQsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBleGNlcHRpb25zXzEubWFrZVR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHVybCBzdHJpbmcgb3IgUmVxdWVzdCBpbnN0YW5jZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VPYnNlcnZhYmxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByZXF1ZXN0IHdpdGggYGdldGAgaHR0cCBtZXRob2QuXG4gICAgICovXG4gICAgSHR0cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaHR0cFJlcXVlc3QodGhpcy5fYmFja2VuZCwgbmV3IHN0YXRpY19yZXF1ZXN0XzEuUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIGVudW1zXzEuUmVxdWVzdE1ldGhvZC5HZXQsIHVybCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBwb3N0YCBodHRwIG1ldGhvZC5cbiAgICAgKi9cbiAgICBIdHRwLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaHR0cFJlcXVlc3QodGhpcy5fYmFja2VuZCwgbmV3IHN0YXRpY19yZXF1ZXN0XzEuUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMubWVyZ2UobmV3IGJhc2VfcmVxdWVzdF9vcHRpb25zXzEuUmVxdWVzdE9wdGlvbnMoeyBib2R5OiBib2R5IH0pKSwgb3B0aW9ucywgZW51bXNfMS5SZXF1ZXN0TWV0aG9kLlBvc3QsIHVybCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBwdXRgIGh0dHAgbWV0aG9kLlxuICAgICAqL1xuICAgIEh0dHAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGh0dHBSZXF1ZXN0KHRoaXMuX2JhY2tlbmQsIG5ldyBzdGF0aWNfcmVxdWVzdF8xLlJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLm1lcmdlKG5ldyBiYXNlX3JlcXVlc3Rfb3B0aW9uc18xLlJlcXVlc3RPcHRpb25zKHsgYm9keTogYm9keSB9KSksIG9wdGlvbnMsIGVudW1zXzEuUmVxdWVzdE1ldGhvZC5QdXQsIHVybCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBkZWxldGVgIGh0dHAgbWV0aG9kLlxuICAgICAqL1xuICAgIEh0dHAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGh0dHBSZXF1ZXN0KHRoaXMuX2JhY2tlbmQsIG5ldyBzdGF0aWNfcmVxdWVzdF8xLlJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBlbnVtc18xLlJlcXVlc3RNZXRob2QuRGVsZXRlLCB1cmwpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlcXVlc3Qgd2l0aCBgcGF0Y2hgIGh0dHAgbWV0aG9kLlxuICAgICAqL1xuICAgIEh0dHAucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gaHR0cFJlcXVlc3QodGhpcy5fYmFja2VuZCwgbmV3IHN0YXRpY19yZXF1ZXN0XzEuUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMubWVyZ2UobmV3IGJhc2VfcmVxdWVzdF9vcHRpb25zXzEuUmVxdWVzdE9wdGlvbnMoeyBib2R5OiBib2R5IH0pKSwgb3B0aW9ucywgZW51bXNfMS5SZXF1ZXN0TWV0aG9kLlBhdGNoLCB1cmwpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlcXVlc3Qgd2l0aCBgaGVhZGAgaHR0cCBtZXRob2QuXG4gICAgICovXG4gICAgSHR0cC5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGh0dHBSZXF1ZXN0KHRoaXMuX2JhY2tlbmQsIG5ldyBzdGF0aWNfcmVxdWVzdF8xLlJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBlbnVtc18xLlJlcXVlc3RNZXRob2QuSGVhZCwgdXJsKSkpO1xuICAgIH07XG4gICAgSHR0cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBIdHRwLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGludGVyZmFjZXNfMS5Db25uZWN0aW9uQmFja2VuZCwgfSxcbiAgICAgICAgeyB0eXBlOiBiYXNlX3JlcXVlc3Rfb3B0aW9uc18xLlJlcXVlc3RPcHRpb25zLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIEh0dHA7XG59KCkpO1xuZXhwb3J0cy5IdHRwID0gSHR0cDtcbnZhciBKc29ucCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpzb25wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpzb25wKGJhY2tlbmQsIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGJhY2tlbmQsIGRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW55IHR5cGUgb2YgaHR0cCByZXF1ZXN0LiBGaXJzdCBhcmd1bWVudCBpcyByZXF1aXJlZCwgYW5kIGNhbiBlaXRoZXIgYmUgYSB1cmwgb3JcbiAgICAgKiBhIHtAbGluayBSZXF1ZXN0fSBpbnN0YW5jZS4gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgdXJsLCBhbiBvcHRpb25hbCB7QGxpbmsgUmVxdWVzdE9wdGlvbnN9XG4gICAgICogb2JqZWN0IGNhbiBiZSBwcm92aWRlZCBhcyB0aGUgMm5kIGFyZ3VtZW50LiBUaGUgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgdmFsdWVzXG4gICAgICogb2Yge0BsaW5rIEJhc2VSZXF1ZXN0T3B0aW9uc30gYmVmb3JlIHBlcmZvcm1pbmcgdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgSnNvbnAucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXNwb25zZU9ic2VydmFibGU7XG4gICAgICAgIGlmIChsYW5nXzEuaXNTdHJpbmcodXJsKSkge1xuICAgICAgICAgICAgdXJsID1cbiAgICAgICAgICAgICAgICBuZXcgc3RhdGljX3JlcXVlc3RfMS5SZXF1ZXN0KG1lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucywgb3B0aW9ucywgZW51bXNfMS5SZXF1ZXN0TWV0aG9kLkdldCwgdXJsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIHN0YXRpY19yZXF1ZXN0XzEuUmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHVybC5tZXRob2QgIT09IGVudW1zXzEuUmVxdWVzdE1ldGhvZC5HZXQpIHtcbiAgICAgICAgICAgICAgICBleGNlcHRpb25zXzEubWFrZVR5cGVFcnJvcignSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgR0VUIHJlcXVlc3QgbWV0aG9kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZhYmxlID0gaHR0cFJlcXVlc3QodGhpcy5fYmFja2VuZCwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbnNfMS5tYWtlVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdXJsIHN0cmluZyBvciBSZXF1ZXN0IGluc3RhbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZU9ic2VydmFibGU7XG4gICAgfTtcbiAgICBKc29ucC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBKc29ucC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgeyB0eXBlOiBpbnRlcmZhY2VzXzEuQ29ubmVjdGlvbkJhY2tlbmQsIH0sXG4gICAgICAgIHsgdHlwZTogYmFzZV9yZXF1ZXN0X29wdGlvbnNfMS5SZXF1ZXN0T3B0aW9ucywgfSxcbiAgICBdO1xuICAgIHJldHVybiBKc29ucDtcbn0oSHR0cCkpO1xuZXhwb3J0cy5Kc29ucCA9IEpzb25wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBlbnVtc18xID0gcmVxdWlyZSgnLi9lbnVtcycpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kTmFtZShtZXRob2QpIHtcbiAgICBpZiAobGFuZ18xLmlzU3RyaW5nKG1ldGhvZCkpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBtZXRob2QgPSBtZXRob2RcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFx3KShcXHcqKS9nLCBmdW5jdGlvbiAoZzAsIGcxLCBnMikge1xuICAgICAgICAgICAgcmV0dXJuIGcxLnRvVXBwZXJDYXNlKCkgKyBnMi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0aG9kID0gZW51bXNfMS5SZXF1ZXN0TWV0aG9kW21ldGhvZF07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbnNfMS5tYWtlVHlwZUVycm9yKFwiSW52YWxpZCByZXF1ZXN0IG1ldGhvZC4gVGhlIG1ldGhvZCBcXFwiXCIgKyBvcmlnaW5hbE1ldGhvZCArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmV4cG9ydHMubm9ybWFsaXplTWV0aG9kTmFtZSA9IG5vcm1hbGl6ZU1ldGhvZE5hbWU7XG5leHBvcnRzLmlzU3VjY2VzcyA9IGZ1bmN0aW9uIChzdGF0dXMpIHsgcmV0dXJuIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCk7IH07XG5mdW5jdGlvbiBnZXRSZXNwb25zZVVSTCh4aHIpIHtcbiAgICBpZiAoJ3Jlc3BvbnNlVVJMJyBpbiB4aHIpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVVSTDtcbiAgICB9XG4gICAgaWYgKC9eWC1SZXF1ZXN0LVVSTDovbS50ZXN0KHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgICAgcmV0dXJuIHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1SZXF1ZXN0LVVSTCcpO1xuICAgIH1cbiAgICByZXR1cm47XG59XG5leHBvcnRzLmdldFJlc3BvbnNlVVJMID0gZ2V0UmVzcG9uc2VVUkw7XG52YXIgbGFuZ18yID0gcmVxdWlyZSgnLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG5leHBvcnRzLmlzSnNPYmplY3QgPSBsYW5nXzIuaXNKc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBfdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZyb20gd2hpY2ggcmVhbCBiYWNrZW5kcyBhcmUgZGVyaXZlZC5cbiAqXG4gKiBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIGEgYENvbm5lY3Rpb25CYWNrZW5kYCBpcyB0byBjcmVhdGUgbmV3IGNvbm5lY3Rpb25zIHRvIGZ1bGZpbGwgYSBnaXZlblxuICoge0BsaW5rIFJlcXVlc3R9LlxuICovXG52YXIgQ29ubmVjdGlvbkJhY2tlbmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25CYWNrZW5kKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29ubmVjdGlvbkJhY2tlbmQ7XG59KCkpO1xuZXhwb3J0cy5Db25uZWN0aW9uQmFja2VuZCA9IENvbm5lY3Rpb25CYWNrZW5kO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIHJlYWwgY29ubmVjdGlvbnMgYXJlIGRlcml2ZWQuXG4gKi9cbnZhciBDb25uZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29ubmVjdGlvbjtcbn0oKSk7XG5leHBvcnRzLkNvbm5lY3Rpb24gPSBDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJmYWNlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBoZWFkZXJzXzEgPSByZXF1aXJlKCcuL2hlYWRlcnMnKTtcbnZhciBodHRwX3V0aWxzXzEgPSByZXF1aXJlKCcuL2h0dHBfdXRpbHMnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbi8vIFRPRE8oamVmZmJjcm9zcyk6IHByb3Blcmx5IGltcGxlbWVudCBib2R5IGFjY2Vzc29yc1xuLyoqXG4gKiBDcmVhdGVzIGBSZXF1ZXN0YCBpbnN0YW5jZXMgZnJvbSBwcm92aWRlZCB2YWx1ZXMuXG4gKlxuICogVGhlIFJlcXVlc3QncyBpbnRlcmZhY2UgaXMgaW5zcGlyZWQgYnkgdGhlIFJlcXVlc3QgY29uc3RydWN0b3IgZGVmaW5lZCBpbiB0aGUgW0ZldGNoXG4gKiBTcGVjXShodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1jbGFzcyksXG4gKiBidXQgaXMgY29uc2lkZXJlZCBhIHN0YXRpYyB2YWx1ZSB3aG9zZSBib2R5IGNhbiBiZSBhY2Nlc3NlZCBtYW55IHRpbWVzLiBUaGVyZSBhcmUgb3RoZXJcbiAqIGRpZmZlcmVuY2VzIGluIHRoZSBpbXBsZW1lbnRhdGlvbiwgYnV0IHRoaXMgaXMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQuXG4gKlxuICogYFJlcXVlc3RgIGluc3RhbmNlcyBhcmUgdHlwaWNhbGx5IGNyZWF0ZWQgYnkgaGlnaGVyLWxldmVsIGNsYXNzZXMsIGxpa2Uge0BsaW5rIEh0dHB9IGFuZFxuICoge0BsaW5rIEpzb25wfSwgYnV0IGl0IG1heSBvY2Nhc2lvbmFsbHkgYmUgdXNlZnVsIHRvIGV4cGxpY2l0bHkgY3JlYXRlIGBSZXF1ZXN0YCBpbnN0YW5jZXMuXG4gKiBPbmUgc3VjaCBleGFtcGxlIGlzIHdoZW4gY3JlYXRpbmcgc2VydmljZXMgdGhhdCB3cmFwIGhpZ2hlci1sZXZlbCBzZXJ2aWNlcywgbGlrZSB7QGxpbmsgSHR0cH0sXG4gKiB3aGVyZSBpdCBtYXkgYmUgdXNlZnVsIHRvIGdlbmVyYXRlIGEgYFJlcXVlc3RgIHdpdGggYXJiaXRyYXJ5IGhlYWRlcnMgYW5kIHNlYXJjaCBwYXJhbXMuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtJbmplY3RhYmxlLCBJbmplY3Rvcn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQge0hUVFBfUFJPVklERVJTLCBIdHRwLCBSZXF1ZXN0LCBSZXF1ZXN0TWV0aG9kfSBmcm9tICdAYW5ndWxhci9odHRwJztcbiAqXG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBBdXRvQXV0aGVudGljYXRvciB7XG4gKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBodHRwOkh0dHApIHt9XG4gKiAgIHJlcXVlc3QodXJsOnN0cmluZykge1xuICogICAgIHJldHVybiB0aGlzLmh0dHAucmVxdWVzdChuZXcgUmVxdWVzdCh7XG4gKiAgICAgICBtZXRob2Q6IFJlcXVlc3RNZXRob2QuR2V0LFxuICogICAgICAgdXJsOiB1cmwsXG4gKiAgICAgICBzZWFyY2g6ICdwYXNzd29yZD0xMjMnXG4gKiAgICAgfSkpO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbSFRUUF9QUk9WSURFUlMsIEF1dG9BdXRoZW50aWNhdG9yXSk7XG4gKiB2YXIgYXV0aGVudGljYXRvciA9IGluamVjdG9yLmdldChBdXRvQXV0aGVudGljYXRvcik7XG4gKiBhdXRoZW50aWNhdG9yLnJlcXVlc3QoJ3Blb3BsZS5qc29uJykuc3Vic2NyaWJlKHJlcyA9PiB7XG4gKiAgIC8vVVJMIHNob3VsZCBoYXZlIGluY2x1ZGVkICc/cGFzc3dvcmQ9MTIzJ1xuICogICBjb25zb2xlLmxvZygncGVvcGxlJywgcmVzLmpzb24oKSk7XG4gKiB9KTtcbiAqIGBgYFxuICovXG52YXIgUmVxdWVzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAvLyBUT0RPOiBhc3NlcnQgdGhhdCB1cmwgaXMgcHJlc2VudFxuICAgICAgICB2YXIgdXJsID0gcmVxdWVzdE9wdGlvbnMudXJsO1xuICAgICAgICB0aGlzLnVybCA9IHJlcXVlc3RPcHRpb25zLnVybDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQocmVxdWVzdE9wdGlvbnMuc2VhcmNoKSkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHJlcXVlc3RPcHRpb25zLnNlYXJjaC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9ICc/JztcbiAgICAgICAgICAgICAgICBpZiAobGFuZ18xLlN0cmluZ1dyYXBwZXIuY29udGFpbnModGhpcy51cmwsICc/JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gKHRoaXMudXJsW3RoaXMudXJsLmxlbmd0aCAtIDFdID09ICcmJykgPyAnJyA6ICcmJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzoganVzdCBkZWxldGUgc2VhcmNoLXF1ZXJ5LWxvb2tpbmcgc3RyaW5nIGluIHVybD9cbiAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHVybCArIHByZWZpeCArIHNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib2R5ID0gcmVxdWVzdE9wdGlvbnMuYm9keTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBodHRwX3V0aWxzXzEubm9ybWFsaXplTWV0aG9kTmFtZShyZXF1ZXN0T3B0aW9ucy5tZXRob2QpO1xuICAgICAgICAvLyBUT0RPKGplZmZiY3Jvc3MpOiBpbXBsZW1lbnQgYmVoYXZpb3JcbiAgICAgICAgLy8gRGVmYXVsdHMgdG8gJ29taXQnLCBjb25zaXN0ZW50IHdpdGggYnJvd3NlclxuICAgICAgICAvLyBUT0RPKGplZmZiY3Jvc3MpOiBpbXBsZW1lbnQgYmVoYXZpb3JcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IGhlYWRlcnNfMS5IZWFkZXJzKHJlcXVlc3RPcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXF1ZXN0J3MgYm9keSBhcyBzdHJpbmcsIGFzc3VtaW5nIHRoYXQgYm9keSBleGlzdHMuIElmIGJvZHkgaXMgdW5kZWZpbmVkLCByZXR1cm5cbiAgICAgKiBlbXB0eVxuICAgICAqIHN0cmluZy5cbiAgICAgKi9cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl9ib2R5KSA/IHRoaXMuX2JvZHkudG9TdHJpbmcoKSA6ICcnOyB9O1xuICAgIHJldHVybiBSZXF1ZXN0O1xufSgpKTtcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0aWNfcmVxdWVzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBodHRwX3V0aWxzXzEgPSByZXF1aXJlKCcuL2h0dHBfdXRpbHMnKTtcbi8qKlxuICogQ3JlYXRlcyBgUmVzcG9uc2VgIGluc3RhbmNlcyBmcm9tIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBUaG91Z2ggdGhpcyBvYmplY3QgaXNuJ3RcbiAqIHVzdWFsbHkgaW5zdGFudGlhdGVkIGJ5IGVuZC11c2VycywgaXQgaXMgdGhlIHByaW1hcnkgb2JqZWN0IGludGVyYWN0ZWQgd2l0aCB3aGVuIGl0IGNvbWVzIHRpbWUgdG9cbiAqIGFkZCBkYXRhIHRvIGEgdmlldy5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogaHR0cC5yZXF1ZXN0KCdteS1mcmllbmRzLnR4dCcpLnN1YnNjcmliZShyZXNwb25zZSA9PiB0aGlzLmZyaWVuZHMgPSByZXNwb25zZS50ZXh0KCkpO1xuICogYGBgXG4gKlxuICogVGhlIFJlc3BvbnNlJ3MgaW50ZXJmYWNlIGlzIGluc3BpcmVkIGJ5IHRoZSBSZXNwb25zZSBjb25zdHJ1Y3RvciBkZWZpbmVkIGluIHRoZSBbRmV0Y2hcbiAqIFNwZWNdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzcyksIGJ1dCBpcyBjb25zaWRlcmVkIGEgc3RhdGljIHZhbHVlIHdob3NlIGJvZHlcbiAqIGNhbiBiZSBhY2Nlc3NlZCBtYW55IHRpbWVzLiBUaGVyZSBhcmUgb3RoZXIgZGlmZmVyZW5jZXMgaW4gdGhlIGltcGxlbWVudGF0aW9uLCBidXQgdGhpcyBpcyB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQuXG4gKi9cbnZhciBSZXNwb25zZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2JvZHkgPSByZXNwb25zZU9wdGlvbnMuYm9keTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSByZXNwb25zZU9wdGlvbnMuc3RhdHVzO1xuICAgICAgICB0aGlzLm9rID0gKHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8PSAyOTkpO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSByZXNwb25zZU9wdGlvbnMuc3RhdHVzVGV4dDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gcmVzcG9uc2VPcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIHRoaXMudHlwZSA9IHJlc3BvbnNlT3B0aW9ucy50eXBlO1xuICAgICAgICB0aGlzLnVybCA9IHJlc3BvbnNlT3B0aW9ucy51cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdCB5ZXQgaW1wbGVtZW50ZWRcbiAgICAgKi9cbiAgICAvLyBUT0RPOiBCbG9iIHJldHVybiB0eXBlXG4gICAgUmVzcG9uc2UucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignXCJibG9iKClcIiBtZXRob2Qgbm90IGltcGxlbWVudGVkIG9uIFJlc3BvbnNlIHN1cGVyY2xhc3MnKTsgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byByZXR1cm4gYm9keSBhcyBwYXJzZWQgYEpTT05gIG9iamVjdCwgb3IgcmFpc2VzIGFuIGV4Y2VwdGlvbi5cbiAgICAgKi9cbiAgICBSZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGpzb25SZXNwb25zZTtcbiAgICAgICAgaWYgKGh0dHBfdXRpbHNfMS5pc0pzT2JqZWN0KHRoaXMuX2JvZHkpKSB7XG4gICAgICAgICAgICBqc29uUmVzcG9uc2UgPSB0aGlzLl9ib2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5pc1N0cmluZyh0aGlzLl9ib2R5KSkge1xuICAgICAgICAgICAganNvblJlc3BvbnNlID0gbGFuZ18xLkpzb24ucGFyc2UodGhpcy5fYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb25SZXNwb25zZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvZHkgYXMgYSBzdHJpbmcsIHByZXN1bWluZyBgdG9TdHJpbmcoKWAgY2FuIGJlIGNhbGxlZCBvbiB0aGUgcmVzcG9uc2UgYm9keS5cbiAgICAgKi9cbiAgICBSZXNwb25zZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2JvZHkudG9TdHJpbmcoKTsgfTtcbiAgICAvKipcbiAgICAgKiBOb3QgeWV0IGltcGxlbWVudGVkXG4gICAgICovXG4gICAgLy8gVE9ETzogQXJyYXlCdWZmZXIgcmV0dXJuIHR5cGVcbiAgICBSZXNwb25zZS5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbignXCJhcnJheUJ1ZmZlcigpXCIgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZCBvbiBSZXNwb25zZSBzdXBlcmNsYXNzJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzcG9uc2U7XG59KCkpO1xuZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGljX3Jlc3BvbnNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xuZnVuY3Rpb24gcGFyYW1QYXJzZXIocmF3UGFyYW1zKSB7XG4gICAgaWYgKHJhd1BhcmFtcyA9PT0gdm9pZCAwKSB7IHJhd1BhcmFtcyA9ICcnOyB9XG4gICAgdmFyIG1hcCA9IG5ldyBjb2xsZWN0aW9uXzEuTWFwKCk7XG4gICAgaWYgKHJhd1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSByYXdQYXJhbXMuc3BsaXQoJyYnKTtcbiAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBwYXJhbS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgdmFyIGtleSA9IHNwbGl0WzBdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHNwbGl0WzFdO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBsYW5nXzEuaXNQcmVzZW50KG1hcC5nZXQoa2V5KSkgPyBtYXAuZ2V0KGtleSkgOiBbXTtcbiAgICAgICAgICAgIGxpc3QucHVzaCh2YWwpO1xuICAgICAgICAgICAgbWFwLnNldChrZXksIGxpc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuICogTWFwLWxpa2UgcmVwcmVzZW50YXRpb24gb2YgdXJsIHNlYXJjaCBwYXJhbWV0ZXJzLCBiYXNlZCBvblxuICogW1VSTFNlYXJjaFBhcmFtc10oaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMpIGluIHRoZSB1cmwgbGl2aW5nIHN0YW5kYXJkLFxuICogd2l0aCBzZXZlcmFsIGV4dGVuc2lvbnMgZm9yIG1lcmdpbmcgVVJMU2VhcmNoUGFyYW1zIG9iamVjdHM6XG4gKiAgIC0gc2V0QWxsKClcbiAqICAgLSBhcHBlbmRBbGwoKVxuICogICAtIHJlcGxhY2VBbGwoKVxuICovXG52YXIgVVJMU2VhcmNoUGFyYW1zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMocmF3UGFyYW1zKSB7XG4gICAgICAgIGlmIChyYXdQYXJhbXMgPT09IHZvaWQgMCkgeyByYXdQYXJhbXMgPSAnJzsgfVxuICAgICAgICB0aGlzLnJhd1BhcmFtcyA9IHJhd1BhcmFtcztcbiAgICAgICAgdGhpcy5wYXJhbXNNYXAgPSBwYXJhbVBhcnNlcihyYXdQYXJhbXMpO1xuICAgIH1cbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGNsb25lLmFwcGVuZEFsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHRoaXMucGFyYW1zTWFwLmhhcyhwYXJhbSk7IH07XG4gICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdmFyIHN0b3JlZFBhcmFtID0gdGhpcy5wYXJhbXNNYXAuZ2V0KHBhcmFtKTtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25fMS5pc0xpc3RMaWtlSXRlcmFibGUoc3RvcmVkUGFyYW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmZpcnN0KHN0b3JlZFBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgbWFwUGFyYW0gPSB0aGlzLnBhcmFtc01hcC5nZXQocGFyYW0pO1xuICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChtYXBQYXJhbSkgPyBtYXBQYXJhbSA6IFtdO1xuICAgIH07XG4gICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocGFyYW0sIHZhbCkge1xuICAgICAgICB2YXIgbWFwUGFyYW0gPSB0aGlzLnBhcmFtc01hcC5nZXQocGFyYW0pO1xuICAgICAgICB2YXIgbGlzdCA9IGxhbmdfMS5pc1ByZXNlbnQobWFwUGFyYW0pID8gbWFwUGFyYW0gOiBbXTtcbiAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsZWFyKGxpc3QpO1xuICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgdGhpcy5wYXJhbXNNYXAuc2V0KHBhcmFtLCBsaXN0KTtcbiAgICB9O1xuICAgIC8vIEEgbWVyZ2Ugb3BlcmF0aW9uXG4gICAgLy8gRm9yIGVhY2ggbmFtZS12YWx1ZXMgcGFpciBpbiBgc2VhcmNoUGFyYW1zYCwgcGVyZm9ybSBgc2V0KG5hbWUsIHZhbHVlc1swXSlgXG4gICAgLy9cbiAgICAvLyBFLmc6IFwiYT1bMSwyLDNdLCBjPVs4XVwiICsgXCJhPVs0LDUsNl0sIGI9WzddXCIgPSBcImE9WzRdLCBjPVs4XSwgYj1bN11cIlxuICAgIC8vXG4gICAgLy8gVE9ETyhAY2FpdHApOiBkb2N1bWVudCB0aGlzIGJldHRlclxuICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2V0QWxsID0gZnVuY3Rpb24gKHNlYXJjaFBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzZWFyY2hQYXJhbXMucGFyYW1zTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBwYXJhbSkge1xuICAgICAgICAgICAgdmFyIG1hcFBhcmFtID0gX3RoaXMucGFyYW1zTWFwLmdldChwYXJhbSk7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IGxhbmdfMS5pc1ByZXNlbnQobWFwUGFyYW0pID8gbWFwUGFyYW0gOiBbXTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25fMS5MaXN0V3JhcHBlci5jbGVhcihsaXN0KTtcbiAgICAgICAgICAgIGxpc3QucHVzaCh2YWx1ZVswXSk7XG4gICAgICAgICAgICBfdGhpcy5wYXJhbXNNYXAuc2V0KHBhcmFtLCBsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsKSB7XG4gICAgICAgIHZhciBtYXBQYXJhbSA9IHRoaXMucGFyYW1zTWFwLmdldChwYXJhbSk7XG4gICAgICAgIHZhciBsaXN0ID0gbGFuZ18xLmlzUHJlc2VudChtYXBQYXJhbSkgPyBtYXBQYXJhbSA6IFtdO1xuICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgdGhpcy5wYXJhbXNNYXAuc2V0KHBhcmFtLCBsaXN0KTtcbiAgICB9O1xuICAgIC8vIEEgbWVyZ2Ugb3BlcmF0aW9uXG4gICAgLy8gRm9yIGVhY2ggbmFtZS12YWx1ZXMgcGFpciBpbiBgc2VhcmNoUGFyYW1zYCwgcGVyZm9ybSBgYXBwZW5kKG5hbWUsIHZhbHVlKWBcbiAgICAvLyBmb3IgZWFjaCB2YWx1ZSBpbiBgdmFsdWVzYC5cbiAgICAvL1xuICAgIC8vIEUuZzogXCJhPVsxLDJdLCBjPVs4XVwiICsgXCJhPVszLDRdLCBiPVs3XVwiID0gXCJhPVsxLDIsMyw0XSwgYz1bOF0sIGI9WzddXCJcbiAgICAvL1xuICAgIC8vIFRPRE8oQGNhaXRwKTogZG9jdW1lbnQgdGhpcyBiZXR0ZXJcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmFwcGVuZEFsbCA9IGZ1bmN0aW9uIChzZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2VhcmNoUGFyYW1zLnBhcmFtc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBtYXBQYXJhbSA9IF90aGlzLnBhcmFtc01hcC5nZXQocGFyYW0pO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBsYW5nXzEuaXNQcmVzZW50KG1hcFBhcmFtKSA/IG1hcFBhcmFtIDogW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnBhcmFtc01hcC5zZXQocGFyYW0sIGxpc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEEgbWVyZ2Ugb3BlcmF0aW9uXG4gICAgLy8gRm9yIGVhY2ggbmFtZS12YWx1ZXMgcGFpciBpbiBgc2VhcmNoUGFyYW1zYCwgcGVyZm9ybSBgZGVsZXRlKG5hbWUpYCxcbiAgICAvLyBmb2xsb3dlZCBieSBgc2V0KG5hbWUsIHZhbHVlcylgXG4gICAgLy9cbiAgICAvLyBFLmc6IFwiYT1bMSwyLDNdLCBjPVs4XVwiICsgXCJhPVs0LDUsNl0sIGI9WzddXCIgPSBcImE9WzQsNSw2XSwgYz1bOF0sIGI9WzddXCJcbiAgICAvL1xuICAgIC8vIFRPRE8oQGNhaXRwKTogZG9jdW1lbnQgdGhpcyBiZXR0ZXJcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAoc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5wYXJhbXNNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgbWFwUGFyYW0gPSBfdGhpcy5wYXJhbXNNYXAuZ2V0KHBhcmFtKTtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbGFuZ18xLmlzUHJlc2VudChtYXBQYXJhbSkgPyBtYXBQYXJhbSA6IFtdO1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNsZWFyKGxpc3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wYXJhbXNNYXAuc2V0KHBhcmFtLCBsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1zTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmFtc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZXMsIGspIHsgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHBhcmFtc0xpc3QucHVzaChrICsgJz0nICsgdik7IH0pOyB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtc0xpc3Quam9pbignJicpO1xuICAgIH07XG4gICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocGFyYW0pIHsgdGhpcy5wYXJhbXNNYXAuZGVsZXRlKHBhcmFtKTsgfTtcbiAgICByZXR1cm4gVVJMU2VhcmNoUGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsX3NlYXJjaF9wYXJhbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xuZXhwb3J0cy5SZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uUmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmVfcHJpdmF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5fX2V4cG9ydChyZXF1aXJlKCcuL3BsYXRmb3JtX2Jyb3dzZXJfZHluYW1pYycpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbXBpbGVyXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb21waWxlcicpO1xudmFyIHhocl9jYWNoZV8xID0gcmVxdWlyZSgnLi9zcmMveGhyL3hocl9jYWNoZScpO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgeGhyX2ltcGxfMSA9IHJlcXVpcmUoJy4vc3JjL3hoci94aHJfaW1wbCcpO1xudmFyIHBsYXRmb3JtX2Jyb3dzZXJfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgY29yZV9wcml2YXRlXzEgPSByZXF1aXJlKCcuL2NvcmVfcHJpdmF0ZScpO1xuZXhwb3J0cy5DQUNIRURfVEVNUExBVEVfUFJPVklERVIgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBbeyBwcm92aWRlOiBjb21waWxlcl8xLlhIUiwgdXNlQ2xhc3M6IHhocl9jYWNoZV8xLkNhY2hlZFhIUiB9XTtcbi8qKlxuICogQW4gYXJyYXkgb2YgcHJvdmlkZXJzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBpbnRvIGBhcHBsaWNhdGlvbigpYCB3aGVuIGJvb3RzdHJhcHBpbmcgYSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydHMuQlJPV1NFUl9BUFBfRFlOQU1JQ19QUk9WSURFUlMgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBbXG4gICAgcGxhdGZvcm1fYnJvd3Nlcl8xLkJST1dTRVJfQVBQX0NPTU1PTl9QUk9WSURFUlMsXG4gICAgY29tcGlsZXJfMS5DT01QSUxFUl9QUk9WSURFUlMsXG4gICAgeyBwcm92aWRlOiBjb21waWxlcl8xLlhIUiwgdXNlQ2xhc3M6IHhocl9pbXBsXzEuWEhSSW1wbCB9LFxuXTtcbi8qKlxuICogQm9vdHN0cmFwcGluZyBmb3IgQW5ndWxhciBhcHBsaWNhdGlvbnMuXG4gKlxuICogWW91IGluc3RhbnRpYXRlIGFuIEFuZ3VsYXIgYXBwbGljYXRpb24gYnkgZXhwbGljaXRseSBzcGVjaWZ5aW5nIGEgY29tcG9uZW50IHRvIHVzZVxuICogYXMgdGhlIHJvb3QgY29tcG9uZW50IGZvciB5b3VyIGFwcGxpY2F0aW9uIHZpYSB0aGUgYGJvb3RzdHJhcCgpYCBtZXRob2QuXG4gKlxuICogIyMgU2ltcGxlIEV4YW1wbGVcbiAqXG4gKiBBc3N1bWluZyB0aGlzIGBpbmRleC5odG1sYDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8aHRtbD5cbiAqICAgPCEtLSBsb2FkIEFuZ3VsYXIgc2NyaXB0IHRhZ3MgaGVyZS4gLS0+XG4gKiAgIDxib2R5PlxuICogICAgIDxteS1hcHA+bG9hZGluZy4uLjwvbXktYXBwPlxuICogICA8L2JvZHk+XG4gKiA8L2h0bWw+XG4gKiBgYGBcbiAqXG4gKiBBbiBhcHBsaWNhdGlvbiBpcyBib290c3RyYXBwZWQgaW5zaWRlIGFuIGV4aXN0aW5nIGJyb3dzZXIgRE9NLCB0eXBpY2FsbHkgYGluZGV4Lmh0bWxgLlxuICogVW5saWtlIEFuZ3VsYXIgMSwgQW5ndWxhciAyIGRvZXMgbm90IGNvbXBpbGUvcHJvY2VzcyBwcm92aWRlcnMgaW4gYGluZGV4Lmh0bWxgLiBUaGlzIGlzXG4gKiBtYWlubHkgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGFzIHdlbGwgYXMgYXJjaGl0ZWN0dXJhbCBjaGFuZ2VzIGluIEFuZ3VsYXIgMi4gVGhpcyBtZWFuc1xuICogdGhhdCBgaW5kZXguaHRtbGAgY2FuIHNhZmVseSBiZSBwcm9jZXNzZWQgdXNpbmcgc2VydmVyLXNpZGUgdGVjaG5vbG9naWVzIHN1Y2ggYXNcbiAqIHByb3ZpZGVycy4gQmluZGluZ3MgY2FuIHRodXMgdXNlIGRvdWJsZS1jdXJseSBge3sgc3ludGF4IH19YCB3aXRob3V0IGNvbGxpc2lvbiBmcm9tXG4gKiBBbmd1bGFyIDIgY29tcG9uZW50IGRvdWJsZS1jdXJseSBge3sgc3ludGF4IH19YC5cbiAqXG4gKiBXZSBjYW4gdXNlIHRoaXMgc2NyaXB0IGNvZGU6XG4gKlxuICoge0BleGFtcGxlIGNvcmUvdHMvYm9vdHN0cmFwL2Jvb3RzdHJhcC50cyByZWdpb249J2Jvb3RzdHJhcCd9XG4gKlxuICogV2hlbiB0aGUgYXBwIGRldmVsb3BlciBpbnZva2VzIGBib290c3RyYXAoKWAgd2l0aCB0aGUgcm9vdCBjb21wb25lbnQgYE15QXBwYCBhcyBpdHNcbiAqIGFyZ3VtZW50LCBBbmd1bGFyIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgdGFza3M6XG4gKlxuICogIDEuIEl0IHVzZXMgdGhlIGNvbXBvbmVudCdzIGBzZWxlY3RvcmAgcHJvcGVydHkgdG8gbG9jYXRlIHRoZSBET00gZWxlbWVudCB3aGljaCBuZWVkc1xuICogICAgIHRvIGJlIHVwZ3JhZGVkIGludG8gdGhlIGFuZ3VsYXIgY29tcG9uZW50LlxuICogIDIuIEl0IGNyZWF0ZXMgYSBuZXcgY2hpbGQgaW5qZWN0b3IgKGZyb20gdGhlIHBsYXRmb3JtIGluamVjdG9yKS4gT3B0aW9uYWxseSwgeW91IGNhblxuICogICAgIGFsc28gb3ZlcnJpZGUgdGhlIGluamVjdG9yIGNvbmZpZ3VyYXRpb24gZm9yIGFuIGFwcCBieSBpbnZva2luZyBgYm9vdHN0cmFwYCB3aXRoIHRoZVxuICogICAgIGBjb21wb25lbnRJbmplY3RhYmxlQmluZGluZ3NgIGFyZ3VtZW50LlxuICogIDMuIEl0IGNyZWF0ZXMgYSBuZXcgYFpvbmVgIGFuZCBjb25uZWN0cyBpdCB0byB0aGUgYW5ndWxhciBhcHBsaWNhdGlvbidzIGNoYW5nZSBkZXRlY3Rpb25cbiAqICAgICBkb21haW4gaW5zdGFuY2UuXG4gKiAgNC4gSXQgY3JlYXRlcyBhbiBlbXVsYXRlZCBvciBzaGFkb3cgRE9NIG9uIHRoZSBzZWxlY3RlZCBjb21wb25lbnQncyBob3N0IGVsZW1lbnQgYW5kIGxvYWRzIHRoZVxuICogICAgIHRlbXBsYXRlIGludG8gaXQuXG4gKiAgNS4gSXQgaW5zdGFudGlhdGVzIHRoZSBzcGVjaWZpZWQgY29tcG9uZW50LlxuICogIDYuIEZpbmFsbHksIEFuZ3VsYXIgcGVyZm9ybXMgY2hhbmdlIGRldGVjdGlvbiB0byBhcHBseSB0aGUgaW5pdGlhbCBkYXRhIHByb3ZpZGVycyBmb3IgdGhlXG4gKiAgICAgYXBwbGljYXRpb24uXG4gKlxuICpcbiAqICMjIEJvb3RzdHJhcHBpbmcgTXVsdGlwbGUgQXBwbGljYXRpb25zXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGhpbiBhIGJyb3dzZXIgd2luZG93LCB0aGVyZSBhcmUgbWFueSBzaW5nbGV0b24gcmVzb3VyY2VzOiBjb29raWVzLCB0aXRsZSxcbiAqIGxvY2F0aW9uLCBhbmQgb3RoZXJzLiBBbmd1bGFyIHNlcnZpY2VzIHRoYXQgcmVwcmVzZW50IHRoZXNlIHJlc291cmNlcyBtdXN0IGxpa2V3aXNlIGJlXG4gKiBzaGFyZWQgYWNyb3NzIGFsbCBBbmd1bGFyIGFwcGxpY2F0aW9ucyB0aGF0IG9jY3VweSB0aGUgc2FtZSBicm93c2VyIHdpbmRvdy4gRm9yIHRoaXNcbiAqIHJlYXNvbiwgQW5ndWxhciBjcmVhdGVzIGV4YWN0bHkgb25lIGdsb2JhbCBwbGF0Zm9ybSBvYmplY3Qgd2hpY2ggc3RvcmVzIGFsbCBzaGFyZWRcbiAqIHNlcnZpY2VzLCBhbmQgZWFjaCBhbmd1bGFyIGFwcGxpY2F0aW9uIGluamVjdG9yIGhhcyB0aGUgcGxhdGZvcm0gaW5qZWN0b3IgYXMgaXRzIHBhcmVudC5cbiAqXG4gKiBFYWNoIGFwcGxpY2F0aW9uIGhhcyBpdHMgb3duIHByaXZhdGUgaW5qZWN0b3IgYXMgd2VsbC4gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGVcbiAqIGFwcGxpY2F0aW9ucyBvbiBhIHBhZ2UsIEFuZ3VsYXIgdHJlYXRzIGVhY2ggYXBwbGljYXRpb24gaW5qZWN0b3IncyBzZXJ2aWNlcyBhcyBwcml2YXRlXG4gKiB0byB0aGF0IGFwcGxpY2F0aW9uLlxuICpcbiAqICMjIEFQSVxuICpcbiAqIC0gYGFwcENvbXBvbmVudFR5cGVgOiBUaGUgcm9vdCBjb21wb25lbnQgd2hpY2ggc2hvdWxkIGFjdCBhcyB0aGUgYXBwbGljYXRpb24uIFRoaXMgaXNcbiAqICAgYSByZWZlcmVuY2UgdG8gYSBgVHlwZWAgd2hpY2ggaXMgYW5ub3RhdGVkIHdpdGggYEBDb21wb25lbnQoLi4uKWAuXG4gKiAtIGBjdXN0b21Qcm92aWRlcnNgOiBBbiBhZGRpdGlvbmFsIHNldCBvZiBwcm92aWRlcnMgdGhhdCBjYW4gYmUgYWRkZWQgdG8gdGhlXG4gKiAgIGFwcCBpbmplY3RvciB0byBvdmVycmlkZSBkZWZhdWx0IGluamVjdGlvbiBiZWhhdmlvci5cbiAqXG4gKiBSZXR1cm5zIGEgYFByb21pc2VgIG9mIHtAbGluayBDb21wb25lbnRSZWZ9LlxuICovXG5mdW5jdGlvbiBib290c3RyYXAoYXBwQ29tcG9uZW50VHlwZSwgY3VzdG9tUHJvdmlkZXJzKSB7XG4gICAgY29yZV8xLnJlZmxlY3Rvci5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gbmV3IGNvcmVfcHJpdmF0ZV8xLlJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKTtcbiAgICB2YXIgYXBwSW5qZWN0b3IgPSBjb3JlXzEuUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW2V4cG9ydHMuQlJPV1NFUl9BUFBfRFlOQU1JQ19QUk9WSURFUlMsIGxhbmdfMS5pc1ByZXNlbnQoY3VzdG9tUHJvdmlkZXJzKSA/IGN1c3RvbVByb3ZpZGVycyA6IFtdXSwgcGxhdGZvcm1fYnJvd3Nlcl8xLmJyb3dzZXJQbGF0Zm9ybSgpLmluamVjdG9yKTtcbiAgICByZXR1cm4gY29yZV8xLmNvcmVMb2FkQW5kQm9vdHN0cmFwKGFwcEluamVjdG9yLCBhcHBDb21wb25lbnRUeXBlKTtcbn1cbmV4cG9ydHMuYm9vdHN0cmFwID0gYm9vdHN0cmFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm1fYnJvd3Nlcl9keW5hbWljLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgZ2xvYmFsU2NvcGU7XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBhbnkgd2l0aCBXb3JrZXJHbG9iYWxTY29wZSBmcm9tIGxpYi53ZWJ3b3JrZXIuZC50cyAjMzQ5MlxuICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICB9XG59XG5lbHNlIHtcbiAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGZuKSB7XG4gICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdzY2hlZHVsZU1pY3JvdGFzaycsIGZuKTtcbn1cbmV4cG9ydHMuc2NoZWR1bGVNaWNyb1Rhc2sgPSBzY2hlZHVsZU1pY3JvVGFzaztcbmV4cG9ydHMuSVNfREFSVCA9IGZhbHNlO1xuLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4vLyBleHBvcnRzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgc3ltYm9sLlxudmFyIF9nbG9iYWwgPSBnbG9iYWxTY29wZTtcbmV4cG9ydHMuZ2xvYmFsID0gX2dsb2JhbDtcbmV4cG9ydHMuVHlwZSA9IEZ1bmN0aW9uO1xuZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgIGlmICh0eXBlWyduYW1lJ10pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVbJ25hbWUnXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlO1xufVxuZXhwb3J0cy5nZXRUeXBlTmFtZUZvckRlYnVnZ2luZyA9IGdldFR5cGVOYW1lRm9yRGVidWdnaW5nO1xuZXhwb3J0cy5NYXRoID0gX2dsb2JhbC5NYXRoO1xuZXhwb3J0cy5EYXRlID0gX2dsb2JhbC5EYXRlO1xudmFyIF9kZXZNb2RlID0gdHJ1ZTtcbnZhciBfbW9kZUxvY2tlZCA9IGZhbHNlO1xuZnVuY3Rpb24gbG9ja01vZGUoKSB7XG4gICAgX21vZGVMb2NrZWQgPSB0cnVlO1xufVxuZXhwb3J0cy5sb2NrTW9kZSA9IGxvY2tNb2RlO1xuLyoqXG4gKiBEaXNhYmxlIEFuZ3VsYXIncyBkZXZlbG9wbWVudCBtb2RlLCB3aGljaCB0dXJucyBvZmYgYXNzZXJ0aW9ucyBhbmQgb3RoZXJcbiAqIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yay5cbiAqXG4gKiBPbmUgaW1wb3J0YW50IGFzc2VydGlvbiB0aGlzIGRpc2FibGVzIHZlcmlmaWVzIHRoYXQgYSBjaGFuZ2UgZGV0ZWN0aW9uIHBhc3NcbiAqIGRvZXMgbm90IHJlc3VsdCBpbiBhZGRpdGlvbmFsIGNoYW5nZXMgdG8gYW55IGJpbmRpbmdzIChhbHNvIGtub3duIGFzXG4gKiB1bmlkaXJlY3Rpb25hbCBkYXRhIGZsb3cpLlxuICovXG5mdW5jdGlvbiBlbmFibGVQcm9kTW9kZSgpIHtcbiAgICBpZiAoX21vZGVMb2NrZWQpIHtcbiAgICAgICAgLy8gQ2Fubm90IHVzZSBCYXNlRXhjZXB0aW9uIGFzIHRoYXQgZW5kcyB1cCBpbXBvcnRpbmcgZnJvbSBmYWNhZGUvbGFuZy5cbiAgICAgICAgdGhyb3cgJ0Nhbm5vdCBlbmFibGUgcHJvZCBtb2RlIGFmdGVyIHBsYXRmb3JtIHNldHVwLic7XG4gICAgfVxuICAgIF9kZXZNb2RlID0gZmFsc2U7XG59XG5leHBvcnRzLmVuYWJsZVByb2RNb2RlID0gZW5hYmxlUHJvZE1vZGU7XG5mdW5jdGlvbiBhc3NlcnRpb25zRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gX2Rldk1vZGU7XG59XG5leHBvcnRzLmFzc2VydGlvbnNFbmFibGVkID0gYXNzZXJ0aW9uc0VuYWJsZWQ7XG4vLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbi8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbl9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgIC8vIFRPRE86IHRvIGJlIGZpeGVkIHByb3Blcmx5IHZpYSAjMjgzMCwgbm9vcCBmb3Igbm93XG59O1xuZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGw7XG59XG5leHBvcnRzLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbmZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNCbGFuayA9IGlzQmxhbms7XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiYm9vbGVhblwiO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIjtcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmZ1bmN0aW9uIGlzVHlwZShvYmopIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvYmopO1xufVxuZXhwb3J0cy5pc1R5cGUgPSBpc1R5cGU7XG5mdW5jdGlvbiBpc1N0cmluZ01hcChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1N0cmluZ01hcCA9IGlzU3RyaW5nTWFwO1xudmFyIFNUUklOR19NQVBfUFJPVE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuZnVuY3Rpb24gaXNTdHJpY3RTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nTWFwKG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IFNUUklOR19NQVBfUFJPVE87XG59XG5leHBvcnRzLmlzU3RyaWN0U3RyaW5nTWFwID0gaXNTdHJpY3RTdHJpbmdNYXA7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIF9nbG9iYWwuUHJvbWlzZTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgZXhwb3J0cy5EYXRlICYmICFpc05hTihvYmoudmFsdWVPZigpKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZXhwb3J0cy5ub29wID0gbm9vcDtcbmZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xuICAgIH1cbiAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgIH1cbiAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoXCJcXG5cIik7XG4gICAgcmV0dXJuIChuZXdMaW5lSW5kZXggPT09IC0xKSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuLy8gc2VyaWFsaXplIC8gZGVzZXJpYWxpemUgZW51bSBleGlzdCBvbmx5IGZvciBjb25zaXN0ZW5jeSB3aXRoIGRhcnQgQVBJXG4vLyBlbnVtcyBpbiB0eXBlc2NyaXB0IGRvbid0IG5lZWQgdG8gYmUgc2VyaWFsaXplZFxuZnVuY3Rpb24gc2VyaWFsaXplRW51bSh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0cy5zZXJpYWxpemVFbnVtID0gc2VyaWFsaXplRW51bTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRW51bSh2YWwsIHZhbHVlcykge1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplRW51bSA9IGRlc2VyaWFsaXplRW51bTtcbmZ1bmN0aW9uIHJlc29sdmVFbnVtVG9rZW4oZW51bVZhbHVlLCB2YWwpIHtcbiAgICByZXR1cm4gZW51bVZhbHVlW3ZhbF07XG59XG5leHBvcnRzLnJlc29sdmVFbnVtVG9rZW4gPSByZXNvbHZlRW51bVRva2VuO1xudmFyIFN0cmluZ1dyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ1dyYXBwZXIoKSB7XG4gICAgfVxuICAgIFN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7IH07XG4gICAgU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0ID0gZnVuY3Rpb24gKHMsIGluZGV4KSB7IHJldHVybiBzLmNoYXJDb2RlQXQoaW5kZXgpOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3BsaXQgPSBmdW5jdGlvbiAocywgcmVnRXhwKSB7IHJldHVybiBzLnNwbGl0KHJlZ0V4cCk7IH07XG4gICAgU3RyaW5nV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAocywgczIpIHsgcmV0dXJuIHMgPT09IHMyOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBMZWZ0ID0gZnVuY3Rpb24gKHMsIGNoYXJWYWwpIHtcbiAgICAgICAgaWYgKHMgJiYgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT0gY2hhclZhbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcocG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBSaWdodCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHMuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQgPSBmdW5jdGlvbiAocywgZnJvbSwgY2IpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9mZnNldCAmIHN0cmluZyBmcm9tIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKC0yLCAyKTtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayByZWNlaXZlcyBtYXRjaCwgcDEsIC4uLiwgcG5cbiAgICAgICAgICAgIHJldHVybiBjYihtYXRjaGVzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKHMsIHN1YnN0cikgeyByZXR1cm4gcy5pbmRleE9mKHN1YnN0cikgIT0gLTE7IH07XG4gICAgU3RyaW5nV3JhcHBlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nV3JhcHBlciA9IFN0cmluZ1dyYXBwZXI7XG52YXIgU3RyaW5nSm9pbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdKb2luZXIocGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHsgcGFydHMgPSBbXTsgfVxuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgfVxuICAgIFN0cmluZ0pvaW5lci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHBhcnQpIHsgdGhpcy5wYXJ0cy5wdXNoKHBhcnQpOyB9O1xuICAgIFN0cmluZ0pvaW5lci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnRzLmpvaW4oXCJcIik7IH07XG4gICAgcmV0dXJuIFN0cmluZ0pvaW5lcjtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ0pvaW5lciA9IFN0cmluZ0pvaW5lcjtcbnZhciBOdW1iZXJQYXJzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTnVtYmVyUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdW1iZXJQYXJzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIE51bWJlclBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9O1xuICAgIHJldHVybiBOdW1iZXJQYXJzZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5OdW1iZXJQYXJzZUVycm9yID0gTnVtYmVyUGFyc2VFcnJvcjtcbnZhciBOdW1iZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgIH1cbiAgICBOdW1iZXJXcmFwcGVyLnRvRml4ZWQgPSBmdW5jdGlvbiAobiwgZnJhY3Rpb25EaWdpdHMpIHsgcmV0dXJuIG4udG9GaXhlZChmcmFjdGlvbkRpZ2l0cyk7IH07XG4gICAgTnVtYmVyV3JhcHBlci5lcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09PSBiOyB9O1xuICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50ID0gZnVuY3Rpb24gKHRleHQsIHJhZGl4KSB7XG4gICAgICAgIGlmIChyYWRpeCA9PSAxMCkge1xuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTldKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhZGl4ID09IDE2KSB7XG4gICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOUFCQ0RFRmFiY2RlZl0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTnVtYmVyUGFyc2VFcnJvcihcIkludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyBcIiArIHRleHQgKyBcIiBpbiBiYXNlIFwiICtcbiAgICAgICAgICAgIHJhZGl4KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IE5hTiBpcyBhIHZhbGlkIGxpdGVyYWwgYnV0IGlzIHJldHVybmVkIGJ5IHBhcnNlRmxvYXQgdG8gaW5kaWNhdGUgYW4gZXJyb3IuXG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUZsb2F0ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGV4dCk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIFwiTmFOXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOYU47IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE51bWJlcldyYXBwZXIuaXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzTmFOKHZhbHVlKTsgfTtcbiAgICBOdW1iZXJXcmFwcGVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7IH07XG4gICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5OdW1iZXJXcmFwcGVyID0gTnVtYmVyV3JhcHBlcjtcbmV4cG9ydHMuUmVnRXhwID0gX2dsb2JhbC5SZWdFeHA7XG52YXIgUmVnRXhwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnRXhwV3JhcHBlcigpIHtcbiAgICB9XG4gICAgUmVnRXhwV3JhcHBlci5jcmVhdGUgPSBmdW5jdGlvbiAocmVnRXhwU3RyLCBmbGFncykge1xuICAgICAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9ICcnOyB9XG4gICAgICAgIGZsYWdzID0gZmxhZ3MucmVwbGFjZSgvZy9nLCAnJyk7XG4gICAgICAgIHJldHVybiBuZXcgX2dsb2JhbC5SZWdFeHAocmVnRXhwU3RyLCBmbGFncyArICdnJyk7XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLmZpcnN0TWF0Y2ggPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xuICAgICAgICAvLyBSZXNldCBtdWx0aW1hdGNoIHJlZ2V4IHN0YXRlXG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci50ZXN0ID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiByZWdFeHAudGVzdChpbnB1dCk7XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLm1hdGNoZXIgPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCkge1xuICAgICAgICAvLyBSZXNldCByZWdleCBzdGF0ZSBmb3IgdGhlIGNhc2VcbiAgICAgICAgLy8gc29tZW9uZSBkaWQgbm90IGxvb3Agb3ZlciBhbGwgbWF0Y2hlc1xuICAgICAgICAvLyBsYXN0IHRpbWUuXG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4geyByZTogcmVnRXhwLCBpbnB1dDogaW5wdXQgfTtcbiAgICB9O1xuICAgIFJlZ0V4cFdyYXBwZXIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0LCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBjID0gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgICAgICB2YXIgcmVzID0gJyc7XG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcHJldiA9IDA7XG4gICAgICAgIHdoaWxlIChjKSB7XG4gICAgICAgICAgICByZXMgKz0gaW5wdXQuc3Vic3RyaW5nKHByZXYsIGMuaW5kZXgpO1xuICAgICAgICAgICAgcmVzICs9IHJlcGxhY2UoYyk7XG4gICAgICAgICAgICBwcmV2ID0gYy5pbmRleCArIGNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IHByZXY7XG4gICAgICAgICAgICBjID0gcmVnRXhwLmV4ZWMoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBpbnB1dC5zdWJzdHJpbmcocHJldik7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnRXhwV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlJlZ0V4cFdyYXBwZXIgPSBSZWdFeHBXcmFwcGVyO1xudmFyIFJlZ0V4cE1hdGNoZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWdFeHBNYXRjaGVyV3JhcHBlcigpIHtcbiAgICB9XG4gICAgUmVnRXhwTWF0Y2hlcldyYXBwZXIubmV4dCA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLnJlLmV4ZWMobWF0Y2hlci5pbnB1dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnRXhwTWF0Y2hlcldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5SZWdFeHBNYXRjaGVyV3JhcHBlciA9IFJlZ0V4cE1hdGNoZXJXcmFwcGVyO1xudmFyIEZ1bmN0aW9uV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25XcmFwcGVyKCkge1xuICAgIH1cbiAgICBGdW5jdGlvbldyYXBwZXIuYXBwbHkgPSBmdW5jdGlvbiAoZm4sIHBvc0FyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KG51bGwsIHBvc0FyZ3MpOyB9O1xuICAgIHJldHVybiBGdW5jdGlvbldyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5GdW5jdGlvbldyYXBwZXIgPSBGdW5jdGlvbldyYXBwZXI7XG4vLyBKUyBoYXMgTmFOICE9PSBOYU5cbmZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbn1cbmV4cG9ydHMubG9vc2VJZGVudGljYWwgPSBsb29zZUlkZW50aWNhbDtcbi8vIEpTIGNvbnNpZGVycyBOYU4gaXMgdGhlIHNhbWUgYXMgTmFOIGZvciBtYXAgS2V5ICh3aGlsZSBOYU4gIT09IE5hTiBvdGhlcndpc2UpXG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwXG5mdW5jdGlvbiBnZXRNYXBLZXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLmdldE1hcEtleSA9IGdldE1hcEtleTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsYW5rKG9iaikge1xuICAgIHJldHVybiBpc0JsYW5rKG9iaikgPyBudWxsIDogb2JqO1xufVxuZXhwb3J0cy5ub3JtYWxpemVCbGFuayA9IG5vcm1hbGl6ZUJsYW5rO1xuZnVuY3Rpb24gbm9ybWFsaXplQm9vbChvYmopIHtcbiAgICByZXR1cm4gaXNCbGFuayhvYmopID8gZmFsc2UgOiBvYmo7XG59XG5leHBvcnRzLm5vcm1hbGl6ZUJvb2wgPSBub3JtYWxpemVCb29sO1xuZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG8gPT09IFwib2JqZWN0XCIpO1xufVxuZXhwb3J0cy5pc0pzT2JqZWN0ID0gaXNKc09iamVjdDtcbmZ1bmN0aW9uIHByaW50KG9iaikge1xuICAgIGNvbnNvbGUubG9nKG9iaik7XG59XG5leHBvcnRzLnByaW50ID0gcHJpbnQ7XG5mdW5jdGlvbiB3YXJuKG9iaikge1xuICAgIGNvbnNvbGUud2FybihvYmopO1xufVxuZXhwb3J0cy53YXJuID0gd2Fybjtcbi8vIENhbid0IGJlIGFsbCB1cHBlcmNhc2UgYXMgb3VyIHRyYW5zcGlsZXIgd291bGQgdGhpbmsgaXQgaXMgYSBzcGVjaWFsIGRpcmVjdGl2ZS4uLlxudmFyIEpzb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpzb24oKSB7XG4gICAgfVxuICAgIEpzb24ucGFyc2UgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gX2dsb2JhbC5KU09OLnBhcnNlKHMpOyB9O1xuICAgIEpzb24uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gRGFydCBkb2Vzbid0IHRha2UgMyBhcmd1bWVudHNcbiAgICAgICAgcmV0dXJuIF9nbG9iYWwuSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XG4gICAgfTtcbiAgICByZXR1cm4gSnNvbjtcbn0oKSk7XG5leHBvcnRzLkpzb24gPSBKc29uO1xudmFyIERhdGVXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlV3JhcHBlcigpIHtcbiAgICB9XG4gICAgRGF0ZVdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcykge1xuICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IDE7IH1cbiAgICAgICAgaWYgKGRheSA9PT0gdm9pZCAwKSB7IGRheSA9IDE7IH1cbiAgICAgICAgaWYgKGhvdXIgPT09IHZvaWQgMCkgeyBob3VyID0gMDsgfVxuICAgICAgICBpZiAobWludXRlcyA9PT0gdm9pZCAwKSB7IG1pbnV0ZXMgPSAwOyB9XG4gICAgICAgIGlmIChzZWNvbmRzID09PSB2b2lkIDApIHsgc2Vjb25kcyA9IDA7IH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdm9pZCAwKSB7IG1pbGxpc2Vjb25kcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XG4gICAgfTtcbiAgICBEYXRlV3JhcHBlci5mcm9tSVNPU3RyaW5nID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gbmV3IGV4cG9ydHMuRGF0ZShzdHIpOyB9O1xuICAgIERhdGVXcmFwcGVyLmZyb21NaWxsaXMgPSBmdW5jdGlvbiAobXMpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUobXMpOyB9O1xuICAgIERhdGVXcmFwcGVyLnRvTWlsbGlzID0gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpOyB9O1xuICAgIERhdGVXcmFwcGVyLm5vdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoKTsgfTtcbiAgICBEYXRlV3JhcHBlci50b0pzb24gPSBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS50b0pTT04oKTsgfTtcbiAgICByZXR1cm4gRGF0ZVdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5EYXRlV3JhcHBlciA9IERhdGVXcmFwcGVyO1xuZnVuY3Rpb24gc2V0VmFsdWVPblBhdGgoZ2xvYmFsLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICB2YXIgb2JqID0gZ2xvYmFsO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1ByZXNlbnQob2JqW25hbWVdKSkge1xuICAgICAgICAgICAgb2JqID0gb2JqW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb2JqW25hbWVdID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBvYmogPSB7fTtcbiAgICB9XG4gICAgb2JqW3BhcnRzLnNoaWZ0KCldID0gdmFsdWU7XG59XG5leHBvcnRzLnNldFZhbHVlT25QYXRoID0gc2V0VmFsdWVPblBhdGg7XG52YXIgX3N5bWJvbEl0ZXJhdG9yID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICAgIGlmIChpc0JsYW5rKF9zeW1ib2xJdGVyYXRvcikpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChnbG9iYWxTY29wZS5TeW1ib2wpICYmIGlzUHJlc2VudChTeW1ib2wuaXRlcmF0b3IpKSB7XG4gICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJlxuICAgICAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW2tleV0gPT09IE1hcC5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfc3ltYm9sSXRlcmF0b3I7XG59XG5leHBvcnRzLmdldFN5bWJvbEl0ZXJhdG9yID0gZ2V0U3ltYm9sSXRlcmF0b3I7XG5mdW5jdGlvbiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwsIGV4cHIsIGRlY2xhcmF0aW9ucywgdmFycykge1xuICAgIHZhciBmbkJvZHkgPSBkZWNsYXJhdGlvbnMgKyBcIlxcbnJldHVybiBcIiArIGV4cHIgKyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBzb3VyY2VVcmw7XG4gICAgdmFyIGZuQXJnTmFtZXMgPSBbXTtcbiAgICB2YXIgZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgZm5BcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICBmbkFyZ1ZhbHVlcy5wdXNoKHZhcnNbYXJnTmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5iaW5kLmFwcGx5KEZ1bmN0aW9uLCBbdm9pZCAwXS5jb25jYXQoZm5BcmdOYW1lcy5jb25jYXQoZm5Cb2R5KSkpKSgpLmFwcGx5KHZvaWQgMCwgZm5BcmdWYWx1ZXMpO1xufVxuZXhwb3J0cy5ldmFsRXhwcmVzc2lvbiA9IGV2YWxFeHByZXNzaW9uO1xuZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgcmV0dXJuICFpc0pzT2JqZWN0KG9iaik7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5mdW5jdGlvbiBoYXNDb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSkge1xuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gdHlwZTtcbn1cbmV4cG9ydHMuaGFzQ29uc3RydWN0b3IgPSBoYXNDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIGJpdFdpc2VPcih2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSB8IGI7IH0pO1xufVxuZXhwb3J0cy5iaXRXaXNlT3IgPSBiaXRXaXNlT3I7XG5mdW5jdGlvbiBiaXRXaXNlQW5kKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XG59XG5leHBvcnRzLmJpdFdpc2VBbmQgPSBiaXRXaXNlQW5kO1xuZnVuY3Rpb24gZXNjYXBlKHMpIHtcbiAgICByZXR1cm4gX2dsb2JhbC5lbmNvZGVVUkkocyk7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb21waWxlcl8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29tcGlsZXInKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBwcm9taXNlXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL3Byb21pc2UnKTtcbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgWEhSIHRoYXQgdXNlcyBhIHRlbXBsYXRlIGNhY2hlIHRvIGF2b2lkIGRvaW5nIGFuIGFjdHVhbFxuICogWEhSLlxuICpcbiAqIFRoZSB0ZW1wbGF0ZSBjYWNoZSBuZWVkcyB0byBiZSBidWlsdCBhbmQgbG9hZGVkIGludG8gd2luZG93LiR0ZW1wbGF0ZUNhY2hlXG4gKiB2aWEgYSBzZXBhcmF0ZSBtZWNoYW5pc20uXG4gKi9cbnZhciBDYWNoZWRYSFIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWNoZWRYSFIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FjaGVkWEhSKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBsYW5nXzEuZ2xvYmFsLiR0ZW1wbGF0ZUNhY2hlO1xuICAgICAgICBpZiAodGhpcy5fY2FjaGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5CYXNlRXhjZXB0aW9uKCdDYWNoZWRYSFI6IFRlbXBsYXRlIGNhY2hlIHdhcyBub3QgZm91bmQgaW4gJHRlbXBsYXRlQ2FjaGUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FjaGVkWEhSLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXNPd25Qcm9wZXJ0eSh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZV8xLlByb21pc2VXcmFwcGVyLnJlc29sdmUodGhpcy5fY2FjaGVbdXJsXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZV8xLlByb21pc2VXcmFwcGVyLnJlamVjdCgnQ2FjaGVkWEhSOiBEaWQgbm90IGZpbmQgY2FjaGVkIHRlbXBsYXRlIGZvciAnICsgdXJsLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhY2hlZFhIUjtcbn0oY29tcGlsZXJfMS5YSFIpKTtcbmV4cG9ydHMuQ2FjaGVkWEhSID0gQ2FjaGVkWEhSO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyX2NhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29tcGlsZXJfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbXBpbGVyJyk7XG52YXIgcHJvbWlzZV8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9wcm9taXNlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgWEhSSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhIUkltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWEhSSW1wbCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFhIUkltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlciA9IHByb21pc2VfMS5Qcm9taXNlV3JhcHBlci5jb21wbGV0ZXIoKTtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlVGV4dCBpcyB0aGUgb2xkLXNjaG9vbCB3YXkgb2YgcmV0cmlldmluZyByZXNwb25zZSAoc3VwcG9ydGVkIGJ5IElFOCAmIDkpXG4gICAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gWEhSIExldmVsMiBzcGVjIChzdXBwb3J0ZWQgYnkgSUUxMClcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGxhbmdfMS5pc1ByZXNlbnQoeGhyLnJlc3BvbnNlKSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAvLyBub3JtYWxpemUgSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MClcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cztcbiAgICAgICAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSB3aGVuIGl0IGlzIDAgKDAgc3RhdHVzIGlzIHVuZG9jdW1lbnRlZCkuXG4gICAgICAgICAgICAvLyBPY2N1cnMgd2hlbiBhY2Nlc3NpbmcgZmlsZSByZXNvdXJjZXMgb3Igb24gQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxuICAgICAgICAgICAgLy8gd2hpbGUgcmV0cmlldmluZyBmaWxlcyBmcm9tIGFwcGxpY2F0aW9uIGNhY2hlLlxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHJlc3BvbnNlID8gMjAwIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8PSAzMDApIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXIucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXIucmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgY29tcGxldGVyLnJlamVjdChcIkZhaWxlZCB0byBsb2FkIFwiICsgdXJsLCBudWxsKTsgfTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlci5wcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIFhIUkltcGw7XG59KGNvbXBpbGVyXzEuWEhSKSk7XG5leHBvcnRzLlhIUkltcGwgPSBYSFJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyX2ltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xuZXhwb3J0cy5SZW5kZXJEZWJ1Z0luZm8gPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy5SZW5kZXJEZWJ1Z0luZm87XG5leHBvcnRzLnd0ZkluaXQgPSBjb3JlXzEuX19jb3JlX3ByaXZhdGVfXy53dGZJbml0O1xuZXhwb3J0cy5SZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uUmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbmV4cG9ydHMuVklFV19FTkNBUFNVTEFUSU9OX1ZBTFVFUyA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlZJRVdfRU5DQVBTVUxBVElPTl9WQUxVRVM7XG5leHBvcnRzLkRlYnVnRG9tUm9vdFJlbmRlcmVyID0gY29yZV8xLl9fY29yZV9wcml2YXRlX18uRGVidWdEb21Sb290UmVuZGVyZXI7XG5leHBvcnRzLlNlY3VyaXR5Q29udGV4dCA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlNlY3VyaXR5Q29udGV4dDtcbmV4cG9ydHMuU2FuaXRpemF0aW9uU2VydmljZSA9IGNvcmVfMS5fX2NvcmVfcHJpdmF0ZV9fLlNhbml0aXphdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlX3ByaXZhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuX19leHBvcnQocmVxdWlyZSgnLi9zcmMvcGxhdGZvcm1fYnJvd3NlcicpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGFuaW1hdGlvbl9idWlsZGVyID0gcmVxdWlyZSgnLi9zcmMvYW5pbWF0ZS9hbmltYXRpb25fYnVpbGRlcicpO1xudmFyIGNzc19hbmltYXRpb25fYnVpbGRlciA9IHJlcXVpcmUoJy4vc3JjL2FuaW1hdGUvY3NzX2FuaW1hdGlvbl9idWlsZGVyJyk7XG52YXIgYnJvd3Nlcl9kZXRhaWxzID0gcmVxdWlyZSgnLi9zcmMvYW5pbWF0ZS9icm93c2VyX2RldGFpbHMnKTtcbnZhciBjc3NfYW5pbWF0aW9uX29wdGlvbnMgPSByZXF1aXJlKCcuL3NyYy9hbmltYXRlL2Nzc19hbmltYXRpb25fb3B0aW9ucycpO1xudmFyIGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vc3JjL2FuaW1hdGUvYW5pbWF0aW9uJyk7XG52YXIgZG9tX2FkYXB0ZXIgPSByZXF1aXJlKCcuL3NyYy9kb20vZG9tX2FkYXB0ZXInKTtcbnZhciBicm93c2VyX2FkYXB0ZXIgPSByZXF1aXJlKCcuL3NyYy9icm93c2VyL2Jyb3dzZXJfYWRhcHRlcicpO1xudmFyIF9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX187XG4oZnVuY3Rpb24gKF9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18pIHtcbiAgICBfX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fLkRvbUFkYXB0ZXIgPSBkb21fYWRhcHRlci5Eb21BZGFwdGVyO1xuICAgIGZ1bmN0aW9uIGdldERPTSgpIHsgcmV0dXJuIGRvbV9hZGFwdGVyLmdldERPTSgpOyB9XG4gICAgX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXy5nZXRET00gPSBnZXRET007XG4gICAgZnVuY3Rpb24gc2V0RE9NKGFkYXB0ZXIpIHsgcmV0dXJuIGRvbV9hZGFwdGVyLnNldERPTShhZGFwdGVyKTsgfVxuICAgIF9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18uc2V0RE9NID0gc2V0RE9NO1xuICAgIF9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18uc2V0Um9vdERvbUFkYXB0ZXIgPSBkb21fYWRhcHRlci5zZXRSb290RG9tQWRhcHRlcjtcbiAgICBfX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fLkJyb3dzZXJEb21BZGFwdGVyID0gYnJvd3Nlcl9hZGFwdGVyLkJyb3dzZXJEb21BZGFwdGVyO1xuICAgIF9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18uQW5pbWF0aW9uQnVpbGRlciA9IGFuaW1hdGlvbl9idWlsZGVyLkFuaW1hdGlvbkJ1aWxkZXI7XG4gICAgX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXy5Dc3NBbmltYXRpb25CdWlsZGVyID0gY3NzX2FuaW1hdGlvbl9idWlsZGVyLkNzc0FuaW1hdGlvbkJ1aWxkZXI7XG4gICAgX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXy5Dc3NBbmltYXRpb25PcHRpb25zID0gY3NzX2FuaW1hdGlvbl9vcHRpb25zLkNzc0FuaW1hdGlvbk9wdGlvbnM7XG4gICAgX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXy5BbmltYXRpb24gPSBhbmltYXRpb24uQW5pbWF0aW9uO1xuICAgIF9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18uQnJvd3NlckRldGFpbHMgPSBicm93c2VyX2RldGFpbHMuQnJvd3NlckRldGFpbHM7XG59KShfX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fID0gZXhwb3J0cy5fX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fIHx8IChleHBvcnRzLl9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJpdmF0ZV9leHBvcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgbWF0aF8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9tYXRoJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgdXRpbF8xID0gcmVxdWlyZSgnLi4vZG9tL3V0aWwnKTtcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi4vZG9tL2RvbV9hZGFwdGVyJyk7XG52YXIgQW5pbWF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHN0YXJ0IHRpbWUgYW5kIHN0YXJ0cyB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBicm93c2VyRGV0YWlsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihlbGVtZW50LCBkYXRhLCBicm93c2VyRGV0YWlscykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmJyb3dzZXJEZXRhaWxzID0gYnJvd3NlckRldGFpbHM7XG4gICAgICAgIC8qKiBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkIHVwb24gY29tcGxldGlvbiAqL1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAvKiogZnVuY3Rpb25zIGZvciByZW1vdmluZyBldmVudCBsaXN0ZW5lcnMgKi9cbiAgICAgICAgdGhpcy5ldmVudENsZWFyRnVuY3Rpb25zID0gW107XG4gICAgICAgIC8qKiBmbGFnIHVzZWQgdG8gdHJhY2sgd2hldGhlciBvciBub3QgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQgKi9cbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RyaW5nUHJlZml4ID0gJyc7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbGFuZ18xLkRhdGVXcmFwcGVyLnRvTWlsbGlzKGxhbmdfMS5EYXRlV3JhcHBlci5ub3coKSk7XG4gICAgICAgIHRoaXMuX3N0cmluZ1ByZWZpeCA9IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0QW5pbWF0aW9uUHJlZml4KCk7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICAgICAgdGhpcy53YWl0KGZ1bmN0aW9uICh0aW1lc3RhbXApIHsgcmV0dXJuIF90aGlzLnN0YXJ0KCk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uLnByb3RvdHlwZSwgXCJ0b3RhbFRpbWVcIiwge1xuICAgICAgICAvKiogdG90YWwgYW1vdW50IG9mIHRpbWUgdGhhdCB0aGUgYW5pbWF0aW9uIHNob3VsZCB0YWtlIGluY2x1ZGluZyBkZWxheSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMuY29tcHV0ZWREZWxheSAhPSBudWxsID8gdGhpcy5jb21wdXRlZERlbGF5IDogMDtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuY29tcHV0ZWREdXJhdGlvbiAhPSBudWxsID8gdGhpcy5jb21wdXRlZER1cmF0aW9uIDogMDtcbiAgICAgICAgICAgIHJldHVybiBkZWxheSArIGR1cmF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBbmltYXRpb24ucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgLy8gRmlyZWZveCByZXF1aXJlcyAyIGZyYW1lcyBmb3Igc29tZSByZWFzb25cbiAgICAgICAgdGhpcy5icm93c2VyRGV0YWlscy5yYWYoY2FsbGJhY2ssIDIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgaW5pdGlhbCBzdHlsZXMgYmVmb3JlIHRoZSBhbmltYXRpb24gaXMgc3RhcnRlZFxuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZnJvbVN0eWxlcyAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5hcHBseVN0eWxlcyh0aGlzLmRhdGEuZnJvbVN0eWxlcyk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZHVyYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTdHlsZXMoeyAndHJhbnNpdGlvbkR1cmF0aW9uJzogdGhpcy5kYXRhLmR1cmF0aW9uLnRvU3RyaW5nKCkgKyAnbXMnIH0pO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRlbGF5ICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKHsgJ3RyYW5zaXRpb25EZWxheSc6IHRoaXMuZGF0YS5kZWxheS50b1N0cmluZygpICsgJ21zJyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBpbml0aWFsIHNldHVwIGhhcyBvY2N1cnJlZCwgdGhpcyBtZXRob2QgYWRkcyB0aGUgYW5pbWF0aW9uIHN0eWxlc1xuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3Nlcyh0aGlzLmRhdGEuY2xhc3Nlc1RvQWRkKTtcbiAgICAgICAgdGhpcy5hZGRDbGFzc2VzKHRoaXMuZGF0YS5hbmltYXRpb25DbGFzc2VzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzc2VzKHRoaXMuZGF0YS5jbGFzc2VzVG9SZW1vdmUpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLnRvU3R5bGVzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKHRoaXMuZGF0YS50b1N0eWxlcyk7XG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlcyA9IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmNvbXB1dGVkRGVsYXkgPVxuICAgICAgICAgICAgbWF0aF8xLk1hdGgubWF4KHRoaXMucGFyc2VEdXJhdGlvblN0cmluZyhjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMuX3N0cmluZ1ByZWZpeCArICd0cmFuc2l0aW9uLWRlbGF5JykpLCB0aGlzLnBhcnNlRHVyYXRpb25TdHJpbmcodGhpcy5lbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUodGhpcy5fc3RyaW5nUHJlZml4ICsgJ3RyYW5zaXRpb24tZGVsYXknKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVkRHVyYXRpb24gPSBtYXRoXzEuTWF0aC5tYXgodGhpcy5wYXJzZUR1cmF0aW9uU3RyaW5nKGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUodGhpcy5fc3RyaW5nUHJlZml4ICsgJ3RyYW5zaXRpb24tZHVyYXRpb24nKSksIHRoaXMucGFyc2VEdXJhdGlvblN0cmluZyh0aGlzLmVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh0aGlzLl9zdHJpbmdQcmVmaXggKyAndHJhbnNpdGlvbi1kdXJhdGlvbicpKSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBzdHlsZXMgdG8gdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gc3R5bGVzXG4gICAgICovXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hcHBseVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaChzdHlsZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgZGFzaENhc2VLZXkgPSB1dGlsXzEuY2FtZWxDYXNlVG9EYXNoQ2FzZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5nZXRTdHlsZShfdGhpcy5lbGVtZW50LCBkYXNoQ2FzZUtleSkpKSB7XG4gICAgICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5zZXRTdHlsZShfdGhpcy5lbGVtZW50LCBkYXNoQ2FzZUtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnNldFN0eWxlKF90aGlzLmVsZW1lbnQsIF90aGlzLl9zdHJpbmdQcmVmaXggKyBkYXNoQ2FzZUtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgcHJvdmlkZWQgY2xhc3NlcyB0byB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSBjbGFzc2VzXG4gICAgICovXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5hZGRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgY2xhc3Nlc1tpXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCBjbGFzc2VzIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gY2xhc3Nlc1xuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIGNsYXNzZXNbaV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudHMgdG8gdHJhY2sgd2hlbiBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmFkZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudG90YWxUaW1lID4gMCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudENsZWFyRnVuY3Rpb25zLnB1c2goZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5vbkFuZENhbmNlbCh0aGlzLmVsZW1lbnQsIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0VHJhbnNpdGlvbkVuZCgpLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUFuaW1hdGlvbkV2ZW50KGV2ZW50KTsgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBbmltYXRpb25Db21wbGV0ZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5oYW5kbGVBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBtYXRoXzEuTWF0aC5yb3VuZChldmVudC5lbGFwc2VkVGltZSAqIDEwMDApO1xuICAgICAgICBpZiAoIXRoaXMuYnJvd3NlckRldGFpbHMuZWxhcHNlZFRpbWVJbmNsdWRlc0RlbGF5KVxuICAgICAgICAgICAgZWxhcHNlZFRpbWUgKz0gdGhpcy5jb21wdXRlZERlbGF5O1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGVsYXBzZWRUaW1lID49IHRoaXMudG90YWxUaW1lKVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVBbmltYXRpb25Db21wbGV0ZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1bnMgYWxsIGFuaW1hdGlvbiBjYWxsYmFja3MgYW5kIHJlbW92ZXMgdGVtcG9yYXJ5IGNsYXNzZXNcbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmhhbmRsZUFuaW1hdGlvbkNvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzc2VzKHRoaXMuZGF0YS5hbmltYXRpb25DbGFzc2VzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH0pO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50Q2xlYXJGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICB0aGlzLmV2ZW50Q2xlYXJGdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhbmltYXRpb24gY2FsbGJhY2tzIHRvIGJlIGNhbGxlZCB1cG9uIGNvbXBsZXRpb25cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9ufVxuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUub25Db21wbGV0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBkdXJhdGlvbiBzdHJpbmcgdG8gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcGFyYW0gZHVyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUucGFyc2VEdXJhdGlvblN0cmluZyA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbWF4VmFsdWUgPSAwO1xuICAgICAgICAvLyBkdXJhdGlvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIHRvIGJlIHZhbGlkLiAobnVtYmVyICsgdHlwZSlcbiAgICAgICAgaWYgKGR1cmF0aW9uID09IG51bGwgfHwgZHVyYXRpb24ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR1cmF0aW9uLnN1YnN0cmluZyhkdXJhdGlvbi5sZW5ndGggLSAyKSA9PSAnbXMnKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsYW5nXzEuTnVtYmVyV3JhcHBlci5wYXJzZUludCh0aGlzLnN0cmlwTGV0dGVycyhkdXJhdGlvbiksIDEwKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKVxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHVyYXRpb24uc3Vic3RyaW5nKGR1cmF0aW9uLmxlbmd0aCAtIDEpID09ICdzJykge1xuICAgICAgICAgICAgdmFyIG1zID0gbGFuZ18xLk51bWJlcldyYXBwZXIucGFyc2VGbG9hdCh0aGlzLnN0cmlwTGV0dGVycyhkdXJhdGlvbikpICogMTAwMDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGhfMS5NYXRoLmZsb29yKG1zKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKVxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RyaXBzIHRoZSBsZXR0ZXJzIGZyb20gdGhlIGR1cmF0aW9uIHN0cmluZ1xuICAgICAqIEBwYXJhbSBzdHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuc3RyaXBMZXR0ZXJzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChzdHIsIGxhbmdfMS5SZWdFeHBXcmFwcGVyLmNyZWF0ZSgnW14wLTldKyQnLCAnJyksICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb247XG59KCkpO1xuZXhwb3J0cy5BbmltYXRpb24gPSBBbmltYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNzc19hbmltYXRpb25fYnVpbGRlcl8xID0gcmVxdWlyZSgnLi9jc3NfYW5pbWF0aW9uX2J1aWxkZXInKTtcbnZhciBicm93c2VyX2RldGFpbHNfMSA9IHJlcXVpcmUoJy4vYnJvd3Nlcl9kZXRhaWxzJyk7XG52YXIgQW5pbWF0aW9uQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgRElcbiAgICAgKiBAcGFyYW0gYnJvd3NlckRldGFpbHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBbmltYXRpb25CdWlsZGVyKGJyb3dzZXJEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYnJvd3NlckRldGFpbHMgPSBicm93c2VyRGV0YWlscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDU1MgQW5pbWF0aW9uXG4gICAgICogQHJldHVybnMge0Nzc0FuaW1hdGlvbkJ1aWxkZXJ9XG4gICAgICovXG4gICAgQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IGNzc19hbmltYXRpb25fYnVpbGRlcl8xLkNzc0FuaW1hdGlvbkJ1aWxkZXIodGhpcy5icm93c2VyRGV0YWlscyk7IH07XG4gICAgQW5pbWF0aW9uQnVpbGRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBBbmltYXRpb25CdWlsZGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IGJyb3dzZXJfZGV0YWlsc18xLkJyb3dzZXJEZXRhaWxzLCB9LFxuICAgIF07XG4gICAgcmV0dXJuIEFuaW1hdGlvbkJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5BbmltYXRpb25CdWlsZGVyID0gQW5pbWF0aW9uQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFuaW1hdGlvbl9idWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL21hdGgnKTtcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi4vZG9tL2RvbV9hZGFwdGVyJyk7XG52YXIgQnJvd3NlckRldGFpbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJEZXRhaWxzKCkge1xuICAgICAgICB0aGlzLmVsYXBzZWRUaW1lSW5jbHVkZXNEZWxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvZXNFbGFwc2VkVGltZUluY2x1ZGVzRGVsYXkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBgZXZlbnQuZWxhcHNlZFRpbWVgIGluY2x1ZGVzIHRyYW5zaXRpb24gZGVsYXkgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci4gIEF0IHRoaXNcbiAgICAgKiB0aW1lLCBDaHJvbWUgYW5kIE9wZXJhIHNlZW0gdG8gYmUgdGhlIG9ubHkgYnJvd3NlcnMgdGhhdCBpbmNsdWRlIHRoaXMuXG4gICAgICovXG4gICAgQnJvd3NlckRldGFpbHMucHJvdG90eXBlLmRvZXNFbGFwc2VkVGltZUluY2x1ZGVzRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkaXYgPSBkb21fYWRhcHRlcl8xLmdldERPTSgpLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnNldEF0dHJpYnV0ZShkaXYsICdzdHlsZScsIFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IC05OTk5cHg7IGxlZnQ6IC05OTk5cHg7IHdpZHRoOiAxcHg7XFxuICAgICAgaGVpZ2h0OiAxcHg7IHRyYW5zaXRpb246IGFsbCAxbXMgbGluZWFyIDFtcztcIik7XG4gICAgICAgIC8vIEZpcmVmb3ggcmVxdWlyZXMgdGhhdCB3ZSB3YWl0IGZvciAyIGZyYW1lcyBmb3Igc29tZSByZWFzb25cbiAgICAgICAgdGhpcy5yYWYoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5vbihkaXYsICd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsYXBzZWQgPSBtYXRoXzEuTWF0aC5yb3VuZChldmVudC5lbGFwc2VkVGltZSAqIDEwMDApO1xuICAgICAgICAgICAgICAgIF90aGlzLmVsYXBzZWRUaW1lSW5jbHVkZXNEZWxheSA9IGVsYXBzZWQgPT0gMjtcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnJlbW92ZShkaXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnNldFN0eWxlKGRpdiwgJ3dpZHRoJywgJzJweCcpO1xuICAgICAgICB9LCAyKTtcbiAgICB9O1xuICAgIEJyb3dzZXJEZXRhaWxzLnByb3RvdHlwZS5yYWYgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGZyYW1lcykge1xuICAgICAgICBpZiAoZnJhbWVzID09PSB2b2lkIDApIHsgZnJhbWVzID0gMTsgfVxuICAgICAgICB2YXIgcXVldWUgPSBuZXcgUmFmUXVldWUoY2FsbGJhY2ssIGZyYW1lcyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBxdWV1ZS5jYW5jZWwoKTsgfTtcbiAgICB9O1xuICAgIEJyb3dzZXJEZXRhaWxzLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIEJyb3dzZXJEZXRhaWxzLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgcmV0dXJuIEJyb3dzZXJEZXRhaWxzO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlckRldGFpbHMgPSBCcm93c2VyRGV0YWlscztcbnZhciBSYWZRdWV1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFmUXVldWUoY2FsbGJhY2ssIGZyYW1lcykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuZnJhbWVzID0gZnJhbWVzO1xuICAgICAgICB0aGlzLl9yYWYoKTtcbiAgICB9XG4gICAgUmFmUXVldWUucHJvdG90eXBlLl9yYWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lSWQgPVxuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKHRpbWVzdGFtcCkgeyByZXR1cm4gX3RoaXMuX25leHRGcmFtZSh0aW1lc3RhbXApOyB9KTtcbiAgICB9O1xuICAgIFJhZlF1ZXVlLnByb3RvdHlwZS5fbmV4dEZyYW1lID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICB0aGlzLmZyYW1lcy0tO1xuICAgICAgICBpZiAodGhpcy5mcmFtZXMgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yYWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFmUXVldWUucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmN1cnJlbnRGcmFtZUlkKTtcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVJZCA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUmFmUXVldWU7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl9kZXRhaWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNzc19hbmltYXRpb25fb3B0aW9uc18xID0gcmVxdWlyZSgnLi9jc3NfYW5pbWF0aW9uX29wdGlvbnMnKTtcbnZhciBhbmltYXRpb25fMSA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uJyk7XG52YXIgQ3NzQW5pbWF0aW9uQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBwdWJsaWMgcHJvcGVydGllcyBmb3IgQ3NzQW5pbWF0aW9uQnVpbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENzc0FuaW1hdGlvbkJ1aWxkZXIoYnJvd3NlckRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5icm93c2VyRGV0YWlscyA9IGJyb3dzZXJEZXRhaWxzO1xuICAgICAgICAvKiogQHR5cGUge0Nzc0FuaW1hdGlvbk9wdGlvbnN9ICovXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBjc3NfYW5pbWF0aW9uX29wdGlvbnNfMS5Dc3NBbmltYXRpb25PcHRpb25zKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZW1wb3JhcnkgY2xhc3MgdGhhdCB3aWxsIGJlIHJlbW92ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLmFkZEFuaW1hdGlvbkNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmRhdGEuYW5pbWF0aW9uQ2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNsYXNzIHRoYXQgd2lsbCByZW1haW4gb24gdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWRcbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICovXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuZGF0YS5jbGFzc2VzVG9BZGQucHVzaChjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmRhdGEuY2xhc3Nlc1RvUmVtb3ZlLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbmltYXRpb24gZHVyYXRpb24gKGFuZCBvdmVycmlkZXMgYW55IGRlZmluZWQgdGhyb3VnaCBDU1MpXG4gICAgICogQHBhcmFtIGR1cmF0aW9uXG4gICAgICovXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuc2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5kYXRhLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYW5pbWF0aW9uIGRlbGF5IChhbmQgb3ZlcnJpZGVzIGFueSBkZWZpbmVkIHRocm91Z2ggQ1NTKVxuICAgICAqIEBwYXJhbSBkZWxheVxuICAgICAqL1xuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldERlbGF5ID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHRoaXMuZGF0YS5kZWxheSA9IGRlbGF5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgc3R5bGVzIGZvciBib3RoIHRoZSBpbml0aWFsIHN0YXRlIGFuZCB0aGUgZGVzdGluYXRpb24gc3RhdGVcbiAgICAgKiBAcGFyYW0gZnJvbVxuICAgICAqIEBwYXJhbSB0b1xuICAgICAqL1xuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRGcm9tU3R5bGVzKGZyb20pLnNldFRvU3R5bGVzKHRvKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluaXRpYWwgc3R5bGVzIGZvciB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGZyb21cbiAgICAgKi9cbiAgICBDc3NBbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5zZXRGcm9tU3R5bGVzID0gZnVuY3Rpb24gKGZyb20pIHtcbiAgICAgICAgdGhpcy5kYXRhLmZyb21TdHlsZXMgPSBmcm9tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlc3RpbmF0aW9uIHN0eWxlcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB0b1xuICAgICAqL1xuICAgIENzc0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnNldFRvU3R5bGVzID0gZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIHRoaXMuZGF0YS50b1N0eWxlcyA9IHRvO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgYW5pbWF0aW9uIGFuZCByZXR1cm5zIGEgcHJvbWlzZVxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICovXG4gICAgQ3NzQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IGFuaW1hdGlvbl8xLkFuaW1hdGlvbihlbGVtZW50LCB0aGlzLmRhdGEsIHRoaXMuYnJvd3NlckRldGFpbHMpO1xuICAgIH07XG4gICAgcmV0dXJuIENzc0FuaW1hdGlvbkJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5Dc3NBbmltYXRpb25CdWlsZGVyID0gQ3NzQW5pbWF0aW9uQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzc19hbmltYXRpb25fYnVpbGRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDc3NBbmltYXRpb25PcHRpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NBbmltYXRpb25PcHRpb25zKCkge1xuICAgICAgICAvKiogY2xhc3NlcyB0byBiZSBhZGRlZCB0byB0aGUgZWxlbWVudCAqL1xuICAgICAgICB0aGlzLmNsYXNzZXNUb0FkZCA9IFtdO1xuICAgICAgICAvKiogY2xhc3NlcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQgKi9cbiAgICAgICAgdGhpcy5jbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgLyoqIGNsYXNzZXMgdG8gYmUgYWRkZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ2xhc3NlcyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gQ3NzQW5pbWF0aW9uT3B0aW9ucztcbn0oKSk7XG5leHBvcnRzLkNzc0FuaW1hdGlvbk9wdGlvbnMgPSBDc3NBbmltYXRpb25PcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzX2FuaW1hdGlvbl9vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZ2VuZXJpY19icm93c2VyX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4vZ2VuZXJpY19icm93c2VyX2FkYXB0ZXInKTtcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi4vZG9tL2RvbV9hZGFwdGVyJyk7XG52YXIgX2F0dHJUb1Byb3BNYXAgPSB7XG4gICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4J1xufTtcbnZhciBET01fS0VZX0xPQ0FUSU9OX05VTVBBRCA9IDM7XG4vLyBNYXAgdG8gY29udmVydCBzb21lIGtleSBvciBrZXlJZGVudGlmaWVyIHZhbHVlcyB0byB3aGF0IHdpbGwgYmUgcmV0dXJuZWQgYnkgZ2V0RXZlbnRLZXlcbnZhciBfa2V5TWFwID0ge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgdmFsdWVzIGFyZSBoZXJlIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkgYW5kIHRvIG1hdGNoIHRoZSBXM0Mgc3RhbmRhcmRcbiAgICAvLyBjZiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMta2V5L1xuICAgICdcXGInOiAnQmFja3NwYWNlJyxcbiAgICAnXFx0JzogJ1RhYicsXG4gICAgJ1xceDdGJzogJ0RlbGV0ZScsXG4gICAgJ1xceDFCJzogJ0VzY2FwZScsXG4gICAgJ0RlbCc6ICdEZWxldGUnLFxuICAgICdFc2MnOiAnRXNjYXBlJyxcbiAgICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAgICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcbiAgICAnVXAnOiAnQXJyb3dVcCcsXG4gICAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgICAnV2luJzogJ09TJ1xufTtcbi8vIFRoZXJlIGlzIGEgYnVnIGluIENocm9tZSBmb3IgbnVtZXJpYyBrZXlwYWQga2V5czpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTU2NTRcbi8vIDEsIDIsIDMgLi4uIGFyZSByZXBvcnRlZCBhcyBBLCBCLCBDIC4uLlxudmFyIF9jaHJvbWVOdW1LZXlQYWRNYXAgPSB7XG4gICAgJ0EnOiAnMScsXG4gICAgJ0InOiAnMicsXG4gICAgJ0MnOiAnMycsXG4gICAgJ0QnOiAnNCcsXG4gICAgJ0UnOiAnNScsXG4gICAgJ0YnOiAnNicsXG4gICAgJ0cnOiAnNycsXG4gICAgJ0gnOiAnOCcsXG4gICAgJ0knOiAnOScsXG4gICAgJ0onOiAnKicsXG4gICAgJ0snOiAnKycsXG4gICAgJ00nOiAnLScsXG4gICAgJ04nOiAnLicsXG4gICAgJ08nOiAnLycsXG4gICAgJ1xceDYwJzogJzAnLFxuICAgICdcXHg5MCc6ICdOdW1Mb2NrJ1xufTtcbi8qKlxuICogQSBgRG9tQWRhcHRlcmAgcG93ZXJlZCBieSBmdWxsIGJyb3dzZXIgRE9NIEFQSXMuXG4gKi9cbi8qIHRzbGludDpkaXNhYmxlOnJlcXVpcmVQYXJhbWV0ZXJUeXBlICovXG52YXIgQnJvd3NlckRvbUFkYXB0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCcm93c2VyRG9tQWRhcHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCcm93c2VyRG9tQWRhcHRlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUh0bWwpIHsgdGhyb3cgbmV3IEVycm9yKFwicGFyc2Ugbm90IGltcGxlbWVudGVkXCIpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLm1ha2VDdXJyZW50ID0gZnVuY3Rpb24gKCkgeyBkb21fYWRhcHRlcl8xLnNldFJvb3REb21BZGFwdGVyKG5ldyBCcm93c2VyRG9tQWRhcHRlcigpKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgeyByZXR1cm4gbmFtZSBpbiBlbGVtZW50OyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHsgZWxbbmFtZV0gPSB2YWx1ZTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgcmV0dXJuIGVsW25hbWVdOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZWwsIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgZWxbbWV0aG9kTmFtZV0uYXBwbHkoZWwsIGFyZ3MpO1xuICAgIH07XG4gICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHRoaXMgaW50byBhIHNlcGFyYXRlIGVudmlyb25tZW50IGNsYXNzIG9uY2Ugd2UgaGF2ZSBpdFxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoZXJyb3IpIHsgd2luZG93LmNvbnNvbGUubG9nKGVycm9yKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXAgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlLmdyb3VwKSB7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5ncm91cChlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmxvZ0Vycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKSB7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLCBcImF0dHJUb1Byb3BNYXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9hdHRyVG9Qcm9wTWFwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKGVsLCBzZWxlY3RvcikgeyByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoZWwsIHNlbGVjdG9yKSB7IHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZWwsIGV2dCwgbGlzdGVuZXIpIHsgZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGxpc3RlbmVyLCBmYWxzZSk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm9uQW5kQ2FuY2VsID0gZnVuY3Rpb24gKGVsLCBldnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAvLyBOZWVkZWQgdG8gZm9sbG93IERhcnQncyBzdWJzY3JpcHRpb24gc2VtYW50aWMsIHVudGlsIGZpeCBvZlxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhcnQvaXNzdWVzL2RldGFpbD9pZD0xNzQwNlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTsgfTtcbiAgICB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGVsLCBldnQpIHsgZWwuZGlzcGF0Y2hFdmVudChldnQpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVNb3VzZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gZXZ0O1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGV2dDtcbiAgICB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2dC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzUHJldmVudGVkID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgbGFuZ18xLmlzUHJlc2VudChldnQucmV0dXJuVmFsdWUpICYmICFldnQucmV0dXJuVmFsdWU7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5pbm5lckhUTUw7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldE91dGVySFRNTCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwub3V0ZXJIVE1MOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5ub2RlTmFtZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVOYW1lOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5ub2RlVmFsdWUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVmFsdWU7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50eXBlOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUHJvcGVydHkobm9kZSwgXCJjb250ZW50XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5maXJzdENoaWxkID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5maXJzdENoaWxkOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5uZXh0U2libGluZyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwubmV4dFNpYmxpbmc7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnBhcmVudE5vZGU7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNoaWxkTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoaWxkTm9kZXM7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNoaWxkTm9kZXNBc0xpc3QgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBlbC5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgcmVzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZShjaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsZWFyTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwuYXBwZW5kQ2hpbGQobm9kZSk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnJlbW92ZUNoaWxkKG5vZGUpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQgPSBmdW5jdGlvbiAoZWwsIG5ld0NoaWxkLCBvbGRDaGlsZCkgeyBlbC5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBlbCk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEFsbEJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgbm9kZXMpIHsgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgZWwpOyB9KTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgZWwubmV4dFNpYmxpbmcpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLmlubmVySFRNTCA9IHZhbHVlOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC50ZXh0Q29udGVudDsgfTtcbiAgICAvLyBUT0RPKHZpY2IpOiByZW1vdmVkIEVsZW1lbnQgdHlwZSBiZWNhdXNlIGl0IGRvZXMgbm90IHN1cHBvcnQgU3R5bGVFbGVtZW50XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLnRleHRDb250ZW50ID0gdmFsdWU7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC52YWx1ZTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLnZhbHVlID0gdmFsdWU7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENoZWNrZWQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoZWNrZWQ7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldENoZWNrZWQgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLmNoZWNrZWQgPSB2YWx1ZTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIGRvYykge1xuICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cbiAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnROUyA9IGZ1bmN0aW9uIChucywgdGFnTmFtZSwgZG9jKSB7XG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnTmFtZSk7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGV4dE5vZGUgPSBmdW5jdGlvbiAodGV4dCwgZG9jKSB7XG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFRhZyA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgYXR0clZhbHVlLCBkb2MpIHtcbiAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdTQ1JJUFQnKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGNzcywgZG9jKSB7XG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICB2YXIgc3R5bGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdHlsZSwgdGhpcy5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNyZWF0ZVNoYWRvd1Jvb3QoKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0U2hhZG93Um9vdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuc2hhZG93Um9vdDsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0SG9zdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuaG9zdDsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG5hbWUpO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQuY2xhc3NMaXN0LCAwKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7IGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHsgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkgeyByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVuYW1lKSB7IGVsZW1lbnQuc3R5bGVbc3R5bGVuYW1lXSA9IG51bGw7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlbmFtZSkgeyByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZW5hbWVdOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IHZvaWQgMCkgeyBzdHlsZVZhbHVlID0gbnVsbDsgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFN0eWxlKGVsZW1lbnQsIHN0eWxlTmFtZSkgfHwgJyc7XG4gICAgICAgIHJldHVybiBzdHlsZVZhbHVlID8gdmFsdWUgPT0gc3R5bGVWYWx1ZSA6IHZhbHVlLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudGFnTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnRhZ05hbWU7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZU1hcCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBlbEF0dHJzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsQXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBlbEF0dHJzW2ldO1xuICAgICAgICAgICAgcmVzLnNldChhdHRyaWIubmFtZSwgYXR0cmliLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUpIHsgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0F0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIGF0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkgeyByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkgeyBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG5zLCBuYW1lLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkgeyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBucywgbmFtZSkgeyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBuYW1lKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudGVtcGxhdGVBd2FyZVJvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQoZWwpID8gdGhpcy5jb250ZW50KGVsKSA6IGVsOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVIdG1sRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ2Zha2VUaXRsZScpO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmRlZmF1bHREb2MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudDsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC50aXRsZTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAobmV3VGl0bGUpIHsgZG9jdW1lbnQudGl0bGUgPSBuZXdUaXRsZSB8fCAnJzsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZWxlbWVudE1hdGNoZXMgPSBmdW5jdGlvbiAobiwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBuLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobi5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBuLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyA9IG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1RlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlbC5ub2RlTmFtZSA9PSBcIlRFTVBMQVRFXCI7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkNPTU1FTlRfTk9ERTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNFbGVtZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgbGFuZ18xLmlzUHJlc2VudChub2RlLnNoYWRvd1Jvb3QpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1NoYWRvd1Jvb3QgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmltcG9ydEludG9Eb2MgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdG9JbXBvcnQgPSBub2RlO1xuICAgICAgICBpZiAodGhpcy5pc1RlbXBsYXRlRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgdG9JbXBvcnQgPSB0aGlzLmNvbnRlbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmltcG9ydE5vZGUodG9JbXBvcnQsIHRydWUpO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFkb3B0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBkb2N1bWVudC5hZG9wdE5vZGUobm9kZSk7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhyZWYgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmhyZWY7IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEV2ZW50S2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhrZXkpKSB7XG4gICAgICAgICAgICBrZXkgPSBldmVudC5rZXlJZGVudGlmaWVyO1xuICAgICAgICAgICAgLy8ga2V5SWRlbnRpZmllciBpcyBkZWZpbmVkIGluIHRoZSBvbGQgZHJhZnQgb2YgRE9NIExldmVsIDMgRXZlbnRzIGltcGxlbWVudGVkIGJ5IENocm9tZSBhbmRcbiAgICAgICAgICAgIC8vIFNhZmFyaVxuICAgICAgICAgICAgLy8gY2ZcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2V2ZW50cy5odG1sI0V2ZW50cy1LZXlib2FyZEV2ZW50cy1JbnRlcmZhY2VzXG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnVW5pZGVudGlmaWVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnVSsnKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoa2V5LnN1YnN0cmluZygyKSwgMTYpKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQubG9jYXRpb24gPT09IERPTV9LRVlfTE9DQVRJT05fTlVNUEFEICYmIF9jaHJvbWVOdW1LZXlQYWRNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGJ1ZyBpbiBDaHJvbWUgZm9yIG51bWVyaWMga2V5cGFkIGtleXM6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTU2NTRcbiAgICAgICAgICAgICAgICAgICAgLy8gMSwgMiwgMyAuLi4gYXJlIHJlcG9ydGVkIGFzIEEsIEIsIEMgLi4uXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IF9jaHJvbWVOdW1LZXlQYWRNYXBba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9rZXlNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAga2V5ID0gX2tleU1hcFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0R2xvYmFsRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gXCJ3aW5kb3dcIikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09IFwiYm9keVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuaGlzdG9yeTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cubG9jYXRpb247IH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaHJlZiA9IGdldEJhc2VFbGVtZW50SHJlZigpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoaHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVBhdGgoaHJlZik7XG4gICAgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVzZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHsgYmFzZUVsZW1lbnQgPSBudWxsOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRVc2VyQWdlbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS0nICsgbmFtZSwgdmFsdWUpO1xuICAgIH07XG4gICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtJyArIG5hbWUpOyB9O1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7IH07XG4gICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHRoaXMgaW50byBhIHNlcGFyYXRlIGVudmlyb25tZW50IGNsYXNzIG9uY2Ugd2UgaGF2ZSBpdFxuICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRHbG9iYWxWYXIgPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUpIHsgbGFuZ18xLnNldFZhbHVlT25QYXRoKGxhbmdfMS5nbG9iYWwsIHBhdGgsIHZhbHVlKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHsgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTsgfTtcbiAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlLm5vdygpIGlzIG5vdCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzLCBzZWVcbiAgICAgICAgLy8gaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cGVyZm9ybWFuY2Uubm93XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHdpbmRvdy5wZXJmb3JtYW5jZSkgJiYgbGFuZ18xLmlzUHJlc2VudCh3aW5kb3cucGVyZm9ybWFuY2Uubm93KSkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsYW5nXzEuRGF0ZVdyYXBwZXIudG9NaWxsaXMobGFuZ18xLkRhdGVXcmFwcGVyLm5vdygpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJyb3dzZXJEb21BZGFwdGVyO1xufShnZW5lcmljX2Jyb3dzZXJfYWRhcHRlcl8xLkdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcikpO1xuZXhwb3J0cy5Ccm93c2VyRG9tQWRhcHRlciA9IEJyb3dzZXJEb21BZGFwdGVyO1xudmFyIGJhc2VFbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldEJhc2VFbGVtZW50SHJlZigpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoYmFzZUVsZW1lbnQpKSB7XG4gICAgICAgIGJhc2VFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgICBpZiAobGFuZ18xLmlzQmxhbmsoYmFzZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG59XG4vLyBiYXNlZCBvbiB1cmxVdGlscy5qcyBpbiBBbmd1bGFySlMgMVxudmFyIHVybFBhcnNpbmdOb2RlID0gbnVsbDtcbmZ1bmN0aW9uIHJlbGF0aXZlUGF0aCh1cmwpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsodXJsUGFyc2luZ05vZGUpKSB7XG4gICAgICAgIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgfVxuICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgcmV0dXJuICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgPyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl9hZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4uL2RvbS9kb21fYWRhcHRlcicpO1xuLyoqXG4gKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbnkgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqL1xudmFyIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25QcmVmaXggPSBudWxsO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KCdkaXYnLCB0aGlzLmRlZmF1bHREb2MoKSk7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudCh0aGlzLmdldFN0eWxlKGVsZW1lbnQsICdhbmltYXRpb25OYW1lJykpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tUHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5nZXRTdHlsZShlbGVtZW50LCBkb21QcmVmaXhlc1tpXSArICdBbmltYXRpb25OYW1lJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25QcmVmaXggPSAnLScgKyBkb21QcmVmaXhlc1tpXS50b0xvd2VyQ2FzZSgpICsgJy0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgICAgICAgICBNb3pUcmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICAgICAgICAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCh0cmFuc0VuZEV2ZW50TmFtZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoX3RoaXMuZ2V0U3R5bGUoZWxlbWVudCwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zaXRpb25FbmQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RGlzdHJpYnV0ZWROb2RlcyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuZ2V0RGlzdHJpYnV0ZWROb2RlcygpOyB9O1xuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVzb2x2ZUFuZFNldEhyZWYgPSBmdW5jdGlvbiAoZWwsIGJhc2VVcmwsIGhyZWYpIHtcbiAgICAgICAgZWwuaHJlZiA9IGhyZWYgPT0gbnVsbCA/IGJhc2VVcmwgOiBiYXNlVXJsICsgJy8uLi8nICsgaHJlZjtcbiAgICB9O1xuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNET01FdmVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNOYXRpdmVTaGFkb3dET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNGdW5jdGlvbih0aGlzLmRlZmF1bHREb2MoKS5ib2R5LmNyZWF0ZVNoYWRvd1Jvb3QpO1xuICAgIH07XG4gICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRBbmltYXRpb25QcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2FuaW1hdGlvblByZWZpeCkgPyB0aGlzLl9hbmltYXRpb25QcmVmaXggOiBcIlwiO1xuICAgIH07XG4gICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ18xLmlzUHJlc2VudCh0aGlzLl90cmFuc2l0aW9uRW5kKSA/IHRoaXMuX3RyYW5zaXRpb25FbmQgOiBcIlwiOyB9O1xuICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2FuaW1hdGlvblByZWZpeCkgJiYgbGFuZ18xLmlzUHJlc2VudCh0aGlzLl90cmFuc2l0aW9uRW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXI7XG59KGRvbV9hZGFwdGVyXzEuRG9tQWRhcHRlcikpO1xuZXhwb3J0cy5HZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIgPSBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmljX2Jyb3dzZXJfYWRhcHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpO1xudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCcuLi8uLi9kb20vZG9tX2FkYXB0ZXInKTtcbnZhciBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIG1vdmVkIHRvIGl0cyBvd24gbWV0aG9kIHNvIHRoYXQgYE1vY2tQbGF0Zm9ybUxvY2F0aW9uU3RyYXRlZ3lgIGNhbiBvdmVyd3JpdGUgaXRcbiAgICAvKiogQGludGVybmFsICovXG4gICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0SGlzdG9yeSgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmdldEJhc2VIcmVmRnJvbURPTSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0QmFzZUhyZWYoKTsgfTtcbiAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KCd3aW5kb3cnKS5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZuLCBmYWxzZSk7XG4gICAgfTtcbiAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0R2xvYmFsRXZlbnRUYXJnZXQoJ3dpbmRvdycpLmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmbiwgZmFsc2UpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJwYXRobmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbG9jYXRpb24ucGF0aG5hbWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1BhdGgpIHsgdGhpcy5fbG9jYXRpb24ucGF0aG5hbWUgPSBuZXdQYXRoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInNlYXJjaFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbG9jYXRpb24uc2VhcmNoOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhhc2hcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLmhhc2g7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICAgIH07XG4gICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gICAgfTtcbiAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5mb3J3YXJkKCk7IH07XG4gICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hpc3RvcnkuYmFjaygpOyB9O1xuICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgcmV0dXJuIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uO1xufShjb21tb25fMS5QbGF0Zm9ybUxvY2F0aW9uKSk7XG5leHBvcnRzLkJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uID0gQnJvd3NlclBsYXRmb3JtTG9jYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyX3BsYXRmb3JtX2xvY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi4vZG9tL2RvbV9hZGFwdGVyJyk7XG52YXIgUHVibGljVGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1YmxpY1Rlc3RhYmlsaXR5KHRlc3RhYmlsaXR5KSB7XG4gICAgICAgIHRoaXMuX3Rlc3RhYmlsaXR5ID0gdGVzdGFiaWxpdHk7XG4gICAgfVxuICAgIFB1YmxpY1Rlc3RhYmlsaXR5LnByb3RvdHlwZS5pc1N0YWJsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Rlc3RhYmlsaXR5LmlzU3RhYmxlKCk7IH07XG4gICAgUHVibGljVGVzdGFiaWxpdHkucHJvdG90eXBlLndoZW5TdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5fdGVzdGFiaWxpdHkud2hlblN0YWJsZShjYWxsYmFjayk7IH07XG4gICAgUHVibGljVGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRCaW5kaW5ncyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFByb3ZpZGVycyh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpO1xuICAgIH07XG4gICAgUHVibGljVGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRQcm92aWRlcnMgPSBmdW5jdGlvbiAodXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0YWJpbGl0eS5maW5kQmluZGluZ3ModXNpbmcsIHByb3ZpZGVyLCBleGFjdE1hdGNoKTtcbiAgICB9O1xuICAgIHJldHVybiBQdWJsaWNUZXN0YWJpbGl0eTtcbn0oKSk7XG52YXIgQnJvd3NlckdldFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyR2V0VGVzdGFiaWxpdHkoKSB7XG4gICAgfVxuICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eS5pbml0ID0gZnVuY3Rpb24gKCkgeyBjb3JlXzEuc2V0VGVzdGFiaWxpdHlHZXR0ZXIobmV3IEJyb3dzZXJHZXRUZXN0YWJpbGl0eSgpKTsgfTtcbiAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZFRvV2luZG93ID0gZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7XG4gICAgICAgIGxhbmdfMS5nbG9iYWwuZ2V0QW5ndWxhclRlc3RhYmlsaXR5ID0gZnVuY3Rpb24gKGVsZW0sIGZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICAgICAgaWYgKGZpbmRJbkFuY2VzdG9ycyA9PT0gdm9pZCAwKSB7IGZpbmRJbkFuY2VzdG9ycyA9IHRydWU7IH1cbiAgICAgICAgICAgIHZhciB0ZXN0YWJpbGl0eSA9IHJlZ2lzdHJ5LmZpbmRUZXN0YWJpbGl0eUluVHJlZShlbGVtLCBmaW5kSW5BbmNlc3RvcnMpO1xuICAgICAgICAgICAgaWYgKHRlc3RhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRlc3RhYmlsaXR5IGZvciBlbGVtZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNUZXN0YWJpbGl0eSh0ZXN0YWJpbGl0eSk7XG4gICAgICAgIH07XG4gICAgICAgIGxhbmdfMS5nbG9iYWwuZ2V0QWxsQW5ndWxhclRlc3RhYmlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGVzdGFiaWxpdGllcyA9IHJlZ2lzdHJ5LmdldEFsbFRlc3RhYmlsaXRpZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0YWJpbGl0aWVzLm1hcChmdW5jdGlvbiAodGVzdGFiaWxpdHkpIHsgcmV0dXJuIG5ldyBQdWJsaWNUZXN0YWJpbGl0eSh0ZXN0YWJpbGl0eSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBsYW5nXzEuZ2xvYmFsLmdldEFsbEFuZ3VsYXJSb290RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RyeS5nZXRBbGxSb290RWxlbWVudHMoKTsgfTtcbiAgICAgICAgdmFyIHdoZW5BbGxTdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciB0ZXN0YWJpbGl0aWVzID0gbGFuZ18xLmdsb2JhbC5nZXRBbGxBbmd1bGFyVGVzdGFiaWxpdGllcygpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGVzdGFiaWxpdGllcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZGlkV29yayA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGRlY3JlbWVudCA9IGZ1bmN0aW9uIChkaWRXb3JrXykge1xuICAgICAgICAgICAgICAgIGRpZFdvcmsgPSBkaWRXb3JrIHx8IGRpZFdvcmtfO1xuICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGlkV29yayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRlc3RhYmlsaXRpZXMuZm9yRWFjaChmdW5jdGlvbiAodGVzdGFiaWxpdHkpIHsgdGVzdGFiaWxpdHkud2hlblN0YWJsZShkZWNyZW1lbnQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFsYW5nXzEuZ2xvYmFsLmZyYW1ld29ya1N0YWJpbGl6ZXJzKSB7XG4gICAgICAgICAgICBsYW5nXzEuZ2xvYmFsLmZyYW1ld29ya1N0YWJpbGl6ZXJzID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLmNyZWF0ZUdyb3dhYmxlU2l6ZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBsYW5nXzEuZ2xvYmFsLmZyYW1ld29ya1N0YWJpbGl6ZXJzLnB1c2god2hlbkFsbFN0YWJsZSk7XG4gICAgfTtcbiAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgIGlmIChlbGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gcmVnaXN0cnkuZ2V0VGVzdGFiaWxpdHkoZWxlbSk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5pc1NoYWRvd1Jvb3QoZWxlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRUZXN0YWJpbGl0eUluVHJlZShyZWdpc3RyeSwgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5nZXRIb3N0KGVsZW0pLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5kVGVzdGFiaWxpdHlJblRyZWUocmVnaXN0cnksIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkucGFyZW50RWxlbWVudChlbGVtKSwgdHJ1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnJvd3NlckdldFRlc3RhYmlsaXR5O1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlckdldFRlc3RhYmlsaXR5ID0gQnJvd3NlckdldFRlc3RhYmlsaXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVzdGFiaWxpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4uL2RvbS9kb21fYWRhcHRlcicpO1xuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgYW5kIHNldCB0aGUgdGl0bGUgb2YgYSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gKlxuICogU2luY2UgYW4gQW5ndWxhciAyIGFwcGxpY2F0aW9uIGNhbid0IGJlIGJvb3RzdHJhcHBlZCBvbiB0aGUgZW50aXJlIEhUTUwgZG9jdW1lbnQgKGA8aHRtbD5gIHRhZylcbiAqIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBiaW5kIHRvIHRoZSBgdGV4dGAgcHJvcGVydHkgb2YgdGhlIGBIVE1MVGl0bGVFbGVtZW50YCBlbGVtZW50c1xuICogKHJlcHJlc2VudGluZyB0aGUgYDx0aXRsZT5gIHRhZykuIEluc3RlYWQsIHRoaXMgc2VydmljZSBjYW4gYmUgdXNlZCB0byBzZXQgYW5kIGdldCB0aGUgY3VycmVudFxuICogdGl0bGUgdmFsdWUuXG4gKi9cbnZhciBUaXRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGl0bGUoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgSFRNTCBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRpdGxlLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0VGl0bGUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIG5ld1RpdGxlXG4gICAgICovXG4gICAgVGl0bGUucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKG5ld1RpdGxlKSB7IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuc2V0VGl0bGUobmV3VGl0bGUpOyB9O1xuICAgIHJldHVybiBUaXRsZTtcbn0oKSk7XG5leHBvcnRzLlRpdGxlID0gVGl0bGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aXRsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgYnJvd3Nlcl8xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9icm93c2VyJyk7XG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4uLy4uL2RvbS9kb21fYWRhcHRlcicpO1xudmFyIENoYW5nZURldGVjdGlvblBlcmZSZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5nZURldGVjdGlvblBlcmZSZWNvcmQobXNQZXJUaWNrLCBudW1UaWNrcykge1xuICAgICAgICB0aGlzLm1zUGVyVGljayA9IG1zUGVyVGljaztcbiAgICAgICAgdGhpcy5udW1UaWNrcyA9IG51bVRpY2tzO1xuICAgIH1cbiAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZDtcbn0oKSk7XG5leHBvcnRzLkNoYW5nZURldGVjdGlvblBlcmZSZWNvcmQgPSBDaGFuZ2VEZXRlY3Rpb25QZXJmUmVjb3JkO1xuLyoqXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIEFuZ3VsYXIgZGVidWcgdG9vbHMuIFRoaXMgb2JqZWN0IGNvcnJlc3BvbmRzIHRvIHRoZSBgbmdgXG4gKiBnbG9iYWwgdmFyaWFibGUgYWNjZXNzaWJsZSBpbiB0aGUgZGV2IGNvbnNvbGUuXG4gKi9cbnZhciBBbmd1bGFyVG9vbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuZ3VsYXJUb29scyhyZWYpIHtcbiAgICAgICAgdGhpcy5wcm9maWxlciA9IG5ldyBBbmd1bGFyUHJvZmlsZXIocmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIEFuZ3VsYXJUb29scztcbn0oKSk7XG5leHBvcnRzLkFuZ3VsYXJUb29scyA9IEFuZ3VsYXJUb29scztcbi8qKlxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBBbmd1bGFyIHByb2ZpbGluZy1yZWxhdGVkIGRlYnVnIHRvb2xzLiBUaGlzIG9iamVjdFxuICogY29ycmVzcG9uZHMgdG8gdGhlIGBuZy5wcm9maWxlcmAgaW4gdGhlIGRldiBjb25zb2xlLlxuICovXG52YXIgQW5ndWxhclByb2ZpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmd1bGFyUHJvZmlsZXIocmVmKSB7XG4gICAgICAgIHRoaXMuYXBwUmVmID0gcmVmLmluamVjdG9yLmdldChjb3JlXzEuQXBwbGljYXRpb25SZWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVyY2lzZXMgY2hhbmdlIGRldGVjdGlvbiBpbiBhIGxvb3AgYW5kIHRoZW4gcHJpbnRzIHRoZSBhdmVyYWdlIGFtb3VudCBvZlxuICAgICAqIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGhvdyBsb25nIGEgc2luZ2xlIHJvdW5kIG9mIGNoYW5nZSBkZXRlY3Rpb24gdGFrZXMgZm9yXG4gICAgICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFVJLiBJdCBydW5zIGEgbWluaW11bSBvZiA1IHJvdW5kcyBmb3IgYSBtaW5pbXVtXG4gICAgICogb2YgNTAwIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIE9wdGlvbmFsbHksIGEgdXNlciBtYXkgcGFzcyBhIGBjb25maWdgIHBhcmFtZXRlciBjb250YWluaW5nIGEgbWFwIG9mXG4gICAgICogb3B0aW9ucy4gU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogYHJlY29yZGAgKGJvb2xlYW4pIC0gY2F1c2VzIHRoZSBwcm9maWxlciB0byByZWNvcmQgYSBDUFUgcHJvZmlsZSB3aGlsZVxuICAgICAqIGl0IGV4ZXJjaXNlcyB0aGUgY2hhbmdlIGRldGVjdG9yLiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogbmcucHJvZmlsZXIudGltZUNoYW5nZURldGVjdGlvbih7cmVjb3JkOiB0cnVlfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBBbmd1bGFyUHJvZmlsZXIucHJvdG90eXBlLnRpbWVDaGFuZ2VEZXRlY3Rpb24gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBsYW5nXzEuaXNQcmVzZW50KGNvbmZpZykgJiYgY29uZmlnWydyZWNvcmQnXTtcbiAgICAgICAgdmFyIHByb2ZpbGVOYW1lID0gJ0NoYW5nZSBEZXRlY3Rpb24nO1xuICAgICAgICAvLyBQcm9maWxlciBpcyBub3QgYXZhaWxhYmxlIGluIEFuZHJvaWQgYnJvd3NlcnMsIG5vciBpbiBJRSA5IHdpdGhvdXQgZGV2IHRvb2xzIG9wZW5lZFxuICAgICAgICB2YXIgaXNQcm9maWxlckF2YWlsYWJsZSA9IGxhbmdfMS5pc1ByZXNlbnQoYnJvd3Nlcl8xLndpbmRvdy5jb25zb2xlLnByb2ZpbGUpO1xuICAgICAgICBpZiAocmVjb3JkICYmIGlzUHJvZmlsZXJBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGJyb3dzZXJfMS53aW5kb3cuY29uc29sZS5wcm9maWxlKHByb2ZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBkb21fYWRhcHRlcl8xLmdldERPTSgpLnBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHZhciBudW1UaWNrcyA9IDA7XG4gICAgICAgIHdoaWxlIChudW1UaWNrcyA8IDUgfHwgKGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkucGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0KSA8IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5hcHBSZWYudGljaygpO1xuICAgICAgICAgICAgbnVtVGlja3MrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0gZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBpZiAocmVjb3JkICYmIGlzUHJvZmlsZXJBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY2FzdCB0byA8YW55PiBiZWNhdXNlIHR5cGUgY2hlY2tlciB0aGlua3MgdGhlcmUncyBubyBhcmd1bWVudFxuICAgICAgICAgICAgLy8gd2hpbGUgaW4gZmFjdCB0aGVyZSBpczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ29uc29sZS9wcm9maWxlRW5kXG4gICAgICAgICAgICBicm93c2VyXzEud2luZG93LmNvbnNvbGUucHJvZmlsZUVuZChwcm9maWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zUGVyVGljayA9IChlbmQgLSBzdGFydCkgLyBudW1UaWNrcztcbiAgICAgICAgYnJvd3Nlcl8xLndpbmRvdy5jb25zb2xlLmxvZyhcInJhbiBcIiArIG51bVRpY2tzICsgXCIgY2hhbmdlIGRldGVjdGlvbiBjeWNsZXNcIik7XG4gICAgICAgIGJyb3dzZXJfMS53aW5kb3cuY29uc29sZS5sb2cobGFuZ18xLk51bWJlcldyYXBwZXIudG9GaXhlZChtc1BlclRpY2ssIDIpICsgXCIgbXMgcGVyIGNoZWNrXCIpO1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZURldGVjdGlvblBlcmZSZWNvcmQobXNQZXJUaWNrLCBudW1UaWNrcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQW5ndWxhclByb2ZpbGVyO1xufSgpKTtcbmV4cG9ydHMuQW5ndWxhclByb2ZpbGVyID0gQW5ndWxhclByb2ZpbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uX3Rvb2xzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvbGFuZycpO1xudmFyIGNvbW1vbl90b29sc18xID0gcmVxdWlyZSgnLi9jb21tb25fdG9vbHMnKTtcbnZhciBjb250ZXh0ID0gbGFuZ18xLmdsb2JhbDtcbi8qKlxuICogRW5hYmxlZCBBbmd1bGFyIDIgZGVidWcgdG9vbHMgdGhhdCBhcmUgYWNjZXNzaWJsZSB2aWEgeW91ciBicm93c2VyJ3NcbiAqIGRldmVsb3BlciBjb25zb2xlLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqIDEuIE9wZW4gZGV2ZWxvcGVyIGNvbnNvbGUgKGUuZy4gaW4gQ2hyb21lIEN0cmwgKyBTaGlmdCArIGopXG4gKiAxLiBUeXBlIGBuZy5gICh1c3VhbGx5IHRoZSBjb25zb2xlIHdpbGwgc2hvdyBhdXRvLWNvbXBsZXRlIHN1Z2dlc3Rpb24pXG4gKiAxLiBUcnkgdGhlIGNoYW5nZSBkZXRlY3Rpb24gcHJvZmlsZXIgYG5nLnByb2ZpbGVyLnRpbWVDaGFuZ2VEZXRlY3Rpb24oKWBcbiAqICAgIHRoZW4gaGl0IEVudGVyLlxuICovXG5mdW5jdGlvbiBlbmFibGVEZWJ1Z1Rvb2xzKHJlZikge1xuICAgIGNvbnRleHQubmcgPSBuZXcgY29tbW9uX3Rvb2xzXzEuQW5ndWxhclRvb2xzKHJlZik7XG59XG5leHBvcnRzLmVuYWJsZURlYnVnVG9vbHMgPSBlbmFibGVEZWJ1Z1Rvb2xzO1xuLyoqXG4gKiBEaXNhYmxlcyBBbmd1bGFyIDIgdG9vbHMuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVEZWJ1Z1Rvb2xzKCkge1xuICAgIGRlbGV0ZSBjb250ZXh0Lm5nO1xufVxuZXhwb3J0cy5kaXNhYmxlRGVidWdUb29scyA9IGRpc2FibGVEZWJ1Z1Rvb2xzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9vbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNvcmVfcHJpdmF0ZV8xID0gcmVxdWlyZSgnLi4vY29yZV9wcml2YXRlJyk7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKTtcbnZhciBkb21fc2FuaXRpemF0aW9uX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vc2VjdXJpdHkvZG9tX3Nhbml0aXphdGlvbl9zZXJ2aWNlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi9mYWNhZGUvbGFuZycpO1xudmFyIGJyb3dzZXJfYWRhcHRlcl8xID0gcmVxdWlyZSgnLi9icm93c2VyL2Jyb3dzZXJfYWRhcHRlcicpO1xudmFyIHRlc3RhYmlsaXR5XzEgPSByZXF1aXJlKCcuL2Jyb3dzZXIvdGVzdGFiaWxpdHknKTtcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi9kb20vZG9tX2FkYXB0ZXInKTtcbnZhciBkb21fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2RvbS9kb21fdG9rZW5zJyk7XG52YXIgZXZlbnRfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9kb20vZXZlbnRzL2V2ZW50X21hbmFnZXInKTtcbnZhciBkb21fcmVuZGVyZXJfMSA9IHJlcXVpcmUoJy4vZG9tL2RvbV9yZW5kZXJlcicpO1xudmFyIHNoYXJlZF9zdHlsZXNfaG9zdF8xID0gcmVxdWlyZSgnLi9kb20vc2hhcmVkX3N0eWxlc19ob3N0Jyk7XG52YXIga2V5X2V2ZW50c18xID0gcmVxdWlyZSgnLi9kb20vZXZlbnRzL2tleV9ldmVudHMnKTtcbnZhciBuZ19wcm9iZV8xID0gcmVxdWlyZSgnLi9kb20vZGVidWcvbmdfcHJvYmUnKTtcbnZhciBkb21fZXZlbnRzXzEgPSByZXF1aXJlKCcuL2RvbS9ldmVudHMvZG9tX2V2ZW50cycpO1xudmFyIGhhbW1lcl9nZXN0dXJlc18xID0gcmVxdWlyZSgnLi9kb20vZXZlbnRzL2hhbW1lcl9nZXN0dXJlcycpO1xudmFyIHNoYXJlZF9zdHlsZXNfaG9zdF8yID0gcmVxdWlyZSgnLi9kb20vc2hhcmVkX3N0eWxlc19ob3N0Jyk7XG52YXIgYW5pbWF0aW9uX2J1aWxkZXJfMSA9IHJlcXVpcmUoJy4vYW5pbWF0ZS9hbmltYXRpb25fYnVpbGRlcicpO1xudmFyIGJyb3dzZXJfZGV0YWlsc18xID0gcmVxdWlyZSgnLi9hbmltYXRlL2Jyb3dzZXJfZGV0YWlscycpO1xudmFyIHRpdGxlXzEgPSByZXF1aXJlKCcuL2Jyb3dzZXIvdGl0bGUnKTtcbmV4cG9ydHMuVGl0bGUgPSB0aXRsZV8xLlRpdGxlO1xudmFyIGJyb3dzZXJfYWRhcHRlcl8yID0gcmVxdWlyZSgnLi9icm93c2VyL2Jyb3dzZXJfYWRhcHRlcicpO1xuZXhwb3J0cy5Ccm93c2VyRG9tQWRhcHRlciA9IGJyb3dzZXJfYWRhcHRlcl8yLkJyb3dzZXJEb21BZGFwdGVyO1xudmFyIHRvb2xzXzEgPSByZXF1aXJlKCcuL2Jyb3dzZXIvdG9vbHMvdG9vbHMnKTtcbmV4cG9ydHMuZW5hYmxlRGVidWdUb29scyA9IHRvb2xzXzEuZW5hYmxlRGVidWdUb29scztcbmV4cG9ydHMuZGlzYWJsZURlYnVnVG9vbHMgPSB0b29sc18xLmRpc2FibGVEZWJ1Z1Rvb2xzO1xudmFyIGJ5XzEgPSByZXF1aXJlKCcuL2RvbS9kZWJ1Zy9ieScpO1xuZXhwb3J0cy5CeSA9IGJ5XzEuQnk7XG5leHBvcnRzLkJST1dTRVJfUExBVEZPUk1fTUFSS0VSID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gbmV3IGNvcmVfMS5PcGFxdWVUb2tlbignQnJvd3NlclBsYXRmb3JtTWFya2VyJyk7XG4vKipcbiAqIEEgc2V0IG9mIHByb3ZpZGVycyB0byBpbml0aWFsaXplIHRoZSBBbmd1bGFyIHBsYXRmb3JtIGluIGEgd2ViIGJyb3dzZXIuXG4gKlxuICogVXNlZCBhdXRvbWF0aWNhbGx5IGJ5IGBib290c3RyYXBgLCBvciBjYW4gYmUgcGFzc2VkIHRvIHtAbGluayBwbGF0Zm9ybX0uXG4gKi9cbmV4cG9ydHMuQlJPV1NFUl9QUk9WSURFUlMgPSBbXG4gICAgLypAdHMyZGFydF9Qcm92aWRlciovIHsgcHJvdmlkZTogZXhwb3J0cy5CUk9XU0VSX1BMQVRGT1JNX01BUktFUiwgdXNlVmFsdWU6IHRydWUgfSxcbiAgICBjb3JlXzEuUExBVEZPUk1fQ09NTU9OX1BST1ZJREVSUyxcbiAgICAvKkB0czJkYXJ0X1Byb3ZpZGVyKi8geyBwcm92aWRlOiBjb3JlXzEuUExBVEZPUk1fSU5JVElBTElaRVIsIHVzZVZhbHVlOiBpbml0RG9tQWRhcHRlciwgbXVsdGk6IHRydWUgfSxcbl07XG5mdW5jdGlvbiBfZXhjZXB0aW9uSGFuZGxlcigpIHtcbiAgICAvLyAhSVNfREFSVCBpcyByZXF1aXJlZCBiZWNhdXNlIHdlIG11c3QgcmV0aHJvdyBleGNlcHRpb25zIGluIEpTLFxuICAgIC8vIGJ1dCBtdXN0IG5vdCByZXRocm93IGV4Y2VwdGlvbnMgaW4gRGFydFxuICAgIHJldHVybiBuZXcgY29yZV8xLkV4Y2VwdGlvbkhhbmRsZXIoZG9tX2FkYXB0ZXJfMS5nZXRET00oKSwgIWxhbmdfMS5JU19EQVJUKTtcbn1cbmZ1bmN0aW9uIF9kb2N1bWVudCgpIHtcbiAgICByZXR1cm4gZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5kZWZhdWx0RG9jKCk7XG59XG5leHBvcnRzLkJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUyA9IFtcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGNvcmVfcHJpdmF0ZV8xLlNhbml0aXphdGlvblNlcnZpY2UsIHVzZUV4aXN0aW5nOiBkb21fc2FuaXRpemF0aW9uX3NlcnZpY2VfMS5Eb21TYW5pdGl6YXRpb25TZXJ2aWNlIH0sXG4gICAgLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8geyBwcm92aWRlOiBkb21fc2FuaXRpemF0aW9uX3NlcnZpY2VfMS5Eb21TYW5pdGl6YXRpb25TZXJ2aWNlLCB1c2VDbGFzczogZG9tX3Nhbml0aXphdGlvbl9zZXJ2aWNlXzEuRG9tU2FuaXRpemF0aW9uU2VydmljZUltcGwgfSxcbl07XG4vKipcbiAqIEEgc2V0IG9mIHByb3ZpZGVycyB0byBpbml0aWFsaXplIGFuIEFuZ3VsYXIgYXBwbGljYXRpb24gaW4gYSB3ZWIgYnJvd3Nlci5cbiAqXG4gKiBVc2VkIGF1dG9tYXRpY2FsbHkgYnkgYGJvb3RzdHJhcGAsIG9yIGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIFBsYXRmb3JtUmVmLmFwcGxpY2F0aW9ufS5cbiAqL1xuZXhwb3J0cy5CUk9XU0VSX0FQUF9DT01NT05fUFJPVklERVJTID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gW1xuICAgIGNvcmVfMS5BUFBMSUNBVElPTl9DT01NT05fUFJPVklERVJTLFxuICAgIGNvbW1vbl8xLkZPUk1fUFJPVklERVJTLFxuICAgIGV4cG9ydHMuQlJPV1NFUl9TQU5JVElaQVRJT05fUFJPVklERVJTLFxuICAgIC8qIEB0czJkYXJ0X1Byb3ZpZGVyICovIHsgcHJvdmlkZTogY29yZV8xLlBMQVRGT1JNX1BJUEVTLCB1c2VWYWx1ZTogY29tbW9uXzEuQ09NTU9OX1BJUEVTLCBtdWx0aTogdHJ1ZSB9LFxuICAgIC8qIEB0czJkYXJ0X1Byb3ZpZGVyICovIHsgcHJvdmlkZTogY29yZV8xLlBMQVRGT1JNX0RJUkVDVElWRVMsIHVzZVZhbHVlOiBjb21tb25fMS5DT01NT05fRElSRUNUSVZFUywgbXVsdGk6IHRydWUgfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGNvcmVfMS5FeGNlcHRpb25IYW5kbGVyLCB1c2VGYWN0b3J5OiBfZXhjZXB0aW9uSGFuZGxlciwgZGVwczogW10gfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGRvbV90b2tlbnNfMS5ET0NVTUVOVCwgdXNlRmFjdG9yeTogX2RvY3VtZW50LCBkZXBzOiBbXSB9LFxuICAgIC8qIEB0czJkYXJ0X1Byb3ZpZGVyICovIHsgcHJvdmlkZTogZXZlbnRfbWFuYWdlcl8xLkVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IGRvbV9ldmVudHNfMS5Eb21FdmVudHNQbHVnaW4sIG11bHRpOiB0cnVlIH0sXG4gICAgLyogQHRzMmRhcnRfUHJvdmlkZXIgKi8geyBwcm92aWRlOiBldmVudF9tYW5hZ2VyXzEuRVZFTlRfTUFOQUdFUl9QTFVHSU5TLCB1c2VDbGFzczoga2V5X2V2ZW50c18xLktleUV2ZW50c1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGV2ZW50X21hbmFnZXJfMS5FVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHVzZUNsYXNzOiBoYW1tZXJfZ2VzdHVyZXNfMS5IYW1tZXJHZXN0dXJlc1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGhhbW1lcl9nZXN0dXJlc18xLkhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IGhhbW1lcl9nZXN0dXJlc18xLkhhbW1lckdlc3R1cmVDb25maWcgfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGRvbV9yZW5kZXJlcl8xLkRvbVJvb3RSZW5kZXJlciwgdXNlQ2xhc3M6IGRvbV9yZW5kZXJlcl8xLkRvbVJvb3RSZW5kZXJlcl8gfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IGNvcmVfMS5Sb290UmVuZGVyZXIsIHVzZUV4aXN0aW5nOiBkb21fcmVuZGVyZXJfMS5Eb21Sb290UmVuZGVyZXIgfSxcbiAgICAvKiBAdHMyZGFydF9Qcm92aWRlciAqLyB7IHByb3ZpZGU6IHNoYXJlZF9zdHlsZXNfaG9zdF8xLlNoYXJlZFN0eWxlc0hvc3QsIHVzZUV4aXN0aW5nOiBzaGFyZWRfc3R5bGVzX2hvc3RfMi5Eb21TaGFyZWRTdHlsZXNIb3N0IH0sXG4gICAgc2hhcmVkX3N0eWxlc19ob3N0XzIuRG9tU2hhcmVkU3R5bGVzSG9zdCxcbiAgICBjb3JlXzEuVGVzdGFiaWxpdHksXG4gICAgYnJvd3Nlcl9kZXRhaWxzXzEuQnJvd3NlckRldGFpbHMsXG4gICAgYW5pbWF0aW9uX2J1aWxkZXJfMS5BbmltYXRpb25CdWlsZGVyLFxuICAgIGV2ZW50X21hbmFnZXJfMS5FdmVudE1hbmFnZXIsXG4gICAgbmdfcHJvYmVfMS5FTEVNRU5UX1BST0JFX1BST1ZJREVSU1xuXTtcbnZhciBoYW1tZXJfZ2VzdHVyZXNfMiA9IHJlcXVpcmUoJy4uL3NyYy9kb20vZXZlbnRzL2hhbW1lcl9nZXN0dXJlcycpO1xuZXhwb3J0cy5IQU1NRVJfR0VTVFVSRV9DT05GSUcgPSBoYW1tZXJfZ2VzdHVyZXNfMi5IQU1NRVJfR0VTVFVSRV9DT05GSUc7XG5leHBvcnRzLkhhbW1lckdlc3R1cmVDb25maWcgPSBoYW1tZXJfZ2VzdHVyZXNfMi5IYW1tZXJHZXN0dXJlQ29uZmlnO1xuZnVuY3Rpb24gaW5pdERvbUFkYXB0ZXIoKSB7XG4gICAgYnJvd3Nlcl9hZGFwdGVyXzEuQnJvd3NlckRvbUFkYXB0ZXIubWFrZUN1cnJlbnQoKTtcbiAgICBjb3JlX3ByaXZhdGVfMS53dGZJbml0KCk7XG4gICAgdGVzdGFiaWxpdHlfMS5Ccm93c2VyR2V0VGVzdGFiaWxpdHkuaW5pdCgpO1xufVxuZXhwb3J0cy5pbml0RG9tQWRhcHRlciA9IGluaXREb21BZGFwdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlcl9jb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4uLy4uL2RvbS9kb21fYWRhcHRlcicpO1xuLyoqXG4gKiBQcmVkaWNhdGVzIGZvciB1c2Ugd2l0aCB7QGxpbmsgRGVidWdFbGVtZW50fSdzIHF1ZXJ5IGZ1bmN0aW9ucy5cbiAqL1xudmFyIEJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCeSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYWxsIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIHBsYXRmb3JtL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2FsbCd9XG4gICAgICovXG4gICAgQnkuYWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfTsgfTtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBlbGVtZW50cyBieSB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIHBsYXRmb3JtL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2Nzcyd9XG4gICAgICovXG4gICAgQnkuY3NzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFuZ18xLmlzUHJlc2VudChkZWJ1Z0VsZW1lbnQubmF0aXZlRWxlbWVudCkgP1xuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZWxlbWVudE1hdGNoZXMoZGVidWdFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIGRpcmVjdGl2ZSBwcmVzZW50LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIHBsYXRmb3JtL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2RpcmVjdGl2ZSd9XG4gICAgICovXG4gICAgQnkuZGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHsgcmV0dXJuIGRlYnVnRWxlbWVudC5wcm92aWRlclRva2Vucy5pbmRleE9mKHR5cGUpICE9PSAtMTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBCeTtcbn0oKSk7XG5leHBvcnRzLkJ5ID0gQnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgY29yZV9wcml2YXRlXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9jb3JlX3ByaXZhdGUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9mYWNhZGUvbGFuZycpO1xudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCcuLi9kb21fYWRhcHRlcicpO1xudmFyIGRvbV9yZW5kZXJlcl8xID0gcmVxdWlyZSgnLi4vZG9tX3JlbmRlcmVyJyk7XG52YXIgQ09SRV9UT0tFTlMgPSB7ICdBcHBsaWNhdGlvblJlZic6IGNvcmVfMS5BcHBsaWNhdGlvblJlZiwgJ05nWm9uZSc6IGNvcmVfMS5OZ1pvbmUgfTtcbnZhciBJTlNQRUNUX0dMT0JBTF9OQU1FID0gJ25nLnByb2JlJztcbnZhciBDT1JFX1RPS0VOU19HTE9CQUxfTkFNRSA9ICduZy5jb3JlVG9rZW5zJztcbi8qKlxuICogUmV0dXJucyBhIHtAbGluayBEZWJ1Z0VsZW1lbnR9IGZvciB0aGUgZ2l2ZW4gbmF0aXZlIERPTSBlbGVtZW50LCBvclxuICogbnVsbCBpZiB0aGUgZ2l2ZW4gbmF0aXZlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBBbmd1bGFyIHZpZXcgYXNzb2NpYXRlZFxuICogd2l0aCBpdC5cbiAqL1xuZnVuY3Rpb24gaW5zcGVjdE5hdGl2ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBjb3JlXzEuZ2V0RGVidWdOb2RlKGVsZW1lbnQpO1xufVxuZXhwb3J0cy5pbnNwZWN0TmF0aXZlRWxlbWVudCA9IGluc3BlY3ROYXRpdmVFbGVtZW50O1xuZnVuY3Rpb24gX2NyZWF0ZUNvbmRpdGlvbmFsUm9vdFJlbmRlcmVyKHJvb3RSZW5kZXJlcikge1xuICAgIGlmIChsYW5nXzEuYXNzZXJ0aW9uc0VuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdFJlbmRlcmVyO1xufVxuZnVuY3Rpb24gX2NyZWF0ZVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIpIHtcbiAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnNldEdsb2JhbFZhcihJTlNQRUNUX0dMT0JBTF9OQU1FLCBpbnNwZWN0TmF0aXZlRWxlbWVudCk7XG4gICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5zZXRHbG9iYWxWYXIoQ09SRV9UT0tFTlNfR0xPQkFMX05BTUUsIENPUkVfVE9LRU5TKTtcbiAgICByZXR1cm4gbmV3IGNvcmVfcHJpdmF0ZV8xLkRlYnVnRG9tUm9vdFJlbmRlcmVyKHJvb3RSZW5kZXJlcik7XG59XG4vKipcbiAqIFByb3ZpZGVycyB3aGljaCBzdXBwb3J0IGRlYnVnZ2luZyBBbmd1bGFyIGFwcGxpY2F0aW9ucyAoZS5nLiB2aWEgYG5nLnByb2JlYCkuXG4gKi9cbmV4cG9ydHMuRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMgPSBbXG4gICAgLypAdHMyZGFydF9Qcm92aWRlciovIHtcbiAgICAgICAgcHJvdmlkZTogY29yZV8xLlJvb3RSZW5kZXJlcixcbiAgICAgICAgdXNlRmFjdG9yeTogX2NyZWF0ZUNvbmRpdGlvbmFsUm9vdFJlbmRlcmVyLFxuICAgICAgICBkZXBzOiBbZG9tX3JlbmRlcmVyXzEuRG9tUm9vdFJlbmRlcmVyXVxuICAgIH1cbl07XG5leHBvcnRzLkVMRU1FTlRfUFJPQkVfUFJPVklERVJTX1BST0RfTU9ERSA9IFtcbiAgICAvKkB0czJkYXJ0X1Byb3ZpZGVyKi8ge1xuICAgICAgICBwcm92aWRlOiBjb3JlXzEuUm9vdFJlbmRlcmVyLFxuICAgICAgICB1c2VGYWN0b3J5OiBfY3JlYXRlUm9vdFJlbmRlcmVyLFxuICAgICAgICBkZXBzOiBbZG9tX3JlbmRlcmVyXzEuRG9tUm9vdFJlbmRlcmVyXVxuICAgIH1cbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ19wcm9iZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBfRE9NID0gbnVsbDtcbmZ1bmN0aW9uIGdldERPTSgpIHtcbiAgICByZXR1cm4gX0RPTTtcbn1cbmV4cG9ydHMuZ2V0RE9NID0gZ2V0RE9NO1xuZnVuY3Rpb24gc2V0RE9NKGFkYXB0ZXIpIHtcbiAgICBfRE9NID0gYWRhcHRlcjtcbn1cbmV4cG9ydHMuc2V0RE9NID0gc2V0RE9NO1xuZnVuY3Rpb24gc2V0Um9vdERvbUFkYXB0ZXIoYWRhcHRlcikge1xuICAgIGlmIChsYW5nXzEuaXNCbGFuayhfRE9NKSkge1xuICAgICAgICBfRE9NID0gYWRhcHRlcjtcbiAgICB9XG59XG5leHBvcnRzLnNldFJvb3REb21BZGFwdGVyID0gc2V0Um9vdERvbUFkYXB0ZXI7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpyZXF1aXJlUGFyYW1ldGVyVHlwZSAqL1xuLyoqXG4gKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbiBlbnZpcm9ubWVudC1hZ25vc3RpYyB3YXkuXG4gKi9cbnZhciBEb21BZGFwdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb21BZGFwdGVyKCkge1xuICAgICAgICB0aGlzLnhoclR5cGUgPSBudWxsO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRYSFIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnhoclR5cGU7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvbUFkYXB0ZXIucHJvdG90eXBlLCBcImF0dHJUb1Byb3BNYXBcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcyBmb3IgY2FzZXNcbiAgICAgICAgICogd2hlcmUgYXR0cmlidXRlIG5hbWUgZG9lc24ndCBtYXRjaCBwcm9wZXJ0eSBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hdHRyVG9Qcm9wTWFwOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9hdHRyVG9Qcm9wTWFwID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIDtcbiAgICA7XG4gICAgcmV0dXJuIERvbUFkYXB0ZXI7XG59KCkpO1xuZXhwb3J0cy5Eb21BZGFwdGVyID0gRG9tQWRhcHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbV9hZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGFuaW1hdGlvbl9idWlsZGVyXzEgPSByZXF1aXJlKCcuLi9hbmltYXRlL2FuaW1hdGlvbl9idWlsZGVyJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9leGNlcHRpb25zJyk7XG52YXIgc2hhcmVkX3N0eWxlc19ob3N0XzEgPSByZXF1aXJlKCcuL3NoYXJlZF9zdHlsZXNfaG9zdCcpO1xudmFyIGV2ZW50X21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vZXZlbnRzL2V2ZW50X21hbmFnZXInKTtcbnZhciBkb21fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2RvbV90b2tlbnMnKTtcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi9kb21fYWRhcHRlcicpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIE5BTUVTUEFDRV9VUklTID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki9cbnsgJ3hsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnc3ZnJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB9O1xudmFyIFRFTVBMQVRFX0NPTU1FTlRfVEVYVCA9ICd0ZW1wbGF0ZSBiaW5kaW5ncz17fSc7XG52YXIgVEVNUExBVEVfQklORElOR1NfRVhQID0gL150ZW1wbGF0ZSBiaW5kaW5ncz0oLiopJC9nO1xudmFyIERvbVJvb3RSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9tUm9vdFJlbmRlcmVyKGRvY3VtZW50LCBldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0ID0gc2hhcmVkU3R5bGVzSG9zdDtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gYW5pbWF0ZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZENvbXBvbmVudHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIERvbVJvb3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3RvKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmdldChjb21wb25lbnRQcm90by5pZCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNCbGFuayhyZW5kZXJlcikpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IERvbVJlbmRlcmVyKHRoaXMsIGNvbXBvbmVudFByb3RvKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRDb21wb25lbnRzLnNldChjb21wb25lbnRQcm90by5pZCwgcmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9O1xuICAgIHJldHVybiBEb21Sb290UmVuZGVyZXI7XG59KCkpO1xuZXhwb3J0cy5Eb21Sb290UmVuZGVyZXIgPSBEb21Sb290UmVuZGVyZXI7XG52YXIgRG9tUm9vdFJlbmRlcmVyXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbVJvb3RSZW5kZXJlcl8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9tUm9vdFJlbmRlcmVyXyhfZG9jdW1lbnQsIF9ldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgX2RvY3VtZW50LCBfZXZlbnRNYW5hZ2VyLCBzaGFyZWRTdHlsZXNIb3N0LCBhbmltYXRlKTtcbiAgICB9XG4gICAgRG9tUm9vdFJlbmRlcmVyXy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBEb21Sb290UmVuZGVyZXJfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW2RvbV90b2tlbnNfMS5ET0NVTUVOVCxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGV2ZW50X21hbmFnZXJfMS5FdmVudE1hbmFnZXIsIH0sXG4gICAgICAgIHsgdHlwZTogc2hhcmVkX3N0eWxlc19ob3N0XzEuRG9tU2hhcmVkU3R5bGVzSG9zdCwgfSxcbiAgICAgICAgeyB0eXBlOiBhbmltYXRpb25fYnVpbGRlcl8xLkFuaW1hdGlvbkJ1aWxkZXIsIH0sXG4gICAgXTtcbiAgICByZXR1cm4gRG9tUm9vdFJlbmRlcmVyXztcbn0oRG9tUm9vdFJlbmRlcmVyKSk7XG5leHBvcnRzLkRvbVJvb3RSZW5kZXJlcl8gPSBEb21Sb290UmVuZGVyZXJfO1xudmFyIERvbVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb21SZW5kZXJlcihfcm9vdFJlbmRlcmVyLCBjb21wb25lbnRQcm90bykge1xuICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIgPSBfcm9vdFJlbmRlcmVyO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFByb3RvID0gY29tcG9uZW50UHJvdG87XG4gICAgICAgIHRoaXMuX3N0eWxlcyA9IF9mbGF0dGVuU3R5bGVzKGNvbXBvbmVudFByb3RvLmlkLCBjb21wb25lbnRQcm90by5zdHlsZXMsIFtdKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gIT09IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LmFkZFN0eWxlcyh0aGlzLl9zdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGVudEF0dHIgPSBfc2hpbUNvbnRlbnRBdHRyaWJ1dGUoY29tcG9uZW50UHJvdG8uaWQpO1xuICAgICAgICAgICAgdGhpcy5faG9zdEF0dHIgPSBfc2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50UHJvdG8uaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udGVudEF0dHIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faG9zdEF0dHIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3RSb290RWxlbWVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKSB7XG4gICAgICAgIHZhciBlbDtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1N0cmluZyhzZWxlY3Rvck9yTm9kZSkpIHtcbiAgICAgICAgICAgIGVsID0gZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5xdWVyeVNlbGVjdG9yKHRoaXMuX3Jvb3RSZW5kZXJlci5kb2N1bWVudCwgc2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKGVsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIlRoZSBzZWxlY3RvciBcXFwiXCIgKyBzZWxlY3Rvck9yTm9kZSArIFwiXFxcIiBkaWQgbm90IG1hdGNoIGFueSBlbGVtZW50c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsID0gc2VsZWN0b3JPck5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5jbGVhck5vZGVzKGVsKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgdmFyIG5zQW5kTmFtZSA9IHNwbGl0TmFtZXNwYWNlKG5hbWUpO1xuICAgICAgICB2YXIgZWwgPSBsYW5nXzEuaXNQcmVzZW50KG5zQW5kTmFtZVswXSkgP1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5jcmVhdGVFbGVtZW50TlMoTkFNRVNQQUNFX1VSSVNbbnNBbmROYW1lWzBdXSwgbnNBbmROYW1lWzFdKSA6XG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLmNyZWF0ZUVsZW1lbnQobnNBbmROYW1lWzFdKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQodGhpcy5fY29udGVudEF0dHIpKSB7XG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnNldEF0dHJpYnV0ZShlbCwgdGhpcy5fY29udGVudEF0dHIsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVWaWV3Um9vdCA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCkge1xuICAgICAgICB2YXIgbm9kZXNQYXJlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUpIHtcbiAgICAgICAgICAgIG5vZGVzUGFyZW50ID0gZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5jcmVhdGVTaGFkb3dSb290KGhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LmFkZEhvc3Qobm9kZXNQYXJlbnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLmFwcGVuZENoaWxkKG5vZGVzUGFyZW50LCBkb21fYWRhcHRlcl8xLmdldERPTSgpLmNyZWF0ZVN0eWxlRWxlbWVudCh0aGlzLl9zdHlsZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHRoaXMuX2hvc3RBdHRyKSkge1xuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuc2V0QXR0cmlidXRlKGhvc3RFbGVtZW50LCB0aGlzLl9ob3N0QXR0ciwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXNQYXJlbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXNQYXJlbnQ7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7XG4gICAgICAgIHZhciBjb21tZW50ID0gZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5jcmVhdGVDb21tZW50KFRFTVBMQVRFX0NPTU1FTlRfVEVYVCk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KHBhcmVudEVsZW1lbnQpKSB7XG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudEVsZW1lbnQsIGNvbW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgdmFsdWUsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgbm9kZSA9IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChwYXJlbnRFbGVtZW50KSkge1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5hcHBlbmRDaGlsZChwYXJlbnRFbGVtZW50LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5wcm9qZWN0Tm9kZXMgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbm9kZXMpIHtcbiAgICAgICAgaWYgKGxhbmdfMS5pc0JsYW5rKHBhcmVudEVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhcHBlbmROb2RlcyhwYXJlbnRFbGVtZW50LCBub2Rlcyk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoVmlld0FmdGVyID0gZnVuY3Rpb24gKG5vZGUsIHZpZXdSb290Tm9kZXMpIHtcbiAgICAgICAgbW92ZU5vZGVzQWZ0ZXJTaWJsaW5nKG5vZGUsIHZpZXdSb290Tm9kZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdSb290Tm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVOb2RlRW50ZXIodmlld1Jvb3ROb2Rlc1tpXSk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuZGV0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3Um9vdE5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld1Jvb3ROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB2aWV3Um9vdE5vZGVzW2ldO1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVOb2RlTGVhdmUobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95VmlldyA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCwgdmlld0FsbE5vZGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUgJiYgbGFuZ18xLmlzUHJlc2VudChob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LnJlbW92ZUhvc3QoZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5nZXRTaGFkb3dSb290KGhvc3RFbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RSZW5kZXJlci5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihyZW5kZXJFbGVtZW50LCBuYW1lLCBkZWNvcmF0ZVByZXZlbnREZWZhdWx0KGNhbGxiYWNrKSk7XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuR2xvYmFsID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RSZW5kZXJlci5ldmVudE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIG5hbWUsIGRlY29yYXRlUHJldmVudERlZmF1bHQoY2FsbGJhY2spKTtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuc2V0UHJvcGVydHkocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICB9O1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50QXR0cmlidXRlID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIHZhciBhdHRyTnM7XG4gICAgICAgIHZhciBuc0FuZE5hbWUgPSBzcGxpdE5hbWVzcGFjZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQobnNBbmROYW1lWzBdKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IG5zQW5kTmFtZVswXSArICc6JyArIG5zQW5kTmFtZVsxXTtcbiAgICAgICAgICAgIGF0dHJOcyA9IE5BTUVTUEFDRV9VUklTW25zQW5kTmFtZVswXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmdfMS5pc1ByZXNlbnQoYXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChhdHRyTnMpKSB7XG4gICAgICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5zZXRBdHRyaWJ1dGVOUyhyZW5kZXJFbGVtZW50LCBhdHRyTnMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuc2V0QXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGF0dHJOcykpIHtcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnJlbW92ZUF0dHJpYnV0ZU5TKHJlbmRlckVsZW1lbnQsIGF0dHJOcywgbnNBbmROYW1lWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkucmVtb3ZlQXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0QmluZGluZ0RlYnVnSW5mbyA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgdmFyIGRhc2hDYXNlZFByb3BlcnR5TmFtZSA9IHV0aWxfMS5jYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChkb21fYWRhcHRlcl8xLmdldERPTSgpLmlzQ29tbWVudE5vZGUocmVuZGVyRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ0JpbmRpbmdzID0gbGFuZ18xLlJlZ0V4cFdyYXBwZXIuZmlyc3RNYXRjaChURU1QTEFURV9CSU5ESU5HU19FWFAsIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5nZXRUZXh0KHJlbmRlckVsZW1lbnQpLCAvXFxuL2csICcnKSk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQmluZGluZ3MgPSBsYW5nXzEuSnNvbi5wYXJzZShleGlzdGluZ0JpbmRpbmdzWzFdKTtcbiAgICAgICAgICAgIHBhcnNlZEJpbmRpbmdzW2Rhc2hDYXNlZFByb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5zZXRUZXh0KHJlbmRlckVsZW1lbnQsIGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2UoVEVNUExBVEVfQ09NTUVOVF9URVhULCAne30nLCBsYW5nXzEuSnNvbi5zdHJpbmdpZnkocGFyc2VkQmluZGluZ3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRDbGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUsIGlzQWRkKSB7XG4gICAgICAgIGlmIChpc0FkZCkge1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5hZGRDbGFzcyhyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5yZW1vdmVDbGFzcyhyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgICBpZiAobGFuZ18xLmlzUHJlc2VudChzdHlsZVZhbHVlKSkge1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5zZXRTdHlsZShyZW5kZXJFbGVtZW50LCBzdHlsZU5hbWUsIGxhbmdfMS5zdHJpbmdpZnkoc3R5bGVWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5yZW1vdmVTdHlsZShyZW5kZXJFbGVtZW50LCBzdHlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuaW52b2tlRWxlbWVudE1ldGhvZCA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuaW52b2tlKHJlbmRlckVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuICAgIH07XG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAocmVuZGVyTm9kZSwgdGV4dCkgeyBkb21fYWRhcHRlcl8xLmdldERPTSgpLnNldFRleHQocmVuZGVyTm9kZSwgdGV4dCk7IH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW5pbWF0aW9ucyBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlTm9kZUVudGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuaXNFbGVtZW50Tm9kZShub2RlKSAmJiBkb21fYWRhcHRlcl8xLmdldERPTSgpLmhhc0NsYXNzKG5vZGUsICduZy1hbmltYXRlJykpIHtcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuYWRkQ2xhc3Mobm9kZSwgJ25nLWVudGVyJyk7XG4gICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIuYW5pbWF0ZS5jc3MoKVxuICAgICAgICAgICAgICAgIC5hZGRBbmltYXRpb25DbGFzcygnbmctZW50ZXItYWN0aXZlJylcbiAgICAgICAgICAgICAgICAuc3RhcnQobm9kZSlcbiAgICAgICAgICAgICAgICAub25Db21wbGV0ZShmdW5jdGlvbiAoKSB7IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkucmVtb3ZlQ2xhc3Mobm9kZSwgJ25nLWVudGVyJyk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBhbmltYXRpb25zIGFyZSBuZWNlc3NhcnksIHBlcmZvcm1zIGFuaW1hdGlvbnMgdGhlbiByZW1vdmVzIHRoZSBlbGVtZW50OyBvdGhlcndpc2UsIGl0IGp1c3RcbiAgICAgKiByZW1vdmVzIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmFuaW1hdGVOb2RlTGVhdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5pc0VsZW1lbnROb2RlKG5vZGUpICYmIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuaGFzQ2xhc3Mobm9kZSwgJ25nLWFuaW1hdGUnKSkge1xuICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5hZGRDbGFzcyhub2RlLCAnbmctbGVhdmUnKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5hbmltYXRlLmNzcygpXG4gICAgICAgICAgICAgICAgLmFkZEFuaW1hdGlvbkNsYXNzKCduZy1sZWF2ZS1hY3RpdmUnKVxuICAgICAgICAgICAgICAgIC5zdGFydChub2RlKVxuICAgICAgICAgICAgICAgIC5vbkNvbXBsZXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnJlbW92ZUNsYXNzKG5vZGUsICduZy1sZWF2ZScpO1xuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb21fYWRhcHRlcl8xLmdldERPTSgpLnJlbW92ZShub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERvbVJlbmRlcmVyO1xufSgpKTtcbmV4cG9ydHMuRG9tUmVuZGVyZXIgPSBEb21SZW5kZXJlcjtcbmZ1bmN0aW9uIG1vdmVOb2Rlc0FmdGVyU2libGluZyhzaWJsaW5nLCBub2Rlcykge1xuICAgIHZhciBwYXJlbnQgPSBkb21fYWRhcHRlcl8xLmdldERPTSgpLnBhcmVudEVsZW1lbnQoc2libGluZyk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+IDAgJiYgbGFuZ18xLmlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkubmV4dFNpYmxpbmcoc2libGluZyk7XG4gICAgICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuaW5zZXJ0QmVmb3JlKG5leHRTaWJsaW5nLCBub2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5hcHBlbmRDaGlsZChwYXJlbnQsIG5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZE5vZGVzKHBhcmVudCwgbm9kZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50LCBub2Rlc1tpXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChldmVudEhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhbGxvd0RlZmF1bHRCZWhhdmlvciA9IGV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgICAgIGlmIChhbGxvd0RlZmF1bHRCZWhhdmlvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSBwcmV2ZW50RGVmYXVsdCBpbnRvIGV2ZW50IHBsdWdpbnMuLi5cbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBDT01QT05FTlRfUkVHRVggPSAvJUNPTVAlL2c7XG5leHBvcnRzLkNPTVBPTkVOVF9WQVJJQUJMRSA9ICclQ09NUCUnO1xuZXhwb3J0cy5IT1NUX0FUVFIgPSBcIl9uZ2hvc3QtXCIgKyBleHBvcnRzLkNPTVBPTkVOVF9WQVJJQUJMRTtcbmV4cG9ydHMuQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgZXhwb3J0cy5DT01QT05FTlRfVkFSSUFCTEU7XG5mdW5jdGlvbiBfc2hpbUNvbnRlbnRBdHRyaWJ1dGUoY29tcG9uZW50U2hvcnRJZCkge1xuICAgIHJldHVybiBsYW5nXzEuU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsKGV4cG9ydHMuQ09OVEVOVF9BVFRSLCBDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudFNob3J0SWQpO1xufVxuZnVuY3Rpb24gX3NoaW1Ib3N0QXR0cmlidXRlKGNvbXBvbmVudFNob3J0SWQpIHtcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChleHBvcnRzLkhPU1RfQVRUUiwgQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRTaG9ydElkKTtcbn1cbmZ1bmN0aW9uIF9mbGF0dGVuU3R5bGVzKGNvbXBJZCwgc3R5bGVzLCB0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgICAgIGlmIChsYW5nXzEuaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgICAgIF9mbGF0dGVuU3R5bGVzKGNvbXBJZCwgc3R5bGUsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZSA9IGxhbmdfMS5TdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoc3R5bGUsIENPTVBPTkVOVF9SRUdFWCwgY29tcElkKTtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxudmFyIE5TX1BSRUZJWF9SRSA9IC9eQChbXjpdKyk6KC4rKS9nO1xuZnVuY3Rpb24gc3BsaXROYW1lc3BhY2UobmFtZSkge1xuICAgIGlmIChuYW1lWzBdICE9ICdAJykge1xuICAgICAgICByZXR1cm4gW251bGwsIG5hbWVdO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBsYW5nXzEuUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoKE5TX1BSRUZJWF9SRSwgbmFtZSk7XG4gICAgcmV0dXJuIFttYXRjaFsxXSwgbWF0Y2hbMl1dO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tX3JlbmRlcmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbi8qKlxuICogQSBESSBUb2tlbiByZXByZXNlbnRpbmcgdGhlIG1haW4gcmVuZGVyaW5nIGNvbnRleHQuIEluIGEgYnJvd3NlciB0aGlzIGlzIHRoZSBET00gRG9jdW1lbnQuXG4gKlxuICogTm90ZTogRG9jdW1lbnQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiB0aGUgQXBwbGljYXRpb24gQ29udGV4dCB3aGVuIEFwcGxpY2F0aW9uIGFuZCBSZW5kZXJpbmdcbiAqIENvbnRleHRzIGFyZSBub3QgdGhlIHNhbWUgKGUuZy4gd2hlbiBydW5uaW5nIHRoZSBhcHBsaWNhdGlvbiBpbnRvIGEgV2ViIFdvcmtlcikuXG4gKi9cbmV4cG9ydHMuRE9DVU1FTlQgPSBuZXcgY29yZV8xLk9wYXF1ZVRva2VuKCdEb2N1bWVudFRva2VuJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21fdG9rZW5zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGRvbV9hZGFwdGVyXzEgPSByZXF1aXJlKCcuLi9kb21fYWRhcHRlcicpO1xudmFyIGV2ZW50X21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vZXZlbnRfbWFuYWdlcicpO1xudmFyIERvbUV2ZW50c1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbUV2ZW50c1BsdWdpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21FdmVudHNQbHVnaW4oKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvLyBUaGlzIHBsdWdpbiBzaG91bGQgY29tZSBsYXN0IGluIHRoZSBsaXN0IG9mIHBsdWdpbnMsIGJlY2F1c2UgaXQgYWNjZXB0cyBhbGxcbiAgICAvLyBldmVudHMuXG4gICAgRG9tRXZlbnRzUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgRG9tRXZlbnRzUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgem9uZSA9IHRoaXMubWFuYWdlci5nZXRab25lKCk7XG4gICAgICAgIHZhciBvdXRzaWRlSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gem9uZS5ydW5HdWFyZGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhbmRsZXIoZXZlbnQpOyB9KTsgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRab25lKCkucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5vbkFuZENhbmNlbChlbGVtZW50LCBldmVudE5hbWUsIG91dHNpZGVIYW5kbGVyKTsgfSk7XG4gICAgfTtcbiAgICBEb21FdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb21fYWRhcHRlcl8xLmdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIHZhciB6b25lID0gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKTtcbiAgICAgICAgdmFyIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiB6b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFuZGxlcihldmVudCk7IH0pOyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBkb21fYWRhcHRlcl8xLmdldERPTSgpLm9uQW5kQ2FuY2VsKGVsZW1lbnQsIGV2ZW50TmFtZSwgb3V0c2lkZUhhbmRsZXIpOyB9KTtcbiAgICB9O1xuICAgIERvbUV2ZW50c1BsdWdpbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gRG9tRXZlbnRzUGx1Z2luO1xufShldmVudF9tYW5hZ2VyXzEuRXZlbnRNYW5hZ2VyUGx1Z2luKSk7XG5leHBvcnRzLkRvbUV2ZW50c1BsdWdpbiA9IERvbUV2ZW50c1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbV9ldmVudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvZXhjZXB0aW9ucycpO1xudmFyIGNvbGxlY3Rpb25fMSA9IHJlcXVpcmUoJy4uLy4uLy4uL3NyYy9mYWNhZGUvY29sbGVjdGlvbicpO1xuZXhwb3J0cy5FVkVOVF9NQU5BR0VSX1BMVUdJTlMgPSBcbi8qQHRzMmRhcnRfY29uc3QqLyBuZXcgY29yZV8xLk9wYXF1ZVRva2VuKFwiRXZlbnRNYW5hZ2VyUGx1Z2luc1wiKTtcbnZhciBFdmVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcihwbHVnaW5zLCBfem9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5tYW5hZ2VyID0gX3RoaXM7IH0pO1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0gY29sbGVjdGlvbl8xLkxpc3RXcmFwcGVyLnJldmVyc2VkKHBsdWdpbnMpO1xuICAgIH1cbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiBwbHVnaW4uYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRHbG9iYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiBwbHVnaW4uYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFpvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl96b25lOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLl9maW5kUGx1Z2luRm9yID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuQmFzZUV4Y2VwdGlvbihcIk5vIGV2ZW50IG1hbmFnZXIgcGx1Z2luIGZvdW5kIGZvciBldmVudCBcIiArIGV2ZW50TmFtZSk7XG4gICAgfTtcbiAgICBFdmVudE1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgRXZlbnRNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW2V4cG9ydHMuRVZFTlRfTUFOQUdFUl9QTFVHSU5TLF0gfSxdIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdO1xuICAgIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXI7XG52YXIgRXZlbnRNYW5hZ2VyUGx1Z2luID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXJQbHVnaW4oKSB7XG4gICAgfVxuICAgIC8vIFRoYXQgaXMgZXF1aXZhbGVudCB0byBoYXZpbmcgc3VwcG9ydGluZyAkZXZlbnQudGFyZ2V0XG4gICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhyb3cgXCJub3QgaW1wbGVtZW50ZWRcIjtcbiAgICB9O1xuICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhyb3cgXCJub3QgaW1wbGVtZW50ZWRcIjtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudE1hbmFnZXJQbHVnaW47XG59KCkpO1xuZXhwb3J0cy5FdmVudE1hbmFnZXJQbHVnaW4gPSBFdmVudE1hbmFnZXJQbHVnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudF9tYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgZXZlbnRfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9ldmVudF9tYW5hZ2VyJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgX2V2ZW50TmFtZXMgPSB7XG4gICAgLy8gcGFuXG4gICAgJ3Bhbic6IHRydWUsXG4gICAgJ3BhbnN0YXJ0JzogdHJ1ZSxcbiAgICAncGFubW92ZSc6IHRydWUsXG4gICAgJ3BhbmVuZCc6IHRydWUsXG4gICAgJ3BhbmNhbmNlbCc6IHRydWUsXG4gICAgJ3BhbmxlZnQnOiB0cnVlLFxuICAgICdwYW5yaWdodCc6IHRydWUsXG4gICAgJ3BhbnVwJzogdHJ1ZSxcbiAgICAncGFuZG93bic6IHRydWUsXG4gICAgLy8gcGluY2hcbiAgICAncGluY2gnOiB0cnVlLFxuICAgICdwaW5jaHN0YXJ0JzogdHJ1ZSxcbiAgICAncGluY2htb3ZlJzogdHJ1ZSxcbiAgICAncGluY2hlbmQnOiB0cnVlLFxuICAgICdwaW5jaGNhbmNlbCc6IHRydWUsXG4gICAgJ3BpbmNoaW4nOiB0cnVlLFxuICAgICdwaW5jaG91dCc6IHRydWUsXG4gICAgLy8gcHJlc3NcbiAgICAncHJlc3MnOiB0cnVlLFxuICAgICdwcmVzc3VwJzogdHJ1ZSxcbiAgICAvLyByb3RhdGVcbiAgICAncm90YXRlJzogdHJ1ZSxcbiAgICAncm90YXRlc3RhcnQnOiB0cnVlLFxuICAgICdyb3RhdGVtb3ZlJzogdHJ1ZSxcbiAgICAncm90YXRlZW5kJzogdHJ1ZSxcbiAgICAncm90YXRlY2FuY2VsJzogdHJ1ZSxcbiAgICAvLyBzd2lwZVxuICAgICdzd2lwZSc6IHRydWUsXG4gICAgJ3N3aXBlbGVmdCc6IHRydWUsXG4gICAgJ3N3aXBlcmlnaHQnOiB0cnVlLFxuICAgICdzd2lwZXVwJzogdHJ1ZSxcbiAgICAnc3dpcGVkb3duJzogdHJ1ZSxcbiAgICAvLyB0YXBcbiAgICAndGFwJzogdHJ1ZSxcbn07XG52YXIgSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhfZXZlbnROYW1lcywgZXZlbnROYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbjtcbn0oZXZlbnRfbWFuYWdlcl8xLkV2ZW50TWFuYWdlclBsdWdpbikpO1xuZXhwb3J0cy5IYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiA9IEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFtbWVyX2NvbW1vbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2V4Y2VwdGlvbnMnKTtcbnZhciBoYW1tZXJfY29tbW9uXzEgPSByZXF1aXJlKCcuL2hhbW1lcl9jb21tb24nKTtcbmV4cG9ydHMuSEFNTUVSX0dFU1RVUkVfQ09ORklHID0gXG4vKkB0czJkYXJ0X2NvbnN0Ki8gbmV3IGNvcmVfMS5PcGFxdWVUb2tlbihcIkhhbW1lckdlc3R1cmVDb25maWdcIik7XG52YXIgSGFtbWVyR2VzdHVyZUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGFtbWVyR2VzdHVyZUNvbmZpZygpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5vdmVycmlkZXMgPSB7fTtcbiAgICB9XG4gICAgSGFtbWVyR2VzdHVyZUNvbmZpZy5wcm90b3R5cGUuYnVpbGRIYW1tZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgbWMgPSBuZXcgSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICBtYy5nZXQoJ3BpbmNoJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICBtYy5nZXQoJ3JvdGF0ZScpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMub3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBtYy5nZXQoZXZlbnROYW1lKS5zZXQodGhpcy5vdmVycmlkZXNbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1jO1xuICAgIH07XG4gICAgSGFtbWVyR2VzdHVyZUNvbmZpZy5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gSGFtbWVyR2VzdHVyZUNvbmZpZztcbn0oKSk7XG5leHBvcnRzLkhhbW1lckdlc3R1cmVDb25maWcgPSBIYW1tZXJHZXN0dXJlQ29uZmlnO1xudmFyIEhhbW1lckdlc3R1cmVzUGx1Z2luID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGFtbWVyR2VzdHVyZXNQbHVnaW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGFtbWVyR2VzdHVyZXNQbHVnaW4oX2NvbmZpZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICB9XG4gICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIV9zdXBlci5wcm90b3R5cGUuc3VwcG9ydHMuY2FsbCh0aGlzLCBldmVudE5hbWUpICYmICF0aGlzLmlzQ3VzdG9tRXZlbnQoZXZlbnROYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFsYW5nXzEuaXNQcmVzZW50KHdpbmRvd1snSGFtbWVyJ10pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLkJhc2VFeGNlcHRpb24oXCJIYW1tZXIuanMgaXMgbm90IGxvYWRlZCwgY2FuIG5vdCBiaW5kIFwiICsgZXZlbnROYW1lICsgXCIgZXZlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHpvbmUgPSB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpO1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIG1hbmFnZXIgYmluZCBldmVudHMsIG11c3QgYmUgZG9uZSBvdXRzaWRlIG9mIGFuZ3VsYXJcbiAgICAgICAgICAgIHZhciBtYyA9IF90aGlzLl9jb25maWcuYnVpbGRIYW1tZXIoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnRPYmopIHsgem9uZS5ydW5HdWFyZGVkKGZ1bmN0aW9uICgpIHsgaGFuZGxlcihldmVudE9iaik7IH0pOyB9O1xuICAgICAgICAgICAgbWMub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBtYy5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7IH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLmlzQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiB0aGlzLl9jb25maWcuZXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xOyB9O1xuICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IEhhbW1lckdlc3R1cmVDb25maWcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IGNvcmVfMS5JbmplY3QsIGFyZ3M6IFtleHBvcnRzLkhBTU1FUl9HRVNUVVJFX0NPTkZJRyxdIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIEhhbW1lckdlc3R1cmVzUGx1Z2luO1xufShoYW1tZXJfY29tbW9uXzEuSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24pKTtcbmV4cG9ydHMuSGFtbWVyR2VzdHVyZXNQbHVnaW4gPSBIYW1tZXJHZXN0dXJlc1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhbW1lcl9nZXN0dXJlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2xhbmcnKTtcbnZhciBjb2xsZWN0aW9uXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvZmFjYWRlL2NvbGxlY3Rpb24nKTtcbnZhciBkb21fYWRhcHRlcl8xID0gcmVxdWlyZSgnLi4vZG9tX2FkYXB0ZXInKTtcbnZhciBldmVudF9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL2V2ZW50X21hbmFnZXInKTtcbnZhciBtb2RpZmllcktleXMgPSBbJ2FsdCcsICdjb250cm9sJywgJ21ldGEnLCAnc2hpZnQnXTtcbnZhciBtb2RpZmllcktleUdldHRlcnMgPSB7XG4gICAgJ2FsdCc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuYWx0S2V5OyB9LFxuICAgICdjb250cm9sJzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5jdHJsS2V5OyB9LFxuICAgICdtZXRhJzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5tZXRhS2V5OyB9LFxuICAgICdzaGlmdCc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuc2hpZnRLZXk7IH1cbn07XG52YXIgS2V5RXZlbnRzUGx1Z2luID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5RXZlbnRzUGx1Z2luLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEtleUV2ZW50c1BsdWdpbigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIEtleUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBsYW5nXzEuaXNQcmVzZW50KEtleUV2ZW50c1BsdWdpbi5wYXJzZUV2ZW50TmFtZShldmVudE5hbWUpKTtcbiAgICB9O1xuICAgIEtleUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHBhcnNlZEV2ZW50ID0gS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgIHZhciBvdXRzaWRlSGFuZGxlciA9IEtleUV2ZW50c1BsdWdpbi5ldmVudENhbGxiYWNrKGVsZW1lbnQsIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChwYXJzZWRFdmVudCwgJ2Z1bGxLZXknKSwgaGFuZGxlciwgdGhpcy5tYW5hZ2VyLmdldFpvbmUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb21fYWRhcHRlcl8xLmdldERPTSgpLm9uQW5kQ2FuY2VsKGVsZW1lbnQsIGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmdldChwYXJzZWRFdmVudCwgJ2RvbUV2ZW50TmFtZScpLCBvdXRzaWRlSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgZG9tRXZlbnROYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKChwYXJ0cy5sZW5ndGggPT09IDApIHx8XG4gICAgICAgICAgICAhKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhkb21FdmVudE5hbWUsICdrZXlkb3duJykgfHxcbiAgICAgICAgICAgICAgICBsYW5nXzEuU3RyaW5nV3JhcHBlci5lcXVhbHMoZG9tRXZlbnROYW1lLCAna2V5dXAnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBLZXlFdmVudHNQbHVnaW4uX25vcm1hbGl6ZUtleShwYXJ0cy5wb3AoKSk7XG4gICAgICAgIHZhciBmdWxsS2V5ID0gJyc7XG4gICAgICAgIG1vZGlmaWVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck5hbWUpIHtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIuY29udGFpbnMocGFydHMsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uXzEuTGlzdFdyYXBwZXIucmVtb3ZlKHBhcnRzLCBtb2RpZmllck5hbWUpO1xuICAgICAgICAgICAgICAgIGZ1bGxLZXkgKz0gbW9kaWZpZXJOYW1lICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVsbEtleSArPSBrZXk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT0gMCB8fCBrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgbnVsbCBpbnN0ZWFkIG9mIHRocm93aW5nIHRvIGxldCBhbm90aGVyIHBsdWdpbiBwcm9jZXNzIHRoZSBldmVudFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb25fMS5TdHJpbmdNYXBXcmFwcGVyLmNyZWF0ZSgpO1xuICAgICAgICBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5zZXQocmVzdWx0LCAnZG9tRXZlbnROYW1lJywgZG9tRXZlbnROYW1lKTtcbiAgICAgICAgY29sbGVjdGlvbl8xLlN0cmluZ01hcFdyYXBwZXIuc2V0KHJlc3VsdCwgJ2Z1bGxLZXknLCBmdWxsS2V5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEtleUV2ZW50c1BsdWdpbi5nZXRFdmVudEZ1bGxLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGZ1bGxLZXkgPSAnJztcbiAgICAgICAgdmFyIGtleSA9IGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuZ2V0RXZlbnRLZXkoZXZlbnQpO1xuICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhrZXksICcgJykpIHtcbiAgICAgICAgICAgIGtleSA9ICdzcGFjZSc7IC8vIGZvciByZWFkYWJpbGl0eVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhbmdfMS5TdHJpbmdXcmFwcGVyLmVxdWFscyhrZXksICcuJykpIHtcbiAgICAgICAgICAgIGtleSA9ICdkb3QnOyAvLyBiZWNhdXNlICcuJyBpcyB1c2VkIGFzIGEgc2VwYXJhdG9yIGluIGV2ZW50IG5hbWVzXG4gICAgICAgIH1cbiAgICAgICAgbW9kaWZpZXJLZXlzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVyTmFtZSAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZXJHZXR0ZXIgPSBjb2xsZWN0aW9uXzEuU3RyaW5nTWFwV3JhcHBlci5nZXQobW9kaWZpZXJLZXlHZXR0ZXJzLCBtb2RpZmllck5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllckdldHRlcihldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbEtleSArPSBtb2RpZmllck5hbWUgKyAnLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVsbEtleSArPSBrZXk7XG4gICAgICAgIHJldHVybiBmdWxsS2V5O1xuICAgIH07XG4gICAgS2V5RXZlbnRzUGx1Z2luLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZWxlbWVudCwgZnVsbEtleSwgaGFuZGxlciwgem9uZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAobGFuZ18xLlN0cmluZ1dyYXBwZXIuZXF1YWxzKEtleUV2ZW50c1BsdWdpbi5nZXRFdmVudEZ1bGxLZXkoZXZlbnQpLCBmdWxsS2V5KSkge1xuICAgICAgICAgICAgICAgIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgS2V5RXZlbnRzUGx1Z2luLl9ub3JtYWxpemVLZXkgPSBmdW5jdGlvbiAoa2V5TmFtZSkge1xuICAgICAgICAvLyBUT0RPOiBzd2l0Y2ggdG8gYSBTdHJpbmdNYXAgaWYgdGhlIG1hcHBpbmcgZ3Jvd3MgdG9vIG11Y2hcbiAgICAgICAgc3dpdGNoIChrZXlOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdlc2MnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZXNjYXBlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleU5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtleUV2ZW50c1BsdWdpbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBLZXlFdmVudHNQbHVnaW4uY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICByZXR1cm4gS2V5RXZlbnRzUGx1Z2luO1xufShldmVudF9tYW5hZ2VyXzEuRXZlbnRNYW5hZ2VyUGx1Z2luKSk7XG5leHBvcnRzLktleUV2ZW50c1BsdWdpbiA9IEtleUV2ZW50c1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleV9ldmVudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgY29sbGVjdGlvbl8xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9jb2xsZWN0aW9uJyk7XG52YXIgZG9tX2FkYXB0ZXJfMSA9IHJlcXVpcmUoJy4vZG9tX2FkYXB0ZXInKTtcbnZhciBkb21fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2RvbV90b2tlbnMnKTtcbnZhciBTaGFyZWRTdHlsZXNIb3N0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaGFyZWRTdHlsZXNIb3N0KCkge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3N0eWxlcyA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3N0eWxlc1NldCA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuYWRkU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWRkaXRpb25zID0gW107XG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5oYXMoX3RoaXMuX3N0eWxlc1NldCwgc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlc1NldC5hZGQoc3R5bGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZXMucHVzaChzdHlsZSk7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblN0eWxlc0FkZGVkKGFkZGl0aW9ucyk7XG4gICAgfTtcbiAgICBTaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5vblN0eWxlc0FkZGVkID0gZnVuY3Rpb24gKGFkZGl0aW9ucykgeyB9O1xuICAgIFNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLmdldEFsbFN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0eWxlczsgfTtcbiAgICBTaGFyZWRTdHlsZXNIb3N0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIFNoYXJlZFN0eWxlc0hvc3QuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICByZXR1cm4gU2hhcmVkU3R5bGVzSG9zdDtcbn0oKSk7XG5leHBvcnRzLlNoYXJlZFN0eWxlc0hvc3QgPSBTaGFyZWRTdHlsZXNIb3N0O1xudmFyIERvbVNoYXJlZFN0eWxlc0hvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb21TaGFyZWRTdHlsZXNIb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvbVNoYXJlZFN0eWxlc0hvc3QoZG9jKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9ob3N0Tm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2hvc3ROb2Rlcy5hZGQoZG9jLmhlYWQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuX2FkZFN0eWxlc1RvSG9zdCA9IGZ1bmN0aW9uIChzdHlsZXMsIGhvc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgICAgIGRvbV9hZGFwdGVyXzEuZ2V0RE9NKCkuYXBwZW5kQ2hpbGQoaG9zdCwgZG9tX2FkYXB0ZXJfMS5nZXRET00oKS5jcmVhdGVTdHlsZUVsZW1lbnQoc3R5bGUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuYWRkSG9zdCA9IGZ1bmN0aW9uIChob3N0Tm9kZSkge1xuICAgICAgICB0aGlzLl9hZGRTdHlsZXNUb0hvc3QodGhpcy5fc3R5bGVzLCBob3N0Tm9kZSk7XG4gICAgICAgIHRoaXMuX2hvc3ROb2Rlcy5hZGQoaG9zdE5vZGUpO1xuICAgIH07XG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUucmVtb3ZlSG9zdCA9IGZ1bmN0aW9uIChob3N0Tm9kZSkgeyBjb2xsZWN0aW9uXzEuU2V0V3JhcHBlci5kZWxldGUodGhpcy5faG9zdE5vZGVzLCBob3N0Tm9kZSk7IH07XG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IGZ1bmN0aW9uIChhZGRpdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faG9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGhvc3ROb2RlKSB7IF90aGlzLl9hZGRTdHlsZXNUb0hvc3QoYWRkaXRpb25zLCBob3N0Tm9kZSk7IH0pO1xuICAgIH07XG4gICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICBEb21TaGFyZWRTdHlsZXNIb3N0LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZV8xLkluamVjdCwgYXJnczogW2RvbV90b2tlbnNfMS5ET0NVTUVOVCxdIH0sXSB9LFxuICAgIF07XG4gICAgcmV0dXJuIERvbVNoYXJlZFN0eWxlc0hvc3Q7XG59KFNoYXJlZFN0eWxlc0hvc3QpKTtcbmV4cG9ydHMuRG9tU2hhcmVkU3R5bGVzSG9zdCA9IERvbVNoYXJlZFN0eWxlc0hvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWRfc3R5bGVzX2hvc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi4vLi4vc3JjL2ZhY2FkZS9sYW5nJyk7XG52YXIgQ0FNRUxfQ0FTRV9SRUdFWFAgPSAvKFtBLVpdKS9nO1xudmFyIERBU0hfQ0FTRV9SRUdFWFAgPSAvLShbYS16XSkvZztcbmZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaENhc2UoaW5wdXQpIHtcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgQ0FNRUxfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uIChtKSB7IHJldHVybiAnLScgKyBtWzFdLnRvTG93ZXJDYXNlKCk7IH0pO1xufVxuZXhwb3J0cy5jYW1lbENhc2VUb0Rhc2hDYXNlID0gY2FtZWxDYXNlVG9EYXNoQ2FzZTtcbmZ1bmN0aW9uIGRhc2hDYXNlVG9DYW1lbENhc2UoaW5wdXQpIHtcbiAgICByZXR1cm4gbGFuZ18xLlN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTsgfSk7XG59XG5leHBvcnRzLmRhc2hDYXNlVG9DYW1lbENhc2UgPSBkYXNoQ2FzZVRvQ2FtZWxDYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuKiBKUyB2ZXJzaW9uIG9mIGJyb3dzZXIgQVBJcy4gVGhpcyBsaWJyYXJ5IGNhbiBvbmx5IHJ1biBpbiB0aGUgYnJvd3Nlci5cbiovXG52YXIgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93IHx8IHt9O1xuZXhwb3J0cy53aW5kb3cgPSB3aW47XG5leHBvcnRzLmRvY3VtZW50ID0gd2luLmRvY3VtZW50O1xuZXhwb3J0cy5sb2NhdGlvbiA9IHdpbi5sb2NhdGlvbjtcbmV4cG9ydHMuZ2MgPSB3aW5bJ2djJ10gPyBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5bJ2djJ10oKTsgfSA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG5leHBvcnRzLnBlcmZvcm1hbmNlID0gd2luWydwZXJmb3JtYW5jZSddID8gd2luWydwZXJmb3JtYW5jZSddIDogbnVsbDtcbmV4cG9ydHMuRXZlbnQgPSB3aW5bJ0V2ZW50J107XG5leHBvcnRzLk1vdXNlRXZlbnQgPSB3aW5bJ01vdXNlRXZlbnQnXTtcbmV4cG9ydHMuS2V5Ym9hcmRFdmVudCA9IHdpblsnS2V5Ym9hcmRFdmVudCddO1xuZXhwb3J0cy5FdmVudFRhcmdldCA9IHdpblsnRXZlbnRUYXJnZXQnXTtcbmV4cG9ydHMuSGlzdG9yeSA9IHdpblsnSGlzdG9yeSddO1xuZXhwb3J0cy5Mb2NhdGlvbiA9IHdpblsnTG9jYXRpb24nXTtcbmV4cG9ydHMuRXZlbnRMaXN0ZW5lciA9IHdpblsnRXZlbnRMaXN0ZW5lciddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGdsb2JhbFNjb3BlO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XG4gICAgfVxufVxuZWxzZSB7XG4gICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG59XG5mdW5jdGlvbiBzY2hlZHVsZU1pY3JvVGFzayhmbikge1xuICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XG59XG5leHBvcnRzLnNjaGVkdWxlTWljcm9UYXNrID0gc2NoZWR1bGVNaWNyb1Rhc2s7XG5leHBvcnRzLklTX0RBUlQgPSBmYWxzZTtcbi8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbnZhciBfZ2xvYmFsID0gZ2xvYmFsU2NvcGU7XG5leHBvcnRzLmdsb2JhbCA9IF9nbG9iYWw7XG5leHBvcnRzLlR5cGUgPSBGdW5jdGlvbjtcbmZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGUpIHtcbiAgICBpZiAodHlwZVsnbmFtZSddKSB7XG4gICAgICAgIHJldHVybiB0eXBlWyduYW1lJ107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdHlwZTtcbn1cbmV4cG9ydHMuZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcgPSBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZztcbmV4cG9ydHMuTWF0aCA9IF9nbG9iYWwuTWF0aDtcbmV4cG9ydHMuRGF0ZSA9IF9nbG9iYWwuRGF0ZTtcbnZhciBfZGV2TW9kZSA9IHRydWU7XG52YXIgX21vZGVMb2NrZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGxvY2tNb2RlKCkge1xuICAgIF9tb2RlTG9ja2VkID0gdHJ1ZTtcbn1cbmV4cG9ydHMubG9ja01vZGUgPSBsb2NrTW9kZTtcbi8qKlxuICogRGlzYWJsZSBBbmd1bGFyJ3MgZGV2ZWxvcG1lbnQgbW9kZSwgd2hpY2ggdHVybnMgb2ZmIGFzc2VydGlvbnMgYW5kIG90aGVyXG4gKiBjaGVja3Mgd2l0aGluIHRoZSBmcmFtZXdvcmsuXG4gKlxuICogT25lIGltcG9ydGFudCBhc3NlcnRpb24gdGhpcyBkaXNhYmxlcyB2ZXJpZmllcyB0aGF0IGEgY2hhbmdlIGRldGVjdGlvbiBwYXNzXG4gKiBkb2VzIG5vdCByZXN1bHQgaW4gYWRkaXRpb25hbCBjaGFuZ2VzIHRvIGFueSBiaW5kaW5ncyAoYWxzbyBrbm93biBhc1xuICogdW5pZGlyZWN0aW9uYWwgZGF0YSBmbG93KS5cbiAqL1xuZnVuY3Rpb24gZW5hYmxlUHJvZE1vZGUoKSB7XG4gICAgaWYgKF9tb2RlTG9ja2VkKSB7XG4gICAgICAgIC8vIENhbm5vdCB1c2UgQmFzZUV4Y2VwdGlvbiBhcyB0aGF0IGVuZHMgdXAgaW1wb3J0aW5nIGZyb20gZmFjYWRlL2xhbmcuXG4gICAgICAgIHRocm93ICdDYW5ub3QgZW5hYmxlIHByb2QgbW9kZSBhZnRlciBwbGF0Zm9ybSBzZXR1cC4nO1xuICAgIH1cbiAgICBfZGV2TW9kZSA9IGZhbHNlO1xufVxuZXhwb3J0cy5lbmFibGVQcm9kTW9kZSA9IGVuYWJsZVByb2RNb2RlO1xuZnVuY3Rpb24gYXNzZXJ0aW9uc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIF9kZXZNb2RlO1xufVxuZXhwb3J0cy5hc3NlcnRpb25zRW5hYmxlZCA9IGFzc2VydGlvbnNFbmFibGVkO1xuLy8gVE9ETzogcmVtb3ZlIGNhbGxzIHRvIGFzc2VydCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4vLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbi8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG5fZ2xvYmFsLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xufTtcbmZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG5mdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XG59XG5leHBvcnRzLmlzQmxhbmsgPSBpc0JsYW5rO1xuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImJvb2xlYW5cIjtcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCI7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5mdW5jdGlvbiBpc1R5cGUob2JqKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqKTtcbn1cbmV4cG9ydHMuaXNUeXBlID0gaXNUeXBlO1xuZnVuY3Rpb24gaXNTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNTdHJpbmdNYXAgPSBpc1N0cmluZ01hcDtcbnZhciBTVFJJTkdfTUFQX1BST1RPID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtcbmZ1bmN0aW9uIGlzU3RyaWN0U3RyaW5nTWFwKG9iaikge1xuICAgIHJldHVybiBpc1N0cmluZ01hcChvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xufVxuZXhwb3J0cy5pc1N0cmljdFN0cmluZ01hcCA9IGlzU3RyaWN0U3RyaW5nTWFwO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBfZ2xvYmFsLlByb21pc2U7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIGV4cG9ydHMuRGF0ZSAmJiAhaXNOYU4ob2JqLnZhbHVlT2YoKSk7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5mdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgIH1cbiAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICB9XG4gICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKFwiXFxuXCIpO1xuICAgIHJldHVybiAobmV3TGluZUluZGV4ID09PSAtMSkgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbi8vIHNlcmlhbGl6ZSAvIGRlc2VyaWFsaXplIGVudW0gZXhpc3Qgb25seSBmb3IgY29uc2lzdGVuY3kgd2l0aCBkYXJ0IEFQSVxuLy8gZW51bXMgaW4gdHlwZXNjcmlwdCBkb24ndCBuZWVkIHRvIGJlIHNlcmlhbGl6ZWRcbmZ1bmN0aW9uIHNlcmlhbGl6ZUVudW0odmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmV4cG9ydHMuc2VyaWFsaXplRW51bSA9IHNlcmlhbGl6ZUVudW07XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVudW0odmFsLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZUVudW0gPSBkZXNlcmlhbGl6ZUVudW07XG5mdW5jdGlvbiByZXNvbHZlRW51bVRva2VuKGVudW1WYWx1ZSwgdmFsKSB7XG4gICAgcmV0dXJuIGVudW1WYWx1ZVt2YWxdO1xufVxuZXhwb3J0cy5yZXNvbHZlRW51bVRva2VuID0gcmVzb2x2ZUVudW1Ub2tlbjtcbnZhciBTdHJpbmdXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdXcmFwcGVyKCkge1xuICAgIH1cbiAgICBTdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdCA9IGZ1bmN0aW9uIChzLCBpbmRleCkgeyByZXR1cm4gcy5jaGFyQ29kZUF0KGluZGV4KTsgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnNwbGl0ID0gZnVuY3Rpb24gKHMsIHJlZ0V4cCkgeyByZXR1cm4gcy5zcGxpdChyZWdFeHApOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKHMsIHMyKSB7IHJldHVybiBzID09PSBzMjsgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnN0cmlwTGVmdCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnN0cmlwUmlnaHQgPSBmdW5jdGlvbiAocywgY2hhclZhbCkge1xuICAgICAgICBpZiAocyAmJiBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPSBjaGFyVmFsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzLCBmcm9tLCByZXBsYWNlKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgcmVwbGFjZSk7XG4gICAgfTtcbiAgICBTdHJpbmdXcmFwcGVyLnNsaWNlID0gZnVuY3Rpb24gKHMsIGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBzLnNsaWNlKGZyb20sIHRvID09PSBudWxsID8gdW5kZWZpbmVkIDogdG8pO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkID0gZnVuY3Rpb24gKHMsIGZyb20sIGNiKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzZXQgJiBzdHJpbmcgZnJvbSB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICBtYXRjaGVzLnNwbGljZSgtMiwgMik7XG4gICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbWF0Y2gsIHAxLCAuLi4sIHBuXG4gICAgICAgICAgICByZXR1cm4gY2IobWF0Y2hlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RyaW5nV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChzLCBzdWJzdHIpIHsgcmV0dXJuIHMuaW5kZXhPZihzdWJzdHIpICE9IC0xOyB9O1xuICAgIFN0cmluZ1dyYXBwZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5nV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLlN0cmluZ1dyYXBwZXIgPSBTdHJpbmdXcmFwcGVyO1xudmFyIFN0cmluZ0pvaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nSm9pbmVyKHBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7IHBhcnRzID0gW107IH1cbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIH1cbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwYXJ0KSB7IHRoaXMucGFydHMucHVzaChwYXJ0KTsgfTtcbiAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJ0cy5qb2luKFwiXCIpOyB9O1xuICAgIHJldHVybiBTdHJpbmdKb2luZXI7XG59KCkpO1xuZXhwb3J0cy5TdHJpbmdKb2luZXIgPSBTdHJpbmdKb2luZXI7XG52YXIgTnVtYmVyUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE51bWJlclBhcnNlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVtYmVyUGFyc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBOdW1iZXJQYXJzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfTtcbiAgICByZXR1cm4gTnVtYmVyUGFyc2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuTnVtYmVyUGFyc2VFcnJvciA9IE51bWJlclBhcnNlRXJyb3I7XG52YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVtYmVyV3JhcHBlcigpIHtcbiAgICB9XG4gICAgTnVtYmVyV3JhcHBlci50b0ZpeGVkID0gZnVuY3Rpb24gKG4sIGZyYWN0aW9uRGlnaXRzKSB7IHJldHVybiBuLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpOyB9O1xuICAgIE51bWJlcldyYXBwZXIuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcbiAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE51bWJlclBhcnNlRXJyb3IoXCJJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgXCIgKyB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTnVtYmVyV3JhcHBlci5wYXJzZUludCA9IGZ1bmN0aW9uICh0ZXh0LCByYWRpeCkge1xuICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05XSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYWRpeCA9PSAxNikge1xuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE51bWJlclBhcnNlRXJyb3IoXCJJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgXCIgKyB0ZXh0ICsgXCIgaW4gYmFzZSBcIiArXG4gICAgICAgICAgICByYWRpeCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBOYU4gaXMgYSB2YWxpZCBsaXRlcmFsIGJ1dCBpcyByZXR1cm5lZCBieSBwYXJzZUZsb2F0IHRvIGluZGljYXRlIGFuIGVycm9yLlxuICAgIE51bWJlcldyYXBwZXIucGFyc2VGbG9hdCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBwYXJzZUZsb2F0KHRleHQpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBcIk5hTlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmFOOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOdW1iZXJXcmFwcGVyLmlzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc05hTih2YWx1ZSk7IH07XG4gICAgTnVtYmVyV3JhcHBlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpOyB9O1xuICAgIHJldHVybiBOdW1iZXJXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuTnVtYmVyV3JhcHBlciA9IE51bWJlcldyYXBwZXI7XG5leHBvcnRzLlJlZ0V4cCA9IF9nbG9iYWwuUmVnRXhwO1xudmFyIFJlZ0V4cFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZ0V4cFdyYXBwZXIoKSB7XG4gICAgfVxuICAgIFJlZ0V4cFdyYXBwZXIuY3JlYXRlID0gZnVuY3Rpb24gKHJlZ0V4cFN0ciwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSAnJzsgfVxuICAgICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoL2cvZywgJycpO1xuICAgICAgICByZXR1cm4gbmV3IF9nbG9iYWwuUmVnRXhwKHJlZ0V4cFN0ciwgZmxhZ3MgKyAnZycpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci5maXJzdE1hdGNoID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgLy8gUmVzZXQgbXVsdGltYXRjaCByZWdleCBzdGF0ZVxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICB9O1xuICAgIFJlZ0V4cFdyYXBwZXIudGVzdCA9IGZ1bmN0aW9uIChyZWdFeHAsIGlucHV0KSB7XG4gICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcmVnRXhwLnRlc3QoaW5wdXQpO1xuICAgIH07XG4gICAgUmVnRXhwV3JhcHBlci5tYXRjaGVyID0gZnVuY3Rpb24gKHJlZ0V4cCwgaW5wdXQpIHtcbiAgICAgICAgLy8gUmVzZXQgcmVnZXggc3RhdGUgZm9yIHRoZSBjYXNlXG4gICAgICAgIC8vIHNvbWVvbmUgZGlkIG5vdCBsb29wIG92ZXIgYWxsIG1hdGNoZXNcbiAgICAgICAgLy8gbGFzdCB0aW1lLlxuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHsgcmU6IHJlZ0V4cCwgaW5wdXQ6IGlucHV0IH07XG4gICAgfTtcbiAgICBSZWdFeHBXcmFwcGVyLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAocmVnRXhwLCBpbnB1dCwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgYyA9IHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICAgICAgdmFyIHJlcyA9ICcnO1xuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIHByZXYgPSAwO1xuICAgICAgICB3aGlsZSAoYykge1xuICAgICAgICAgICAgcmVzICs9IGlucHV0LnN1YnN0cmluZyhwcmV2LCBjLmluZGV4KTtcbiAgICAgICAgICAgIHJlcyArPSByZXBsYWNlKGMpO1xuICAgICAgICAgICAgcHJldiA9IGMuaW5kZXggKyBjWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlZ0V4cC5sYXN0SW5kZXggPSBwcmV2O1xuICAgICAgICAgICAgYyA9IHJlZ0V4cC5leGVjKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXMgKz0gaW5wdXQuc3Vic3RyaW5nKHByZXYpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ0V4cFdyYXBwZXI7XG59KCkpO1xuZXhwb3J0cy5SZWdFeHBXcmFwcGVyID0gUmVnRXhwV3JhcHBlcjtcbnZhciBSZWdFeHBNYXRjaGVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVnRXhwTWF0Y2hlcldyYXBwZXIoKSB7XG4gICAgfVxuICAgIFJlZ0V4cE1hdGNoZXJXcmFwcGVyLm5leHQgPSBmdW5jdGlvbiAobWF0Y2hlcikge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5yZS5leGVjKG1hdGNoZXIuaW5wdXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ0V4cE1hdGNoZXJXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuUmVnRXhwTWF0Y2hlcldyYXBwZXIgPSBSZWdFeHBNYXRjaGVyV3JhcHBlcjtcbnZhciBGdW5jdGlvbldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uV3JhcHBlcigpIHtcbiAgICB9XG4gICAgRnVuY3Rpb25XcmFwcGVyLmFwcGx5ID0gZnVuY3Rpb24gKGZuLCBwb3NBcmdzKSB7IHJldHVybiBmbi5hcHBseShudWxsLCBwb3NBcmdzKTsgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25XcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRnVuY3Rpb25XcmFwcGVyID0gRnVuY3Rpb25XcmFwcGVyO1xuLy8gSlMgaGFzIE5hTiAhPT0gTmFOXG5mdW5jdGlvbiBsb29zZUlkZW50aWNhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGIgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XG59XG5leHBvcnRzLmxvb3NlSWRlbnRpY2FsID0gbG9vc2VJZGVudGljYWw7XG4vLyBKUyBjb25zaWRlcnMgTmFOIGlzIHRoZSBzYW1lIGFzIE5hTiBmb3IgbWFwIEtleSAod2hpbGUgTmFOICE9PSBOYU4gb3RoZXJ3aXNlKVxuLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcFxuZnVuY3Rpb24gZ2V0TWFwS2V5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5nZXRNYXBLZXkgPSBnZXRNYXBLZXk7XG5mdW5jdGlvbiBub3JtYWxpemVCbGFuayhvYmopIHtcbiAgICByZXR1cm4gaXNCbGFuayhvYmopID8gbnVsbCA6IG9iajtcbn1cbmV4cG9ydHMubm9ybWFsaXplQmxhbmsgPSBub3JtYWxpemVCbGFuaztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJvb2wob2JqKSB7XG4gICAgcmV0dXJuIGlzQmxhbmsob2JqKSA/IGZhbHNlIDogb2JqO1xufVxuZXhwb3J0cy5ub3JtYWxpemVCb29sID0gbm9ybWFsaXplQm9vbDtcbmZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBvID09PSBcIm9iamVjdFwiKTtcbn1cbmV4cG9ydHMuaXNKc09iamVjdCA9IGlzSnNPYmplY3Q7XG5mdW5jdGlvbiBwcmludChvYmopIHtcbiAgICBjb25zb2xlLmxvZyhvYmopO1xufVxuZXhwb3J0cy5wcmludCA9IHByaW50O1xuZnVuY3Rpb24gd2FybihvYmopIHtcbiAgICBjb25zb2xlLndhcm4ob2JqKTtcbn1cbmV4cG9ydHMud2FybiA9IHdhcm47XG4vLyBDYW4ndCBiZSBhbGwgdXBwZXJjYXNlIGFzIG91ciB0cmFuc3BpbGVyIHdvdWxkIHRoaW5rIGl0IGlzIGEgc3BlY2lhbCBkaXJlY3RpdmUuLi5cbnZhciBKc29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKc29uKCkge1xuICAgIH1cbiAgICBKc29uLnBhcnNlID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF9nbG9iYWwuSlNPTi5wYXJzZShzKTsgfTtcbiAgICBKc29uLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIERhcnQgZG9lc24ndCB0YWtlIDMgYXJndW1lbnRzXG4gICAgICAgIHJldHVybiBfZ2xvYmFsLkpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICAgIH07XG4gICAgcmV0dXJuIEpzb247XG59KCkpO1xuZXhwb3J0cy5Kc29uID0gSnNvbjtcbnZhciBEYXRlV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVdyYXBwZXIoKSB7XG4gICAgfVxuICAgIERhdGVXcmFwcGVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgaWYgKG1vbnRoID09PSB2b2lkIDApIHsgbW9udGggPSAxOyB9XG4gICAgICAgIGlmIChkYXkgPT09IHZvaWQgMCkgeyBkYXkgPSAxOyB9XG4gICAgICAgIGlmIChob3VyID09PSB2b2lkIDApIHsgaG91ciA9IDA7IH1cbiAgICAgICAgaWYgKG1pbnV0ZXMgPT09IHZvaWQgMCkgeyBtaW51dGVzID0gMDsgfVxuICAgICAgICBpZiAoc2Vjb25kcyA9PT0gdm9pZCAwKSB7IHNlY29uZHMgPSAwOyB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMgPT09IHZvaWQgMCkgeyBtaWxsaXNlY29uZHMgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMpO1xuICAgIH07XG4gICAgRGF0ZVdyYXBwZXIuZnJvbUlTT1N0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIG5ldyBleHBvcnRzLkRhdGUoc3RyKTsgfTtcbiAgICBEYXRlV3JhcHBlci5mcm9tTWlsbGlzID0gZnVuY3Rpb24gKG1zKSB7IHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKG1zKTsgfTtcbiAgICBEYXRlV3JhcHBlci50b01pbGxpcyA9IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfTtcbiAgICBEYXRlV3JhcHBlci5ub3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgZXhwb3J0cy5EYXRlKCk7IH07XG4gICAgRGF0ZVdyYXBwZXIudG9Kc29uID0gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUudG9KU09OKCk7IH07XG4gICAgcmV0dXJuIERhdGVXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRGF0ZVdyYXBwZXIgPSBEYXRlV3JhcHBlcjtcbmZ1bmN0aW9uIHNldFZhbHVlT25QYXRoKGdsb2JhbCwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIG9iaiA9IGdsb2JhbDtcbiAgICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNQcmVzZW50KG9ialtuYW1lXSkpIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtuYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgfVxuICAgIG9ialtwYXJ0cy5zaGlmdCgpXSA9IHZhbHVlO1xufVxuZXhwb3J0cy5zZXRWYWx1ZU9uUGF0aCA9IHNldFZhbHVlT25QYXRoO1xudmFyIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XG5mdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICBpZiAoaXNCbGFuayhfc3ltYm9sSXRlcmF0b3IpKSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZ2xvYmFsU2NvcGUuU3ltYm9sKSAmJiBpc1ByZXNlbnQoU3ltYm9sLml0ZXJhdG9yKSkge1xuICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXM2LXNoaW0gc3BlY2lmaWMgbG9naWNcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtrZXldID09PSBNYXAucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3N5bWJvbEl0ZXJhdG9yO1xufVxuZXhwb3J0cy5nZXRTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbEl0ZXJhdG9yO1xuZnVuY3Rpb24gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsLCBleHByLCBkZWNsYXJhdGlvbnMsIHZhcnMpIHtcbiAgICB2YXIgZm5Cb2R5ID0gZGVjbGFyYXRpb25zICsgXCJcXG5yZXR1cm4gXCIgKyBleHByICsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgc291cmNlVXJsO1xuICAgIHZhciBmbkFyZ05hbWVzID0gW107XG4gICAgdmFyIGZuQXJnVmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgYXJnTmFtZSBpbiB2YXJzKSB7XG4gICAgICAgIGZuQXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgW3ZvaWQgMF0uY29uY2F0KGZuQXJnTmFtZXMuY29uY2F0KGZuQm9keSkpKSkoKS5hcHBseSh2b2lkIDAsIGZuQXJnVmFsdWVzKTtcbn1cbmV4cG9ydHMuZXZhbEV4cHJlc3Npb24gPSBldmFsRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuZnVuY3Rpb24gaGFzQ29uc3RydWN0b3IodmFsdWUsIHR5cGUpIHtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IHR5cGU7XG59XG5leHBvcnRzLmhhc0NvbnN0cnVjdG9yID0gaGFzQ29uc3RydWN0b3I7XG5mdW5jdGlvbiBiaXRXaXNlT3IodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgfCBiOyB9KTtcbn1cbmV4cG9ydHMuYml0V2lzZU9yID0gYml0V2lzZU9yO1xuZnVuY3Rpb24gYml0V2lzZUFuZCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAmIGI7IH0pO1xufVxuZXhwb3J0cy5iaXRXaXNlQW5kID0gYml0V2lzZUFuZDtcbmZ1bmN0aW9uIGVzY2FwZShzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWwuZW5jb2RlVVJJKHMpO1xufVxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGxhbmdfMSA9IHJlcXVpcmUoJy4vbGFuZycpO1xuZXhwb3J0cy5NYXRoID0gbGFuZ18xLmdsb2JhbC5NYXRoO1xuZXhwb3J0cy5OYU4gPSB0eXBlb2YgZXhwb3J0cy5OYU47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbGFuZ18xID0gcmVxdWlyZSgnLi9mYWNhZGUvbGFuZycpO1xudmFyIGJyb3dzZXJfY29tbW9uXzEgPSByZXF1aXJlKCcuL2Jyb3dzZXJfY29tbW9uJyk7XG52YXIgZG9tX2V2ZW50c18xID0gcmVxdWlyZSgnLi9kb20vZXZlbnRzL2RvbV9ldmVudHMnKTtcbmV4cG9ydHMuRG9tRXZlbnRzUGx1Z2luID0gZG9tX2V2ZW50c18xLkRvbUV2ZW50c1BsdWdpbjtcbnZhciBldmVudF9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL2RvbS9ldmVudHMvZXZlbnRfbWFuYWdlcicpO1xuZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBldmVudF9tYW5hZ2VyXzEuRXZlbnRNYW5hZ2VyO1xuZXhwb3J0cy5FVkVOVF9NQU5BR0VSX1BMVUdJTlMgPSBldmVudF9tYW5hZ2VyXzEuRVZFTlRfTUFOQUdFUl9QTFVHSU5TO1xudmFyIG5nX3Byb2JlXzEgPSByZXF1aXJlKCcuL2RvbS9kZWJ1Zy9uZ19wcm9iZScpO1xuZXhwb3J0cy5FTEVNRU5UX1BST0JFX1BST1ZJREVSUyA9IG5nX3Byb2JlXzEuRUxFTUVOVF9QUk9CRV9QUk9WSURFUlM7XG52YXIgYnJvd3Nlcl9jb21tb25fMiA9IHJlcXVpcmUoJy4vYnJvd3Nlcl9jb21tb24nKTtcbmV4cG9ydHMuQlJPV1NFUl9BUFBfQ09NTU9OX1BST1ZJREVSUyA9IGJyb3dzZXJfY29tbW9uXzIuQlJPV1NFUl9BUFBfQ09NTU9OX1BST1ZJREVSUztcbmV4cG9ydHMuQlJPV1NFUl9TQU5JVElaQVRJT05fUFJPVklERVJTID0gYnJvd3Nlcl9jb21tb25fMi5CUk9XU0VSX1NBTklUSVpBVElPTl9QUk9WSURFUlM7XG5leHBvcnRzLkJST1dTRVJfUFJPVklERVJTID0gYnJvd3Nlcl9jb21tb25fMi5CUk9XU0VSX1BST1ZJREVSUztcbmV4cG9ydHMuQnkgPSBicm93c2VyX2NvbW1vbl8yLkJ5O1xuZXhwb3J0cy5UaXRsZSA9IGJyb3dzZXJfY29tbW9uXzIuVGl0bGU7XG5leHBvcnRzLmVuYWJsZURlYnVnVG9vbHMgPSBicm93c2VyX2NvbW1vbl8yLmVuYWJsZURlYnVnVG9vbHM7XG5leHBvcnRzLmRpc2FibGVEZWJ1Z1Rvb2xzID0gYnJvd3Nlcl9jb21tb25fMi5kaXNhYmxlRGVidWdUb29scztcbmV4cG9ydHMuSEFNTUVSX0dFU1RVUkVfQ09ORklHID0gYnJvd3Nlcl9jb21tb25fMi5IQU1NRVJfR0VTVFVSRV9DT05GSUc7XG5leHBvcnRzLkhhbW1lckdlc3R1cmVDb25maWcgPSBicm93c2VyX2NvbW1vbl8yLkhhbW1lckdlc3R1cmVDb25maWc7XG5fX2V4cG9ydChyZXF1aXJlKCcuLi9wcml2YXRlX2V4cG9ydCcpKTtcbnZhciBkb21fdG9rZW5zXzEgPSByZXF1aXJlKCcuL2RvbS9kb21fdG9rZW5zJyk7XG5leHBvcnRzLkRPQ1VNRU5UID0gZG9tX3Rva2Vuc18xLkRPQ1VNRU5UO1xudmFyIGRvbV9zYW5pdGl6YXRpb25fc2VydmljZV8xID0gcmVxdWlyZSgnLi9zZWN1cml0eS9kb21fc2FuaXRpemF0aW9uX3NlcnZpY2UnKTtcbmV4cG9ydHMuRG9tU2FuaXRpemF0aW9uU2VydmljZSA9IGRvbV9zYW5pdGl6YXRpb25fc2VydmljZV8xLkRvbVNhbml0aXphdGlvblNlcnZpY2U7XG5leHBvcnRzLlNlY3VyaXR5Q29udGV4dCA9IGRvbV9zYW5pdGl6YXRpb25fc2VydmljZV8xLlNlY3VyaXR5Q29udGV4dDtcbnZhciBwbGF0Zm9ybV9icm93c2VyX3N0YXRpY18xID0gcmVxdWlyZSgnLi9wbGF0Zm9ybV9icm93c2VyX3N0YXRpYycpO1xuZXhwb3J0cy5ib290c3RyYXBTdGF0aWMgPSBwbGF0Zm9ybV9icm93c2VyX3N0YXRpY18xLmJvb3RzdHJhcFN0YXRpYztcbmV4cG9ydHMuYnJvd3NlclN0YXRpY1BsYXRmb3JtID0gcGxhdGZvcm1fYnJvd3Nlcl9zdGF0aWNfMS5icm93c2VyU3RhdGljUGxhdGZvcm07XG5leHBvcnRzLkJST1dTRVJfQVBQX1NUQVRJQ19QUk9WSURFUlMgPSBwbGF0Zm9ybV9icm93c2VyX3N0YXRpY18xLkJST1dTRVJfQVBQX1NUQVRJQ19QUk9WSURFUlM7XG5leHBvcnRzLkJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uID0gcGxhdGZvcm1fYnJvd3Nlcl9zdGF0aWNfMS5Ccm93c2VyUGxhdGZvcm1Mb2NhdGlvbjtcbmZ1bmN0aW9uIGJyb3dzZXJQbGF0Zm9ybSgpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29yZV8xLmdldFBsYXRmb3JtKCkpKSB7XG4gICAgICAgIGNvcmVfMS5jcmVhdGVQbGF0Zm9ybShjb3JlXzEuUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoYnJvd3Nlcl9jb21tb25fMS5CUk9XU0VSX1BST1ZJREVSUykpO1xuICAgIH1cbiAgICByZXR1cm4gY29yZV8xLmFzc2VydFBsYXRmb3JtKGJyb3dzZXJfY29tbW9uXzEuQlJPV1NFUl9QTEFURk9STV9NQVJLRVIpO1xufVxuZXhwb3J0cy5icm93c2VyUGxhdGZvcm0gPSBicm93c2VyUGxhdGZvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybV9icm93c2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBsYW5nXzEgPSByZXF1aXJlKCcuL2ZhY2FkZS9sYW5nJyk7XG52YXIgYnJvd3Nlcl9jb21tb25fMSA9IHJlcXVpcmUoJy4vYnJvd3Nlcl9jb21tb24nKTtcbnZhciBuZ19wcm9iZV8xID0gcmVxdWlyZSgnLi9kb20vZGVidWcvbmdfcHJvYmUnKTtcbmV4cG9ydHMuRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMgPSBuZ19wcm9iZV8xLkVMRU1FTlRfUFJPQkVfUFJPVklERVJTO1xudmFyIGJyb3dzZXJfcGxhdGZvcm1fbG9jYXRpb25fMSA9IHJlcXVpcmUoJy4vYnJvd3Nlci9sb2NhdGlvbi9icm93c2VyX3BsYXRmb3JtX2xvY2F0aW9uJyk7XG5leHBvcnRzLkJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uID0gYnJvd3Nlcl9wbGF0Zm9ybV9sb2NhdGlvbl8xLkJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uO1xudmFyIGJyb3dzZXJfY29tbW9uXzIgPSByZXF1aXJlKCcuL2Jyb3dzZXJfY29tbW9uJyk7XG5leHBvcnRzLkJST1dTRVJfUFJPVklERVJTID0gYnJvd3Nlcl9jb21tb25fMi5CUk9XU0VSX1BST1ZJREVSUztcbmV4cG9ydHMuQnkgPSBicm93c2VyX2NvbW1vbl8yLkJ5O1xuZXhwb3J0cy5UaXRsZSA9IGJyb3dzZXJfY29tbW9uXzIuVGl0bGU7XG5leHBvcnRzLmVuYWJsZURlYnVnVG9vbHMgPSBicm93c2VyX2NvbW1vbl8yLmVuYWJsZURlYnVnVG9vbHM7XG5leHBvcnRzLmRpc2FibGVEZWJ1Z1Rvb2xzID0gYnJvd3Nlcl9jb21tb25fMi5kaXNhYmxlRGVidWdUb29scztcbi8qKlxuICogQW4gYXJyYXkgb2YgcHJvdmlkZXJzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBpbnRvIGBhcHBsaWNhdGlvbigpYCB3aGVuIGJvb3RzdHJhcHBpbmcgYSBjb21wb25lbnRcbiAqIHdoZW4gYWxsIHRlbXBsYXRlc1xuICogaGF2ZSBiZWVuIHByZWNvbXBpbGVkIG9mZmxpbmUuXG4gKi9cbmV4cG9ydHMuQlJPV1NFUl9BUFBfU1RBVElDX1BST1ZJREVSUyA9IFxuLypAdHMyZGFydF9jb25zdCovIGJyb3dzZXJfY29tbW9uXzEuQlJPV1NFUl9BUFBfQ09NTU9OX1BST1ZJREVSUztcbmZ1bmN0aW9uIGJyb3dzZXJTdGF0aWNQbGF0Zm9ybSgpIHtcbiAgICBpZiAobGFuZ18xLmlzQmxhbmsoY29yZV8xLmdldFBsYXRmb3JtKCkpKSB7XG4gICAgICAgIGNvcmVfMS5jcmVhdGVQbGF0Zm9ybShjb3JlXzEuUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoYnJvd3Nlcl9jb21tb25fMS5CUk9XU0VSX1BST1ZJREVSUykpO1xuICAgIH1cbiAgICByZXR1cm4gY29yZV8xLmFzc2VydFBsYXRmb3JtKGJyb3dzZXJfY29tbW9uXzEuQlJPV1NFUl9QTEFURk9STV9NQVJLRVIpO1xufVxuZXhwb3J0cy5icm93c2VyU3RhdGljUGxhdGZvcm0gPSBicm93c2VyU3RhdGljUGxhdGZvcm07XG4vKipcbiAqIFNlZSB7QGxpbmsgYm9vdHN0cmFwfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gYm9vdHN0cmFwU3RhdGljKGFwcENvbXBvbmVudFR5cGUsIGN1c3RvbVByb3ZpZGVycywgaW5pdFJlZmxlY3Rvcikge1xuICAgIGlmIChsYW5nXzEuaXNQcmVzZW50KGluaXRSZWZsZWN0b3IpKSB7XG4gICAgICAgIGluaXRSZWZsZWN0b3IoKTtcbiAgICB9XG4gICAgdmFyIGFwcFByb3ZpZGVycyA9IGxhbmdfMS5pc1ByZXNlbnQoY3VzdG9tUHJvdmlkZXJzKSA/IFtleHBvcnRzLkJST1dTRVJfQVBQX1NUQVRJQ19QUk9WSURFUlMsIGN1c3RvbVByb3ZpZGVyc10gOlxuICAgICAgICBleHBvcnRzLkJST1dTRVJfQVBQX1NUQVRJQ19QUk9WSURFUlM7XG4gICAgdmFyIGFwcEluamVjdG9yID0gY29yZV8xLlJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKGFwcFByb3ZpZGVycywgYnJvd3NlclN0YXRpY1BsYXRmb3JtKCkuaW5qZWN0b3IpO1xuICAgIHJldHVybiBjb3JlXzEuY29yZUxvYWRBbmRCb290c3RyYXAoYXBwSW5qZWN0b3IsIGFwcENvbXBvbmVudFR5cGUpO1xufVxuZXhwb3J0cy5ib290c3RyYXBTdGF0aWMgPSBib290c3RyYXBTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybV9icm93c2VyX3N0YXRpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHVybF9zYW5pdGl6ZXJfMSA9IHJlcXVpcmUoJy4vdXJsX3Nhbml0aXplcicpO1xudmFyIHN0eWxlX3Nhbml0aXplcl8xID0gcmVxdWlyZSgnLi9zdHlsZV9zYW5pdGl6ZXInKTtcbnZhciBjb3JlX3ByaXZhdGVfMSA9IHJlcXVpcmUoJy4uLy4uL2NvcmVfcHJpdmF0ZScpO1xuZXhwb3J0cy5TZWN1cml0eUNvbnRleHQgPSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQ7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xuLyoqXG4gKiBEb21TYW5pdGl6YXRpb25TZXJ2aWNlIGhlbHBzIHByZXZlbnRpbmcgQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgU2VjdXJpdHkgYnVncyAoWFNTKSBieSBzYW5pdGl6aW5nXG4gKiB2YWx1ZXMgdG8gYmUgc2FmZSB0byB1c2UgaW4gdGhlIGRpZmZlcmVudCBET00gY29udGV4dHMuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gYmluZGluZyBhIFVSTCBpbiBhbiBgPGEgW2hyZWZdPVwic29tZVZhbHVlXCI+YCBoeXBlcmxpbmssIGBzb21lVmFsdWVgIHdpbGwgYmVcbiAqIHNhbml0aXplZCBzbyB0aGF0IGFuIGF0dGFja2VyIGNhbm5vdCBpbmplY3QgZS5nLiBhIGBqYXZhc2NyaXB0OmAgVVJMIHRoYXQgd291bGQgZXhlY3V0ZSBjb2RlIG9uXG4gKiB0aGUgd2Vic2l0ZS5cbiAqXG4gKiBJbiBzcGVjaWZpYyBzaXR1YXRpb25zLCBpdCBtaWdodCBiZSBuZWNlc3NhcnkgdG8gZGlzYWJsZSBzYW5pdGl6YXRpb24sIGZvciBleGFtcGxlIGlmIHRoZVxuICogYXBwbGljYXRpb24gZ2VudWluZWx5IG5lZWRzIHRvIHByb2R1Y2UgYSBgamF2YXNjcmlwdDpgIHN0eWxlIGxpbmsgd2l0aCBhIGR5bmFtaWMgdmFsdWUgaW4gaXQuXG4gKiBVc2VycyBjYW4gYnlwYXNzIHNlY3VyaXR5IGJ5IGNvbnN0cnVjdGluZyBhIHZhbHVlIHdpdGggb25lIG9mIHRoZSBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmBcbiAqIG1ldGhvZHMsIGFuZCB0aGVuIGJpbmRpbmcgdG8gdGhhdCB2YWx1ZSBmcm9tIHRoZSB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGVzZSBzaXR1YXRpb25zIHNob3VsZCBiZSB2ZXJ5IHJhcmUsIGFuZCBleHRyYW9yZGluYXJ5IGNhcmUgbXVzdCBiZSB0YWtlbiB0byBhdm9pZCBjcmVhdGluZyBhXG4gKiBDcm9zcyBTaXRlIFNjcmlwdGluZyAoWFNTKSBzZWN1cml0eSBidWchXG4gKlxuICogV2hlbiB1c2luZyBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmAsIG1ha2Ugc3VyZSB0byBjYWxsIHRoZSBtZXRob2QgYXMgZWFybHkgYXMgcG9zc2libGUgYW5kIGFzXG4gKiBjbG9zZSBhcyBwb3NzaWJsZSB0byB0aGUgc291cmNlIG9mIHRoZSB2YWx1ZSwgdG8gbWFrZSBpdCBlYXN5IHRvIHZlcmlmeSBubyBzZWN1cml0eSBidWcgaXNcbiAqIGNyZWF0ZWQgYnkgaXRzIHVzZS5cbiAqXG4gKiBJdCBpcyBub3QgcmVxdWlyZWQgKGFuZCBub3QgcmVjb21tZW5kZWQpIHRvIGJ5cGFzcyBzZWN1cml0eSBpZiB0aGUgdmFsdWUgaXMgc2FmZSwgZS5nLiBhIFVSTCB0aGF0XG4gKiBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3VzcGljaW91cyBwcm90b2NvbCwgb3IgYW4gSFRNTCBzbmlwcGV0IHRoYXQgZG9lcyBub3QgY29udGFpbiBkYW5nZXJvdXNcbiAqIGNvZGUuIFRoZSBzYW5pdGl6ZXIgbGVhdmVzIHNhZmUgdmFsdWVzIGludGFjdC5cbiAqL1xudmFyIERvbVNhbml0aXphdGlvblNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvbVNhbml0aXphdGlvblNlcnZpY2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBEb21TYW5pdGl6YXRpb25TZXJ2aWNlO1xufSgpKTtcbmV4cG9ydHMuRG9tU2FuaXRpemF0aW9uU2VydmljZSA9IERvbVNhbml0aXphdGlvblNlcnZpY2U7XG52YXIgRG9tU2FuaXRpemF0aW9uU2VydmljZUltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIERvbVNhbml0aXphdGlvblNlcnZpY2VJbXBsLnByb3RvdHlwZS5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChjdHgsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHN3aXRjaCAoY3R4KSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfcHJpdmF0ZV8xLlNlY3VyaXR5Q29udGV4dC5OT05FOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgY29yZV9wcml2YXRlXzEuU2VjdXJpdHlDb250ZXh0LkhUTUw6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZUh0bWxJbXBsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm90U2FmZVZhbHVlKHZhbHVlLCAnSFRNTCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplSHRtbChTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgY29yZV9wcml2YXRlXzEuU2VjdXJpdHlDb250ZXh0LlNUWUxFOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTdHlsZUltcGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RTYWZlVmFsdWUodmFsdWUsICdTdHlsZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZV9zYW5pdGl6ZXJfMS5zYW5pdGl6ZVN0eWxlKHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgY29yZV9wcml2YXRlXzEuU2VjdXJpdHlDb250ZXh0LlNDUklQVDpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlU2NyaXB0SW1wbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1NjcmlwdCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlIHZhbHVlIHVzZWQgaW4gYSBzY3JpcHQgY29udGV4dCcpO1xuICAgICAgICAgICAgY2FzZSBjb3JlX3ByaXZhdGVfMS5TZWN1cml0eUNvbnRleHQuVVJMOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVVcmxJbXBsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm90U2FmZVZhbHVlKHZhbHVlLCAnVVJMJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybF9zYW5pdGl6ZXJfMS5zYW5pdGl6ZVVybChTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgY29yZV9wcml2YXRlXzEuU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTDpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlUmVzb3VyY2VVcmxJbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm90U2FmZVZhbHVlKHZhbHVlLCAnUmVzb3VyY2VVUkwnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgcmVzb3VyY2UgVVJMIGNvbnRleHQnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZWN1cml0eUNvbnRleHQgXCIgKyBjdHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbC5wcm90b3R5cGUuY2hlY2tOb3RTYWZlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTYWZlVmFsdWVJbXBsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIGEgc2FmZSAnICsgZXhwZWN0ZWRUeXBlICsgJywgZ290IGEgJyArIHZhbHVlLmdldFR5cGVOYW1lKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbC5wcm90b3R5cGUuc2FuaXRpemVIdG1sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIFRPRE8obWFydGlucHJvYnN0KTogaW1wbGVtZW50LlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdEh0bWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBTYWZlSHRtbEltcGwodmFsdWUpOyB9O1xuICAgIERvbVNhbml0aXphdGlvblNlcnZpY2VJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBTYWZlU3R5bGVJbXBsKHZhbHVlKTsgfTtcbiAgICBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdFNjcmlwdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVTY3JpcHRJbXBsKHZhbHVlKTsgfTtcbiAgICBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdFVybCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVVcmxJbXBsKHZhbHVlKTsgfTtcbiAgICBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbC5wcm90b3R5cGUuYnlwYXNzU2VjdXJpdHlUcnVzdFJlc291cmNlVXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZVJlc291cmNlVXJsSW1wbCh2YWx1ZSk7XG4gICAgfTtcbiAgICBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gRG9tU2FuaXRpemF0aW9uU2VydmljZUltcGw7XG59KERvbVNhbml0aXphdGlvblNlcnZpY2UpKTtcbmV4cG9ydHMuRG9tU2FuaXRpemF0aW9uU2VydmljZUltcGwgPSBEb21TYW5pdGl6YXRpb25TZXJ2aWNlSW1wbDtcbnZhciBTYWZlVmFsdWVJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTYWZlVmFsdWVJbXBsKGNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHkpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5ID0gY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgLy8gZW1wdHlcbiAgICB9XG4gICAgcmV0dXJuIFNhZmVWYWx1ZUltcGw7XG59KCkpO1xudmFyIFNhZmVIdG1sSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVIdG1sSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlSHRtbEltcGwoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTYWZlSHRtbEltcGwucHJvdG90eXBlLmdldFR5cGVOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0hUTUwnOyB9O1xuICAgIHJldHVybiBTYWZlSHRtbEltcGw7XG59KFNhZmVWYWx1ZUltcGwpKTtcbnZhciBTYWZlU3R5bGVJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN0eWxlSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlU3R5bGVJbXBsKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2FmZVN0eWxlSW1wbC5wcm90b3R5cGUuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnU3R5bGUnOyB9O1xuICAgIHJldHVybiBTYWZlU3R5bGVJbXBsO1xufShTYWZlVmFsdWVJbXBsKSk7XG52YXIgU2FmZVNjcmlwdEltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlU2NyaXB0SW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlU2NyaXB0SW1wbCgpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFNhZmVTY3JpcHRJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTY3JpcHQnOyB9O1xuICAgIHJldHVybiBTYWZlU2NyaXB0SW1wbDtcbn0oU2FmZVZhbHVlSW1wbCkpO1xudmFyIFNhZmVVcmxJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVVybEltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVVybEltcGwoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBTYWZlVXJsSW1wbC5wcm90b3R5cGUuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnVVJMJzsgfTtcbiAgICByZXR1cm4gU2FmZVVybEltcGw7XG59KFNhZmVWYWx1ZUltcGwpKTtcbnZhciBTYWZlUmVzb3VyY2VVcmxJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVJlc291cmNlVXJsSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlUmVzb3VyY2VVcmxJbXBsKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgU2FmZVJlc291cmNlVXJsSW1wbC5wcm90b3R5cGUuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnUmVzb3VyY2VVUkwnOyB9O1xuICAgIHJldHVybiBTYWZlUmVzb3VyY2VVcmxJbXBsO1xufShTYWZlVmFsdWVJbXBsKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21fc2FuaXRpemF0aW9uX3NlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiogUmVndWxhciBleHByZXNzaW9uIGZvciBzYWZlIHN0eWxlIHZhbHVlcy5cbipcbiogUXVvdGVzIChcIiBhbmQgJykgYXJlIGFsbG93ZWQsIGJ1dCBhIGNoZWNrIG11c3QgYmUgZG9uZSBlbHNld2hlcmUgdG8gZW5zdXJlXG4qIHRoZXkncmUgYmFsYW5jZWQuXG4qXG4qICcsJyBhbGxvd3MgbXVsdGlwbGUgdmFsdWVzIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBzYW1lIHByb3BlcnR5XG4qIChlLmcuIGJhY2tncm91bmQtYXR0YWNobWVudCBvciBmb250LWZhbWlseSkgYW5kIGhlbmNlIGNvdWxkIGFsbG93XG4qIG11bHRpcGxlIHZhbHVlcyB0byBnZXQgaW5qZWN0ZWQsIGJ1dCB0aGF0IHNob3VsZCBwb3NlIG5vIHJpc2sgb2YgWFNTLlxuKlxuKiBUaGUgcmdiKCkgYW5kIHJnYmEoKSBleHByZXNzaW9uIGNoZWNrcyBvbmx5IGZvciBYU1Mgc2FmZXR5LCBub3QgZm9yIENTU1xuKiB2YWxpZGl0eS5cbipcbiogVGhpcyByZWd1bGFyIGV4cHJlc3Npb24gd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnkuXG4qL1xudmFyIFNBRkVfU1RZTEVfVkFMVUUgPSAvXihbLSwuXCInJV8hIyBhLXpBLVowLTldK3woPzpyZ2J8aHNsKWE/XFwoWzAtOS4lLCBdK1xcKSkkLztcbi8qKlxuICogQ2hlY2tzIHRoYXQgcXVvdGVzIChcIiBhbmQgJykgYXJlIHByb3Blcmx5IGJhbGFuY2VkIGluc2lkZSBhIHN0cmluZy4gQXNzdW1lc1xuICogdGhhdCBuZWl0aGVyIGVzY2FwZSAoXFwpIG5vciBhbnkgb3RoZXIgY2hhcmFjdGVyIHRoYXQgY291bGQgcmVzdWx0IGluXG4gKiBicmVha2luZyBvdXQgb2YgYSBzdHJpbmcgcGFyc2luZyBjb250ZXh0IGFyZSBhbGxvd2VkO1xuICogc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4LyNzdHJpbmctdG9rZW4tZGlhZ3JhbS5cbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnkuXG4gKi9cbmZ1bmN0aW9uIGhhc0JhbGFuY2VkUXVvdGVzKHZhbHVlKSB7XG4gICAgdmFyIG91dHNpZGVTaW5nbGUgPSB0cnVlO1xuICAgIHZhciBvdXRzaWRlRG91YmxlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gdmFsdWUuY2hhckF0KGkpO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcJycgJiYgb3V0c2lkZURvdWJsZSkge1xuICAgICAgICAgICAgb3V0c2lkZVNpbmdsZSA9ICFvdXRzaWRlU2luZ2xlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09ICdcIicgJiYgb3V0c2lkZVNpbmdsZSkge1xuICAgICAgICAgICAgb3V0c2lkZURvdWJsZSA9ICFvdXRzaWRlRG91YmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlU2luZ2xlICYmIG91dHNpZGVEb3VibGU7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVN0eWxlKHZhbHVlKSB7XG4gICAgaWYgKFN0cmluZyh2YWx1ZSkubWF0Y2goU0FGRV9TVFlMRV9WQUxVRSkgJiYgaGFzQmFsYW5jZWRRdW90ZXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuICd1bnNhZmUnO1xufVxuZXhwb3J0cy5zYW5pdGl6ZVN0eWxlID0gc2FuaXRpemVTdHlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlX3Nhbml0aXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4qXG4qIFRoaXMgcmVndWxhciBleHByZXNzaW9uIG1hdGNoZXMgYSBzdWJzZXQgb2YgVVJMcyB0aGF0IHdpbGwgbm90IGNhdXNlIHNjcmlwdFxuKiBleGVjdXRpb24gaWYgdXNlZCBpbiBVUkwgY29udGV4dCB3aXRoaW4gYSBIVE1MIGRvY3VtZW50LiBTcGVjaWZpY2FsbHksIHRoaXNcbiogcmVndWxhciBleHByZXNzaW9uIG1hdGNoZXMgaWYgKGNvbW1lbnQgZnJvbSBoZXJlIG9uIGFuZCByZWdleCBjb3BpZWQgZnJvbVxuKiBTb3kncyBFc2NhcGluZ0NvbnZlbnRpb25zKTpcbiogKDEpIEVpdGhlciBhIHByb3RvY29sIGluIGEgd2hpdGVsaXN0IChodHRwLCBodHRwcywgbWFpbHRvIG9yIGZ0cCkuXG4qICgyKSBvciBubyBwcm90b2NvbC4gIEEgcHJvdG9jb2wgbXVzdCBiZSBmb2xsb3dlZCBieSBhIGNvbG9uLiBUaGUgYmVsb3dcbiogICAgIGFsbG93cyB0aGF0IGJ5IGFsbG93aW5nIGNvbG9ucyBvbmx5IGFmdGVyIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBbLz8jXS5cbiogICAgIEEgY29sb24gYWZ0ZXIgYSBoYXNoICgjKSBtdXN0IGJlIGluIHRoZSBmcmFnbWVudC5cbiogICAgIE90aGVyd2lzZSwgYSBjb2xvbiBhZnRlciBhICg/KSBtdXN0IGJlIGluIGEgcXVlcnkuXG4qICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSBzaW5nbGUgc29saWR1cyAoLykgbXVzdCBiZSBpbiBhIHBhdGguXG4qICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSBkb3VibGUgc29saWR1cyAoLy8pIG11c3QgYmUgaW4gdGhlIGF1dGhvcml0eVxuKiAgICAgKGJlZm9yZSBwb3J0KS5cbipcbiogVGhlIHBhdHRlcm4gZGlzYWxsb3dzICYsIHVzZWQgaW4gSFRNTCBlbnRpdHkgZGVjbGFyYXRpb25zIGJlZm9yZVxuKiBvbmUgb2YgdGhlIGNoYXJhY3RlcnMgaW4gWy8/I10uIFRoaXMgZGlzYWxsb3dzIEhUTUwgZW50aXRpZXMgdXNlZCBpbiB0aGVcbiogcHJvdG9jb2wgbmFtZSwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiwgZS5nLiBcImgmIzExNjt0cFwiIGZvciBcImh0dHBcIi5cbiogSXQgYWxzbyBkaXNhbGxvd3MgSFRNTCBlbnRpdGllcyBpbiB0aGUgZmlyc3QgcGF0aCBwYXJ0IG9mIGEgcmVsYXRpdmUgcGF0aCxcbiogZS5nLiBcImZvbyZsdDtiYXIvYmF6XCIuICBPdXIgZXhpc3RpbmcgZXNjYXBpbmcgZnVuY3Rpb25zIHNob3VsZCBub3QgcHJvZHVjZVxuKiB0aGF0LiBNb3JlIGltcG9ydGFudGx5LCBpdCBkaXNhbGxvd3MgbWFza2luZyBvZiBhIGNvbG9uLFxuKiBlLmcuIFwiamF2YXNjcmlwdCYjNTg7Li4uXCIuXG4qXG4qIFRoaXMgcmVndWxhciBleHByZXNzaW9uIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LlxuKi9cbnZhciBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naTtcbmZ1bmN0aW9uIHNhbml0aXplVXJsKHVybCkge1xuICAgIGlmIChTdHJpbmcodXJsKS5tYXRjaChTQUZFX1VSTF9QQVRURVJOKSlcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICByZXR1cm4gJ3Vuc2FmZTonICsgdXJsO1xufVxuZXhwb3J0cy5zYW5pdGl6ZVVybCA9IHNhbml0aXplVXJsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsX3Nhbml0aXplci5qcy5tYXAiLCIoZnVuY3Rpb24obmFtZSwgZGVmaW5pdGlvbikge1xuXG4vKioqKioqKioqKioqKioqKlxuICogIEEgdG9sZXJhbnQsIG1pbmltYWwgaWNhbGVuZGFyIHBhcnNlclxuICogIChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NTQ1KVxuICpcbiAqICA8cGV0ZXJicmFkZW5AcGV0ZXJicmFkZW4uY28udWs+XG4gKiAqKioqKioqKioqKioqKi9cblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0Jyl7XG4gICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHRoaXNbbmFtZV0gPSBkZWZpbml0aW9uKCk7XG4gIH1cblxufSgnaWNhbCcsIGZ1bmN0aW9uKCl7XG5cbiAgIC8vIFVuZXNjYXBlIFRleHQgcmUgUkZDIDQuMy4xMVxuICB2YXIgdGV4dCA9IGZ1bmN0aW9uKHQpe1xuICAgIHQgPSB0IHx8IFwiXCI7XG4gICAgcmV0dXJuICh0XG4gICAgICAucmVwbGFjZSgvXFxcXFxcLC9nLCAnLCcpXG4gICAgICAucmVwbGFjZSgvXFxcXFxcOy9nLCAnOycpXG4gICAgICAucmVwbGFjZSgvXFxcXFtuTl0vZywgJ1xcbicpXG4gICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKVxuICAgIClcbiAgfVxuXG4gIHZhciBwYXJzZVBhcmFtcyA9IGZ1bmN0aW9uKHApe1xuICAgIHZhciBvdXQgPSB7fVxuICAgIGZvciAodmFyIGkgPSAwOyBpPHAubGVuZ3RoOyBpKyspe1xuICAgICAgaWYgKHBbaV0uaW5kZXhPZignPScpID4gLTEpe1xuICAgICAgICB2YXIgc2VncyA9IHBbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgXG4gICAgICAgIG91dFtzZWdzWzBdXSA9IHBhcnNlVmFsdWUoc2Vncy5zbGljZSgxKS5qb2luKCc9JykpO1xuICAgICAgICBcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dCB8fCBzcFxuICB9XG5cbiAgdmFyIHBhcnNlVmFsdWUgPSBmdW5jdGlvbih2YWwpe1xuICAgIGlmICgnVFJVRScgPT09IHZhbClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIFxuICAgIGlmICgnRkFMU0UnID09PSB2YWwpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbnVtYmVyID0gTnVtYmVyKHZhbCk7XG4gICAgaWYgKCFpc05hTihudW1iZXIpKVxuICAgICAgcmV0dXJuIG51bWJlcjtcblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICB2YXIgc3RvcmVQYXJhbSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiBmdW5jdGlvbih2YWwsIHBhcmFtcywgY3Vycil7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmxlbmd0aCAmJiAhKHBhcmFtcy5sZW5ndGg9PTEgJiYgcGFyYW1zWzBdPT09J0NIQVJTRVQ9dXRmLTgnKSl7XG4gICAgICAgIGRhdGEgPSB7cGFyYW1zOnBhcnNlUGFyYW1zKHBhcmFtcyksIHZhbDp0ZXh0KHZhbCl9XG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGRhdGEgPSB0ZXh0KHZhbClcblxuICAgICAgdmFyIGN1cnJlbnQgPSBjdXJyW25hbWVdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpe1xuICAgICAgICBjdXJyZW50LnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCAhPSBudWxsKXtcbiAgICAgICAgY3VycltuYW1lXSA9IFtjdXJyZW50LCBkYXRhXTtcbiAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICB9XG5cbiAgICAgIGN1cnJbbmFtZV0gPSBkYXRhO1xuICAgICAgcmV0dXJuIGN1cnJcbiAgICB9XG4gIH1cblxuICB2YXIgYWRkVFogPSBmdW5jdGlvbihkdCwgbmFtZSwgcGFyYW1zKXtcbiAgICB2YXIgcCA9IHBhcnNlUGFyYW1zKHBhcmFtcyk7XG5cbiAgICBpZiAocGFyYW1zICYmIHApe1xuICAgICAgZHRbbmFtZV0udHogPSBwLlRaSURcbiAgICB9XG5cbiAgICByZXR1cm4gZHRcbiAgfVxuXG5cbiAgdmFyIGRhdGVQYXJhbSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiBmdW5jdGlvbih2YWwsIHBhcmFtcywgY3Vycil7XG5cbiAgICAgIC8vIFN0b3JlIGFzIHN0cmluZyAtIHdvcnN0IGNhc2Ugc2NlbmFyaW9cbiAgICAgIHN0b3JlUGFyYW0obmFtZSkodmFsLCB1bmRlZmluZWQsIGN1cnIpXG5cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zWzBdID09PSBcIlZBTFVFPURBVEVcIikge1xuICAgICAgICAvLyBKdXN0IERhdGVcblxuICAgICAgICB2YXIgY29tcHMgPSAvXihcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KSQvLmV4ZWModmFsKTtcbiAgICAgICAgaWYgKGNvbXBzICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gTm8gVFogaW5mbyAtIGFzc3VtZSBzYW1lIHRpbWV6b25lIGFzIHRoaXMgY29tcHV0ZXJcbiAgICAgICAgICBjdXJyW25hbWVdID0gbmV3IERhdGUoXG4gICAgICAgICAgICBjb21wc1sxXSxcbiAgICAgICAgICAgIHBhcnNlSW50KGNvbXBzWzJdLCAxMCktMSxcbiAgICAgICAgICAgIGNvbXBzWzNdXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHJldHVybiBhZGRUWihjdXJyLCBuYW1lLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLy90eXBpY2FsIFJGQyBkYXRlLXRpbWUgZm9ybWF0XG4gICAgICB2YXIgY29tcHMgPSAvXihcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KVQoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkoWik/JC8uZXhlYyh2YWwpO1xuICAgICAgaWYgKGNvbXBzICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjb21wc1s3XSA9PSAnWicpeyAvLyBHTVRcbiAgICAgICAgICBjdXJyW25hbWVdID0gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICAgICBwYXJzZUludChjb21wc1sxXSwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoY29tcHNbMl0sIDEwKS0xLFxuICAgICAgICAgICAgcGFyc2VJbnQoY29tcHNbM10sIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGNvbXBzWzRdLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChjb21wc1s1XSwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoY29tcHNbNl0sIDEwIClcbiAgICAgICAgICApKTtcbiAgICAgICAgICAvLyBUT0RPIGFkZCB0elxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJbbmFtZV0gPSBuZXcgRGF0ZShcbiAgICAgICAgICAgIHBhcnNlSW50KGNvbXBzWzFdLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChjb21wc1syXSwgMTApLTEsXG4gICAgICAgICAgICBwYXJzZUludChjb21wc1szXSwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoY29tcHNbNF0sIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGNvbXBzWzVdLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChjb21wc1s2XSwgMTApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkVFooY3VyciwgbmFtZSwgcGFyYW1zKVxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIGdlb1BhcmFtID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCwgcGFyYW1zLCBjdXJyKXtcbiAgICAgIHN0b3JlUGFyYW0odmFsLCBwYXJhbXMsIGN1cnIpXG4gICAgICB2YXIgcGFydHMgPSB2YWwuc3BsaXQoJzsnKTtcbiAgICAgIGN1cnJbbmFtZV0gPSB7bGF0Ok51bWJlcihwYXJ0c1swXSksIGxvbjpOdW1iZXIocGFydHNbMV0pfTtcbiAgICAgIHJldHVybiBjdXJyXG4gICAgfVxuICB9XG5cbiAgdmFyIGNhdGVnb3JpZXNQYXJhbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNlcGFyYXRvclBhdHRlcm4gPSAvXFxzKixcXHMqL2c7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBhcmFtcywgY3Vycikge1xuICAgICAgc3RvcmVQYXJhbSh2YWwsIHBhcmFtcywgY3VycilcbiAgICAgIGN1cnJbbmFtZV0gPSB2YWwgPyB2YWwuc3BsaXQoc2VwYXJhdG9yUGF0dGVybikgOiBbXVxuICAgICAgcmV0dXJuIGN1cnJcbiAgICB9XG4gIH1cblxuICB2YXIgYWRkRkJUeXBlID0gZnVuY3Rpb24oZmIsIHBhcmFtcyl7XG4gICAgdmFyIHAgPSBwYXJzZVBhcmFtcyhwYXJhbXMpO1xuXG4gICAgaWYgKHBhcmFtcyAmJiBwKXtcbiAgICAgIGZiLnR5cGUgPSBwLkZCVFlQRSB8fCBcIkJVU1lcIlxuICAgIH1cblxuICAgIHJldHVybiBmYjtcbiAgfVxuXG4gIHZhciBmcmVlYnVzeVBhcmFtID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsLCBwYXJhbXMsIGN1cnIpe1xuICAgICAgdmFyIGZiID0gYWRkRkJUeXBlKHt9LCBwYXJhbXMpO1xuICAgICAgY3VycltuYW1lXSA9IGN1cnJbbmFtZV0gfHwgW11cbiAgICAgIGN1cnJbbmFtZV0ucHVzaChmYik7XG5cbiAgICAgIHN0b3JlUGFyYW0odmFsLCBwYXJhbXMsIGZiKTtcblxuICAgICAgdmFyIHBhcnRzID0gdmFsLnNwbGl0KCcvJyk7XG5cbiAgICAgIFsnc3RhcnQnLCAnZW5kJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgICAgICAgZGF0ZVBhcmFtKG5hbWUpKHBhcnRzW2luZGV4XSwgcGFyYW1zLCBmYik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGN1cnI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcblxuXG4gICAgb2JqZWN0SGFuZGxlcnMgOiB7XG4gICAgICAnQkVHSU4nIDogZnVuY3Rpb24oY29tcG9uZW50LCBwYXJhbXMsIGN1cnIsIHN0YWNrKXtcbiAgICAgICAgICBzdGFjay5wdXNoKGN1cnIpXG5cbiAgICAgICAgICByZXR1cm4ge3R5cGU6Y29tcG9uZW50LCBwYXJhbXM6cGFyYW1zfVxuICAgICAgICB9XG5cbiAgICAgICwgJ0VORCcgOiBmdW5jdGlvbihjb21wb25lbnQsIHBhcmFtcywgY3Vyciwgc3RhY2spe1xuICAgICAgICAvLyBwcmV2ZW50cyB0aGUgbmVlZCB0byBzZWFyY2ggdGhlIHJvb3Qgb2YgdGhlIHRyZWUgZm9yIHRoZSBWQ0FMRU5EQVIgb2JqZWN0XG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IFwiVkNBTEVOREFSXCIpIHtcbiAgICAgICAgICAgIC8vc2NhbiBhbGwgaGlnaCBsZXZlbCBvYmplY3QgaW4gY3VyciBhbmQgZHJvcCBhbGwgc3RyaW5nc1xuICAgICAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgICAgICBvYmo7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGN1cnIpIHtcbiAgICAgICAgICAgICAgICBpZihjdXJyLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICBvYmogPSBjdXJyW2tleV07XG4gICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyW2tleV07XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGN1cnJcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHBhciA9IHN0YWNrLnBvcCgpXG5cbiAgICAgICAgaWYgKGN1cnIudWlkKVxuICAgICAgICAgIHBhcltjdXJyLnVpZF0gPSBjdXJyXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYXJbTWF0aC5yYW5kb20oKSoxMDAwMDBdID0gY3VyciAgLy8gUmFuZG9tbHkgYXNzaWduIElEIDogVE9ETyAtIHVzZSB0cnVlIEdVSURcblxuICAgICAgICByZXR1cm4gcGFyXG4gICAgICB9XG5cbiAgICAgICwgJ1NVTU1BUlknIDogc3RvcmVQYXJhbSgnc3VtbWFyeScpXG4gICAgICAsICdERVNDUklQVElPTicgOiBzdG9yZVBhcmFtKCdkZXNjcmlwdGlvbicpXG4gICAgICAsICdVUkwnIDogc3RvcmVQYXJhbSgndXJsJylcbiAgICAgICwgJ1VJRCcgOiBzdG9yZVBhcmFtKCd1aWQnKVxuICAgICAgLCAnTE9DQVRJT04nIDogc3RvcmVQYXJhbSgnbG9jYXRpb24nKVxuICAgICAgLCAnRFRTVEFSVCcgOiBkYXRlUGFyYW0oJ3N0YXJ0JylcbiAgICAgICwgJ0RURU5EJyA6IGRhdGVQYXJhbSgnZW5kJylcbiAgICAgICwnIENMQVNTJyA6IHN0b3JlUGFyYW0oJ2NsYXNzJylcbiAgICAgICwgJ1RSQU5TUCcgOiBzdG9yZVBhcmFtKCd0cmFuc3BhcmVuY3knKVxuICAgICAgLCAnR0VPJyA6IGdlb1BhcmFtKCdnZW8nKVxuICAgICAgLCAnUEVSQ0VOVC1DT01QTEVURSc6IHN0b3JlUGFyYW0oJ2NvbXBsZXRpb24nKVxuICAgICAgLCAnQ09NUExFVEVEJzogZGF0ZVBhcmFtKCdjb21wbGV0ZWQnKVxuICAgICAgLCAnQ0FURUdPUklFUyc6IGNhdGVnb3JpZXNQYXJhbSgnY2F0ZWdvcmllcycpXG4gICAgICAsICdGUkVFQlVTWSc6IGZyZWVidXN5UGFyYW0oJ2ZyZWVidXN5JylcbiAgICB9LFxuXG5cbiAgICBoYW5kbGVPYmplY3QgOiBmdW5jdGlvbihuYW1lLCB2YWwsIHBhcmFtcywgY3R4LCBzdGFjaywgbGluZSl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgICAgaWYoc2VsZi5vYmplY3RIYW5kbGVyc1tuYW1lXSlcbiAgICAgICAgcmV0dXJuIHNlbGYub2JqZWN0SGFuZGxlcnNbbmFtZV0odmFsLCBwYXJhbXMsIGN0eCwgc3RhY2ssIGxpbmUpXG5cbiAgICAgIC8vaGFuZGxpbmcgY3VzdG9tIHByb3BlcnRpZXNcbiAgICAgIGlmKG5hbWUubWF0Y2goL1hcXC1bXFx3XFwtXSsvKSAmJiBzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy90cmltbWluZyB0aGUgbGVhZGluZyBhbmQgcGVyZm9ybSBzdG9yZVBhcmFtXG4gICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgIHJldHVybiAoc3RvcmVQYXJhbShuYW1lKSkodmFsLCBwYXJhbXMsIGN0eCwgc3RhY2ssIGxpbmUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gc3RvcmVQYXJhbShuYW1lLnRvTG93ZXJDYXNlKCkpKHZhbCwgcGFyYW1zLCBjdHgpO1xuICAgIH0sXG5cblxuICAgIHBhcnNlSUNTIDogZnVuY3Rpb24oc3RyKXtcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLylcbiAgICAgIHZhciBjdHggPSB7fVxuICAgICAgdmFyIHN0YWNrID0gW11cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoLCBsID0gbGluZXNbMF07IGk8aWk7IGkrKywgbD1saW5lc1tpXSl7XG4gICAgICAgIC8vVW5mb2xkIDogUkZDIzMuMVxuICAgICAgICB3aGlsZSAobGluZXNbaSsxXSAmJiAvWyBcXHRdLy50ZXN0KGxpbmVzW2krMV1bMF0pKSB7XG4gICAgICAgICAgbCArPSBsaW5lc1tpKzFdLnNsaWNlKDEpXG4gICAgICAgICAgaSArPSAxXG4gICAgICAgIH1cblxuICAgICAgICB2YXIga3YgPSBsLnNwbGl0KFwiOlwiKVxuXG4gICAgICAgIGlmIChrdi5sZW5ndGggPCAyKXtcbiAgICAgICAgICAvLyBJbnZhbGlkIGxpbmUgLSBtdXN0IGhhdmUgayZ2XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHRob3VnaCB0aGUgc3BlYyBzYXlzIHRoYXQgdmFscyB3aXRoIGNvbG9ucyBzaG91bGQgYmUgcXVvdGUgd3JhcHBlZFxuICAgICAgICAvLyBpbiBwcmFjdGlzZSBub2JvZHkgZG9lcywgc28gd2UgYXNzdW1lIGZ1cnRoZXIgY29sb25zIGFyZSBwYXJ0IG9mIHRoZVxuICAgICAgICAvLyB2YWxcbiAgICAgICAgdmFyIHZhbHVlID0ga3Yuc2xpY2UoMSkuam9pbihcIjpcIilcbiAgICAgICAgICAsIGtwID0ga3ZbMF0uc3BsaXQoXCI7XCIpXG4gICAgICAgICAgLCBuYW1lID0ga3BbMF1cbiAgICAgICAgICAsIHBhcmFtcyA9IGtwLnNsaWNlKDEpXG5cbiAgICAgICAgY3R4ID0gc2VsZi5oYW5kbGVPYmplY3QobmFtZSwgdmFsdWUsIHBhcmFtcywgY3R4LCBzdGFjaywgbCkgfHwge31cbiAgICAgIH1cblxuICAgICAgIC8vIHR5cGUgYW5kIHBhcmFtcyBhcmUgYWRkZWQgdG8gdGhlIGxpc3Qgb2YgaXRlbXMsIGdldCByaWQgb2YgdGhlbS5cbiAgICAgICBkZWxldGUgY3R4LnR5cGVcbiAgICAgICBkZWxldGUgY3R4LnBhcmFtc1xuXG4gICAgICAgcmV0dXJuIGN0eFxuICAgIH1cblxuICB9XG59KSlcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBvcHRzKSB7XG5cdGlmIChvcHRzLmVuY29kZSkge1xuXHRcdHJldHVybiBvcHRzLnN0cmljdCA/IHN0cmljdFVyaUVuY29kZSh2YWx1ZSkgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJz8nKVsxXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdC8vIENyZWF0ZSBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGVcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvaXNzdWVzLzQ3XG5cdHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0c3RyLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdC8vIEZpcmVmb3ggKHByZSA0MCkgZGVjb2RlcyBgJTNEYCB0byBgPWBcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWQ7XG5cblx0XHRrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG5cdFx0aWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdHJldFtrZXldLnB1c2godmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlXG5cdH07XG5cblx0b3B0cyA9IG9iamVjdEFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG5cblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdHZhbC5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcblx0XHRcdFx0aWYgKHZhbDIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh2YWwyID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goZW5jb2RlKGtleSwgb3B0cykpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKGVuY29kZShrZXksIG9wdHMpICsgJz0nICsgZW5jb2RlKHZhbDIsIG9wdHMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRzKSArICc9JyArIGVuY29kZSh2YWwsIG9wdHMpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuXHR9KS5qb2luKCcmJykgOiAnJztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3V0aWwvcm9vdCcpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi91dGlsL3RvU3Vic2NyaWJlcicpO1xudmFyICQkb2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpcyAgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgaGFuZGxlcnMgZm9yIGhhbmRsaW5nIGVtaXR0ZWQgdmFsdWVzLCBlcnJvciBhbmQgY29tcGxldGlvbnMgZnJvbSB0aGUgb2JzZXJ2YWJsZSwgYW5kXG4gICAgICogIGV4ZWN1dGVzIHRoZSBvYnNlcnZhYmxlJ3Mgc3Vic2NyaWJlciBmdW5jdGlvbiwgd2hpY2ggd2lsbCB0YWtlIGFjdGlvbiB0byBzZXQgdXAgdGhlIHVuZGVybHlpbmcgZGF0YSBzdHJlYW1cbiAgICAgKiBAbWV0aG9kIHN1YnNjcmliZVxuICAgICAqIEBwYXJhbSB7UGFydGlhbE9ic2VydmVyfEZ1bmN0aW9ufSBvYnNlcnZlck9yTmV4dCAob3B0aW9uYWwpIGVpdGhlciBhbiBvYnNlcnZlciBkZWZpbmluZyBhbGwgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZCxcbiAgICAgKiAgb3IgdGhlIGZpcnN0IG9mIHRocmVlIHBvc3NpYmxlIGhhbmRsZXJzLCB3aGljaCBpcyB0aGUgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgKG9wdGlvbmFsKSBhIGhhbmRsZXIgZm9yIGEgdGVybWluYWwgZXZlbnQgcmVzdWx0aW5nIGZyb20gYW4gZXJyb3IuIElmIG5vIGVycm9yIGhhbmRsZXIgaXMgcHJvdmlkZWQsXG4gICAgICogIHRoZSBlcnJvciB3aWxsIGJlIHRocm93biBhcyB1bmhhbmRsZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wbGV0ZSAob3B0aW9uYWwpIGEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAgICogQHJldHVybiB7SVN1YnNjcmlwdGlvbn0gYSBzdWJzY3JpcHRpb24gcmVmZXJlbmNlIHRvIHRoZSByZWdpc3RlcmVkIGhhbmRsZXJzXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgdmFyIHNpbmsgPSB0b1N1YnNjcmliZXJfMS50b1N1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgICAgb3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuX3N1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZm9yRWFjaFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHQgYSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcGFyYW0ge1Byb21pc2VDb25zdHJ1Y3Rvcn0gW1Byb21pc2VDdG9yXSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIFByb21pc2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBlaXRoZXIgcmVzb2x2ZXMgb24gb2JzZXJ2YWJsZSBjb21wbGV0aW9uIG9yXG4gICAgICogIHJlamVjdHMgd2l0aCB0aGUgaGFuZGxlZCBlcnJvclxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgaWYgKHJvb3RfMS5yb290LlJ4ICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZyAmJiByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gX3RoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzdWJzY3JpcHRpb24sIHRoZW4gd2UgY2FuIHN1cm1pc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgaGFuZGxpbmcgaXMgYXN5bmNocm9ub3VzLiBBbnkgZXJyb3JzIHRocm93blxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGJlIHJlamVjdGVkIGV4cGxpY2l0bHkgYW5kIHVuc3Vic2NyaWJlIG11c3QgYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBOTyBzdWJzY3JpcHRpb24sIHRoZW4gd2UncmUgZ2V0dGluZyBhIG5leHRlZFxuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBzeW5jaHJvbm91c2x5IGR1cmluZyBzdWJzY3JpcHRpb24uIFdlIGNhbiBqdXN0IGNhbGwgaXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGVycm9ycywgT2JzZXJ2YWJsZSdzIGBzdWJzY3JpYmVgIGltcGxlIHdpbGwgZW5zdXJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB1bnN1YnNjcmlwdGlvbiBsb2dpYyBpcyBjYWxsZWQsIHRoZW4gc3luY2hyb25vdXNseSByZXRocm93IHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWZ0ZXIgdGhhdCwgUHJvbWlzZSB3aWxsIHRyYXAgdGhlIGVycm9yIGFuZCBzZW5kIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvd24gdGhlIHJlamVjdGlvbiBwYXRoLlxuICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QsIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW50ZXJvcCBwb2ludCBkZWZpbmVkIGJ5IHRoZSBlczctb2JzZXJ2YWJsZSBzcGVjIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIFN5bWJvbC5vYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gdGhpcyBpbnN0YW5jZSBvZiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgICAvLyBmaWdodCBhZ2FpbnN0IFR5cGVTY3JpcHQgaGVyZSBzbyBTdWJqZWN0IGNhbiBoYXZlIGEgZGlmZmVyZW50IHN0YXRpYyBjcmVhdGUgc2lnbmF0dXJlXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xkIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmU/IHRoZSBzdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IGNvbGQgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbXB0eSA9IHtcbiAgICBpc1Vuc3Vic2NyaWJlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIFN1YmplY3QucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaWJlcih0aGlzKTtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXcgQW5vbnltb3VzU3ViamVjdCh0aGlzLCB0aGlzKTtcbiAgICAgICAgc3ViamVjdC5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IGVycjtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvcHlbaV0uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb25fMS5TdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0O1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TdWJqZWN0ID0gU3ViamVjdDtcbi8qKlxuICogQGNsYXNzIEFub255bW91c1N1YmplY3Q8VD5cbiAqL1xudmFyIEFub255bW91c1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24ubmV4dCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgU3ViamVjdFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Vuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpYmVySW5kZXggPSBvYnNlcnZlcnMuaW5kZXhPZih0aGlzLnN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpcHRpb24gPSBTdWJqZWN0U3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdFN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKCcuL09ic2VydmVyJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbi8qKlxuICogSW1wbGVtZW50cyB0aGUge0BsaW5rIE9ic2VydmVyfSBpbnRlcmZhY2UgYW5kIGV4dGVuZHMgdGhlXG4gKiB7QGxpbmsgU3Vic2NyaXB0aW9ufSBjbGFzcy4gV2hpbGUgdGhlIHtAbGluayBPYnNlcnZlcn0gaXMgdGhlIHB1YmxpYyBBUEkgZm9yXG4gKiBjb25zdW1pbmcgdGhlIHZhbHVlcyBvZiBhbiB7QGxpbmsgT2JzZXJ2YWJsZX0sIGFsbCBPYnNlcnZlcnMgZ2V0IGNvbnZlcnRlZCB0b1xuICogYSBTdWJzY3JpYmVyLCBpbiBvcmRlciB0byBwcm92aWRlIFN1YnNjcmlwdGlvbi1saWtlIGNhcGFiaWxpdGllcyBzdWNoIGFzXG4gKiBgdW5zdWJzY3JpYmVgLiBTdWJzY3JpYmVyIGlzIGEgY29tbW9uIHR5cGUgaW4gUnhKUywgYW5kIGNydWNpYWwgZm9yXG4gKiBpbXBsZW1lbnRpbmcgb3BlcmF0b3JzLCBidXQgaXQgaXMgcmFyZWx5IHVzZWQgYXMgYSBwdWJsaWMgQVBJLlxuICpcbiAqIEBjbGFzcyBTdWJzY3JpYmVyPFQ+XG4gKi9cbnZhciBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gW2Rlc3RpbmF0aW9uT3JOZXh0XSBBIHBhcnRpYWxseVxuICAgICAqIGRlZmluZWQgT2JzZXJ2ZXIgb3IgYSBgbmV4dGAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlOiA/YW55KTogdm9pZH0gW2Vycm9yXSBUaGUgYGVycm9yYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBUaGUgYGNvbXBsZXRlYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZXIoZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25Pck5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck5leHQgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb25Pck5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmFkZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIodGhpcywgZGVzdGluYXRpb25Pck5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIodGhpcywgZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0YXRpYyBmYWN0b3J5IGZvciBhIFN1YnNjcmliZXIsIGdpdmVuIGEgKHBvdGVudGlhbGx5IHBhcnRpYWwpIGRlZmluaXRpb25cbiAgICAgKiBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHg6ID9UKTogdm9pZH0gW25leHRdIFRoZSBgbmV4dGAgY2FsbGJhY2sgb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlOiA/YW55KTogdm9pZH0gW2Vycm9yXSBUaGUgYGVycm9yYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBUaGUgYGNvbXBsZXRlYCBjYWxsYmFjayBvZiBhblxuICAgICAqIE9ic2VydmVyLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmliZXI8VD59IEEgU3Vic2NyaWJlciB3cmFwcGluZyB0aGUgKHBhcnRpYWxseSBkZWZpbmVkKVxuICAgICAqIE9ic2VydmVyIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICAgICovXG4gICAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXIobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgc3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgbmV4dGAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGEgdmFsdWUuIFRoZSBPYnNlcnZhYmxlIG1heSBjYWxsIHRoaXMgbWV0aG9kIDAgb3IgbW9yZVxuICAgICAqIHRpbWVzLlxuICAgICAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBUaGUgYG5leHRgIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYGVycm9yYCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYW4gYXR0YWNoZWQge0BsaW5rIEVycm9yfS4gTm90aWZpZXMgdGhlIE9ic2VydmVyIHRoYXRcbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSBoYXMgZXhwZXJpZW5jZWQgYW4gZXJyb3IgY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7YW55fSBbZXJyXSBUaGUgYGVycm9yYCBleGNlcHRpb24uXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhIHZhbHVlbGVzcyBub3RpZmljYXRpb24gb2YgdHlwZVxuICAgICAqIGBjb21wbGV0ZWAgZnJvbSB0aGUgT2JzZXJ2YWJsZS4gTm90aWZpZXMgdGhlIE9ic2VydmVyIHRoYXQgdGhlIE9ic2VydmFibGVcbiAgICAgKiBoYXMgZmluaXNoZWQgc2VuZGluZyBwdXNoLWJhc2VkIG5vdGlmaWNhdGlvbnMuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnQsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICAgICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihjb250ZXh0LnVuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQudW5zdWJzY3JpYmUuYmluZChjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnVuc3Vic2NyaWJlID0gdGhpcy51bnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCAmJiB0aGlzLl9uZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50LnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudCwgdGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclVuc3ViID0gZnVuY3Rpb24gKGZuLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgX3BhcmVudC51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfdW5zdWJzY3JpYmUgPSBfYS5fdW5zdWJzY3JpYmUsIF9zdWJzY3JpcHRpb25zID0gX2EuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChfdW5zdWJzY3JpYmUpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIChlcnJvcnMgPSBlcnJvcnMgfHwgW10pLnB1c2goZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfc3Vic2NyaXB0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0XzEuaXNPYmplY3Qoc3ViKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHN1Yi51bnN1YnNjcmliZSkuY2FsbChzdWIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChlcnIuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgaXNVbnN1YnNjcmliZWRgIHN0YXRlLCB0aGUgcGFzc2VkXG4gICAgICogdGVhciBkb3duIGxvZ2ljIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RlYXJkb3duTG9naWN9IHRlYXJkb3duIFRoZSBhZGRpdGlvbmFsIGxvZ2ljIHRvIGV4ZWN1dGUgb25cbiAgICAgKiB0ZWFyZG93bi5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259IFJldHVybnMgdGhlIFN1YnNjcmlwdGlvbiB1c2VkIG9yIGNyZWF0ZWQgdG8gYmVcbiAgICAgKiBhZGRlZCB0byB0aGUgaW5uZXIgc3Vic2NyaXB0aW9ucyBsaXN0LiBUaGlzIFN1YnNjcmlwdGlvbiBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICogYHJlbW92ZSgpYCB0byByZW1vdmUgdGhlIHBhc3NlZCB0ZWFyZG93biBsb2dpYyBmcm9tIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAgICogbGlzdC5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICBpZiAoIXRlYXJkb3duIHx8ICh0ZWFyZG93biA9PT0gdGhpcykgfHwgKHRlYXJkb3duID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YiA9IHRlYXJkb3duO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3ViLmlzVW5zdWJzY3JpYmVkIHx8IHR5cGVvZiBzdWIudW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5fc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdKSkucHVzaChzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBTdWJzY3JpcHRpb24gZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHRoYXQgd2lsbFxuICAgICAqIHVuc3Vic2NyaWJlIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUgcHJvY2VzcyBvZiB0aGlzIFN1YnNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBzdWJzY3JpcHRpb24gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIEhBQ0s6IFRoaXMgbWlnaHQgYmUgcmVkdW5kYW50IGJlY2F1c2Ugb2YgdGhlIGxvZ2ljIGluIGBhZGQoKWBcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PSBudWxsIHx8IChzdWJzY3JpcHRpb24gPT09IHRoaXMpIHx8IChzdWJzY3JpcHRpb24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfShuZXcgU3Vic2NyaXB0aW9uKCkpKTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBQcm9taXNlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb21pc2VPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb21pc2VPYnNlcnZhYmxlKHByb21pc2UsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgUHJvbWlzZSB0byBhbiBPYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGp1c3QgZW1pdHMgdGhlIFByb21pc2Unc1xuICAgICAqIHJlc29sdmVkIHZhbHVlLCB0aGVuIGNvbXBsZXRlcy48L3NwYW4+XG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyBhbiBFUzIwMTUgUHJvbWlzZSBvciBhIFByb21pc2VzL0ErIHNwZWMgY29tcGxpYW50IFByb21pc2UgdG8gYW5cbiAgICAgKiBPYnNlcnZhYmxlLiBJZiB0aGUgUHJvbWlzZSByZXNvbHZlcyB3aXRoIGEgdmFsdWUsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICAgICAqIGVtaXRzIHRoYXQgcmVzb2x2ZWQgdmFsdWUgYXMgYSBgbmV4dGAsIGFuZCB0aGVuIGNvbXBsZXRlcy4gSWYgdGhlIFByb21pc2VcbiAgICAgKiBpcyByZWplY3RlZCwgdGhlbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgdGhlIGNvcnJlc3BvbmRpbmcgRXJyb3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IEZldGNoIHRvIGFuIE9ic2VydmFibGU8L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZnJvbVByb21pc2UoZmV0Y2goJ2h0dHA6Ly9teXNlcnZlci5jb20vJykpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGJpbmRDYWxsYmFja31cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlIFRoZSBwcm9taXNlIHRvIGJlIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQW4gb3B0aW9uYWwgU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBkZWxpdmVyeSBvZiB0aGUgcmVzb2x2ZWQgdmFsdWUgKG9yIHRoZSByZWplY3Rpb24pLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgd2hpY2ggd3JhcHMgdGhlIFByb21pc2UuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbVByb21pc2VcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFByb21pc2VPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlT2JzZXJ2YWJsZShwcm9taXNlLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgUHJvbWlzZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1NjYWxhcikge1xuICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSB0aGUgcHJvbWlzZSB0cmFwLCB0aHJvdyB1bmhhbmRsZWQgZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHJvb3RfMS5yb290LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB0aGlzLnZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlOiB2YWx1ZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnIsIHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHByb21pc2UgdHJhcCwgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICByb290XzEucm9vdC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2VPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Qcm9taXNlT2JzZXJ2YWJsZSA9IFByb21pc2VPYnNlcnZhYmxlO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KGFyZykge1xuICAgIHZhciB2YWx1ZSA9IGFyZy52YWx1ZSwgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIGlmICghc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlzcGF0Y2hFcnJvcihhcmcpIHtcbiAgICB2YXIgZXJyID0gYXJnLmVyciwgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIGlmICghc3Vic2NyaWJlci5pc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvbWlzZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG4vKipcbiAqIEBwYXJhbSBQcm9taXNlQ3RvclxuICogQHJldHVybiB7UHJvbWlzZTxUPn1cbiAqIEBtZXRob2QgdG9Qcm9taXNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0b1Byb21pc2UoUHJvbWlzZUN0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgaWYgKHJvb3RfMS5yb290LlJ4ICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZyAmJiByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Qcm9taXNlKSB7XG4gICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHZhbHVlID0geDsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUodmFsdWUpOyB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudG9Qcm9taXNlID0gdG9Qcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9Qcm9taXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBhY3Rpb24gaXMgaW52YWxpZCBiZWNhdXNlIHRoZSBvYmplY3QgaGFzIGJlZW5cbiAqIHVuc3Vic2NyaWJlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBTdWJqZWN0fVxuICogQHNlZSB7QGxpbmsgQmVoYXZpb3JTdWJqZWN0fVxuICpcbiAqIEBjbGFzcyBPYmplY3RVbnN1YnNjcmliZWRFcnJvclxuICovXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RVbnN1YnNjcmliZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVycm9ycyA/IGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcblwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiAoKGkgKyAxKSArIFwiKSBcIiArIGVyci50b1N0cmluZygpKTsgfSkuam9pbignXFxuJykgOiAnJztcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0cy5lcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJzsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0FycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRnVuY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc09iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2Vcbn07XG5leHBvcnRzLnJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpIHx8IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xuLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG52YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xudmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG52YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbmlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICBleHBvcnRzLnJvb3QgPSBmcmVlR2xvYmFsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIGlmIChuZXh0T3JPYnNlcnZlcikge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuZXhwb3J0cy50b1N1YnNjcmliZXIgPSB0b1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1N1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vZXJyb3JPYmplY3QnKTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cbmV4cG9ydHMudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyeUNhdGNoLmpzLm1hcCIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCkqXS9nLCBmdW5jdGlvbiAoYykge1xuXHRcdHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdH0pO1xufTtcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BvbnlmaWxsJykoZ2xvYmFsIHx8IHdpbmRvdyB8fCB0aGlzKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuIl19
